// TODO: in future try to replace most inline compability checks with polyfills for code readability 

// element.textContent polyfill.
// Unsupporting browsers: IE8

if (Object.defineProperty && Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(Element.prototype, "textContent") && !Object.getOwnPropertyDescriptor(Element.prototype, "textContent").get) {
	(function() {
		var innerText = Object.getOwnPropertyDescriptor(Element.prototype, "innerText");
		Object.defineProperty(Element.prototype, "textContent",
			{
				get: function() {
					return innerText.get.call(this);
				},
				set: function(s) {
					return innerText.set.call(this, s);
				}
			}
		);
	})();
}

// isArray polyfill for ie8
if(!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
};/**
 * @license wysihtml5x v0.4.15
 * https://github.com/Edicy/wysihtml5
 *
 * Author: Christopher Blum (https://github.com/tiff)
 * Secondary author of extended features: Oliver Pulges (https://github.com/pulges)
 *
 * Copyright (C) 2012 XING AG
 * Licensed under the MIT license (MIT)
 *
 */
var wysihtml5 = {
  version: "0.4.15",

  // namespaces
  commands:   {},
  dom:        {},
  quirks:     {},
  toolbar:    {},
  lang:       {},
  selection:  {},
  views:      {},

  INVISIBLE_SPACE: "\uFEFF",

  EMPTY_FUNCTION: function() {},

  ELEMENT_NODE: 1,
  TEXT_NODE:    3,

  BACKSPACE_KEY:  8,
  ENTER_KEY:      13,
  ESCAPE_KEY:     27,
  SPACE_KEY:      32,
  DELETE_KEY:     46
};
;/**
 * Rangy, a cross-browser JavaScript range and selection library
 * http://code.google.com/p/rangy/
 *
 * Copyright 2014, Tim Down
 * Licensed under the MIT license.
 * Version: 1.3alpha.20140804
 * Build date: 4 August 2014
 */

(function(factory, global) {
    if (typeof define == "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
/*
    TODO: look into this properly.
    
    } else if (typeof exports == "object") {
        // Node/CommonJS style for Browserify
        module.exports = factory;
*/
    } else {
        // No AMD or CommonJS support so we place Rangy in a global variable
        global.rangy = factory();
    }
})(function() {

    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";

    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START
    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.
    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
        "commonAncestorContainer"];

    // Minimal set of methods required for DOM Level 2 Range compliance
    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",
        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",
        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];

    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];

    // Subset of TextRange's full set of methods that we're interested in
    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",
        "setEndPoint", "getBoundingClientRect"];

    /*----------------------------------------------------------------------------------------------------------------*/

    // Trio of functions taken from Peter Michaux's article:
    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
    function isHostMethod(o, p) {
        var t = typeof o[p];
        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";
    }

    function isHostObject(o, p) {
        return !!(typeof o[p] == OBJECT && o[p]);
    }

    function isHostProperty(o, p) {
        return typeof o[p] != UNDEFINED;
    }

    // Creates a convenience function to save verbose repeated calls to tests functions
    function createMultiplePropertyTest(testFunc) {
        return function(o, props) {
            var i = props.length;
            while (i--) {
                if (!testFunc(o, props[i])) {
                    return false;
                }
            }
            return true;
        };
    }

    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions
    var areHostMethods = createMultiplePropertyTest(isHostMethod);
    var areHostObjects = createMultiplePropertyTest(isHostObject);
    var areHostProperties = createMultiplePropertyTest(isHostProperty);

    function isTextRange(range) {
        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
    }

    function getBody(doc) {
        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
    }

    var modules = {};

    var api = {
        version: "1.3alpha.20140804",
        initialized: false,
        supported: true,

        util: {
            isHostMethod: isHostMethod,
            isHostObject: isHostObject,
            isHostProperty: isHostProperty,
            areHostMethods: areHostMethods,
            areHostObjects: areHostObjects,
            areHostProperties: areHostProperties,
            isTextRange: isTextRange,
            getBody: getBody
        },

        features: {},

        modules: modules,
        config: {
            alertOnFail: true,
            alertOnWarn: false,
            preferTextRange: false,
            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize
        }
    };

    function consoleLog(msg) {
        if (isHostObject(window, "console") && isHostMethod(window.console, "log")) {
            window.console.log(msg);
        }
    }

    function alertOrLog(msg, shouldAlert) {
        if (shouldAlert) {
            window.alert(msg);
        } else  {
            consoleLog(msg);
        }
    }

    function fail(reason) {
        api.initialized = true;
        api.supported = false;
        alertOrLog("Rangy is not supported on this page in your browser. Reason: " + reason, api.config.alertOnFail);
    }

    api.fail = fail;

    function warn(msg) {
        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
    }

    api.warn = warn;

    // Add utility extend() method
    if ({}.hasOwnProperty) {
        api.util.extend = function(obj, props, deep) {
            var o, p;
            for (var i in props) {
                if (props.hasOwnProperty(i)) {
                    o = obj[i];
                    p = props[i];
                    if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {
                        api.util.extend(o, p, true);
                    }
                    obj[i] = p;
                }
            }
            // Special case for toString, which does not show up in for...in loops in IE <= 8
            if (props.hasOwnProperty("toString")) {
                obj.toString = props.toString;
            }
            return obj;
        };
    } else {
        fail("hasOwnProperty not supported");
    }

    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not
    (function() {
        var el = document.createElement("div");
        el.appendChild(document.createElement("span"));
        var slice = [].slice;
        var toArray;
        try {
            if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
                toArray = function(arrayLike) {
                    return slice.call(arrayLike, 0);
                };
            }
        } catch (e) {}

        if (!toArray) {
            toArray = function(arrayLike) {
                var arr = [];
                for (var i = 0, len = arrayLike.length; i < len; ++i) {
                    arr[i] = arrayLike[i];
                }
                return arr;
            };
        }

        api.util.toArray = toArray;
    })();


    // Very simple event handler wrapper function that doesn't attempt to solve issues such as "this" handling or
    // normalization of event properties
    var addListener;
    if (isHostMethod(document, "addEventListener")) {
        addListener = function(obj, eventType, listener) {
            obj.addEventListener(eventType, listener, false);
        };
    } else if (isHostMethod(document, "attachEvent")) {
        addListener = function(obj, eventType, listener) {
            obj.attachEvent("on" + eventType, listener);
        };
    } else {
        fail("Document does not have required addEventListener or attachEvent method");
    }

    api.util.addListener = addListener;

    var initListeners = [];

    function getErrorDesc(ex) {
        return ex.message || ex.description || String(ex);
    }

    // Initialization
    function init() {
        if (api.initialized) {
            return;
        }
        var testRange;
        var implementsDomRange = false, implementsTextRange = false;

        // First, perform basic feature tests

        if (isHostMethod(document, "createRange")) {
            testRange = document.createRange();
            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
                implementsDomRange = true;
            }
        }

        var body = getBody(document);
        if (!body || body.nodeName.toLowerCase() != "body") {
            fail("No body element found");
            return;
        }

        if (body && isHostMethod(body, "createTextRange")) {
            testRange = body.createTextRange();
            if (isTextRange(testRange)) {
                implementsTextRange = true;
            }
        }

        if (!implementsDomRange && !implementsTextRange) {
            fail("Neither Range nor TextRange are available");
            return;
        }

        api.initialized = true;
        api.features = {
            implementsDomRange: implementsDomRange,
            implementsTextRange: implementsTextRange
        };

        // Initialize modules
        var module, errorMessage;
        for (var moduleName in modules) {
            if ( (module = modules[moduleName]) instanceof Module ) {
                module.init(module, api);
            }
        }

        // Call init listeners
        for (var i = 0, len = initListeners.length; i < len; ++i) {
            try {
                initListeners[i](api);
            } catch (ex) {
                errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
                consoleLog(errorMessage);
            }
        }
    }

    // Allow external scripts to initialize this library in case it's loaded after the document has loaded
    api.init = init;

    // Execute listener immediately if already initialized
    api.addInitListener = function(listener) {
        if (api.initialized) {
            listener(api);
        } else {
            initListeners.push(listener);
        }
    };

    var shimListeners = [];

    api.addShimListener = function(listener) {
        shimListeners.push(listener);
    };

    function shim(win) {
        win = win || window;
        init();

        // Notify listeners
        for (var i = 0, len = shimListeners.length; i < len; ++i) {
            shimListeners[i](win);
        }
    }

    api.shim = api.createMissingNativeApi = shim;

    function Module(name, dependencies, initializer) {
        this.name = name;
        this.dependencies = dependencies;
        this.initialized = false;
        this.supported = false;
        this.initializer = initializer;
    }

    Module.prototype = {
        init: function() {
            var requiredModuleNames = this.dependencies || [];
            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
                moduleName = requiredModuleNames[i];

                requiredModule = modules[moduleName];
                if (!requiredModule || !(requiredModule instanceof Module)) {
                    throw new Error("required module '" + moduleName + "' not found");
                }

                requiredModule.init();

                if (!requiredModule.supported) {
                    throw new Error("required module '" + moduleName + "' not supported");
                }
            }
            
            // Now run initializer
            this.initializer(this);
        },
        
        fail: function(reason) {
            this.initialized = true;
            this.supported = false;
            throw new Error("Module '" + this.name + "' failed to load: " + reason);
        },

        warn: function(msg) {
            api.warn("Module " + this.name + ": " + msg);
        },

        deprecationNotice: function(deprecated, replacement) {
            api.warn("DEPRECATED: " + deprecated + " in module " + this.name + "is deprecated. Please use " +
                replacement + " instead");
        },

        createError: function(msg) {
            return new Error("Error in Rangy " + this.name + " module: " + msg);
        }
    };
    
    function createModule(isCore, name, dependencies, initFunc) {
        var newModule = new Module(name, dependencies, function(module) {
            if (!module.initialized) {
                module.initialized = true;
                try {
                    initFunc(api, module);
                    module.supported = true;
                } catch (ex) {
                    var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
                    consoleLog(errorMessage);
                }
            }
        });
        modules[name] = newModule;
    }

    api.createModule = function(name) {
        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)
        var initFunc, dependencies;
        if (arguments.length == 2) {
            initFunc = arguments[1];
            dependencies = [];
        } else {
            initFunc = arguments[2];
            dependencies = arguments[1];
        }

        var module = createModule(false, name, dependencies, initFunc);

        // Initialize the module immediately if the core is already initialized
        if (api.initialized) {
            module.init();
        }
    };

    api.createCoreModule = function(name, dependencies, initFunc) {
        createModule(true, name, dependencies, initFunc);
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately

    function RangePrototype() {}
    api.RangePrototype = RangePrototype;
    api.rangePrototype = new RangePrototype();

    function SelectionPrototype() {}
    api.selectionPrototype = new SelectionPrototype();

    /*----------------------------------------------------------------------------------------------------------------*/

    // Wait for document to load before running tests

    var docReady = false;

    var loadHandler = function(e) {
        if (!docReady) {
            docReady = true;
            if (!api.initialized && api.config.autoInitialize) {
                init();
            }
        }
    };

    // Test whether we have window and document objects that we will need
    if (typeof window == UNDEFINED) {
        fail("No window found");
        return;
    }
    if (typeof document == UNDEFINED) {
        fail("No document found");
        return;
    }

    if (isHostMethod(document, "addEventListener")) {
        document.addEventListener("DOMContentLoaded", loadHandler, false);
    }

    // Add a fallback in case the DOMContentLoaded event isn't supported
    addListener(window, "load", loadHandler);

    /*----------------------------------------------------------------------------------------------------------------*/
    
    // DOM utility methods used by Rangy
    api.createCoreModule("DomUtil", [], function(api, module) {
        var UNDEF = "undefined";
        var util = api.util;

        // Perform feature tests
        if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
            module.fail("document missing a Node creation method");
        }

        if (!util.isHostMethod(document, "getElementsByTagName")) {
            module.fail("document missing getElementsByTagName method");
        }

        var el = document.createElement("div");
        if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||
                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {
            module.fail("Incomplete Element implementation");
        }

        // innerHTML is required for Range's createContextualFragment method
        if (!util.isHostProperty(el, "innerHTML")) {
            module.fail("Element is missing innerHTML property");
        }

        var textNode = document.createTextNode("test");
        if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||
                !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||
                !util.areHostProperties(textNode, ["data"]))) {
            module.fail("Incomplete Text Node implementation");
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been
        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that
        // contains just the document as a single element and the value searched for is the document.
        var arrayContains = /*Array.prototype.indexOf ?
            function(arr, val) {
                return arr.indexOf(val) > -1;
            }:*/

            function(arr, val) {
                var i = arr.length;
                while (i--) {
                    if (arr[i] === val) {
                        return true;
                    }
                }
                return false;
            };

        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI
        function isHtmlNamespace(node) {
            var ns;
            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
        }

        function parentElement(node) {
            var parent = node.parentNode;
            return (parent.nodeType == 1) ? parent : null;
        }

        function getNodeIndex(node) {
            var i = 0;
            while( (node = node.previousSibling) ) {
                ++i;
            }
            return i;
        }

        function getNodeLength(node) {
            switch (node.nodeType) {
                case 7:
                case 10:
                    return 0;
                case 3:
                case 8:
                    return node.length;
                default:
                    return node.childNodes.length;
            }
        }

        function getCommonAncestor(node1, node2) {
            var ancestors = [], n;
            for (n = node1; n; n = n.parentNode) {
                ancestors.push(n);
            }

            for (n = node2; n; n = n.parentNode) {
                if (arrayContains(ancestors, n)) {
                    return n;
                }
            }

            return null;
        }

        function isAncestorOf(ancestor, descendant, selfIsAncestor) {
            var n = selfIsAncestor ? descendant : descendant.parentNode;
            while (n) {
                if (n === ancestor) {
                    return true;
                } else {
                    n = n.parentNode;
                }
            }
            return false;
        }

        function isOrIsAncestorOf(ancestor, descendant) {
            return isAncestorOf(ancestor, descendant, true);
        }

        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
            var p, n = selfIsAncestor ? node : node.parentNode;
            while (n) {
                p = n.parentNode;
                if (p === ancestor) {
                    return n;
                }
                n = p;
            }
            return null;
        }

        function isCharacterDataNode(node) {
            var t = node.nodeType;
            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment
        }

        function isTextOrCommentNode(node) {
            if (!node) {
                return false;
            }
            var t = node.nodeType;
            return t == 3 || t == 8 ; // Text or Comment
        }

        function insertAfter(node, precedingNode) {
            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
            if (nextNode) {
                parent.insertBefore(node, nextNode);
            } else {
                parent.appendChild(node);
            }
            return node;
        }

        // Note that we cannot use splitText() because it is bugridden in IE 9.
        function splitDataNode(node, index, positionsToPreserve) {
            var newNode = node.cloneNode(false);
            newNode.deleteData(0, index);
            node.deleteData(index, node.length - index);
            insertAfter(newNode, node);

            // Preserve positions
            if (positionsToPreserve) {
                for (var i = 0, position; position = positionsToPreserve[i++]; ) {
                    // Handle case where position was inside the portion of node after the split point
                    if (position.node == node && position.offset > index) {
                        position.node = newNode;
                        position.offset -= index;
                    }
                    // Handle the case where the position is a node offset within node's parent
                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {
                        ++position.offset;
                    }
                }
            }
            return newNode;
        }

        function getDocument(node) {
            if (node.nodeType == 9) {
                return node;
            } else if (typeof node.ownerDocument != UNDEF) {
                return node.ownerDocument;
            } else if (typeof node.document != UNDEF) {
                return node.document;
            } else if (node.parentNode) {
                return getDocument(node.parentNode);
            } else {
                throw module.createError("getDocument: no document found for node");
            }
        }

        function getWindow(node) {
            var doc = getDocument(node);
            if (typeof doc.defaultView != UNDEF) {
                return doc.defaultView;
            } else if (typeof doc.parentWindow != UNDEF) {
                return doc.parentWindow;
            } else {
                throw module.createError("Cannot get a window object for node");
            }
        }

        function getIframeDocument(iframeEl) {
            if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument;
            } else if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow.document;
            } else {
                throw module.createError("getIframeDocument: No Document object found for iframe element");
            }
        }

        function getIframeWindow(iframeEl) {
            if (typeof iframeEl.contentWindow != UNDEF) {
                return iframeEl.contentWindow;
            } else if (typeof iframeEl.contentDocument != UNDEF) {
                return iframeEl.contentDocument.defaultView;
            } else {
                throw module.createError("getIframeWindow: No Window object found for iframe element");
            }
        }

        // This looks bad. Is it worth it?
        function isWindow(obj) {
            return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");
        }

        function getContentDocument(obj, module, methodName) {
            var doc;

            if (!obj) {
                doc = document;
            }

            // Test if a DOM node has been passed and obtain a document object for it if so
            else if (util.isHostProperty(obj, "nodeType")) {
                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?
                    getIframeDocument(obj) : getDocument(obj);
            }

            // Test if the doc parameter appears to be a Window object
            else if (isWindow(obj)) {
                doc = obj.document;
            }

            if (!doc) {
                throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");
            }

            return doc;
        }

        function getRootContainer(node) {
            var parent;
            while ( (parent = node.parentNode) ) {
                node = parent;
            }
            return node;
        }

        function comparePoints(nodeA, offsetA, nodeB, offsetB) {
            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing
            var nodeC, root, childA, childB, n;
            if (nodeA == nodeB) {
                // Case 1: nodes are the same
                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;
            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {
                // Case 2: node C (container B or an ancestor) is a child node of A
                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {
                // Case 3: node C (container A or an ancestor) is a child node of B
                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;
            } else {
                root = getCommonAncestor(nodeA, nodeB);
                if (!root) {
                    throw new Error("comparePoints error: nodes have no common ancestor");
                }

                // Case 4: containers are siblings or descendants of siblings
                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);
                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);

                if (childA === childB) {
                    // This shouldn't be possible
                    throw module.createError("comparePoints got to case 4 and childA and childB are the same!");
                } else {
                    n = root.firstChild;
                    while (n) {
                        if (n === childA) {
                            return -1;
                        } else if (n === childB) {
                            return 1;
                        }
                        n = n.nextSibling;
                    }
                }
            }
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried
        var crashyTextNodes = false;

        function isBrokenNode(node) {
            var n;
            try {
                n = node.parentNode;
                return false;
            } catch (e) {
                return true;
            }
        }

        (function() {
            var el = document.createElement("b");
            el.innerHTML = "1";
            var textNode = el.firstChild;
            el.innerHTML = "<br>";
            crashyTextNodes = isBrokenNode(textNode);

            api.features.crashyTextNodes = crashyTextNodes;
        })();

        /*----------------------------------------------------------------------------------------------------------------*/

        function inspectNode(node) {
            if (!node) {
                return "[No node]";
            }
            if (crashyTextNodes && isBrokenNode(node)) {
                return "[Broken node]";
            }
            if (isCharacterDataNode(node)) {
                return '"' + node.data + '"';
            }
            if (node.nodeType == 1) {
                var idAttr = node.id ? ' id="' + node.id + '"' : "";
                return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
            }
            return node.nodeName;
        }

        function fragmentFromNodeChildren(node) {
            var fragment = getDocument(node).createDocumentFragment(), child;
            while ( (child = node.firstChild) ) {
                fragment.appendChild(child);
            }
            return fragment;
        }

        var getComputedStyleProperty;
        if (typeof window.getComputedStyle != UNDEF) {
            getComputedStyleProperty = function(el, propName) {
                return getWindow(el).getComputedStyle(el, null)[propName];
            };
        } else if (typeof document.documentElement.currentStyle != UNDEF) {
            getComputedStyleProperty = function(el, propName) {
                return el.currentStyle[propName];
            };
        } else {
            module.fail("No means of obtaining computed style properties found");
        }

        function NodeIterator(root) {
            this.root = root;
            this._next = root;
        }

        NodeIterator.prototype = {
            _current: null,

            hasNext: function() {
                return !!this._next;
            },

            next: function() {
                var n = this._current = this._next;
                var child, next;
                if (this._current) {
                    child = n.firstChild;
                    if (child) {
                        this._next = child;
                    } else {
                        next = null;
                        while ((n !== this.root) && !(next = n.nextSibling)) {
                            n = n.parentNode;
                        }
                        this._next = next;
                    }
                }
                return this._current;
            },

            detach: function() {
                this._current = this._next = this.root = null;
            }
        };

        function createIterator(root) {
            return new NodeIterator(root);
        }

        function DomPosition(node, offset) {
            this.node = node;
            this.offset = offset;
        }

        DomPosition.prototype = {
            equals: function(pos) {
                return !!pos && this.node === pos.node && this.offset == pos.offset;
            },

            inspect: function() {
                return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
            },

            toString: function() {
                return this.inspect();
            }
        };

        function DOMException(codeName) {
            this.code = this[codeName];
            this.codeName = codeName;
            this.message = "DOMException: " + this.codeName;
        }

        DOMException.prototype = {
            INDEX_SIZE_ERR: 1,
            HIERARCHY_REQUEST_ERR: 3,
            WRONG_DOCUMENT_ERR: 4,
            NO_MODIFICATION_ALLOWED_ERR: 7,
            NOT_FOUND_ERR: 8,
            NOT_SUPPORTED_ERR: 9,
            INVALID_STATE_ERR: 11,
            INVALID_NODE_TYPE_ERR: 24
        };

        DOMException.prototype.toString = function() {
            return this.message;
        };

        api.dom = {
            arrayContains: arrayContains,
            isHtmlNamespace: isHtmlNamespace,
            parentElement: parentElement,
            getNodeIndex: getNodeIndex,
            getNodeLength: getNodeLength,
            getCommonAncestor: getCommonAncestor,
            isAncestorOf: isAncestorOf,
            isOrIsAncestorOf: isOrIsAncestorOf,
            getClosestAncestorIn: getClosestAncestorIn,
            isCharacterDataNode: isCharacterDataNode,
            isTextOrCommentNode: isTextOrCommentNode,
            insertAfter: insertAfter,
            splitDataNode: splitDataNode,
            getDocument: getDocument,
            getWindow: getWindow,
            getIframeWindow: getIframeWindow,
            getIframeDocument: getIframeDocument,
            getBody: util.getBody,
            isWindow: isWindow,
            getContentDocument: getContentDocument,
            getRootContainer: getRootContainer,
            comparePoints: comparePoints,
            isBrokenNode: isBrokenNode,
            inspectNode: inspectNode,
            getComputedStyleProperty: getComputedStyleProperty,
            fragmentFromNodeChildren: fragmentFromNodeChildren,
            createIterator: createIterator,
            DomPosition: DomPosition
        };

        api.DOMException = DOMException;
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // Pure JavaScript implementation of DOM Range
    api.createCoreModule("DomRange", ["DomUtil"], function(api, module) {
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DOMException = api.DOMException;

        var isCharacterDataNode = dom.isCharacterDataNode;
        var getNodeIndex = dom.getNodeIndex;
        var isOrIsAncestorOf = dom.isOrIsAncestorOf;
        var getDocument = dom.getDocument;
        var comparePoints = dom.comparePoints;
        var splitDataNode = dom.splitDataNode;
        var getClosestAncestorIn = dom.getClosestAncestorIn;
        var getNodeLength = dom.getNodeLength;
        var arrayContains = dom.arrayContains;
        var getRootContainer = dom.getRootContainer;
        var crashyTextNodes = api.features.crashyTextNodes;

        /*----------------------------------------------------------------------------------------------------------------*/

        // Utility functions

        function isNonTextPartiallySelected(node, range) {
            return (node.nodeType != 3) &&
                   (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));
        }

        function getRangeDocument(range) {
            return range.document || getDocument(range.startContainer);
        }

        function getBoundaryBeforeNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node));
        }

        function getBoundaryAfterNode(node) {
            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);
        }

        function insertNodeAtPosition(node, n, o) {
            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
            if (isCharacterDataNode(n)) {
                if (o == n.length) {
                    dom.insertAfter(node, n);
                } else {
                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));
                }
            } else if (o >= n.childNodes.length) {
                n.appendChild(node);
            } else {
                n.insertBefore(node, n.childNodes[o]);
            }
            return firstNodeInserted;
        }

        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
            assertRangeValid(rangeA);
            assertRangeValid(rangeB);

            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }

            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),
                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);

            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        }

        function cloneSubtree(iterator) {
            var partiallySelected;
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
                partiallySelected = iterator.isPartiallySelectedSubtree();
                node = node.cloneNode(!partiallySelected);
                if (partiallySelected) {
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(cloneSubtree(subIterator));
                    subIterator.detach();
                }

                if (node.nodeType == 10) { // DocumentType
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }

        function iterateSubtree(rangeIterator, func, iteratorState) {
            var it, n;
            iteratorState = iteratorState || { stop: false };
            for (var node, subRangeIterator; node = rangeIterator.next(); ) {
                if (rangeIterator.isPartiallySelectedSubtree()) {
                    if (func(node) === false) {
                        iteratorState.stop = true;
                        return;
                    } else {
                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of
                        // the node selected by the Range.
                        subRangeIterator = rangeIterator.getSubtreeIterator();
                        iterateSubtree(subRangeIterator, func, iteratorState);
                        subRangeIterator.detach();
                        if (iteratorState.stop) {
                            return;
                        }
                    }
                } else {
                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its
                    // descendants
                    it = dom.createIterator(node);
                    while ( (n = it.next()) ) {
                        if (func(n) === false) {
                            iteratorState.stop = true;
                            return;
                        }
                    }
                }
            }
        }

        function deleteSubtree(iterator) {
            var subIterator;
            while (iterator.next()) {
                if (iterator.isPartiallySelectedSubtree()) {
                    subIterator = iterator.getSubtreeIterator();
                    deleteSubtree(subIterator);
                    subIterator.detach();
                } else {
                    iterator.remove();
                }
            }
        }

        function extractSubtree(iterator) {
            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {

                if (iterator.isPartiallySelectedSubtree()) {
                    node = node.cloneNode(false);
                    subIterator = iterator.getSubtreeIterator();
                    node.appendChild(extractSubtree(subIterator));
                    subIterator.detach();
                } else {
                    iterator.remove();
                }
                if (node.nodeType == 10) { // DocumentType
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }
                frag.appendChild(node);
            }
            return frag;
        }

        function getNodesInRange(range, nodeTypes, filter) {
            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
            var filterExists = !!filter;
            if (filterNodeTypes) {
                regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
            }

            var nodes = [];
            iterateSubtree(new RangeIterator(range, false), function(node) {
                if (filterNodeTypes && !regex.test(node.nodeType)) {
                    return;
                }
                if (filterExists && !filter(node)) {
                    return;
                }
                // Don't include a boundary container if it is a character data node and the range does not contain any
                // of its character data. See issue 190.
                var sc = range.startContainer;
                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
                    return;
                }

                var ec = range.endContainer;
                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
                    return;
                }

                nodes.push(node);
            });
            return nodes;
        }

        function inspect(range) {
            var name = (typeof range.getName == "undefined") ? "Range" : range.getName();
            return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +
                    dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)

        function RangeIterator(range, clonePartiallySelectedTextNodes) {
            this.range = range;
            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;


            if (!range.collapsed) {
                this.sc = range.startContainer;
                this.so = range.startOffset;
                this.ec = range.endContainer;
                this.eo = range.endOffset;
                var root = range.commonAncestorContainer;

                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
                    this.isSingleCharacterDataNode = true;
                    this._first = this._last = this._next = this.sc;
                } else {
                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?
                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?
                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
                }
            }
        }

        RangeIterator.prototype = {
            _current: null,
            _next: null,
            _first: null,
            _last: null,
            isSingleCharacterDataNode: false,

            reset: function() {
                this._current = null;
                this._next = this._first;
            },

            hasNext: function() {
                return !!this._next;
            },

            next: function() {
                // Move to next node
                var current = this._current = this._next;
                if (current) {
                    this._next = (current !== this._last) ? current.nextSibling : null;

                    // Check for partially selected text nodes
                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
                        if (current === this.ec) {
                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
                        }
                        if (this._current === this.sc) {
                            (current = current.cloneNode(true)).deleteData(0, this.so);
                        }
                    }
                }

                return current;
            },

            remove: function() {
                var current = this._current, start, end;

                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
                    start = (current === this.sc) ? this.so : 0;
                    end = (current === this.ec) ? this.eo : current.length;
                    if (start != end) {
                        current.deleteData(start, end - start);
                    }
                } else {
                    if (current.parentNode) {
                        current.parentNode.removeChild(current);
                    } else {
                    }
                }
            },

            // Checks if the current node is partially selected
            isPartiallySelectedSubtree: function() {
                var current = this._current;
                return isNonTextPartiallySelected(current, this.range);
            },

            getSubtreeIterator: function() {
                var subRange;
                if (this.isSingleCharacterDataNode) {
                    subRange = this.range.cloneRange();
                    subRange.collapse(false);
                } else {
                    subRange = new Range(getRangeDocument(this.range));
                    var current = this._current;
                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);

                    if (isOrIsAncestorOf(current, this.sc)) {
                        startContainer = this.sc;
                        startOffset = this.so;
                    }
                    if (isOrIsAncestorOf(current, this.ec)) {
                        endContainer = this.ec;
                        endOffset = this.eo;
                    }

                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
                }
                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
            },

            detach: function() {
                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
            }
        };

        /*----------------------------------------------------------------------------------------------------------------*/

        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
        var rootContainerNodeTypes = [2, 9, 11];
        var readonlyNodeTypes = [5, 6, 10, 12];
        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];

        function createAncestorFinder(nodeTypes) {
            return function(node, selfIsAncestor) {
                var t, n = selfIsAncestor ? node : node.parentNode;
                while (n) {
                    t = n.nodeType;
                    if (arrayContains(nodeTypes, t)) {
                        return n;
                    }
                    n = n.parentNode;
                }
                return null;
            };
        }

        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );
        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );

        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }

        function assertValidNodeType(node, invalidTypes) {
            if (!arrayContains(invalidTypes, node.nodeType)) {
                throw new DOMException("INVALID_NODE_TYPE_ERR");
            }
        }

        function assertValidOffset(node, offset) {
            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
                throw new DOMException("INDEX_SIZE_ERR");
            }
        }

        function assertSameDocumentOrFragment(node1, node2) {
            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }

        function assertNodeNotReadOnly(node) {
            if (getReadonlyAncestor(node, true)) {
                throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");
            }
        }

        function assertNode(node, codeName) {
            if (!node) {
                throw new DOMException(codeName);
            }
        }

        function isOrphan(node) {
            return (crashyTextNodes && dom.isBrokenNode(node)) ||
                !arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);
        }

        function isValidOffset(node, offset) {
            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
        }

        function isRangeValid(range) {
            return (!!range.startContainer && !!range.endContainer &&
                    !isOrphan(range.startContainer) &&
                    !isOrphan(range.endContainer) &&
                    isValidOffset(range.startContainer, range.startOffset) &&
                    isValidOffset(range.endContainer, range.endOffset));
        }

        function assertRangeValid(range) {
            if (!isRangeValid(range)) {
                throw new Error("Range error: Range is no longer valid after DOM mutation (" + range.inspect() + ")");
            }
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Test the browser's innerHTML support to decide how to implement createContextualFragment
        var styleEl = document.createElement("style");
        var htmlParsingConforms = false;
        try {
            styleEl.innerHTML = "<b>x</b>";
            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node
        } catch (e) {
            // IE 6 and 7 throw
        }

        api.features.htmlParsingConforms = htmlParsingConforms;

        var createContextualFragment = htmlParsingConforms ?

            // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See
            // discussion and base code for this implementation at issue 67.
            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface
            // Thanks to Aleks Williams.
            function(fragmentStr) {
                // "Let node the context object's start's node."
                var node = this.startContainer;
                var doc = getDocument(node);

                // "If the context object's start's node is null, raise an INVALID_STATE_ERR
                // exception and abort these steps."
                if (!node) {
                    throw new DOMException("INVALID_STATE_ERR");
                }

                // "Let element be as follows, depending on node's interface:"
                // Document, Document Fragment: null
                var el = null;

                // "Element: node"
                if (node.nodeType == 1) {
                    el = node;

                // "Text, Comment: node's parentElement"
                } else if (isCharacterDataNode(node)) {
                    el = dom.parentElement(node);
                }

                // "If either element is null or element's ownerDocument is an HTML document
                // and element's local name is "html" and element's namespace is the HTML
                // namespace"
                if (el === null || (
                    el.nodeName == "HTML" &&
                    dom.isHtmlNamespace(getDocument(el).documentElement) &&
                    dom.isHtmlNamespace(el)
                )) {

                // "let element be a new Element with "body" as its local name and the HTML
                // namespace as its namespace.""
                    el = doc.createElement("body");
                } else {
                    el = el.cloneNode(false);
                }

                // "If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm."
                // "If the node's document is an XML document: Invoke the XML fragment parsing algorithm."
                // "In either case, the algorithm must be invoked with fragment as the input
                // and element as the context element."
                el.innerHTML = fragmentStr;

                // "If this raises an exception, then abort these steps. Otherwise, let new
                // children be the nodes returned."

                // "Let fragment be a new DocumentFragment."
                // "Append all new children to fragment."
                // "Return fragment."
                return dom.fragmentFromNodeChildren(el);
            } :

            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that
            // previous versions of Rangy used (with the exception of using a body element rather than a div)
            function(fragmentStr) {
                var doc = getRangeDocument(this);
                var el = doc.createElement("body");
                el.innerHTML = fragmentStr;

                return dom.fragmentFromNodeChildren(el);
            };

        function splitRangeBoundaries(range, positionsToPreserve) {
            assertRangeValid(range);

            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
            var startEndSame = (sc === ec);

            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
                splitDataNode(ec, eo, positionsToPreserve);
            }

            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
                sc = splitDataNode(sc, so, positionsToPreserve);
                if (startEndSame) {
                    eo -= so;
                    ec = sc;
                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
                    eo++;
                }
                so = 0;
            }
            range.setStartAndEnd(sc, so, ec, eo);
        }
        
        function rangeToHtml(range) {
            assertRangeValid(range);
            var container = range.commonAncestorContainer.parentNode.cloneNode(false);
            container.appendChild( range.cloneContents() );
            return container.innerHTML;
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
            "commonAncestorContainer"];

        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;

        util.extend(api.rangePrototype, {
            compareBoundaryPoints: function(how, range) {
                assertRangeValid(this);
                assertSameDocumentOrFragment(this.startContainer, range.startContainer);

                var nodeA, offsetA, nodeB, offsetB;
                var prefixA = (how == e2s || how == s2s) ? "start" : "end";
                var prefixB = (how == s2e || how == s2s) ? "start" : "end";
                nodeA = this[prefixA + "Container"];
                offsetA = this[prefixA + "Offset"];
                nodeB = range[prefixB + "Container"];
                offsetB = range[prefixB + "Offset"];
                return comparePoints(nodeA, offsetA, nodeB, offsetB);
            },

            insertNode: function(node) {
                assertRangeValid(this);
                assertValidNodeType(node, insertableNodeTypes);
                assertNodeNotReadOnly(this.startContainer);

                if (isOrIsAncestorOf(node, this.startContainer)) {
                    throw new DOMException("HIERARCHY_REQUEST_ERR");
                }

                // No check for whether the container of the start of the Range is of a type that does not allow
                // children of the type of node: the browser's DOM implementation should do this for us when we attempt
                // to add the node

                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
                this.setStartBefore(firstNodeInserted);
            },

            cloneContents: function() {
                assertRangeValid(this);

                var clone, frag;
                if (this.collapsed) {
                    return getRangeDocument(this).createDocumentFragment();
                } else {
                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
                        clone = this.startContainer.cloneNode(true);
                        clone.data = clone.data.slice(this.startOffset, this.endOffset);
                        frag = getRangeDocument(this).createDocumentFragment();
                        frag.appendChild(clone);
                        return frag;
                    } else {
                        var iterator = new RangeIterator(this, true);
                        clone = cloneSubtree(iterator);
                        iterator.detach();
                    }
                    return clone;
                }
            },

            canSurroundContents: function() {
                assertRangeValid(this);
                assertNodeNotReadOnly(this.startContainer);
                assertNodeNotReadOnly(this.endContainer);

                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
                // no non-text nodes.
                var iterator = new RangeIterator(this, true);
                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                iterator.detach();
                return !boundariesInvalid;
            },

            surroundContents: function(node) {
                assertValidNodeType(node, surroundNodeTypes);

                if (!this.canSurroundContents()) {
                    throw new DOMException("INVALID_STATE_ERR");
                }

                // Extract the contents
                var content = this.extractContents();

                // Clear the children of the node
                if (node.hasChildNodes()) {
                    while (node.lastChild) {
                        node.removeChild(node.lastChild);
                    }
                }

                // Insert the new node and add the extracted contents
                insertNodeAtPosition(node, this.startContainer, this.startOffset);
                node.appendChild(content);

                this.selectNode(node);
            },

            cloneRange: function() {
                assertRangeValid(this);
                var range = new Range(getRangeDocument(this));
                var i = rangeProperties.length, prop;
                while (i--) {
                    prop = rangeProperties[i];
                    range[prop] = this[prop];
                }
                return range;
            },

            toString: function() {
                assertRangeValid(this);
                var sc = this.startContainer;
                if (sc === this.endContainer && isCharacterDataNode(sc)) {
                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";
                } else {
                    var textParts = [], iterator = new RangeIterator(this, true);
                    iterateSubtree(iterator, function(node) {
                        // Accept only text or CDATA nodes, not comments
                        if (node.nodeType == 3 || node.nodeType == 4) {
                            textParts.push(node.data);
                        }
                    });
                    iterator.detach();
                    return textParts.join("");
                }
            },

            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since
            // been removed from Mozilla.

            compareNode: function(node) {
                assertRangeValid(this);

                var parent = node.parentNode;
                var nodeIndex = getNodeIndex(node);

                if (!parent) {
                    throw new DOMException("NOT_FOUND_ERR");
                }

                var startComparison = this.comparePoint(parent, nodeIndex),
                    endComparison = this.comparePoint(parent, nodeIndex + 1);

                if (startComparison < 0) { // Node starts before
                    return (endComparison > 0) ? n_b_a : n_b;
                } else {
                    return (endComparison > 0) ? n_a : n_i;
                }
            },

            comparePoint: function(node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);

                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
                    return -1;
                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
                    return 1;
                }
                return 0;
            },

            createContextualFragment: createContextualFragment,

            toHtml: function() {
                return rangeToHtml(this);
            },

            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects
            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)
            intersectsNode: function(node, touchingIsIntersecting) {
                assertRangeValid(this);
                assertNode(node, "NOT_FOUND_ERR");
                if (getDocument(node) !== getRangeDocument(this)) {
                    return false;
                }

                var parent = node.parentNode, offset = getNodeIndex(node);
                assertNode(parent, "NOT_FOUND_ERR");

                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),
                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);

                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
            },

            isPointInRange: function(node, offset) {
                assertRangeValid(this);
                assertNode(node, "HIERARCHY_REQUEST_ERR");
                assertSameDocumentOrFragment(node, this.startContainer);

                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&
                       (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);
            },

            // The methods below are non-standard and invented by me.

            // Sharing a boundary start-to-end or end-to-start does not count as intersection.
            intersectsRange: function(range) {
                return rangesIntersect(this, range, false);
            },

            // Sharing a boundary start-to-end or end-to-start does count as intersection.
            intersectsOrTouchesRange: function(range) {
                return rangesIntersect(this, range, true);
            },

            intersection: function(range) {
                if (this.intersectsRange(range)) {
                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),
                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);

                    var intersectionRange = this.cloneRange();
                    if (startComparison == -1) {
                        intersectionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (endComparison == 1) {
                        intersectionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return intersectionRange;
                }
                return null;
            },

            union: function(range) {
                if (this.intersectsOrTouchesRange(range)) {
                    var unionRange = this.cloneRange();
                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
                        unionRange.setStart(range.startContainer, range.startOffset);
                    }
                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
                        unionRange.setEnd(range.endContainer, range.endOffset);
                    }
                    return unionRange;
                } else {
                    throw new DOMException("Ranges do not intersect");
                }
            },

            containsNode: function(node, allowPartial) {
                if (allowPartial) {
                    return this.intersectsNode(node, false);
                } else {
                    return this.compareNode(node) == n_i;
                }
            },

            containsNodeContents: function(node) {
                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
            },

            containsRange: function(range) {
                var intersection = this.intersection(range);
                return intersection !== null && range.equals(intersection);
            },

            containsNodeText: function(node) {
                var nodeRange = this.cloneRange();
                nodeRange.selectNode(node);
                var textNodes = nodeRange.getNodes([3]);
                if (textNodes.length > 0) {
                    nodeRange.setStart(textNodes[0], 0);
                    var lastTextNode = textNodes.pop();
                    nodeRange.setEnd(lastTextNode, lastTextNode.length);
                    return this.containsRange(nodeRange);
                } else {
                    return this.containsNodeContents(node);
                }
            },

            getNodes: function(nodeTypes, filter) {
                assertRangeValid(this);
                return getNodesInRange(this, nodeTypes, filter);
            },

            getDocument: function() {
                return getRangeDocument(this);
            },

            collapseBefore: function(node) {
                this.setEndBefore(node);
                this.collapse(false);
            },

            collapseAfter: function(node) {
                this.setStartAfter(node);
                this.collapse(true);
            },
            
            getBookmark: function(containerNode) {
                var doc = getRangeDocument(this);
                var preSelectionRange = api.createRange(doc);
                containerNode = containerNode || dom.getBody(doc);
                preSelectionRange.selectNodeContents(containerNode);
                var range = this.intersection(preSelectionRange);
                var start = 0, end = 0;
                if (range) {
                    preSelectionRange.setEnd(range.startContainer, range.startOffset);
                    start = preSelectionRange.toString().length;
                    end = start + range.toString().length;
                }

                return {
                    start: start,
                    end: end,
                    containerNode: containerNode
                };
            },
            
            moveToBookmark: function(bookmark) {
                var containerNode = bookmark.containerNode;
                var charIndex = 0;
                this.setStart(containerNode, 0);
                this.collapse(true);
                var nodeStack = [containerNode], node, foundStart = false, stop = false;
                var nextCharIndex, i, childNodes;

                while (!stop && (node = nodeStack.pop())) {
                    if (node.nodeType == 3) {
                        nextCharIndex = charIndex + node.length;
                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
                            this.setStart(node, bookmark.start - charIndex);
                            foundStart = true;
                        }
                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
                            this.setEnd(node, bookmark.end - charIndex);
                            stop = true;
                        }
                        charIndex = nextCharIndex;
                    } else {
                        childNodes = node.childNodes;
                        i = childNodes.length;
                        while (i--) {
                            nodeStack.push(childNodes[i]);
                        }
                    }
                }
            },

            getName: function() {
                return "DomRange";
            },

            equals: function(range) {
                return Range.rangesEqual(this, range);
            },

            isValid: function() {
                return isRangeValid(this);
            },
            
            inspect: function() {
                return inspect(this);
            },
            
            detach: function() {
                // In DOM4, detach() is now a no-op.
            }
        });

        function copyComparisonConstantsToObject(obj) {
            obj.START_TO_START = s2s;
            obj.START_TO_END = s2e;
            obj.END_TO_END = e2e;
            obj.END_TO_START = e2s;

            obj.NODE_BEFORE = n_b;
            obj.NODE_AFTER = n_a;
            obj.NODE_BEFORE_AND_AFTER = n_b_a;
            obj.NODE_INSIDE = n_i;
        }

        function copyComparisonConstants(constructor) {
            copyComparisonConstantsToObject(constructor);
            copyComparisonConstantsToObject(constructor.prototype);
        }

        function createRangeContentRemover(remover, boundaryUpdater) {
            return function() {
                assertRangeValid(this);

                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;

                var iterator = new RangeIterator(this, true);

                // Work out where to position the range after content removal
                var node, boundary;
                if (sc !== root) {
                    node = getClosestAncestorIn(sc, root, true);
                    boundary = getBoundaryAfterNode(node);
                    sc = boundary.node;
                    so = boundary.offset;
                }

                // Check none of the range is read-only
                iterateSubtree(iterator, assertNodeNotReadOnly);

                iterator.reset();

                // Remove the content
                var returnValue = remover(iterator);
                iterator.detach();

                // Move to the new position
                boundaryUpdater(this, sc, so, sc, so);

                return returnValue;
            };
        }

        function createPrototypeRange(constructor, boundaryUpdater) {
            function createBeforeAfterNodeSetter(isBefore, isStart) {
                return function(node) {
                    assertValidNodeType(node, beforeAfterNodeTypes);
                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);

                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
                };
            }

            function setRangeStart(range, node, offset) {
                var ec = range.endContainer, eo = range.endOffset;
                if (node !== range.startContainer || offset !== range.startOffset) {
                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
                    // is after the current end. In either case, collapse the range to the new position
                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
                        ec = node;
                        eo = offset;
                    }
                    boundaryUpdater(range, node, offset, ec, eo);
                }
            }

            function setRangeEnd(range, node, offset) {
                var sc = range.startContainer, so = range.startOffset;
                if (node !== range.endContainer || offset !== range.endOffset) {
                    // Check the root containers of the range and the new boundary, and also check whether the new boundary
                    // is after the current end. In either case, collapse the range to the new position
                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
                        sc = node;
                        so = offset;
                    }
                    boundaryUpdater(range, sc, so, node, offset);
                }
            }

            // Set up inheritance
            var F = function() {};
            F.prototype = api.rangePrototype;
            constructor.prototype = new F();

            util.extend(constructor.prototype, {
                setStart: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);

                    setRangeStart(this, node, offset);
                },

                setEnd: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);

                    setRangeEnd(this, node, offset);
                },

                /**
                 * Convenience method to set a range's start and end boundaries. Overloaded as follows:
                 * - Two parameters (node, offset) creates a collapsed range at that position
                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at
                 *   startOffset and ending at endOffset
                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in
                 *   startNode and ending at endOffset in endNode
                 */
                setStartAndEnd: function() {
                    var args = arguments;
                    var sc = args[0], so = args[1], ec = sc, eo = so;

                    switch (args.length) {
                        case 3:
                            eo = args[2];
                            break;
                        case 4:
                            ec = args[2];
                            eo = args[3];
                            break;
                    }

                    boundaryUpdater(this, sc, so, ec, eo);
                },
                
                setBoundary: function(node, offset, isStart) {
                    this["set" + (isStart ? "Start" : "End")](node, offset);
                },

                setStartBefore: createBeforeAfterNodeSetter(true, true),
                setStartAfter: createBeforeAfterNodeSetter(false, true),
                setEndBefore: createBeforeAfterNodeSetter(true, false),
                setEndAfter: createBeforeAfterNodeSetter(false, false),

                collapse: function(isStart) {
                    assertRangeValid(this);
                    if (isStart) {
                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
                    } else {
                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
                    }
                },

                selectNodeContents: function(node) {
                    assertNoDocTypeNotationEntityAncestor(node, true);

                    boundaryUpdater(this, node, 0, node, getNodeLength(node));
                },

                selectNode: function(node) {
                    assertNoDocTypeNotationEntityAncestor(node, false);
                    assertValidNodeType(node, beforeAfterNodeTypes);

                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
                },

                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),

                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),

                canSurroundContents: function() {
                    assertRangeValid(this);
                    assertNodeNotReadOnly(this.startContainer);
                    assertNodeNotReadOnly(this.endContainer);

                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
                    // no non-text nodes.
                    var iterator = new RangeIterator(this, true);
                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||
                            (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                    iterator.detach();
                    return !boundariesInvalid;
                },

                splitBoundaries: function() {
                    splitRangeBoundaries(this);
                },

                splitBoundariesPreservingPositions: function(positionsToPreserve) {
                    splitRangeBoundaries(this, positionsToPreserve);
                },

                normalizeBoundaries: function() {
                    assertRangeValid(this);

                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;

                    var mergeForward = function(node) {
                        var sibling = node.nextSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            ec = node;
                            eo = node.length;
                            node.appendData(sibling.data);
                            sibling.parentNode.removeChild(sibling);
                        }
                    };

                    var mergeBackward = function(node) {
                        var sibling = node.previousSibling;
                        if (sibling && sibling.nodeType == node.nodeType) {
                            sc = node;
                            var nodeLength = node.length;
                            so = sibling.length;
                            node.insertData(0, sibling.data);
                            sibling.parentNode.removeChild(sibling);
                            if (sc == ec) {
                                eo += so;
                                ec = sc;
                            } else if (ec == node.parentNode) {
                                var nodeIndex = getNodeIndex(node);
                                if (eo == nodeIndex) {
                                    ec = node;
                                    eo = nodeLength;
                                } else if (eo > nodeIndex) {
                                    eo--;
                                }
                            }
                        }
                    };

                    var normalizeStart = true;

                    if (isCharacterDataNode(ec)) {
                        if (ec.length == eo) {
                            mergeForward(ec);
                        }
                    } else {
                        if (eo > 0) {
                            var endNode = ec.childNodes[eo - 1];
                            if (endNode && isCharacterDataNode(endNode)) {
                                mergeForward(endNode);
                            }
                        }
                        normalizeStart = !this.collapsed;
                    }

                    if (normalizeStart) {
                        if (isCharacterDataNode(sc)) {
                            if (so == 0) {
                                mergeBackward(sc);
                            }
                        } else {
                            if (so < sc.childNodes.length) {
                                var startNode = sc.childNodes[so];
                                if (startNode && isCharacterDataNode(startNode)) {
                                    mergeBackward(startNode);
                                }
                            }
                        }
                    } else {
                        sc = ec;
                        so = eo;
                    }

                    boundaryUpdater(this, sc, so, ec, eo);
                },

                collapseToPoint: function(node, offset) {
                    assertNoDocTypeNotationEntityAncestor(node, true);
                    assertValidOffset(node, offset);
                    this.setStartAndEnd(node, offset);
                }
            });

            copyComparisonConstants(constructor);
        }

        /*----------------------------------------------------------------------------------------------------------------*/

        // Updates commonAncestorContainer and collapsed after boundary change
        function updateCollapsedAndCommonAncestor(range) {
            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
            range.commonAncestorContainer = range.collapsed ?
                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
        }

        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
            range.startContainer = startContainer;
            range.startOffset = startOffset;
            range.endContainer = endContainer;
            range.endOffset = endOffset;
            range.document = dom.getDocument(startContainer);

            updateCollapsedAndCommonAncestor(range);
        }

        function Range(doc) {
            this.startContainer = doc;
            this.startOffset = 0;
            this.endContainer = doc;
            this.endOffset = 0;
            this.document = doc;
            updateCollapsedAndCommonAncestor(this);
        }

        createPrototypeRange(Range, updateBoundaries);

        util.extend(Range, {
            rangeProperties: rangeProperties,
            RangeIterator: RangeIterator,
            copyComparisonConstants: copyComparisonConstants,
            createPrototypeRange: createPrototypeRange,
            inspect: inspect,
            toHtml: rangeToHtml,
            getRangeDocument: getRangeDocument,
            rangesEqual: function(r1, r2) {
                return r1.startContainer === r2.startContainer &&
                    r1.startOffset === r2.startOffset &&
                    r1.endContainer === r2.endContainer &&
                    r1.endOffset === r2.endOffset;
            }
        });

        api.DomRange = Range;
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // Wrappers for the browser's native DOM Range and/or TextRange implementation 
    api.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {
        var WrappedRange, WrappedTextRange;
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DomRange = api.DomRange;
        var getBody = dom.getBody;
        var getContentDocument = dom.getContentDocument;
        var isCharacterDataNode = dom.isCharacterDataNode;


        /*----------------------------------------------------------------------------------------------------------------*/

        if (api.features.implementsDomRange) {
            // This is a wrapper around the browser's native DOM Range. It has two aims:
            // - Provide workarounds for specific browser bugs
            // - provide convenient extensions, which are inherited from Rangy's DomRange

            (function() {
                var rangeProto;
                var rangeProperties = DomRange.rangeProperties;

                function updateRangeProperties(range) {
                    var i = rangeProperties.length, prop;
                    while (i--) {
                        prop = rangeProperties[i];
                        range[prop] = range.nativeRange[prop];
                    }
                    // Fix for broken collapsed property in IE 9.
                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
                }

                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {
                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);
                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);
                    var nativeRangeDifferent = !range.equals(range.nativeRange);

                    // Always set both boundaries for the benefit of IE9 (see issue 35)
                    if (startMoved || endMoved || nativeRangeDifferent) {
                        range.setEnd(endContainer, endOffset);
                        range.setStart(startContainer, startOffset);
                    }
                }

                var createBeforeAfterNodeSetter;

                WrappedRange = function(range) {
                    if (!range) {
                        throw module.createError("WrappedRange: Range must be specified");
                    }
                    this.nativeRange = range;
                    updateRangeProperties(this);
                };

                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);

                rangeProto = WrappedRange.prototype;

                rangeProto.selectNode = function(node) {
                    this.nativeRange.selectNode(node);
                    updateRangeProperties(this);
                };

                rangeProto.cloneContents = function() {
                    return this.nativeRange.cloneContents();
                };

                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,
                // insertNode() is never delegated to the native range.

                rangeProto.surroundContents = function(node) {
                    this.nativeRange.surroundContents(node);
                    updateRangeProperties(this);
                };

                rangeProto.collapse = function(isStart) {
                    this.nativeRange.collapse(isStart);
                    updateRangeProperties(this);
                };

                rangeProto.cloneRange = function() {
                    return new WrappedRange(this.nativeRange.cloneRange());
                };

                rangeProto.refresh = function() {
                    updateRangeProperties(this);
                };

                rangeProto.toString = function() {
                    return this.nativeRange.toString();
                };

                // Create test range and node for feature detection

                var testTextNode = document.createTextNode("test");
                getBody(document).appendChild(testTextNode);
                var range = document.createRange();

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and
                // correct for it

                range.setStart(testTextNode, 0);
                range.setEnd(testTextNode, 0);

                try {
                    range.setStart(testTextNode, 1);

                    rangeProto.setStart = function(node, offset) {
                        this.nativeRange.setStart(node, offset);
                        updateRangeProperties(this);
                    };

                    rangeProto.setEnd = function(node, offset) {
                        this.nativeRange.setEnd(node, offset);
                        updateRangeProperties(this);
                    };

                    createBeforeAfterNodeSetter = function(name) {
                        return function(node) {
                            this.nativeRange[name](node);
                            updateRangeProperties(this);
                        };
                    };

                } catch(ex) {

                    rangeProto.setStart = function(node, offset) {
                        try {
                            this.nativeRange.setStart(node, offset);
                        } catch (ex) {
                            this.nativeRange.setEnd(node, offset);
                            this.nativeRange.setStart(node, offset);
                        }
                        updateRangeProperties(this);
                    };

                    rangeProto.setEnd = function(node, offset) {
                        try {
                            this.nativeRange.setEnd(node, offset);
                        } catch (ex) {
                            this.nativeRange.setStart(node, offset);
                            this.nativeRange.setEnd(node, offset);
                        }
                        updateRangeProperties(this);
                    };

                    createBeforeAfterNodeSetter = function(name, oppositeName) {
                        return function(node) {
                            try {
                                this.nativeRange[name](node);
                            } catch (ex) {
                                this.nativeRange[oppositeName](node);
                                this.nativeRange[name](node);
                            }
                            updateRangeProperties(this);
                        };
                    };
                }

                rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
                rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
                rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
                rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");

                /*--------------------------------------------------------------------------------------------------------*/

                // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing
                // whether the native implementation can be trusted
                rangeProto.selectNodeContents = function(node) {
                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));
                };

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for
                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738

                range.selectNodeContents(testTextNode);
                range.setEnd(testTextNode, 3);

                var range2 = document.createRange();
                range2.selectNodeContents(testTextNode);
                range2.setEnd(testTextNode, 4);
                range2.setStart(testTextNode, 2);

                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&
                        range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
                    // This is the wrong way round, so correct for it

                    rangeProto.compareBoundaryPoints = function(type, range) {
                        range = range.nativeRange || range;
                        if (type == range.START_TO_END) {
                            type = range.END_TO_START;
                        } else if (type == range.END_TO_START) {
                            type = range.START_TO_END;
                        }
                        return this.nativeRange.compareBoundaryPoints(type, range);
                    };
                } else {
                    rangeProto.compareBoundaryPoints = function(type, range) {
                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
                    };
                }

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for IE 9 deleteContents() and extractContents() bug and correct it. See issue 107.

                var el = document.createElement("div");
                el.innerHTML = "123";
                var textNode = el.firstChild;
                var body = getBody(document);
                body.appendChild(el);

                range.setStart(textNode, 1);
                range.setEnd(textNode, 2);
                range.deleteContents();

                if (textNode.data == "13") {
                    // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and
                    // extractContents()
                    rangeProto.deleteContents = function() {
                        this.nativeRange.deleteContents();
                        updateRangeProperties(this);
                    };

                    rangeProto.extractContents = function() {
                        var frag = this.nativeRange.extractContents();
                        updateRangeProperties(this);
                        return frag;
                    };
                } else {
                }

                body.removeChild(el);
                body = null;

                /*--------------------------------------------------------------------------------------------------------*/

                // Test for existence of createContextualFragment and delegate to it if it exists
                if (util.isHostMethod(range, "createContextualFragment")) {
                    rangeProto.createContextualFragment = function(fragmentStr) {
                        return this.nativeRange.createContextualFragment(fragmentStr);
                    };
                }

                /*--------------------------------------------------------------------------------------------------------*/

                // Clean up
                getBody(document).removeChild(testTextNode);

                rangeProto.getName = function() {
                    return "WrappedRange";
                };

                api.WrappedRange = WrappedRange;

                api.createNativeRange = function(doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return doc.createRange();
                };
            })();
        }
        
        if (api.features.implementsTextRange) {
            /*
            This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()
            method. For example, in the following (where pipes denote the selection boundaries):

            <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>

            var range = document.selection.createRange();
            alert(range.parentElement().id); // Should alert "ul" but alerts "b"

            This method returns the common ancestor node of the following:
            - the parentElement() of the textRange
            - the parentElement() of the textRange after calling collapse(true)
            - the parentElement() of the textRange after calling collapse(false)
            */
            var getTextRangeContainerElement = function(textRange) {
                var parentEl = textRange.parentElement();
                var range = textRange.duplicate();
                range.collapse(true);
                var startEl = range.parentElement();
                range = textRange.duplicate();
                range.collapse(false);
                var endEl = range.parentElement();
                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);

                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
            };

            var textRangeIsCollapsed = function(textRange) {
                return textRange.compareEndPoints("StartToEnd", textRange) == 0;
            };

            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started
            // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)
            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange
            // bugs, handling for inputs and images, plus optimizations.
            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
                var workingRange = textRange.duplicate();
                workingRange.collapse(isStart);
                var containerElement = workingRange.parentElement();

                // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so
                // check for that
                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
                    containerElement = wholeRangeContainerElement;
                }


                // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and
                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx
                if (!containerElement.canHaveHTML) {
                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
                    return {
                        boundaryPosition: pos,
                        nodeInfo: {
                            nodeIndex: pos.offset,
                            containerElement: pos.node
                        }
                    };
                }

                var workingNode = dom.getDocument(containerElement).createElement("span");

                // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5
                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64
                if (workingNode.parentNode) {
                    workingNode.parentNode.removeChild(workingNode);
                }

                var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
                var previousNode, nextNode, boundaryPosition, boundaryNode;
                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;
                var childNodeCount = containerElement.childNodes.length;
                var end = childNodeCount;

                // Check end first. Code within the loop assumes that the endth child node of the container is definitely
                // after the range boundary.
                var nodeIndex = end;

                while (true) {
                    if (nodeIndex == childNodeCount) {
                        containerElement.appendChild(workingNode);
                    } else {
                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
                    }
                    workingRange.moveToElementText(workingNode);
                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
                    if (comparison == 0 || start == end) {
                        break;
                    } else if (comparison == -1) {
                        if (end == start + 1) {
                            // We know the endth child node is after the range boundary, so we must be done.
                            break;
                        } else {
                            start = nodeIndex;
                        }
                    } else {
                        end = (end == start + 1) ? start : nodeIndex;
                    }
                    nodeIndex = Math.floor((start + end) / 2);
                    containerElement.removeChild(workingNode);
                }


                // We've now reached or gone past the boundary of the text range we're interested in
                // so have identified the node we want
                boundaryNode = workingNode.nextSibling;

                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of
                    // the node containing the text range's boundary, so we move the end of the working range to the
                    // boundary point and measure the length of its text to get the boundary's offset within the node.
                    workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);

                    var offset;

                    if (/[\r\n]/.test(boundaryNode.data)) {
                        /*
                        For the particular case of a boundary within a text node containing rendered line breaks (within a
                        <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in
                        IE. The facts:
                        
                        - Each line break is represented as \r in the text node's data/nodeValue properties
                        - Each line break is represented as \r\n in the TextRange's 'text' property
                        - The 'text' property of the TextRange does not contain trailing line breaks
                        
                        To get round the problem presented by the final fact above, we can use the fact that TextRange's
                        moveStart() and moveEnd() methods return the actual number of characters moved, which is not
                        necessarily the same as the number of characters it was instructed to move. The simplest approach is
                        to use this to store the characters moved when moving both the start and end of the range to the
                        start of the document body and subtracting the start offset from the end offset (the
                        "move-negative-gazillion" method). However, this is extremely slow when the document is large and
                        the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to
                        the end of the document) has the same problem.
                        
                        Another approach that works is to use moveStart() to move the start boundary of the range up to the
                        end boundary one character at a time and incrementing a counter with the value returned by the
                        moveStart() call. However, the check for whether the start boundary has reached the end boundary is
                        expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected
                        by the location of the range within the document).
                        
                        The approach used below is a hybrid of the two methods above. It uses the fact that a string
                        containing the TextRange's 'text' property with each \r\n converted to a single \r character cannot
                        be longer than the text of the TextRange, so the start of the range is moved that length initially
                        and then a character at a time to make up for any trailing line breaks not contained in the 'text'
                        property. This has good performance in most situations compared to the previous two methods.
                        */
                        var tempRange = workingRange.duplicate();
                        var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;

                        offset = tempRange.moveStart("character", rangeLength);
                        while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
                            offset++;
                            tempRange.moveStart("character", 1);
                        }
                    } else {
                        offset = workingRange.text.length;
                    }
                    boundaryPosition = new DomPosition(boundaryNode, offset);
                } else {

                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour
                    // a position within that, and likewise for a start boundary preceding a character data node
                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
                    if (nextNode && isCharacterDataNode(nextNode)) {
                        boundaryPosition = new DomPosition(nextNode, 0);
                    } else if (previousNode && isCharacterDataNode(previousNode)) {
                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
                    } else {
                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
                    }
                }

                // Clean up
                workingNode.parentNode.removeChild(workingNode);

                return {
                    boundaryPosition: boundaryPosition,
                    nodeInfo: {
                        nodeIndex: nodeIndex,
                        containerElement: containerElement
                    }
                };
            };

            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that
            // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange
            // (http://code.google.com/p/ierange/)
            var createBoundaryTextRange = function(boundaryPosition, isStart) {
                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
                var doc = dom.getDocument(boundaryPosition.node);
                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();
                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);

                if (nodeIsDataNode) {
                    boundaryNode = boundaryPosition.node;
                    boundaryParent = boundaryNode.parentNode;
                } else {
                    childNodes = boundaryPosition.node.childNodes;
                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;
                    boundaryParent = boundaryPosition.node;
                }

                // Position the range immediately before the node containing the boundary
                workingNode = doc.createElement("span");

                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within
                // the element rather than immediately before or after it
                workingNode.innerHTML = "&#feff;";

                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report
                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12
                if (boundaryNode) {
                    boundaryParent.insertBefore(workingNode, boundaryNode);
                } else {
                    boundaryParent.appendChild(workingNode);
                }

                workingRange.moveToElementText(workingNode);
                workingRange.collapse(!isStart);

                // Clean up
                boundaryParent.removeChild(workingNode);

                // Move the working range to the text offset, if required
                if (nodeIsDataNode) {
                    workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
                }

                return workingRange;
            };

            /*------------------------------------------------------------------------------------------------------------*/

            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a
            // prototype

            WrappedTextRange = function(textRange) {
                this.textRange = textRange;
                this.refresh();
            };

            WrappedTextRange.prototype = new DomRange(document);

            WrappedTextRange.prototype.refresh = function() {
                var start, end, startBoundary;

                // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.
                var rangeContainerElement = getTextRangeContainerElement(this.textRange);

                if (textRangeIsCollapsed(this.textRange)) {
                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,
                        true).boundaryPosition;
                } else {
                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
                    start = startBoundary.boundaryPosition;

                    // An optimization used here is that if the start and end boundaries have the same parent element, the
                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes
                    // the start boundary
                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,
                        startBoundary.nodeInfo).boundaryPosition;
                }

                this.setStart(start.node, start.offset);
                this.setEnd(end.node, end.offset);
            };

            WrappedTextRange.prototype.getName = function() {
                return "WrappedTextRange";
            };

            DomRange.copyComparisonConstants(WrappedTextRange);

            var rangeToTextRange = function(range) {
                if (range.collapsed) {
                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                } else {
                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();
                    textRange.setEndPoint("StartToStart", startRange);
                    textRange.setEndPoint("EndToEnd", endRange);
                    return textRange;
                }
            };

            WrappedTextRange.rangeToTextRange = rangeToTextRange;

            WrappedTextRange.prototype.toTextRange = function() {
                return rangeToTextRange(this);
            };

            api.WrappedTextRange = WrappedTextRange;

            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which
            // implementation to use by default.
            if (!api.features.implementsDomRange || api.config.preferTextRange) {
                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work
                var globalObj = (function() { return this; })();
                if (typeof globalObj.Range == "undefined") {
                    globalObj.Range = WrappedTextRange;
                }

                api.createNativeRange = function(doc) {
                    doc = getContentDocument(doc, module, "createNativeRange");
                    return getBody(doc).createTextRange();
                };

                api.WrappedRange = WrappedTextRange;
            }
        }

        api.createRange = function(doc) {
            doc = getContentDocument(doc, module, "createRange");
            return new api.WrappedRange(api.createNativeRange(doc));
        };

        api.createRangyRange = function(doc) {
            doc = getContentDocument(doc, module, "createRangyRange");
            return new DomRange(doc);
        };

        api.createIframeRange = function(iframeEl) {
            module.deprecationNotice("createIframeRange()", "createRange(iframeEl)");
            return api.createRange(iframeEl);
        };

        api.createIframeRangyRange = function(iframeEl) {
            module.deprecationNotice("createIframeRangyRange()", "createRangyRange(iframeEl)");
            return api.createRangyRange(iframeEl);
        };

        api.addShimListener(function(win) {
            var doc = win.document;
            if (typeof doc.createRange == "undefined") {
                doc.createRange = function() {
                    return api.createRange(doc);
                };
            }
            doc = win = null;
        });
    });

    /*----------------------------------------------------------------------------------------------------------------*/

    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification
    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)
    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {
        api.config.checkSelectionRanges = true;

        var BOOLEAN = "boolean";
        var NUMBER = "number";
        var dom = api.dom;
        var util = api.util;
        var isHostMethod = util.isHostMethod;
        var DomRange = api.DomRange;
        var WrappedRange = api.WrappedRange;
        var DOMException = api.DOMException;
        var DomPosition = dom.DomPosition;
        var getNativeSelection;
        var selectionIsCollapsed;
        var features = api.features;
        var CONTROL = "Control";
        var getDocument = dom.getDocument;
        var getBody = dom.getBody;
        var rangesEqual = DomRange.rangesEqual;


        // Utility function to support direction parameters in the API that may be a string ("backward" or "forward") or a
        // Boolean (true for backwards).
        function isDirectionBackward(dir) {
            return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;
        }

        function getWindow(win, methodName) {
            if (!win) {
                return window;
            } else if (dom.isWindow(win)) {
                return win;
            } else if (win instanceof WrappedSelection) {
                return win.win;
            } else {
                var doc = dom.getContentDocument(win, module, methodName);
                return dom.getWindow(doc);
            }
        }

        function getWinSelection(winParam) {
            return getWindow(winParam, "getWinSelection").getSelection();
        }

        function getDocSelection(winParam) {
            return getWindow(winParam, "getDocSelection").document.selection;
        }
        
        function winSelectionIsBackward(sel) {
            var backward = false;
            if (sel.anchorNode) {
                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);
            }
            return backward;
        }

        // Test for the Range/TextRange and Selection features required
        // Test for ability to retrieve selection
        var implementsWinGetSelection = isHostMethod(window, "getSelection"),
            implementsDocSelection = util.isHostObject(document, "selection");

        features.implementsWinGetSelection = implementsWinGetSelection;
        features.implementsDocSelection = implementsDocSelection;

        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);

        if (useDocumentSelection) {
            getNativeSelection = getDocSelection;
            api.isSelectionValid = function(winParam) {
                var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;

                // Check whether the selection TextRange is actually contained within the correct document
                return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);
            };
        } else if (implementsWinGetSelection) {
            getNativeSelection = getWinSelection;
            api.isSelectionValid = function() {
                return true;
            };
        } else {
            module.fail("Neither document.selection or window.getSelection() detected.");
        }

        api.getNativeSelection = getNativeSelection;

        var testSelection = getNativeSelection();
        var testRange = api.createNativeRange(document);
        var body = getBody(document);

        // Obtaining a range from a selection
        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,
            ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);

        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;

        // Test for existence of native selection extend() method
        var selectionHasExtend = isHostMethod(testSelection, "extend");
        features.selectionHasExtend = selectionHasExtend;
        
        // Test if rangeCount exists
        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);
        features.selectionHasRangeCount = selectionHasRangeCount;

        var selectionSupportsMultipleRanges = false;
        var collapsedNonEditableSelectionsSupported = true;

        var addRangeBackwardToNative = selectionHasExtend ?
            function(nativeSelection, range) {
                var doc = DomRange.getRangeDocument(range);
                var endRange = api.createRange(doc);
                endRange.collapseToPoint(range.endContainer, range.endOffset);
                nativeSelection.addRange(getNativeRange(endRange));
                nativeSelection.extend(range.startContainer, range.startOffset);
            } : null;

        if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&
                typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {

            (function() {
                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are
                // performed on the current document's selection. See issue 109.

                // Note also that if a selection previously existed, it is wiped by these tests. This should usually be fine
                // because initialization usually happens when the document loads, but could be a problem for a script that
                // loads and initializes Rangy later. If anyone complains, code could be added to save and restore the
                // selection.
                var sel = window.getSelection();
                if (sel) {
                    // Store the current selection
                    var originalSelectionRangeCount = sel.rangeCount;
                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);
                    var originalSelectionRanges = [];
                    var originalSelectionBackward = winSelectionIsBackward(sel); 
                    for (var i = 0; i < originalSelectionRangeCount; ++i) {
                        originalSelectionRanges[i] = sel.getRangeAt(i);
                    }
                    
                    // Create some test elements
                    var body = getBody(document);
                    var testEl = body.appendChild( document.createElement("div") );
                    testEl.contentEditable = "false";
                    var textNode = testEl.appendChild( document.createTextNode("\u00a0\u00a0\u00a0") );

                    // Test whether the native selection will allow a collapsed selection within a non-editable element
                    var r1 = document.createRange();

                    r1.setStart(textNode, 1);
                    r1.collapse(true);
                    sel.addRange(r1);
                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);
                    sel.removeAllRanges();

                    // Test whether the native selection is capable of supporting multiple ranges.
                    if (!selectionHasMultipleRanges) {
                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a
                        // console error of "Discontiguous selection is not supported." that cannot be suppressed. There's
                        // nothing we can do about this while retaining the feature test so we have to resort to a browser
                        // sniff. I'm not happy about it. See
                        // https://code.google.com/p/chromium/issues/detail?id=399791
                        var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
                            selectionSupportsMultipleRanges = false;
                        } else {
                            var r2 = r1.cloneRange();
                            r1.setStart(textNode, 0);
                            r2.setEnd(textNode, 3);
                            r2.setStart(textNode, 2);
                            sel.addRange(r1);
                            sel.addRange(r2);
                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);
                        }
                    }

                    // Clean up
                    body.removeChild(testEl);
                    sel.removeAllRanges();

                    for (i = 0; i < originalSelectionRangeCount; ++i) {
                        if (i == 0 && originalSelectionBackward) {
                            if (addRangeBackwardToNative) {
                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);
                            } else {
                                api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
                                sel.addRange(originalSelectionRanges[i]);
                            }
                        } else {
                            sel.addRange(originalSelectionRanges[i]);
                        }
                    }
                }
            })();
        }

        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;

        // ControlRanges
        var implementsControlRange = false, testControlRange;

        if (body && isHostMethod(body, "createControlRange")) {
            testControlRange = body.createControlRange();
            if (util.areHostProperties(testControlRange, ["item", "add"])) {
                implementsControlRange = true;
            }
        }
        features.implementsControlRange = implementsControlRange;

        // Selection collapsedness
        if (selectionHasAnchorAndFocus) {
            selectionIsCollapsed = function(sel) {
                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
            };
        } else {
            selectionIsCollapsed = function(sel) {
                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
            };
        }

        function updateAnchorAndFocusFromRange(sel, range, backward) {
            var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
            sel.anchorNode = range[anchorPrefix + "Container"];
            sel.anchorOffset = range[anchorPrefix + "Offset"];
            sel.focusNode = range[focusPrefix + "Container"];
            sel.focusOffset = range[focusPrefix + "Offset"];
        }

        function updateAnchorAndFocusFromNativeSelection(sel) {
            var nativeSel = sel.nativeSelection;
            sel.anchorNode = nativeSel.anchorNode;
            sel.anchorOffset = nativeSel.anchorOffset;
            sel.focusNode = nativeSel.focusNode;
            sel.focusOffset = nativeSel.focusOffset;
        }

        function updateEmptySelection(sel) {
            sel.anchorNode = sel.focusNode = null;
            sel.anchorOffset = sel.focusOffset = 0;
            sel.rangeCount = 0;
            sel.isCollapsed = true;
            sel._ranges.length = 0;
        }

        function getNativeRange(range) {
            var nativeRange;
            if (range instanceof DomRange) {
                nativeRange = api.createNativeRange(range.getDocument());
                nativeRange.setEnd(range.endContainer, range.endOffset);
                nativeRange.setStart(range.startContainer, range.startOffset);
            } else if (range instanceof WrappedRange) {
                nativeRange = range.nativeRange;
            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {
                nativeRange = range;
            }
            return nativeRange;
        }

        function rangeContainsSingleElement(rangeNodes) {
            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
                return false;
            }
            for (var i = 1, len = rangeNodes.length; i < len; ++i) {
                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
                    return false;
                }
            }
            return true;
        }

        function getSingleElementFromRange(range) {
            var nodes = range.getNodes();
            if (!rangeContainsSingleElement(nodes)) {
                throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
            }
            return nodes[0];
        }

        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange
        function isTextRange(range) {
            return !!range && typeof range.text != "undefined";
        }

        function updateFromTextRange(sel, range) {
            // Create a Range from the selected TextRange
            var wrappedRange = new WrappedRange(range);
            sel._ranges = [wrappedRange];

            updateAnchorAndFocusFromRange(sel, wrappedRange, false);
            sel.rangeCount = 1;
            sel.isCollapsed = wrappedRange.collapsed;
        }

        function updateControlSelection(sel) {
            // Update the wrapped selection based on what's now in the native selection
            sel._ranges.length = 0;
            if (sel.docSelection.type == "None") {
                updateEmptySelection(sel);
            } else {
                var controlRange = sel.docSelection.createRange();
                if (isTextRange(controlRange)) {
                    // This case (where the selection type is "Control" and calling createRange() on the selection returns
                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected
                    // ControlRange have been removed from the ControlRange and removed from the document.
                    updateFromTextRange(sel, controlRange);
                } else {
                    sel.rangeCount = controlRange.length;
                    var range, doc = getDocument(controlRange.item(0));
                    for (var i = 0; i < sel.rangeCount; ++i) {
                        range = api.createRange(doc);
                        range.selectNode(controlRange.item(i));
                        sel._ranges.push(range);
                    }
                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
                }
            }
        }

        function addRangeToControlSelection(sel, range) {
            var controlRange = sel.docSelection.createRange();
            var rangeElement = getSingleElementFromRange(range);

            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element
            // contained by the supplied range
            var doc = getDocument(controlRange.item(0));
            var newControlRange = getBody(doc).createControlRange();
            for (var i = 0, len = controlRange.length; i < len; ++i) {
                newControlRange.add(controlRange.item(i));
            }
            try {
                newControlRange.add(rangeElement);
            } catch (ex) {
                throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
            }
            newControlRange.select();

            // Update the wrapped selection based on what's now in the native selection
            updateControlSelection(sel);
        }

        var getSelectionRangeAt;

        if (isHostMethod(testSelection, "getRangeAt")) {
            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.
            // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a
            // lesson to us all, especially me.
            getSelectionRangeAt = function(sel, index) {
                try {
                    return sel.getRangeAt(index);
                } catch (ex) {
                    return null;
                }
            };
        } else if (selectionHasAnchorAndFocus) {
            getSelectionRangeAt = function(sel) {
                var doc = getDocument(sel.anchorNode);
                var range = api.createRange(doc);
                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);

                // Handle the case when the selection was selected backwards (from the end to the start in the
                // document)
                if (range.collapsed !== this.isCollapsed) {
                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
                }

                return range;
            };
        }

        function WrappedSelection(selection, docSelection, win) {
            this.nativeSelection = selection;
            this.docSelection = docSelection;
            this._ranges = [];
            this.win = win;
            this.refresh();
        }

        WrappedSelection.prototype = api.selectionPrototype;

        function deleteProperties(sel) {
            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
            sel.detached = true;
        }

        var cachedRangySelections = [];

        function actOnCachedSelection(win, action) {
            var i = cachedRangySelections.length, cached, sel;
            while (i--) {
                cached = cachedRangySelections[i];
                sel = cached.selection;
                if (action == "deleteAll") {
                    deleteProperties(sel);
                } else if (cached.win == win) {
                    if (action == "delete") {
                        cachedRangySelections.splice(i, 1);
                        return true;
                    } else {
                        return sel;
                    }
                }
            }
            if (action == "deleteAll") {
                cachedRangySelections.length = 0;
            }
            return null;
        }

        var getSelection = function(win) {
            // Check if the parameter is a Rangy Selection object
            if (win && win instanceof WrappedSelection) {
                win.refresh();
                return win;
            }

            win = getWindow(win, "getNativeSelection");

            var sel = actOnCachedSelection(win);
            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
            if (sel) {
                sel.nativeSelection = nativeSel;
                sel.docSelection = docSel;
                sel.refresh();
            } else {
                sel = new WrappedSelection(nativeSel, docSel, win);
                cachedRangySelections.push( { win: win, selection: sel } );
            }
            return sel;
        };

        api.getSelection = getSelection;

        api.getIframeSelection = function(iframeEl) {
            module.deprecationNotice("getIframeSelection()", "getSelection(iframeEl)");
            return api.getSelection(dom.getIframeWindow(iframeEl));
        };

        var selProto = WrappedSelection.prototype;

        function createControlSelection(sel, ranges) {
            // Ensure that the selection becomes of type "Control"
            var doc = getDocument(ranges[0].startContainer);
            var controlRange = getBody(doc).createControlRange();
            for (var i = 0, el, len = ranges.length; i < len; ++i) {
                el = getSingleElementFromRange(ranges[i]);
                try {
                    controlRange.add(el);
                } catch (ex) {
                    throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
                }
            }
            controlRange.select();

            // Update the wrapped selection based on what's now in the native selection
            updateControlSelection(sel);
        }

        // Selecting a range
        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
            selProto.removeAllRanges = function() {
                this.nativeSelection.removeAllRanges();
                updateEmptySelection(this);
            };

            var addRangeBackward = function(sel, range) {
                addRangeBackwardToNative(sel.nativeSelection, range);
                sel.refresh();
            };

            if (selectionHasRangeCount) {
                selProto.addRange = function(range, direction) {
                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                        addRangeToControlSelection(this, range);
                    } else {
                        if (isDirectionBackward(direction) && selectionHasExtend) {
                            addRangeBackward(this, range);
                        } else {
                            var previousRangeCount;
                            if (selectionSupportsMultipleRanges) {
                                previousRangeCount = this.rangeCount;
                            } else {
                                this.removeAllRanges();
                                previousRangeCount = 0;
                            }
                            // Clone the native range so that changing the selected range does not affect the selection.
                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See
                            // issue 80.
                            this.nativeSelection.addRange(getNativeRange(range).cloneRange());

                            // Check whether adding the range was successful
                            this.rangeCount = this.nativeSelection.rangeCount;

                            if (this.rangeCount == previousRangeCount + 1) {
                                // The range was added successfully

                                // Check whether the range that we added to the selection is reflected in the last range extracted from
                                // the selection
                                if (api.config.checkSelectionRanges) {
                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                                    if (nativeRange && !rangesEqual(nativeRange, range)) {
                                        // Happens in WebKit with, for example, a selection placed at the start of a text node
                                        range = new WrappedRange(nativeRange);
                                    }
                                }
                                this._ranges[this.rangeCount - 1] = range;
                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
                                this.isCollapsed = selectionIsCollapsed(this);
                            } else {
                                // The range was not added successfully. The simplest thing is to refresh
                                this.refresh();
                            }
                        }
                    }
                };
            } else {
                selProto.addRange = function(range, direction) {
                    if (isDirectionBackward(direction) && selectionHasExtend) {
                        addRangeBackward(this, range);
                    } else {
                        this.nativeSelection.addRange(getNativeRange(range));
                        this.refresh();
                    }
                };
            }

            selProto.setRanges = function(ranges) {
                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
                    createControlSelection(this, ranges);
                } else {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        this.addRange(ranges[i]);
                    }
                }
            };
        } else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&
                   implementsControlRange && useDocumentSelection) {

            selProto.removeAllRanges = function() {
                // Added try/catch as fix for issue #21
                try {
                    this.docSelection.empty();

                    // Check for empty() not working (issue #24)
                    if (this.docSelection.type != "None") {
                        // Work around failure to empty a control selection by instead selecting a TextRange and then
                        // calling empty()
                        var doc;
                        if (this.anchorNode) {
                            doc = getDocument(this.anchorNode);
                        } else if (this.docSelection.type == CONTROL) {
                            var controlRange = this.docSelection.createRange();
                            if (controlRange.length) {
                                doc = getDocument( controlRange.item(0) );
                            }
                        }
                        if (doc) {
                            var textRange = getBody(doc).createTextRange();
                            textRange.select();
                            this.docSelection.empty();
                        }
                    }
                } catch(ex) {}
                updateEmptySelection(this);
            };

            selProto.addRange = function(range) {
                if (this.docSelection.type == CONTROL) {
                    addRangeToControlSelection(this, range);
                } else {
                    api.WrappedTextRange.rangeToTextRange(range).select();
                    this._ranges[0] = range;
                    this.rangeCount = 1;
                    this.isCollapsed = this._ranges[0].collapsed;
                    updateAnchorAndFocusFromRange(this, range, false);
                }
            };

            selProto.setRanges = function(ranges) {
                this.removeAllRanges();
                var rangeCount = ranges.length;
                if (rangeCount > 1) {
                    createControlSelection(this, ranges);
                } else if (rangeCount) {
                    this.addRange(ranges[0]);
                }
            };
        } else {
            module.fail("No means of selecting a Range or TextRange was found");
            return false;
        }

        selProto.getRangeAt = function(index) {
            if (index < 0 || index >= this.rangeCount) {
                throw new DOMException("INDEX_SIZE_ERR");
            } else {
                // Clone the range to preserve selection-range independence. See issue 80.
                return this._ranges[index].cloneRange();
            }
        };

        var refreshSelection;

        if (useDocumentSelection) {
            refreshSelection = function(sel) {
                var range;
                if (api.isSelectionValid(sel.win)) {
                    range = sel.docSelection.createRange();
                } else {
                    range = getBody(sel.win.document).createTextRange();
                    range.collapse(true);
                }

                if (sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                } else if (isTextRange(range)) {
                    updateFromTextRange(sel, range);
                } else {
                    updateEmptySelection(sel);
                }
            };
        } else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
            refreshSelection = function(sel) {
                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
                    updateControlSelection(sel);
                } else {
                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
                    if (sel.rangeCount) {
                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
                        }
                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
                        sel.isCollapsed = selectionIsCollapsed(sel);
                    } else {
                        updateEmptySelection(sel);
                    }
                }
            };
        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
            refreshSelection = function(sel) {
                var range, nativeSel = sel.nativeSelection;
                if (nativeSel.anchorNode) {
                    range = getSelectionRangeAt(nativeSel, 0);
                    sel._ranges = [range];
                    sel.rangeCount = 1;
                    updateAnchorAndFocusFromNativeSelection(sel);
                    sel.isCollapsed = selectionIsCollapsed(sel);
                } else {
                    updateEmptySelection(sel);
                }
            };
        } else {
            module.fail("No means of obtaining a Range or TextRange from the user's selection was found");
            return false;
        }

        selProto.refresh = function(checkForChanges) {
            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;

            refreshSelection(this);
            if (checkForChanges) {
                // Check the range count first
                var i = oldRanges.length;
                if (i != this._ranges.length) {
                    return true;
                }

                // Now check the direction. Checking the anchor position is the same is enough since we're checking all the
                // ranges after this
                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
                    return true;
                }

                // Finally, compare each range in turn
                while (i--) {
                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {
                        return true;
                    }
                }
                return false;
            }
        };

        // Removal of a single range
        var removeRangeManually = function(sel, range) {
            var ranges = sel.getAllRanges();
            sel.removeAllRanges();
            for (var i = 0, len = ranges.length; i < len; ++i) {
                if (!rangesEqual(range, ranges[i])) {
                    sel.addRange(ranges[i]);
                }
            }
            if (!sel.rangeCount) {
                updateEmptySelection(sel);
            }
        };

        if (implementsControlRange && implementsDocSelection) {
            selProto.removeRange = function(range) {
                if (this.docSelection.type == CONTROL) {
                    var controlRange = this.docSelection.createRange();
                    var rangeElement = getSingleElementFromRange(range);

                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the
                    // element contained by the supplied range
                    var doc = getDocument(controlRange.item(0));
                    var newControlRange = getBody(doc).createControlRange();
                    var el, removed = false;
                    for (var i = 0, len = controlRange.length; i < len; ++i) {
                        el = controlRange.item(i);
                        if (el !== rangeElement || removed) {
                            newControlRange.add(controlRange.item(i));
                        } else {
                            removed = true;
                        }
                    }
                    newControlRange.select();

                    // Update the wrapped selection based on what's now in the native selection
                    updateControlSelection(this);
                } else {
                    removeRangeManually(this, range);
                }
            };
        } else {
            selProto.removeRange = function(range) {
                removeRangeManually(this, range);
            };
        }

        // Detecting if a selection is backward
        var selectionIsBackward;
        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
            selectionIsBackward = winSelectionIsBackward;

            selProto.isBackward = function() {
                return selectionIsBackward(this);
            };
        } else {
            selectionIsBackward = selProto.isBackward = function() {
                return false;
            };
        }

        // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"
        selProto.isBackwards = selProto.isBackward;

        // Selection stringifier
        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.
        // The current spec does not yet define this method.
        selProto.toString = function() {
            var rangeTexts = [];
            for (var i = 0, len = this.rangeCount; i < len; ++i) {
                rangeTexts[i] = "" + this._ranges[i];
            }
            return rangeTexts.join("");
        };

        function assertNodeInSameDocument(sel, node) {
            if (sel.win.document != getDocument(node)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }
        }

        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used
        selProto.collapse = function(node, offset) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.collapseToPoint(node, offset);
            this.setSingleRange(range);
            this.isCollapsed = true;
        };

        selProto.collapseToStart = function() {
            if (this.rangeCount) {
                var range = this._ranges[0];
                this.collapse(range.startContainer, range.startOffset);
            } else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };

        selProto.collapseToEnd = function() {
            if (this.rangeCount) {
                var range = this._ranges[this.rangeCount - 1];
                this.collapse(range.endContainer, range.endOffset);
            } else {
                throw new DOMException("INVALID_STATE_ERR");
            }
        };

        // The spec is very specific on how selectAllChildren should be implemented so the native implementation is
        // never used by Rangy.
        selProto.selectAllChildren = function(node) {
            assertNodeInSameDocument(this, node);
            var range = api.createRange(node);
            range.selectNodeContents(node);
            this.setSingleRange(range);
        };

        selProto.deleteFromDocument = function() {
            // Sepcial behaviour required for IE's control selections
            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                var controlRange = this.docSelection.createRange();
                var element;
                while (controlRange.length) {
                    element = controlRange.item(0);
                    controlRange.remove(element);
                    element.parentNode.removeChild(element);
                }
                this.refresh();
            } else if (this.rangeCount) {
                var ranges = this.getAllRanges();
                if (ranges.length) {
                    this.removeAllRanges();
                    for (var i = 0, len = ranges.length; i < len; ++i) {
                        ranges[i].deleteContents();
                    }
                    // The spec says nothing about what the selection should contain after calling deleteContents on each
                    // range. Firefox moves the selection to where the final selected range was, so we emulate that
                    this.addRange(ranges[len - 1]);
                }
            }
        };

        // The following are non-standard extensions
        selProto.eachRange = function(func, returnValue) {
            for (var i = 0, len = this._ranges.length; i < len; ++i) {
                if ( func( this.getRangeAt(i) ) ) {
                    return returnValue;
                }
            }
        };

        selProto.getAllRanges = function() {
            var ranges = [];
            this.eachRange(function(range) {
                ranges.push(range);
            });
            return ranges;
        };

        selProto.setSingleRange = function(range, direction) {
            this.removeAllRanges();
            this.addRange(range, direction);
        };

        selProto.callMethodOnEachRange = function(methodName, params) {
            var results = [];
            this.eachRange( function(range) {
                results.push( range[methodName].apply(range, params) );
            } );
            return results;
        };
        
        function createStartOrEndSetter(isStart) {
            return function(node, offset) {
                var range;
                if (this.rangeCount) {
                    range = this.getRangeAt(0);
                    range["set" + (isStart ? "Start" : "End")](node, offset);
                } else {
                    range = api.createRange(this.win.document);
                    range.setStartAndEnd(node, offset);
                }
                this.setSingleRange(range, this.isBackward());
            };
        }

        selProto.setStart = createStartOrEndSetter(true);
        selProto.setEnd = createStartOrEndSetter(false);
        
        // Add select() method to Range prototype. Any existing selection will be removed.
        api.rangePrototype.select = function(direction) {
            getSelection( this.getDocument() ).setSingleRange(this, direction);
        };

        selProto.changeEachRange = function(func) {
            var ranges = [];
            var backward = this.isBackward();

            this.eachRange(function(range) {
                func(range);
                ranges.push(range);
            });

            this.removeAllRanges();
            if (backward && ranges.length == 1) {
                this.addRange(ranges[0], "backward");
            } else {
                this.setRanges(ranges);
            }
        };

        selProto.containsNode = function(node, allowPartial) {
            return this.eachRange( function(range) {
                return range.containsNode(node, allowPartial);
            }, true ) || false;
        };

        selProto.getBookmark = function(containerNode) {
            return {
                backward: this.isBackward(),
                rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
            };
        };

        selProto.moveToBookmark = function(bookmark) {
            var selRanges = [];
            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {
                range = api.createRange(this.win);
                range.moveToBookmark(rangeBookmark);
                selRanges.push(range);
            }
            if (bookmark.backward) {
                this.setSingleRange(selRanges[0], "backward");
            } else {
                this.setRanges(selRanges);
            }
        };

        selProto.toHtml = function() {
            var rangeHtmls = [];
            this.eachRange(function(range) {
                rangeHtmls.push( DomRange.toHtml(range) );
            });
            return rangeHtmls.join("");
        };

        if (features.implementsTextRange) {
            selProto.getNativeTextRange = function() {
                var sel, textRange;
                if ( (sel = this.docSelection) ) {
                    var range = sel.createRange();
                    if (isTextRange(range)) {
                        return range;
                    } else {
                        throw module.createError("getNativeTextRange: selection is a control selection"); 
                    }
                } else if (this.rangeCount > 0) {
                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );
                } else {
                    throw module.createError("getNativeTextRange: selection contains no range");
                }
            };
        }

        function inspect(sel) {
            var rangeInspects = [];
            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
            var focus = new DomPosition(sel.focusNode, sel.focusOffset);
            var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";

            if (typeof sel.rangeCount != "undefined") {
                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
                }
            }
            return "[" + name + "(Ranges: " + rangeInspects.join(", ") +
                    ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
        }

        selProto.getName = function() {
            return "WrappedSelection";
        };

        selProto.inspect = function() {
            return inspect(this);
        };

        selProto.detach = function() {
            actOnCachedSelection(this.win, "delete");
            deleteProperties(this);
        };

        WrappedSelection.detachAll = function() {
            actOnCachedSelection(null, "deleteAll");
        };

        WrappedSelection.inspect = inspect;
        WrappedSelection.isDirectionBackward = isDirectionBackward;

        api.Selection = WrappedSelection;

        api.selectionPrototype = selProto;

        api.addShimListener(function(win) {
            if (typeof win.getSelection == "undefined") {
                win.getSelection = function() {
                    return getSelection(win);
                };
            }
            win = null;
        });
    });
    

    /*----------------------------------------------------------------------------------------------------------------*/

    return api;
}, this);;/**
 * Selection save and restore module for Rangy.
 * Saves and restores user selections using marker invisible elements in the DOM.
 *
 * Part of Rangy, a cross-browser JavaScript range and selection library
 * http://code.google.com/p/rangy/
 *
 * Depends on Rangy core.
 *
 * Copyright 2014, Tim Down
 * Licensed under the MIT license.
 * Version: 1.3alpha.20140804
 * Build date: 4 August 2014
 */
(function(factory, global) {
    if (typeof define == "function" && define.amd) {
        // AMD. Register as an anonymous module with a dependency on Rangy.
        define(["rangy"], factory);
        /*
         } else if (typeof exports == "object") {
         // Node/CommonJS style for Browserify
         module.exports = factory;
         */
    } else {
        // No AMD or CommonJS support so we use the rangy global variable
        factory(global.rangy);
    }
})(function(rangy) {
    rangy.createModule("SaveRestore", ["WrappedRange"], function(api, module) {
        var dom = api.dom;

        var markerTextChar = "\ufeff";

        function gEBI(id, doc) {
            return (doc || document).getElementById(id);
        }

        function insertRangeBoundaryMarker(range, atStart) {
            var markerId = "selectionBoundary_" + (+new Date()) + "_" + ("" + Math.random()).slice(2);
            var markerEl;
            var doc = dom.getDocument(range.startContainer);

            // Clone the Range and collapse to the appropriate boundary point
            var boundaryRange = range.cloneRange();
            boundaryRange.collapse(atStart);

            // Create the marker element containing a single invisible character using DOM methods and insert it
            markerEl = doc.createElement("span");
            markerEl.id = markerId;
            markerEl.style.lineHeight = "0";
            markerEl.style.display = "none";
            markerEl.className = "rangySelectionBoundary";
            markerEl.appendChild(doc.createTextNode(markerTextChar));

            boundaryRange.insertNode(markerEl);
            return markerEl;
        }

        function setRangeBoundary(doc, range, markerId, atStart) {
            var markerEl = gEBI(markerId, doc);
            if (markerEl) {
                range[atStart ? "setStartBefore" : "setEndBefore"](markerEl);
                markerEl.parentNode.removeChild(markerEl);
            } else {
                module.warn("Marker element has been removed. Cannot restore selection.");
            }
        }

        function compareRanges(r1, r2) {
            return r2.compareBoundaryPoints(r1.START_TO_START, r1);
        }

        function saveRange(range, backward) {
            var startEl, endEl, doc = api.DomRange.getRangeDocument(range), text = range.toString();

            if (range.collapsed) {
                endEl = insertRangeBoundaryMarker(range, false);
                return {
                    document: doc,
                    markerId: endEl.id,
                    collapsed: true
                };
            } else {
                endEl = insertRangeBoundaryMarker(range, false);
                startEl = insertRangeBoundaryMarker(range, true);

                return {
                    document: doc,
                    startMarkerId: startEl.id,
                    endMarkerId: endEl.id,
                    collapsed: false,
                    backward: backward,
                    toString: function() {
                        return "original text: '" + text + "', new text: '" + range.toString() + "'";
                    }
                };
            }
        }

        function restoreRange(rangeInfo, normalize) {
            var doc = rangeInfo.document;
            if (typeof normalize == "undefined") {
                normalize = true;
            }
            var range = api.createRange(doc);
            if (rangeInfo.collapsed) {
                var markerEl = gEBI(rangeInfo.markerId, doc);
                if (markerEl) {
                    markerEl.style.display = "inline";
                    var previousNode = markerEl.previousSibling;

                    // Workaround for issue 17
                    if (previousNode && previousNode.nodeType == 3) {
                        markerEl.parentNode.removeChild(markerEl);
                        range.collapseToPoint(previousNode, previousNode.length);
                    } else {
                        range.collapseBefore(markerEl);
                        markerEl.parentNode.removeChild(markerEl);
                    }
                } else {
                    module.warn("Marker element has been removed. Cannot restore selection.");
                }
            } else {
                setRangeBoundary(doc, range, rangeInfo.startMarkerId, true);
                setRangeBoundary(doc, range, rangeInfo.endMarkerId, false);
            }

            if (normalize) {
                range.normalizeBoundaries();
            }

            return range;
        }

        function saveRanges(ranges, backward) {
            var rangeInfos = [], range, doc;

            // Order the ranges by position within the DOM, latest first, cloning the array to leave the original untouched
            ranges = ranges.slice(0);
            ranges.sort(compareRanges);

            for (var i = 0, len = ranges.length; i < len; ++i) {
                rangeInfos[i] = saveRange(ranges[i], backward);
            }

            // Now that all the markers are in place and DOM manipulation over, adjust each range's boundaries to lie
            // between its markers
            for (i = len - 1; i >= 0; --i) {
                range = ranges[i];
                doc = api.DomRange.getRangeDocument(range);
                if (range.collapsed) {
                    range.collapseAfter(gEBI(rangeInfos[i].markerId, doc));
                } else {
                    range.setEndBefore(gEBI(rangeInfos[i].endMarkerId, doc));
                    range.setStartAfter(gEBI(rangeInfos[i].startMarkerId, doc));
                }
            }

            return rangeInfos;
        }

        function saveSelection(win) {
            if (!api.isSelectionValid(win)) {
                module.warn("Cannot save selection. This usually happens when the selection is collapsed and the selection document has lost focus.");
                return null;
            }
            var sel = api.getSelection(win);
            var ranges = sel.getAllRanges();
            var backward = (ranges.length == 1 && sel.isBackward());

            var rangeInfos = saveRanges(ranges, backward);

            // Ensure current selection is unaffected
            if (backward) {
                sel.setSingleRange(ranges[0], "backward");
            } else {
                sel.setRanges(ranges);
            }

            return {
                win: win,
                rangeInfos: rangeInfos,
                restored: false
            };
        }

        function restoreRanges(rangeInfos) {
            var ranges = [];

            // Ranges are in reverse order of appearance in the DOM. We want to restore earliest first to avoid
            // normalization affecting previously restored ranges.
            var rangeCount = rangeInfos.length;

            for (var i = rangeCount - 1; i >= 0; i--) {
                ranges[i] = restoreRange(rangeInfos[i], true);
            }

            return ranges;
        }

        function restoreSelection(savedSelection, preserveDirection) {
            if (!savedSelection.restored) {
                var rangeInfos = savedSelection.rangeInfos;
                var sel = api.getSelection(savedSelection.win);
                var ranges = restoreRanges(rangeInfos), rangeCount = rangeInfos.length;

                if (rangeCount == 1 && preserveDirection && api.features.selectionHasExtend && rangeInfos[0].backward) {
                    sel.removeAllRanges();
                    sel.addRange(ranges[0], true);
                } else {
                    sel.setRanges(ranges);
                }

                savedSelection.restored = true;
            }
        }

        function removeMarkerElement(doc, markerId) {
            var markerEl = gEBI(markerId, doc);
            if (markerEl) {
                markerEl.parentNode.removeChild(markerEl);
            }
        }

        function removeMarkers(savedSelection) {
            var rangeInfos = savedSelection.rangeInfos;
            for (var i = 0, len = rangeInfos.length, rangeInfo; i < len; ++i) {
                rangeInfo = rangeInfos[i];
                if (rangeInfo.collapsed) {
                    removeMarkerElement(savedSelection.doc, rangeInfo.markerId);
                } else {
                    removeMarkerElement(savedSelection.doc, rangeInfo.startMarkerId);
                    removeMarkerElement(savedSelection.doc, rangeInfo.endMarkerId);
                }
            }
        }

        api.util.extend(api, {
            saveRange: saveRange,
            restoreRange: restoreRange,
            saveRanges: saveRanges,
            restoreRanges: restoreRanges,
            saveSelection: saveSelection,
            restoreSelection: restoreSelection,
            removeMarkerElement: removeMarkerElement,
            removeMarkers: removeMarkers
        });
    });
    
}, this);;/*
	Base.js, version 1.1a
	Copyright 2006-2010, Dean Edwards
	License: http://www.opensource.org/licenses/mit-license.php
*/

var Base = function() {
	// dummy
};

Base.extend = function(_instance, _static) { // subclass
	var extend = Base.prototype.extend;
	
	// build the prototype
	Base._prototyping = true;
	var proto = new this;
	extend.call(proto, _instance);
  proto.base = function() {
    // call this method from any other method to invoke that method's ancestor
  };
	delete Base._prototyping;
	
	// create the wrapper for the constructor function
	//var constructor = proto.constructor.valueOf(); //-dean
	var constructor = proto.constructor;
	var klass = proto.constructor = function() {
		if (!Base._prototyping) {
			if (this._constructing || this.constructor == klass) { // instantiation
				this._constructing = true;
				constructor.apply(this, arguments);
				delete this._constructing;
			} else if (arguments[0] != null) { // casting
				return (arguments[0].extend || extend).call(arguments[0], proto);
			}
		}
	};
	
	// build the class interface
	klass.ancestor = this;
	klass.extend = this.extend;
	klass.forEach = this.forEach;
	klass.implement = this.implement;
	klass.prototype = proto;
	klass.toString = this.toString;
	klass.valueOf = function(type) {
		//return (type == "object") ? klass : constructor; //-dean
		return (type == "object") ? klass : constructor.valueOf();
	};
	extend.call(klass, _static);
	// class initialisation
	if (typeof klass.init == "function") klass.init();
	return klass;
};

Base.prototype = {	
	extend: function(source, value) {
		if (arguments.length > 1) { // extending with a name/value pair
			var ancestor = this[source];
			if (ancestor && (typeof value == "function") && // overriding a method?
				// the valueOf() comparison is to avoid circular references
				(!ancestor.valueOf || ancestor.valueOf() != value.valueOf()) &&
				/\bbase\b/.test(value)) {
				// get the underlying method
				var method = value.valueOf();
				// override
				value = function() {
					var previous = this.base || Base.prototype.base;
					this.base = ancestor;
					var returnValue = method.apply(this, arguments);
					this.base = previous;
					return returnValue;
				};
				// point to the underlying method
				value.valueOf = function(type) {
					return (type == "object") ? value : method;
				};
				value.toString = Base.toString;
			}
			this[source] = value;
		} else if (source) { // extending with an object literal
			var extend = Base.prototype.extend;
			// if this object has a customised extend method then use it
			if (!Base._prototyping && typeof this != "function") {
				extend = this.extend || extend;
			}
			var proto = {toSource: null};
			// do the "toString" and other methods manually
			var hidden = ["constructor", "toString", "valueOf"];
			// if we are prototyping then include the constructor
			var i = Base._prototyping ? 0 : 1;
			while (key = hidden[i++]) {
				if (source[key] != proto[key]) {
					extend.call(this, key, source[key]);

				}
			}
			// copy each of the source object's properties to this object
			for (var key in source) {
				if (!proto[key]) extend.call(this, key, source[key]);
			}
		}
		return this;
	}
};

// initialise
Base = Base.extend({
	constructor: function() {
		this.extend(arguments[0]);
	}
}, {
	ancestor: Object,
	version: "1.1",
	
	forEach: function(object, block, context) {
		for (var key in object) {
			if (this.prototype[key] === undefined) {
				block.call(context, object[key], key, object);
			}
		}
	},
		
	implement: function() {
		for (var i = 0; i < arguments.length; i++) {
			if (typeof arguments[i] == "function") {
				// if it's a function, call it
				arguments[i](this.prototype);
			} else {
				// add the interface using the extend method
				this.prototype.extend(arguments[i]);
			}
		}
		return this;
	},
	
	toString: function() {
		return String(this.valueOf());
	}
});;/**
 * Detect browser support for specific features
 */
wysihtml5.browser = (function() {
  var userAgent   = navigator.userAgent,
      testElement = document.createElement("div"),
      // Browser sniffing is unfortunately needed since some behaviors are impossible to feature detect
      isGecko     = userAgent.indexOf("Gecko")        !== -1 && userAgent.indexOf("KHTML") === -1,
      isWebKit    = userAgent.indexOf("AppleWebKit/") !== -1,
      isChrome    = userAgent.indexOf("Chrome/")      !== -1,
      isOpera     = userAgent.indexOf("Opera/")       !== -1;

  function iosVersion(userAgent) {
    return +((/ipad|iphone|ipod/.test(userAgent) && userAgent.match(/ os (\d+).+? like mac os x/)) || [undefined, 0])[1];
  }

  function androidVersion(userAgent) {
    return +(userAgent.match(/android (\d+)/) || [undefined, 0])[1];
  }

  function isIE(version, equation) {
    var rv = -1,
        re;

    if (navigator.appName == 'Microsoft Internet Explorer') {
      re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
    } else if (navigator.appName == 'Netscape') {
      re = new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})");
    }

    if (re && re.exec(navigator.userAgent) != null) {
      rv = parseFloat(RegExp.$1);
    }

    if (rv === -1) { return false; }
    if (!version) { return true; }
    if (!equation) { return version === rv; }
    if (equation === "<") { return version < rv; }
    if (equation === ">") { return version > rv; }
    if (equation === "<=") { return version <= rv; }
    if (equation === ">=") { return version >= rv; }
  }

  return {
    // Static variable needed, publicly accessible, to be able override it in unit tests
    USER_AGENT: userAgent,

    /**
     * Exclude browsers that are not capable of displaying and handling
     * contentEditable as desired:
     *    - iPhone, iPad (tested iOS 4.2.2) and Android (tested 2.2) refuse to make contentEditables focusable
     *    - IE < 8 create invalid markup and crash randomly from time to time
     *
     * @return {Boolean}
     */
    supported: function() {
      var userAgent                   = this.USER_AGENT.toLowerCase(),
          // Essential for making html elements editable
          hasContentEditableSupport   = "contentEditable" in testElement,
          // Following methods are needed in order to interact with the contentEditable area
          hasEditingApiSupport        = document.execCommand && document.queryCommandSupported && document.queryCommandState,
          // document selector apis are only supported by IE 8+, Safari 4+, Chrome and Firefox 3.5+
          hasQuerySelectorSupport     = document.querySelector && document.querySelectorAll,
          // contentEditable is unusable in mobile browsers (tested iOS 4.2.2, Android 2.2, Opera Mobile, WebOS 3.05)
          isIncompatibleMobileBrowser = (this.isIos() && iosVersion(userAgent) < 5) || (this.isAndroid() && androidVersion(userAgent) < 4) || userAgent.indexOf("opera mobi") !== -1 || userAgent.indexOf("hpwos/") !== -1;
      return hasContentEditableSupport
        && hasEditingApiSupport
        && hasQuerySelectorSupport
        && !isIncompatibleMobileBrowser;
    },

    isTouchDevice: function() {
      return this.supportsEvent("touchmove");
    },

    isIos: function() {
      return (/ipad|iphone|ipod/i).test(this.USER_AGENT);
    },

    isAndroid: function() {
      return this.USER_AGENT.indexOf("Android") !== -1;
    },

    /**
     * Whether the browser supports sandboxed iframes
     * Currently only IE 6+ offers such feature <iframe security="restricted">
     *
     * http://msdn.microsoft.com/en-us/library/ms534622(v=vs.85).aspx
     * http://blogs.msdn.com/b/ie/archive/2008/01/18/using-frames-more-securely.aspx
     *
     * HTML5 sandboxed iframes are still buggy and their DOM is not reachable from the outside (except when using postMessage)
     */
    supportsSandboxedIframes: function() {
      return isIE();
    },

    /**
     * IE6+7 throw a mixed content warning when the src of an iframe
     * is empty/unset or about:blank
     * window.querySelector is implemented as of IE8
     */
    throwsMixedContentWarningWhenIframeSrcIsEmpty: function() {
      return !("querySelector" in document);
    },

    /**
     * Whether the caret is correctly displayed in contentEditable elements
     * Firefox sometimes shows a huge caret in the beginning after focusing
     */
    displaysCaretInEmptyContentEditableCorrectly: function() {
      return isIE();
    },

    /**
     * Opera and IE are the only browsers who offer the css value
     * in the original unit, thx to the currentStyle object
     * All other browsers provide the computed style in px via window.getComputedStyle
     */
    hasCurrentStyleProperty: function() {
      return "currentStyle" in testElement;
    },

    /**
     * Firefox on OSX navigates through history when hitting CMD + Arrow right/left
     */
    hasHistoryIssue: function() {
      return isGecko && navigator.platform.substr(0, 3) === "Mac";
    },

    /**
     * Whether the browser inserts a <br> when pressing enter in a contentEditable element
     */
    insertsLineBreaksOnReturn: function() {
      return isGecko;
    },

    supportsPlaceholderAttributeOn: function(element) {
      return "placeholder" in element;
    },

    supportsEvent: function(eventName) {
      return "on" + eventName in testElement || (function() {
        testElement.setAttribute("on" + eventName, "return;");
        return typeof(testElement["on" + eventName]) === "function";
      })();
    },

    /**
     * Opera doesn't correctly fire focus/blur events when clicking in- and outside of iframe
     */
    supportsEventsInIframeCorrectly: function() {
      return !isOpera;
    },

    /**
     * Everything below IE9 doesn't know how to treat HTML5 tags
     *
     * @param {Object} context The document object on which to check HTML5 support
     *
     * @example
     *    wysihtml5.browser.supportsHTML5Tags(document);
     */
    supportsHTML5Tags: function(context) {
      var element = context.createElement("div"),
          html5   = "<article>foo</article>";
      element.innerHTML = html5;
      return element.innerHTML.toLowerCase() === html5;
    },

    /**
     * Checks whether a document supports a certain queryCommand
     * In particular, Opera needs a reference to a document that has a contentEditable in it's dom tree
     * in oder to report correct results
     *
     * @param {Object} doc Document object on which to check for a query command
     * @param {String} command The query command to check for
     * @return {Boolean}
     *
     * @example
     *    wysihtml5.browser.supportsCommand(document, "bold");
     */
    supportsCommand: (function() {
      // Following commands are supported but contain bugs in some browsers
      var buggyCommands = {
        // formatBlock fails with some tags (eg. <blockquote>)
        "formatBlock":          isIE(10, "<="),
         // When inserting unordered or ordered lists in Firefox, Chrome or Safari, the current selection or line gets
         // converted into a list (<ul><li>...</li></ul>, <ol><li>...</li></ol>)
         // IE and Opera act a bit different here as they convert the entire content of the current block element into a list
        "insertUnorderedList":  isIE(),
        "insertOrderedList":    isIE()
      };

      // Firefox throws errors for queryCommandSupported, so we have to build up our own object of supported commands
      var supported = {
        "insertHTML": isGecko
      };

      return function(doc, command) {
        var isBuggy = buggyCommands[command];
        if (!isBuggy) {
          // Firefox throws errors when invoking queryCommandSupported or queryCommandEnabled
          try {
            return doc.queryCommandSupported(command);
          } catch(e1) {}

          try {
            return doc.queryCommandEnabled(command);
          } catch(e2) {
            return !!supported[command];
          }
        }
        return false;
      };
    })(),

    /**
     * IE: URLs starting with:
     *    www., http://, https://, ftp://, gopher://, mailto:, new:, snews:, telnet:, wasis:, file://,
     *    nntp://, newsrc:, ldap://, ldaps://, outlook:, mic:// and url:
     * will automatically be auto-linked when either the user inserts them via copy&paste or presses the
     * space bar when the caret is directly after such an url.
     * This behavior cannot easily be avoided in IE < 9 since the logic is hardcoded in the mshtml.dll
     * (related blog post on msdn
     * http://blogs.msdn.com/b/ieinternals/archive/2009/09/17/prevent-automatic-hyperlinking-in-contenteditable-html.aspx).
     */
    doesAutoLinkingInContentEditable: function() {
      return isIE();
    },

    /**
     * As stated above, IE auto links urls typed into contentEditable elements
     * Since IE9 it's possible to prevent this behavior
     */
    canDisableAutoLinking: function() {
      return this.supportsCommand(document, "AutoUrlDetect");
    },

    /**
     * IE leaves an empty paragraph in the contentEditable element after clearing it
     * Chrome/Safari sometimes an empty <div>
     */
    clearsContentEditableCorrectly: function() {
      return isGecko || isOpera || isWebKit;
    },

    /**
     * IE gives wrong results for getAttribute
     */
    supportsGetAttributeCorrectly: function() {
      var td = document.createElement("td");
      return td.getAttribute("rowspan") != "1";
    },

    /**
     * When clicking on images in IE, Opera and Firefox, they are selected, which makes it easy to interact with them.
     * Chrome and Safari both don't support this
     */
    canSelectImagesInContentEditable: function() {
      return isGecko || isIE() || isOpera;
    },

    /**
     * All browsers except Safari and Chrome automatically scroll the range/caret position into view
     */
    autoScrollsToCaret: function() {
      return !isWebKit;
    },

    /**
     * Check whether the browser automatically closes tags that don't need to be opened
     */
    autoClosesUnclosedTags: function() {
      var clonedTestElement = testElement.cloneNode(false),
          returnValue,
          innerHTML;

      clonedTestElement.innerHTML = "<p><div></div>";
      innerHTML                   = clonedTestElement.innerHTML.toLowerCase();
      returnValue                 = innerHTML === "<p></p><div></div>" || innerHTML === "<p><div></div></p>";

      // Cache result by overwriting current function
      this.autoClosesUnclosedTags = function() { return returnValue; };

      return returnValue;
    },

    /**
     * Whether the browser supports the native document.getElementsByClassName which returns live NodeLists
     */
    supportsNativeGetElementsByClassName: function() {
      return String(document.getElementsByClassName).indexOf("[native code]") !== -1;
    },

    /**
     * As of now (19.04.2011) only supported by Firefox 4 and Chrome
     * See https://developer.mozilla.org/en/DOM/Selection/modify
     */
    supportsSelectionModify: function() {
      return "getSelection" in window && "modify" in window.getSelection();
    },

    /**
     * Opera needs a white space after a <br> in order to position the caret correctly
     */
    needsSpaceAfterLineBreak: function() {
      return isOpera;
    },

    /**
     * Whether the browser supports the speech api on the given element
     * See http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/
     *
     * @example
     *    var input = document.createElement("input");
     *    if (wysihtml5.browser.supportsSpeechApiOn(input)) {
     *      // ...
     *    }
     */
    supportsSpeechApiOn: function(input) {
      var chromeVersion = userAgent.match(/Chrome\/(\d+)/) || [undefined, 0];
      return chromeVersion[1] >= 11 && ("onwebkitspeechchange" in input || "speech" in input);
    },

    /**
     * IE9 crashes when setting a getter via Object.defineProperty on XMLHttpRequest or XDomainRequest
     * See https://connect.microsoft.com/ie/feedback/details/650112
     * or try the POC http://tifftiff.de/ie9_crash/
     */
    crashesWhenDefineProperty: function(property) {
      return isIE(9) && (property === "XMLHttpRequest" || property === "XDomainRequest");
    },

    /**
     * IE is the only browser who fires the "focus" event not immediately when .focus() is called on an element
     */
    doesAsyncFocus: function() {
      return isIE();
    },

    /**
     * In IE it's impssible for the user and for the selection library to set the caret after an <img> when it's the lastChild in the document
     */
    hasProblemsSettingCaretAfterImg: function() {
      return isIE();
    },

    hasUndoInContextMenu: function() {
      return isGecko || isChrome || isOpera;
    },

    /**
     * Opera sometimes doesn't insert the node at the right position when range.insertNode(someNode)
     * is used (regardless if rangy or native)
     * This especially happens when the caret is positioned right after a <br> because then
     * insertNode() will insert the node right before the <br>
     */
    hasInsertNodeIssue: function() {
      return isOpera;
    },

    /**
     * IE 8+9 don't fire the focus event of the <body> when the iframe gets focused (even though the caret gets set into the <body>)
     */
    hasIframeFocusIssue: function() {
      return isIE();
    },

    /**
     * Chrome + Safari create invalid nested markup after paste
     *
     *  <p>
     *    foo
     *    <p>bar</p> <!-- BOO! -->
     *  </p>
     */
    createsNestedInvalidMarkupAfterPaste: function() {
      return isWebKit;
    },

    supportsMutationEvents: function() {
        return ("MutationEvent" in window);
    },

    /**
      IE (at least up to 11) does not support clipboardData on event.
      It is on window but cannot return text/html
      Should actually check for clipboardData on paste event, but cannot in firefox
    */
    supportsModenPaste: function () {
      return !("clipboardData" in window);
    }
  };
})();
;wysihtml5.lang.array = function(arr) {
  return {
    /**
     * Check whether a given object exists in an array
     *
     * @example
     *    wysihtml5.lang.array([1, 2]).contains(1);
     *    // => true
     *
     * Can be used to match array with array. If intersection is found true is returned
     */
    contains: function(needle) {
      if (Array.isArray(needle)) {
        for (var i = needle.length; i--;) {
          if (wysihtml5.lang.array(arr).indexOf(needle[i]) !== -1) {
            return true;
          }
        }
        return false;
      } else {
        return wysihtml5.lang.array(arr).indexOf(needle) !== -1;
      }
    },

    /**
     * Check whether a given object exists in an array and return index
     * If no elelemt found returns -1
     *
     * @example
     *    wysihtml5.lang.array([1, 2]).indexOf(2);
     *    // => 1
     */
    indexOf: function(needle) {
        if (arr.indexOf) {
          return arr.indexOf(needle);
        } else {
          for (var i=0, length=arr.length; i<length; i++) {
            if (arr[i] === needle) { return i; }
          }
          return -1;
        }
    },

    /**
     * Substract one array from another
     *
     * @example
     *    wysihtml5.lang.array([1, 2, 3, 4]).without([3, 4]);
     *    // => [1, 2]
     */
    without: function(arrayToSubstract) {
      arrayToSubstract = wysihtml5.lang.array(arrayToSubstract);
      var newArr  = [],
          i       = 0,
          length  = arr.length;
      for (; i<length; i++) {
        if (!arrayToSubstract.contains(arr[i])) {
          newArr.push(arr[i]);
        }
      }
      return newArr;
    },

    /**
     * Return a clean native array
     *
     * Following will convert a Live NodeList to a proper Array
     * @example
     *    var childNodes = wysihtml5.lang.array(document.body.childNodes).get();
     */
    get: function() {
      var i        = 0,
          length   = arr.length,
          newArray = [];
      for (; i<length; i++) {
        newArray.push(arr[i]);
      }
      return newArray;
    },

    /**
     * Creates a new array with the results of calling a provided function on every element in this array.
     * optionally this can be provided as second argument
     *
     * @example
     *    var childNodes = wysihtml5.lang.array([1,2,3,4]).map(function (value, index, array) {
            return value * 2;
     *    });
     *    // => [2,4,6,8]
     */
    map: function(callback, thisArg) {
      if (Array.prototype.map) {
        return arr.map(callback, thisArg);
      } else {
        var len = arr.length >>> 0,
            A = new Array(len),
            i = 0;
        for (; i < len; i++) {
           A[i] = callback.call(thisArg, arr[i], i, arr);
        }
        return A;
      }
    },

    /* ReturnS new array without duplicate entries
     *
     * @example
     *    var uniq = wysihtml5.lang.array([1,2,3,2,1,4]).unique();
     *    // => [1,2,3,4]
     */
    unique: function() {
      var vals = [],
          max = arr.length,
          idx = 0;

      while (idx < max) {
        if (!wysihtml5.lang.array(vals).contains(arr[idx])) {
          vals.push(arr[idx]);
        }
        idx++;
      }
      return vals;
    }

  };
};
;wysihtml5.lang.Dispatcher = Base.extend(
  /** @scope wysihtml5.lang.Dialog.prototype */ {
  on: function(eventName, handler) {
    this.events = this.events || {};
    this.events[eventName] = this.events[eventName] || [];
    this.events[eventName].push(handler);
    return this;
  },

  off: function(eventName, handler) {
    this.events = this.events || {};
    var i = 0,
        handlers,
        newHandlers;
    if (eventName) {
      handlers    = this.events[eventName] || [],
      newHandlers = [];
      for (; i<handlers.length; i++) {
        if (handlers[i] !== handler && handler) {
          newHandlers.push(handlers[i]);
        }
      }
      this.events[eventName] = newHandlers;
    } else {
      // Clean up all events
      this.events = {};
    }
    return this;
  },

  fire: function(eventName, payload) {
    this.events = this.events || {};
    var handlers = this.events[eventName] || [],
        i        = 0;
    for (; i<handlers.length; i++) {
      handlers[i].call(this, payload);
    }
    return this;
  },

  // deprecated, use .on()
  observe: function() {
    return this.on.apply(this, arguments);
  },

  // deprecated, use .off()
  stopObserving: function() {
    return this.off.apply(this, arguments);
  }
});
;wysihtml5.lang.object = function(obj) {
  return {
    /**
     * @example
     *    wysihtml5.lang.object({ foo: 1, bar: 1 }).merge({ bar: 2, baz: 3 }).get();
     *    // => { foo: 1, bar: 2, baz: 3 }
     */
    merge: function(otherObj) {
      for (var i in otherObj) {
        obj[i] = otherObj[i];
      }
      return this;
    },

    get: function() {
      return obj;
    },

    /**
     * @example
     *    wysihtml5.lang.object({ foo: 1 }).clone();
     *    // => { foo: 1 }
     *
     *    v0.4.14 adds options for deep clone : wysihtml5.lang.object({ foo: 1 }).clone(true);
     */
    clone: function(deep) {
      var newObj = {},
          i;

      if (obj === null || !wysihtml5.lang.object(obj).isPlainObject()) {
        return obj;
      }

      for (i in obj) {
        if(obj.hasOwnProperty(i)) {
          if (deep) {
            newObj[i] = wysihtml5.lang.object(obj[i]).clone(deep);
          } else {
            newObj[i] = obj[i];
          }
        }
      }
      return newObj;
    },

    /**
     * @example
     *    wysihtml5.lang.object([]).isArray();
     *    // => true
     */
    isArray: function() {
      return Object.prototype.toString.call(obj) === "[object Array]";
    },

    /**
     * @example
     *    wysihtml5.lang.object(function() {}).isFunction();
     *    // => true
     */
    isFunction: function() {
      return Object.prototype.toString.call(obj) === '[object Function]';
    },

    isPlainObject: function () {
      return Object.prototype.toString.call(obj) === '[object Object]';
    }
  };
};
;(function() {
  var WHITE_SPACE_START = /^\s+/,
      WHITE_SPACE_END   = /\s+$/,
      ENTITY_REG_EXP    = /[&<>\t"]/g,
      ENTITY_MAP = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': "&quot;",
        '\t':"&nbsp; "
      };
  wysihtml5.lang.string = function(str) {
    str = String(str);
    return {
      /**
       * @example
       *    wysihtml5.lang.string("   foo   ").trim();
       *    // => "foo"
       */
      trim: function() {
        return str.replace(WHITE_SPACE_START, "").replace(WHITE_SPACE_END, "");
      },

      /**
       * @example
       *    wysihtml5.lang.string("Hello #{name}").interpolate({ name: "Christopher" });
       *    // => "Hello Christopher"
       */
      interpolate: function(vars) {
        for (var i in vars) {
          str = this.replace("#{" + i + "}").by(vars[i]);
        }
        return str;
      },

      /**
       * @example
       *    wysihtml5.lang.string("Hello Tom").replace("Tom").with("Hans");
       *    // => "Hello Hans"
       */
      replace: function(search) {
        return {
          by: function(replace) {
            return str.split(search).join(replace);
          }
        };
      },

      /**
       * @example
       *    wysihtml5.lang.string("hello<br>").escapeHTML();
       *    // => "hello&lt;br&gt;"
       */
      escapeHTML: function(linebreaks, convertSpaces) {
        var html = str.replace(ENTITY_REG_EXP, function(c) { return ENTITY_MAP[c]; });
        if (linebreaks) {
          html = html.replace(/(?:\r\n|\r|\n)/g, '<br />');
        }
        if (convertSpaces) {
          html = html.replace(/  /gi, "&nbsp; ");
        }
        return html;
      }
    };
  };
})();
;/**
 * Find urls in descendant text nodes of an element and auto-links them
 * Inspired by http://james.padolsey.com/javascript/find-and-replace-text-with-javascript/
 *
 * @param {Element} element Container element in which to search for urls
 *
 * @example
 *    <div id="text-container">Please click here: www.google.com</div>
 *    <script>wysihtml5.dom.autoLink(document.getElementById("text-container"));</script>
 */
(function(wysihtml5) {
  var /**
       * Don't auto-link urls that are contained in the following elements:
       */
      IGNORE_URLS_IN        = wysihtml5.lang.array(["CODE", "PRE", "A", "SCRIPT", "HEAD", "TITLE", "STYLE"]),
      /**
       * revision 1:
       *    /(\S+\.{1}[^\s\,\.\!]+)/g
       *
       * revision 2:
       *    /(\b(((https?|ftp):\/\/)|(www\.))[-A-Z0-9+&@#\/%?=~_|!:,.;\[\]]*[-A-Z0-9+&@#\/%=~_|])/gim
       *
       * put this in the beginning if you don't wan't to match within a word
       *    (^|[\>\(\{\[\s\>])
       */
      URL_REG_EXP           = /((https?:\/\/|www\.)[^\s<]{3,})/gi,
      TRAILING_CHAR_REG_EXP = /([^\w\/\-](,?))$/i,
      MAX_DISPLAY_LENGTH    = 100,
      BRACKETS              = { ")": "(", "]": "[", "}": "{" };

  function autoLink(element, ignoreInClasses) {
    if (_hasParentThatShouldBeIgnored(element, ignoreInClasses)) {
      return element;
    }

    if (element === element.ownerDocument.documentElement) {
      element = element.ownerDocument.body;
    }

    return _parseNode(element, ignoreInClasses);
  }

  /**
   * This is basically a rebuild of
   * the rails auto_link_urls text helper
   */
  function _convertUrlsToLinks(str) {
    return str.replace(URL_REG_EXP, function(match, url) {
      var punctuation = (url.match(TRAILING_CHAR_REG_EXP) || [])[1] || "",
          opening     = BRACKETS[punctuation];
      url = url.replace(TRAILING_CHAR_REG_EXP, "");

      if (url.split(opening).length > url.split(punctuation).length) {
        url = url + punctuation;
        punctuation = "";
      }
      var realUrl    = url,
          displayUrl = url;
      if (url.length > MAX_DISPLAY_LENGTH) {
        displayUrl = displayUrl.substr(0, MAX_DISPLAY_LENGTH) + "...";
      }
      // Add http prefix if necessary
      if (realUrl.substr(0, 4) === "www.") {
        realUrl = "http://" + realUrl;
      }

      return '<a href="' + realUrl + '">' + displayUrl + '</a>' + punctuation;
    });
  }

  /**
   * Creates or (if already cached) returns a temp element
   * for the given document object
   */
  function _getTempElement(context) {
    var tempElement = context._wysihtml5_tempElement;
    if (!tempElement) {
      tempElement = context._wysihtml5_tempElement = context.createElement("div");
    }
    return tempElement;
  }

  /**
   * Replaces the original text nodes with the newly auto-linked dom tree
   */
  function _wrapMatchesInNode(textNode) {
    var parentNode  = textNode.parentNode,
        nodeValue   = wysihtml5.lang.string(textNode.data).escapeHTML(),
        tempElement = _getTempElement(parentNode.ownerDocument);

    // We need to insert an empty/temporary <span /> to fix IE quirks
    // Elsewise IE would strip white space in the beginning
    tempElement.innerHTML = "<span></span>" + _convertUrlsToLinks(nodeValue);
    tempElement.removeChild(tempElement.firstChild);

    while (tempElement.firstChild) {
      // inserts tempElement.firstChild before textNode
      parentNode.insertBefore(tempElement.firstChild, textNode);
    }
    parentNode.removeChild(textNode);
  }

  function _hasParentThatShouldBeIgnored(node, ignoreInClasses) {
    var nodeName;
    while (node.parentNode) {
      node = node.parentNode;
      nodeName = node.nodeName;
      if (node.className && wysihtml5.lang.array(node.className.split(' ')).contains(ignoreInClasses)) {
        return true;
      }
      if (IGNORE_URLS_IN.contains(nodeName)) {
        return true;
      } else if (nodeName === "body") {
        return false;
      }
    }
    return false;
  }

  function _parseNode(element, ignoreInClasses) {
    if (IGNORE_URLS_IN.contains(element.nodeName)) {
      return;
    }

    if (element.className && wysihtml5.lang.array(element.className.split(' ')).contains(ignoreInClasses)) {
      return;
    }

    if (element.nodeType === wysihtml5.TEXT_NODE && element.data.match(URL_REG_EXP)) {
      _wrapMatchesInNode(element);
      return;
    }

    var childNodes        = wysihtml5.lang.array(element.childNodes).get(),
        childNodesLength  = childNodes.length,
        i                 = 0;

    for (; i<childNodesLength; i++) {
      _parseNode(childNodes[i], ignoreInClasses);
    }

    return element;
  }

  wysihtml5.dom.autoLink = autoLink;

  // Reveal url reg exp to the outside
  wysihtml5.dom.autoLink.URL_REG_EXP = URL_REG_EXP;
})(wysihtml5);
;(function(wysihtml5) {
  var api = wysihtml5.dom;

  api.addClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.add(className);
    }
    if (api.hasClass(element, className)) {
      return;
    }
    element.className += " " + className;
  };

  api.removeClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.remove(className);
    }

    element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ");
  };

  api.hasClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.contains(className);
    }

    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className || new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  };
})(wysihtml5);
;wysihtml5.dom.contains = (function() {
  var documentElement = document.documentElement;
  if (documentElement.contains) {
    return function(container, element) {
      if (element.nodeType !== wysihtml5.ELEMENT_NODE) {
        element = element.parentNode;
      }
      return container !== element && container.contains(element);
    };
  } else if (documentElement.compareDocumentPosition) {
    return function(container, element) {
      // https://developer.mozilla.org/en/DOM/Node.compareDocumentPosition
      return !!(container.compareDocumentPosition(element) & 16);
    };
  }
})();
;/**
 * Converts an HTML fragment/element into a unordered/ordered list
 *
 * @param {Element} element The element which should be turned into a list
 * @param {String} listType The list type in which to convert the tree (either "ul" or "ol")
 * @return {Element} The created list
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <span id="pseudo-list">
 *      eminem<br>
 *      dr. dre
 *      <div>50 Cent</div>
 *    </span>
 *
 *    <script>
 *      wysihtml5.dom.convertToList(document.getElementById("pseudo-list"), "ul");
 *    </script>
 *
 *    <!-- Will result in: -->
 *    <ul>
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 */
wysihtml5.dom.convertToList = (function() {
  function _createListItem(doc, list) {
    var listItem = doc.createElement("li");
    list.appendChild(listItem);
    return listItem;
  }

  function _createList(doc, type) {
    return doc.createElement(type);
  }

  function convertToList(element, listType, uneditableClass) {
    if (element.nodeName === "UL" || element.nodeName === "OL" || element.nodeName === "MENU") {
      // Already a list
      return element;
    }

    var doc               = element.ownerDocument,
        list              = _createList(doc, listType),
        lineBreaks        = element.querySelectorAll("br"),
        lineBreaksLength  = lineBreaks.length,
        childNodes,
        childNodesLength,
        childNode,
        lineBreak,
        parentNode,
        isBlockElement,
        isLineBreak,
        currentListItem,
        i;

    // First find <br> at the end of inline elements and move them behind them
    for (i=0; i<lineBreaksLength; i++) {
      lineBreak = lineBreaks[i];
      while ((parentNode = lineBreak.parentNode) && parentNode !== element && parentNode.lastChild === lineBreak) {
        if (wysihtml5.dom.getStyle("display").from(parentNode) === "block") {
          parentNode.removeChild(lineBreak);
          break;
        }
        wysihtml5.dom.insert(lineBreak).after(lineBreak.parentNode);
      }
    }

    childNodes        = wysihtml5.lang.array(element.childNodes).get();
    childNodesLength  = childNodes.length;

    for (i=0; i<childNodesLength; i++) {
      currentListItem   = currentListItem || _createListItem(doc, list);
      childNode         = childNodes[i];
      isBlockElement    = wysihtml5.dom.getStyle("display").from(childNode) === "block";
      isLineBreak       = childNode.nodeName === "BR";

      // consider uneditable as an inline element
      if (isBlockElement && (!uneditableClass || !wysihtml5.dom.hasClass(childNode, uneditableClass))) {
        // Append blockElement to current <li> if empty, otherwise create a new one
        currentListItem = currentListItem.firstChild ? _createListItem(doc, list) : currentListItem;
        currentListItem.appendChild(childNode);
        currentListItem = null;
        continue;
      }

      if (isLineBreak) {
        // Only create a new list item in the next iteration when the current one has already content
        currentListItem = currentListItem.firstChild ? null : currentListItem;
        continue;
      }

      currentListItem.appendChild(childNode);
    }

    if (childNodes.length === 0) {
      _createListItem(doc, list);
    }

    element.parentNode.replaceChild(list, element);
    return list;
  }

  return convertToList;
})();
;/**
 * Copy a set of attributes from one element to another
 *
 * @param {Array} attributesToCopy List of attributes which should be copied
 * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to
 *    copy the attributes from., this again returns an object which provides a method named "to" which can be invoked
 *    with the element where to copy the attributes to (see example)
 *
 * @example
 *    var textarea    = document.querySelector("textarea"),
 *        div         = document.querySelector("div[contenteditable=true]"),
 *        anotherDiv  = document.querySelector("div.preview");
 *    wysihtml5.dom.copyAttributes(["spellcheck", "value", "placeholder"]).from(textarea).to(div).andTo(anotherDiv);
 *
 */
wysihtml5.dom.copyAttributes = function(attributesToCopy) {
  return {
    from: function(elementToCopyFrom) {
      return {
        to: function(elementToCopyTo) {
          var attribute,
              i         = 0,
              length    = attributesToCopy.length;
          for (; i<length; i++) {
            attribute = attributesToCopy[i];
            if (typeof(elementToCopyFrom[attribute]) !== "undefined" && elementToCopyFrom[attribute] !== "") {
              elementToCopyTo[attribute] = elementToCopyFrom[attribute];
            }
          }
          return { andTo: arguments.callee };
        }
      };
    }
  };
};
;/**
 * Copy a set of styles from one element to another
 * Please note that this only works properly across browsers when the element from which to copy the styles
 * is in the dom
 *
 * Interesting article on how to copy styles
 *
 * @param {Array} stylesToCopy List of styles which should be copied
 * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to
 *    copy the styles from., this again returns an object which provides a method named "to" which can be invoked
 *    with the element where to copy the styles to (see example)
 *
 * @example
 *    var textarea    = document.querySelector("textarea"),
 *        div         = document.querySelector("div[contenteditable=true]"),
 *        anotherDiv  = document.querySelector("div.preview");
 *    wysihtml5.dom.copyStyles(["overflow-y", "width", "height"]).from(textarea).to(div).andTo(anotherDiv);
 *
 */
(function(dom) {

  /**
   * Mozilla, WebKit and Opera recalculate the computed width when box-sizing: boder-box; is set
   * So if an element has "width: 200px; -moz-box-sizing: border-box; border: 1px;" then
   * its computed css width will be 198px
   *
   * See https://bugzilla.mozilla.org/show_bug.cgi?id=520992
   */
  var BOX_SIZING_PROPERTIES = ["-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing"];

  var shouldIgnoreBoxSizingBorderBox = function(element) {
    if (hasBoxSizingBorderBox(element)) {
       return parseInt(dom.getStyle("width").from(element), 10) < element.offsetWidth;
    }
    return false;
  };

  var hasBoxSizingBorderBox = function(element) {
    var i       = 0,
        length  = BOX_SIZING_PROPERTIES.length;
    for (; i<length; i++) {
      if (dom.getStyle(BOX_SIZING_PROPERTIES[i]).from(element) === "border-box") {
        return BOX_SIZING_PROPERTIES[i];
      }
    }
  };

  dom.copyStyles = function(stylesToCopy) {
    return {
      from: function(element) {
        if (shouldIgnoreBoxSizingBorderBox(element)) {
          stylesToCopy = wysihtml5.lang.array(stylesToCopy).without(BOX_SIZING_PROPERTIES);
        }

        var cssText = "",
            length  = stylesToCopy.length,
            i       = 0,
            property;
        for (; i<length; i++) {
          property = stylesToCopy[i];
          cssText += property + ":" + dom.getStyle(property).from(element) + ";";
        }

        return {
          to: function(element) {
            dom.setStyles(cssText).on(element);
            return { andTo: arguments.callee };
          }
        };
      }
    };
  };
})(wysihtml5.dom);
;/**
 * Event Delegation
 *
 * @example
 *    wysihtml5.dom.delegate(document.body, "a", "click", function() {
 *      // foo
 *    });
 */
(function(wysihtml5) {

  wysihtml5.dom.delegate = function(container, selector, eventName, handler) {
    return wysihtml5.dom.observe(container, eventName, function(event) {
      var target    = event.target,
          match     = wysihtml5.lang.array(container.querySelectorAll(selector));

      while (target && target !== container) {
        if (match.contains(target)) {
          handler.call(target, event);
          break;
        }
        target = target.parentNode;
      }
    });
  };

})(wysihtml5);
;// TODO: Refactor dom tree traversing here
(function(wysihtml5) {
  wysihtml5.dom.domNode = function(node) {
    var defaultNodeTypes = [wysihtml5.ELEMENT_NODE, wysihtml5.TEXT_NODE];

    var _isBlankText = function(node) {
      return node.nodeType === wysihtml5.TEXT_NODE && (/^\s*$/g).test(node.data);
    };

    return {

      // var node = wysihtml5.dom.domNode(element).prev({nodeTypes: [1,3], ignoreBlankTexts: true});
      prev: function(options) {
        var prevNode = node.previousSibling,
            types = (options && options.nodeTypes) ? options.nodeTypes : defaultNodeTypes;
        
        if (!prevNode) {
          return null;
        }

        if (
          (!wysihtml5.lang.array(types).contains(prevNode.nodeType)) || // nodeTypes check.
          (options && options.ignoreBlankTexts && _isBlankText(prevNode)) // Blank text nodes bypassed if set
        ) {
          return wysihtml5.dom.domNode(prevNode).prev(options);
        }
        
        return prevNode;
      },

      // var node = wysihtml5.dom.domNode(element).next({nodeTypes: [1,3], ignoreBlankTexts: true});
      next: function(options) {
        var nextNode = node.nextSibling,
            types = (options && options.nodeTypes) ? options.nodeTypes : defaultNodeTypes;
        
        if (!nextNode) {
          return null;
        }

        if (
          (!wysihtml5.lang.array(types).contains(nextNode.nodeType)) || // nodeTypes check.
          (options && options.ignoreBlankTexts && _isBlankText(nextNode)) // blank text nodes bypassed if set
        ) {
          return wysihtml5.dom.domNode(nextNode).next(options);
        }
        
        return nextNode;
      }



    };
  };
})(wysihtml5);;/**
 * Returns the given html wrapped in a div element
 *
 * Fixing IE's inability to treat unknown elements (HTML5 section, article, ...) correctly
 * when inserted via innerHTML
 *
 * @param {String} html The html which should be wrapped in a dom element
 * @param {Obejct} [context] Document object of the context the html belongs to
 *
 * @example
 *    wysihtml5.dom.getAsDom("<article>foo</article>");
 */
wysihtml5.dom.getAsDom = (function() {

  var _innerHTMLShiv = function(html, context) {
    var tempElement = context.createElement("div");
    tempElement.style.display = "none";
    context.body.appendChild(tempElement);
    // IE throws an exception when trying to insert <frameset></frameset> via innerHTML
    try { tempElement.innerHTML = html; } catch(e) {}
    context.body.removeChild(tempElement);
    return tempElement;
  };

  /**
   * Make sure IE supports HTML5 tags, which is accomplished by simply creating one instance of each element
   */
  var _ensureHTML5Compatibility = function(context) {
    if (context._wysihtml5_supportsHTML5Tags) {
      return;
    }
    for (var i=0, length=HTML5_ELEMENTS.length; i<length; i++) {
      context.createElement(HTML5_ELEMENTS[i]);
    }
    context._wysihtml5_supportsHTML5Tags = true;
  };


  /**
   * List of html5 tags
   * taken from http://simon.html5.org/html5-elements
   */
  var HTML5_ELEMENTS = [
    "abbr", "article", "aside", "audio", "bdi", "canvas", "command", "datalist", "details", "figcaption",
    "figure", "footer", "header", "hgroup", "keygen", "mark", "meter", "nav", "output", "progress",
    "rp", "rt", "ruby", "svg", "section", "source", "summary", "time", "track", "video", "wbr"
  ];

  return function(html, context) {
    context = context || document;
    var tempElement;
    if (typeof(html) === "object" && html.nodeType) {
      tempElement = context.createElement("div");
      tempElement.appendChild(html);
    } else if (wysihtml5.browser.supportsHTML5Tags(context)) {
      tempElement = context.createElement("div");
      tempElement.innerHTML = html;
    } else {
      _ensureHTML5Compatibility(context);
      tempElement = _innerHTMLShiv(html, context);
    }
    return tempElement;
  };
})();
;/**
 * Walks the dom tree from the given node up until it finds a match
 * Designed for optimal performance.
 *
 * @param {Element} node The from which to check the parent nodes
 * @param {Object} matchingSet Object to match against (possible properties: nodeName, className, classRegExp)
 * @param {Number} [levels] How many parents should the function check up from the current node (defaults to 50)
 * @return {null|Element} Returns the first element that matched the desiredNodeName(s)
 * @example
 *    var listElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: ["MENU", "UL", "OL"] });
 *    // ... or ...
 *    var unorderedListElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: "UL" });
 *    // ... or ...
 *    var coloredElement = wysihtml5.dom.getParentElement(myTextNode, { nodeName: "SPAN", className: "wysiwyg-color-red", classRegExp: /wysiwyg-color-[a-z]/g });
 */
wysihtml5.dom.getParentElement = (function() {

  function _isSameNodeName(nodeName, desiredNodeNames) {
    if (!desiredNodeNames || !desiredNodeNames.length) {
      return true;
    }

    if (typeof(desiredNodeNames) === "string") {
      return nodeName === desiredNodeNames;
    } else {
      return wysihtml5.lang.array(desiredNodeNames).contains(nodeName);
    }
  }

  function _isElement(node) {
    return node.nodeType === wysihtml5.ELEMENT_NODE;
  }

  function _hasClassName(element, className, classRegExp) {
    var classNames = (element.className || "").match(classRegExp) || [];
    if (!className) {
      return !!classNames.length;
    }
    return classNames[classNames.length - 1] === className;
  }

  function _hasStyle(element, cssStyle, styleRegExp) {
    var styles = (element.getAttribute('style') || "").match(styleRegExp) || [];
    if (!cssStyle) {
      return !!styles.length;
    }
    return styles[styles.length - 1] === cssStyle;
  }

  return function(node, matchingSet, levels, container) {
    var findByStyle = (matchingSet.cssStyle || matchingSet.styleRegExp),
        findByClass = (matchingSet.className || matchingSet.classRegExp);

    levels = levels || 50; // Go max 50 nodes upwards from current node

    while (levels-- && node && node.nodeName !== "BODY" && (!container || node !== container)) {
      if (_isElement(node) && _isSameNodeName(node.nodeName, matchingSet.nodeName) &&
          (!findByStyle || _hasStyle(node, matchingSet.cssStyle, matchingSet.styleRegExp)) &&
          (!findByClass || _hasClassName(node, matchingSet.className, matchingSet.classRegExp))
      ) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };
})();
;/**
 * Get element's style for a specific css property
 *
 * @param {Element} element The element on which to retrieve the style
 * @param {String} property The CSS property to retrieve ("float", "display", "text-align", ...)
 *
 * @example
 *    wysihtml5.dom.getStyle("display").from(document.body);
 *    // => "block"
 */
wysihtml5.dom.getStyle = (function() {
  var stylePropertyMapping = {
        "float": ("styleFloat" in document.createElement("div").style) ? "styleFloat" : "cssFloat"
      },
      REG_EXP_CAMELIZE = /\-[a-z]/g;

  function camelize(str) {
    return str.replace(REG_EXP_CAMELIZE, function(match) {
      return match.charAt(1).toUpperCase();
    });
  }

  return function(property) {
    return {
      from: function(element) {
        if (element.nodeType !== wysihtml5.ELEMENT_NODE) {
          return;
        }

        var doc               = element.ownerDocument,
            camelizedProperty = stylePropertyMapping[property] || camelize(property),
            style             = element.style,
            currentStyle      = element.currentStyle,
            styleValue        = style[camelizedProperty];
        if (styleValue) {
          return styleValue;
        }

        // currentStyle is no standard and only supported by Opera and IE but it has one important advantage over the standard-compliant
        // window.getComputedStyle, since it returns css property values in their original unit:
        // If you set an elements width to "50%", window.getComputedStyle will give you it's current width in px while currentStyle
        // gives you the original "50%".
        // Opera supports both, currentStyle and window.getComputedStyle, that's why checking for currentStyle should have higher prio
        if (currentStyle) {
          try {
            return currentStyle[camelizedProperty];
          } catch(e) {
            //ie will occasionally fail for unknown reasons. swallowing exception
          }
        }

        var win                 = doc.defaultView || doc.parentWindow,
            needsOverflowReset  = (property === "height" || property === "width") && element.nodeName === "TEXTAREA",
            originalOverflow,
            returnValue;

        if (win.getComputedStyle) {
          // Chrome and Safari both calculate a wrong width and height for textareas when they have scroll bars
          // therfore we remove and restore the scrollbar and calculate the value in between
          if (needsOverflowReset) {
            originalOverflow = style.overflow;
            style.overflow = "hidden";
          }
          returnValue = win.getComputedStyle(element, null).getPropertyValue(property);
          if (needsOverflowReset) {
            style.overflow = originalOverflow || "";
          }
          return returnValue;
        }
      }
    };
  };
})();
;wysihtml5.dom.getTextNodes = function(node, ingoreEmpty){
  var all = [];
  for (node=node.firstChild;node;node=node.nextSibling){
    if (node.nodeType == 3) {
      if (!ingoreEmpty || !(/^\s*$/).test(node.innerText || node.textContent)) {
        all.push(node);
      }
    } else {
      all = all.concat(wysihtml5.dom.getTextNodes(node, ingoreEmpty));
    }
  }
  return all;
};;/**
 * High performant way to check whether an element with a specific tag name is in the given document
 * Optimized for being heavily executed
 * Unleashes the power of live node lists
 *
 * @param {Object} doc The document object of the context where to check
 * @param {String} tagName Upper cased tag name
 * @example
 *    wysihtml5.dom.hasElementWithTagName(document, "IMG");
 */
wysihtml5.dom.hasElementWithTagName = (function() {
  var LIVE_CACHE          = {},
      DOCUMENT_IDENTIFIER = 1;

  function _getDocumentIdentifier(doc) {
    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);
  }

  return function(doc, tagName) {
    var key         = _getDocumentIdentifier(doc) + ":" + tagName,
        cacheEntry  = LIVE_CACHE[key];
    if (!cacheEntry) {
      cacheEntry = LIVE_CACHE[key] = doc.getElementsByTagName(tagName);
    }

    return cacheEntry.length > 0;
  };
})();
;/**
 * High performant way to check whether an element with a specific class name is in the given document
 * Optimized for being heavily executed
 * Unleashes the power of live node lists
 *
 * @param {Object} doc The document object of the context where to check
 * @param {String} tagName Upper cased tag name
 * @example
 *    wysihtml5.dom.hasElementWithClassName(document, "foobar");
 */
(function(wysihtml5) {
  var LIVE_CACHE          = {},
      DOCUMENT_IDENTIFIER = 1;

  function _getDocumentIdentifier(doc) {
    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);
  }

  wysihtml5.dom.hasElementWithClassName = function(doc, className) {
    // getElementsByClassName is not supported by IE<9
    // but is sometimes mocked via library code (which then doesn't return live node lists)
    if (!wysihtml5.browser.supportsNativeGetElementsByClassName()) {
      return !!doc.querySelector("." + className);
    }

    var key         = _getDocumentIdentifier(doc) + ":" + className,
        cacheEntry  = LIVE_CACHE[key];
    if (!cacheEntry) {
      cacheEntry = LIVE_CACHE[key] = doc.getElementsByClassName(className);
    }

    return cacheEntry.length > 0;
  };
})(wysihtml5);
;wysihtml5.dom.insert = function(elementToInsert) {
  return {
    after: function(element) {
      element.parentNode.insertBefore(elementToInsert, element.nextSibling);
    },

    before: function(element) {
      element.parentNode.insertBefore(elementToInsert, element);
    },

    into: function(element) {
      element.appendChild(elementToInsert);
    }
  };
};
;wysihtml5.dom.insertCSS = function(rules) {
  rules = rules.join("\n");

  return {
    into: function(doc) {
      var styleElement = doc.createElement("style");
      styleElement.type = "text/css";

      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = rules;
      } else {
        styleElement.appendChild(doc.createTextNode(rules));
      }

      var link = doc.querySelector("head link");
      if (link) {
        link.parentNode.insertBefore(styleElement, link);
        return;
      } else {
        var head = doc.querySelector("head");
        if (head) {
          head.appendChild(styleElement);
        }
      }
    }
  };
};
;// TODO: Refactor dom tree traversing here
(function(wysihtml5) {
  wysihtml5.dom.lineBreaks = function(node) {

    function _isLineBreak(n) {
      return n.nodeName === "BR";
    }

    /**
     * Checks whether the elment causes a visual line break
     * (<br> or block elements)
     */
    function _isLineBreakOrBlockElement(element) {
      if (_isLineBreak(element)) {
        return true;
      }

      if (wysihtml5.dom.getStyle("display").from(element) === "block") {
        return true;
      }

      return false;
    }

    return {

      /* wysihtml5.dom.lineBreaks(element).add();
       *
       * Adds line breaks before and after the given node if the previous and next siblings
       * aren't already causing a visual line break (block element or <br>)
       */
      add: function(options) {
        var doc             = node.ownerDocument,
          nextSibling     = wysihtml5.dom.domNode(node).next({ignoreBlankTexts: true}),
          previousSibling = wysihtml5.dom.domNode(node).prev({ignoreBlankTexts: true});

        if (nextSibling && !_isLineBreakOrBlockElement(nextSibling)) {
          wysihtml5.dom.insert(doc.createElement("br")).after(node);
        }
        if (previousSibling && !_isLineBreakOrBlockElement(previousSibling)) {
          wysihtml5.dom.insert(doc.createElement("br")).before(node);
        }
      },

      /* wysihtml5.dom.lineBreaks(element).remove();
       *
       * Removes line breaks before and after the given node
       */
      remove: function(options) {
        var nextSibling     = wysihtml5.dom.domNode(node).next({ignoreBlankTexts: true}),
            previousSibling = wysihtml5.dom.domNode(node).prev({ignoreBlankTexts: true});

        if (nextSibling && _isLineBreak(nextSibling)) {
          nextSibling.parentNode.removeChild(nextSibling);
        }
        if (previousSibling && _isLineBreak(previousSibling)) {
          previousSibling.parentNode.removeChild(previousSibling);
        }
      }
    };
  };
})(wysihtml5);;/**
 * Method to set dom events
 *
 * @example
 *    wysihtml5.dom.observe(iframe.contentWindow.document.body, ["focus", "blur"], function() { ... });
 */
wysihtml5.dom.observe = function(element, eventNames, handler) {
  eventNames = typeof(eventNames) === "string" ? [eventNames] : eventNames;

  var handlerWrapper,
      eventName,
      i       = 0,
      length  = eventNames.length;

  for (; i<length; i++) {
    eventName = eventNames[i];
    if (element.addEventListener) {
      element.addEventListener(eventName, handler, false);
    } else {
      handlerWrapper = function(event) {
        if (!("target" in event)) {
          event.target = event.srcElement;
        }
        event.preventDefault = event.preventDefault || function() {
          this.returnValue = false;
        };
        event.stopPropagation = event.stopPropagation || function() {
          this.cancelBubble = true;
        };
        handler.call(element, event);
      };
      element.attachEvent("on" + eventName, handlerWrapper);
    }
  }

  return {
    stop: function() {
      var eventName,
          i       = 0,
          length  = eventNames.length;
      for (; i<length; i++) {
        eventName = eventNames[i];
        if (element.removeEventListener) {
          element.removeEventListener(eventName, handler, false);
        } else {
          element.detachEvent("on" + eventName, handlerWrapper);
        }
      }
    }
  };
};
;/**
 * HTML Sanitizer
 * Rewrites the HTML based on given rules
 *
 * @param {Element|String} elementOrHtml HTML String to be sanitized OR element whose content should be sanitized
 * @param {Object} [rules] List of rules for rewriting the HTML, if there's no rule for an element it will
 *    be converted to a "span". Each rule is a key/value pair where key is the tag to convert, and value the
 *    desired substitution.
 * @param {Object} context Document object in which to parse the html, needed to sandbox the parsing
 *
 * @return {Element|String} Depends on the elementOrHtml parameter. When html then the sanitized html as string elsewise the element.
 *
 * @example
 *    var userHTML = '<div id="foo" onclick="alert(1);"><p><font color="red">foo</font><script>alert(1);</script></p></div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      tags {
 *        p:      "div",      // Rename p tags to div tags
 *        font:   "span"      // Rename font tags to span tags
 *        div:    true,       // Keep them, also possible (same result when passing: "div" or true)
 *        script: undefined   // Remove script elements
 *      }
 *    });
 *    // => <div><div><span>foo bar</span></div></div>
 *
 *    var userHTML = '<table><tbody><tr><td>I'm a table!</td></tr></tbody></table>';
 *    wysihtml5.dom.parse(userHTML);
 *    // => '<span><span><span><span>I'm a table!</span></span></span></span>'
 *
 *    var userHTML = '<div>foobar<br>foobar</div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      tags: {
 *        div: undefined,
 *        br:  true
 *      }
 *    });
 *    // => ''
 *
 *    var userHTML = '<div class="red">foo</div><div class="pink">bar</div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      classes: {
 *        red:    1,
 *        green:  1
 *      },
 *      tags: {
 *        div: {
 *          rename_tag:     "p"
 *        }
 *      }
 *    });
 *    // => '<p class="red">foo</p><p>bar</p>'
 */

wysihtml5.dom.parse = function(elementOrHtml_current, config_current) {
  /* TODO: Currently escaped module pattern as otherwise folloowing default swill be shared among multiple editors.
   * Refactor whole code as this method while workind is kind of awkward too */

  /**
   * It's not possible to use a XMLParser/DOMParser as HTML5 is not always well-formed XML
   * new DOMParser().parseFromString('<img src="foo.gif">') will cause a parseError since the
   * node isn't closed
   *
   * Therefore we've to use the browser's ordinary HTML parser invoked by setting innerHTML.
   */
  var NODE_TYPE_MAPPING = {
        "1": _handleElement,
        "3": _handleText,
        "8": _handleComment
      },
      // Rename unknown tags to this
      DEFAULT_NODE_NAME   = "span",
      WHITE_SPACE_REG_EXP = /\s+/,
      defaultRules        = { tags: {}, classes: {} },
      currentRules        = {};

  /**
   * Iterates over all childs of the element, recreates them, appends them into a document fragment
   * which later replaces the entire body content
   */
   function parse(elementOrHtml, config) {
    wysihtml5.lang.object(currentRules).merge(defaultRules).merge(config.rules).get();

    var context       = config.context || elementOrHtml.ownerDocument || document,
        fragment      = context.createDocumentFragment(),
        isString      = typeof(elementOrHtml) === "string",
        clearInternals = false,
        element,
        newNode,
        firstChild;

    if (config.clearInternals === true) {
      clearInternals = true;
    }

    if (isString) {
      element = wysihtml5.dom.getAsDom(elementOrHtml, context);
    } else {
      element = elementOrHtml;
    }

    if (currentRules.selectors) {
      _applySelectorRules(element, currentRules.selectors);
    }

    while (element.firstChild) {
      firstChild = element.firstChild;
      newNode = _convert(firstChild, config.cleanUp, clearInternals, config.uneditableClass);
      if (newNode) {
        fragment.appendChild(newNode);
      }
      if (firstChild !== newNode) {
        element.removeChild(firstChild);
      }
    }

    if (config.unjoinNbsps) {
      // replace joined non-breakable spaces with unjoined
      var txtnodes = wysihtml5.dom.getTextNodes(fragment);
      for (var n = txtnodes.length; n--;) {
        txtnodes[n].nodeValue = txtnodes[n].nodeValue.replace(/([\S\u00A0])\u00A0/gi, "$1 ");
      }
    }

    // Clear element contents
    element.innerHTML = "";

    // Insert new DOM tree
    element.appendChild(fragment);

    return isString ? wysihtml5.quirks.getCorrectInnerHTML(element) : element;
  }

  function _convert(oldNode, cleanUp, clearInternals, uneditableClass) {
    var oldNodeType     = oldNode.nodeType,
        oldChilds       = oldNode.childNodes,
        oldChildsLength = oldChilds.length,
        method          = NODE_TYPE_MAPPING[oldNodeType],
        i               = 0,
        fragment,
        newNode,
        newChild;

    // Passes directly elemets with uneditable class
    if (uneditableClass && oldNodeType === 1 && wysihtml5.dom.hasClass(oldNode, uneditableClass)) {
        return oldNode;
    }

    newNode = method && method(oldNode, clearInternals);

    // Remove or unwrap node in case of return value null or false
    if (!newNode) {
        if (newNode === false) {
            // false defines that tag should be removed but contents should remain (unwrap)
            fragment = oldNode.ownerDocument.createDocumentFragment();

            for (i = oldChildsLength; i--;) {
              if (oldChilds[i]) {
                newChild = _convert(oldChilds[i], cleanUp, clearInternals, uneditableClass);
                if (newChild) {
                  if (oldChilds[i] === newChild) {
                    i--;
                  }
                  fragment.insertBefore(newChild, fragment.firstChild);
                }
              }
            }

            if (wysihtml5.dom.getStyle("display").from(oldNode) === "block") {
              fragment.appendChild(oldNode.ownerDocument.createElement("br"));
            }

            // TODO: try to minimize surplus spaces
            if (wysihtml5.lang.array([
                "div", "pre", "p",
                "table", "td", "th",
                "ul", "ol", "li",
                "dd", "dl",
                "footer", "header", "section",
                "h1", "h2", "h3", "h4", "h5", "h6"
            ]).contains(oldNode.nodeName.toLowerCase()) && oldNode.parentNode.lastChild !== oldNode) {
                // add space at first when unwraping non-textflow elements
                if (!oldNode.nextSibling || oldNode.nextSibling.nodeType !== 3 || !(/^\s/).test(oldNode.nextSibling.nodeValue)) {
                  fragment.appendChild(oldNode.ownerDocument.createTextNode(" "));
                }
            }

            if (fragment.normalize) {
              fragment.normalize();
            }
            return fragment;
        } else {
          // Remove
          return null;
        }
    }

    // Converts all childnodes
    for (i=0; i<oldChildsLength; i++) {
      if (oldChilds[i]) {
        newChild = _convert(oldChilds[i], cleanUp, clearInternals, uneditableClass);
        if (newChild) {
          if (oldChilds[i] === newChild) {
            i--;
          }
          newNode.appendChild(newChild);
        }
      }
    }

    // Cleanup senseless <span> elements
    if (cleanUp &&
        newNode.nodeName.toLowerCase() === DEFAULT_NODE_NAME &&
        (!newNode.childNodes.length ||
         ((/^\s*$/gi).test(newNode.innerHTML) && (clearInternals || (oldNode.className !== "_wysihtml5-temp-placeholder" && oldNode.className !== "rangySelectionBoundary"))) ||
         !newNode.attributes.length)
        ) {
      fragment = newNode.ownerDocument.createDocumentFragment();
      while (newNode.firstChild) {
        fragment.appendChild(newNode.firstChild);
      }
      if (fragment.normalize) {
        fragment.normalize();
      }
      return fragment;
    }

    if (newNode.normalize) {
      newNode.normalize();
    }
    return newNode;
  }

  function _applySelectorRules (element, selectorRules) {
    var sel, method, els;

    for (sel in selectorRules) {
      if (selectorRules.hasOwnProperty(sel)) {
        if (wysihtml5.lang.object(selectorRules[sel]).isFunction()) {
          method = selectorRules[sel];
        } else if (typeof(selectorRules[sel]) === "string" && elementHandlingMethods[selectorRules[sel]]) {
          method = elementHandlingMethods[selectorRules[sel]];
        }
        els = element.querySelectorAll(sel);
        for (var i = els.length; i--;) {
          method(els[i]);
        }
      }
    }
  }

  function _handleElement(oldNode, clearInternals) {
    var rule,
        newNode,
        tagRules    = currentRules.tags,
        nodeName    = oldNode.nodeName.toLowerCase(),
        scopeName   = oldNode.scopeName,
        renameTag;

    /**
     * We already parsed that element
     * ignore it! (yes, this sometimes happens in IE8 when the html is invalid)
     */
    if (oldNode._wysihtml5) {
      return null;
    }
    oldNode._wysihtml5 = 1;

    if (oldNode.className === "wysihtml5-temp") {
      return null;
    }

    /**
     * IE is the only browser who doesn't include the namespace in the
     * nodeName, that's why we have to prepend it by ourselves
     * scopeName is a proprietary IE feature
     * read more here http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx
     */
    if (scopeName && scopeName != "HTML") {
      nodeName = scopeName + ":" + nodeName;
    }
    /**
     * Repair node
     * IE is a bit bitchy when it comes to invalid nested markup which includes unclosed tags
     * A <p> doesn't need to be closed according HTML4-5 spec, we simply replace it with a <div> to preserve its content and layout
     */
    if ("outerHTML" in oldNode) {
      if (!wysihtml5.browser.autoClosesUnclosedTags() &&
          oldNode.nodeName === "P" &&
          oldNode.outerHTML.slice(-4).toLowerCase() !== "</p>") {
        nodeName = "div";
      }
    }

    if (nodeName in tagRules) {
      rule = tagRules[nodeName];
      if (!rule || rule.remove) {
        return null;
      } else if (rule.unwrap) {
        return false;
      }
      rule = typeof(rule) === "string" ? { rename_tag: rule } : rule;
    } else if (oldNode.firstChild) {
      rule = { rename_tag: DEFAULT_NODE_NAME };
    } else {
      // Remove empty unknown elements
      return null;
    }

    // tests if type condition is met or node should be removed/unwrapped/renamed
    if (rule.one_of_type && !_testTypes(oldNode, currentRules, rule.one_of_type, clearInternals)) {
      if (rule.remove_action) {
        if (rule.remove_action === "unwrap") {
          return false;
        } else if (rule.remove_action === "rename") {
          renameTag = rule.remove_action_rename_to || DEFAULT_NODE_NAME;
        } else {
          return null;
        }
      } else {
        return null;
      }
    }

    newNode = oldNode.ownerDocument.createElement(renameTag || rule.rename_tag || nodeName);
    _handleAttributes(oldNode, newNode, rule, clearInternals);
    _handleStyles(oldNode, newNode, rule);

    oldNode = null;

    if (newNode.normalize) { newNode.normalize(); }
    return newNode;
  }

  function _testTypes(oldNode, rules, types, clearInternals) {
    var definition, type;

    // do not interfere with placeholder span or pasting caret position is not maintained
    if (oldNode.nodeName === "SPAN" && !clearInternals && (oldNode.className === "_wysihtml5-temp-placeholder" || oldNode.className === "rangySelectionBoundary")) {
      return true;
    }

    for (type in types) {
      if (types.hasOwnProperty(type) && rules.type_definitions && rules.type_definitions[type]) {
        definition = rules.type_definitions[type];
        if (_testType(oldNode, definition)) {
          return true;
        }
      }
    }
    return false;
  }

  function array_contains(a, obj) {
      var i = a.length;
      while (i--) {
         if (a[i] === obj) {
             return true;
         }
      }
      return false;
  }

  function _testType(oldNode, definition) {

    var nodeClasses = oldNode.getAttribute("class"),
        nodeStyles =  oldNode.getAttribute("style"),
        classesLength, s, s_corrected, a, attr, currentClass, styleProp;

    // test for methods
    if (definition.methods) {
      for (var m in definition.methods) {
        if (definition.methods.hasOwnProperty(m) && typeCeckMethods[m]) {

          if (typeCeckMethods[m](oldNode)) {
            return true;
          }
        }
      }
    }

    // test for classes, if one found return true
    if (nodeClasses && definition.classes) {
      nodeClasses = nodeClasses.replace(/^\s+/g, '').replace(/\s+$/g, '').split(WHITE_SPACE_REG_EXP);
      classesLength = nodeClasses.length;
      for (var i = 0; i < classesLength; i++) {
        if (definition.classes[nodeClasses[i]]) {
          return true;
        }
      }
    }

    // test for styles, if one found return true
    if (nodeStyles && definition.styles) {

      nodeStyles = nodeStyles.split(';');
      for (s in definition.styles) {
        if (definition.styles.hasOwnProperty(s)) {
          for (var sp = nodeStyles.length; sp--;) {
            styleProp = nodeStyles[sp].split(':');

            if (styleProp[0].replace(/\s/g, '').toLowerCase() === s) {
              if (definition.styles[s] === true || definition.styles[s] === 1 || wysihtml5.lang.array(definition.styles[s]).contains(styleProp[1].replace(/\s/g, '').toLowerCase()) ) {
                return true;
              }
            }
          }
        }
      }
    }

    // test for attributes in general against regex match
    if (definition.attrs) {
        for (a in definition.attrs) {
            if (definition.attrs.hasOwnProperty(a)) {
                attr = wysihtml5.dom.getAttribute(oldNode, a);
                if (typeof(attr) === "string") {
                    if (attr.search(definition.attrs[a]) > -1) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
  }

  function _handleStyles(oldNode, newNode, rule) {
    var s, v;
    if(rule && rule.keep_styles) {
      for (s in rule.keep_styles) {
        if (rule.keep_styles.hasOwnProperty(s)) {
          v = (s === "float") ? oldNode.style.styleFloat || oldNode.style.cssFloat : oldNode.style[s];
          // value can be regex and if so should match or style skipped
          if (rule.keep_styles[s] instanceof RegExp && !(rule.keep_styles[s].test(v))) {
            continue;
          }
          if (s === "float") {
            // IE compability
            newNode.style[(oldNode.style.styleFloat) ? 'styleFloat': 'cssFloat'] = v;
           } else if (oldNode.style[s]) {
             newNode.style[s] = v;
           }
        }
      }
    }
  };

  function _getAttributesBeginningWith(beginning, attributes) {
    var returnAttributes = [];
    for (var attr in attributes) {
      if (attributes.hasOwnProperty(attr) && attr.indexOf(beginning) === 0) {
        returnAttributes.push(attr);
      }
    }
    return returnAttributes;
  }

  function _checkAttribute(attributeName, attributeValue, methodName, nodeName) {
    var method = attributeCheckMethods[methodName],
        newAttributeValue;

    if (method) {
      if (attributeValue || (attributeName === "alt" && nodeName == "IMG")) {
        newAttributeValue = method(attributeValue);
        if (typeof(newAttributeValue) === "string") {
          return newAttributeValue;
        }
      }
    }

    return false;
  }

  function _checkAttributes(oldNode, local_attributes) {
    var globalAttributes  = wysihtml5.lang.object(currentRules.attributes || {}).clone(), // global values for check/convert values of attributes
        checkAttributes   = wysihtml5.lang.object(globalAttributes).merge( wysihtml5.lang.object(local_attributes || {}).clone()).get(),
        attributes        = {},
        oldAttributes     = wysihtml5.dom.getAttributes(oldNode),
        attributeName, newValue, matchingAttributes;

    for (attributeName in checkAttributes) {
      if ((/\*$/).test(attributeName)) {

        matchingAttributes = _getAttributesBeginningWith(attributeName.slice(0,-1), oldAttributes);
        for (var i = 0, imax = matchingAttributes.length; i < imax; i++) {

          newValue = _checkAttribute(matchingAttributes[i], oldAttributes[matchingAttributes[i]], checkAttributes[attributeName], oldNode.nodeName);
          if (newValue !== false) {
            attributes[matchingAttributes[i]] = newValue;
          }
        }
      } else {
        newValue = _checkAttribute(attributeName, oldAttributes[attributeName], checkAttributes[attributeName], oldNode.nodeName);
        if (newValue !== false) {
          attributes[attributeName] = newValue;
        }
      }
    }

    return attributes;
  }

  // TODO: refactor. Too long to read
  function _handleAttributes(oldNode, newNode, rule, clearInternals) {
    var attributes          = {},                         // fresh new set of attributes to set on newNode
        setClass            = rule.set_class,             // classes to set
        addClass            = rule.add_class,             // add classes based on existing attributes
        addStyle            = rule.add_style,             // add styles based on existing attributes
        setAttributes       = rule.set_attributes,        // attributes to set on the current node
        allowedClasses      = currentRules.classes,
        i                   = 0,
        classes             = [],
        styles              = [],
        newClasses          = [],
        oldClasses          = [],
        classesLength,
        newClassesLength,
        currentClass,
        newClass,
        attributeName,
        method;

    if (setAttributes) {
      attributes = wysihtml5.lang.object(setAttributes).clone();
    }

    // check/convert values of attributes
    attributes = wysihtml5.lang.object(attributes).merge(_checkAttributes(oldNode,  rule.check_attributes)).get();

    if (setClass) {
      classes.push(setClass);
    }

    if (addClass) {
      for (attributeName in addClass) {
        method = addClassMethods[addClass[attributeName]];
        if (!method) {
          continue;
        }
        newClass = method(wysihtml5.dom.getAttribute(oldNode, attributeName));
        if (typeof(newClass) === "string") {
          classes.push(newClass);
        }
      }
    }

    if (addStyle) {
      for (attributeName in addStyle) {
        method = addStyleMethods[addStyle[attributeName]];
        if (!method) {
          continue;
        }

        newStyle = method(wysihtml5.dom.getAttribute(oldNode, attributeName));
        if (typeof(newStyle) === "string") {
          styles.push(newStyle);
        }
      }
    }


    if (typeof(allowedClasses) === "string" && allowedClasses === "any" && oldNode.getAttribute("class")) {
      if (currentRules.classes_blacklist) {
        oldClasses = oldNode.getAttribute("class");
        if (oldClasses) {
          classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));
        }

        classesLength = classes.length;
        for (; i<classesLength; i++) {
          currentClass = classes[i];
          if (!currentRules.classes_blacklist[currentClass]) {
            newClasses.push(currentClass);
          }
        }

        if (newClasses.length) {
          attributes["class"] = wysihtml5.lang.array(newClasses).unique().join(" ");
        }

      } else {
        attributes["class"] = oldNode.getAttribute("class");
      }
    } else {
      // make sure that wysihtml5 temp class doesn't get stripped out
      if (!clearInternals) {
        allowedClasses["_wysihtml5-temp-placeholder"] = 1;
        allowedClasses["_rangySelectionBoundary"] = 1;
        allowedClasses["wysiwyg-tmp-selected-cell"] = 1;
      }

      // add old classes last
      oldClasses = oldNode.getAttribute("class");
      if (oldClasses) {
        classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));
      }
      classesLength = classes.length;
      for (; i<classesLength; i++) {
        currentClass = classes[i];
        if (allowedClasses[currentClass]) {
          newClasses.push(currentClass);
        }
      }

      if (newClasses.length) {
        attributes["class"] = wysihtml5.lang.array(newClasses).unique().join(" ");
      }
    }

    // remove table selection class if present
    if (attributes["class"] && clearInternals) {
      attributes["class"] = attributes["class"].replace("wysiwyg-tmp-selected-cell", "");
      if ((/^\s*$/g).test(attributes["class"])) {
        delete attributes["class"];
      }
    }

    if (styles.length) {
      attributes["style"] = wysihtml5.lang.array(styles).unique().join(" ");
    }

    // set attributes on newNode
    for (attributeName in attributes) {
      // Setting attributes can cause a js error in IE under certain circumstances
      // eg. on a <img> under https when it's new attribute value is non-https
      // TODO: Investigate this further and check for smarter handling
      try {
        newNode.setAttribute(attributeName, attributes[attributeName]);
      } catch(e) {}
    }

    // IE8 sometimes loses the width/height attributes when those are set before the "src"
    // so we make sure to set them again
    if (attributes.src) {
      if (typeof(attributes.width) !== "undefined") {
        newNode.setAttribute("width", attributes.width);
      }
      if (typeof(attributes.height) !== "undefined") {
        newNode.setAttribute("height", attributes.height);
      }
    }
  }

  var INVISIBLE_SPACE_REG_EXP = /\uFEFF/g;
  function _handleText(oldNode) {
    var nextSibling = oldNode.nextSibling;
    if (nextSibling && nextSibling.nodeType === wysihtml5.TEXT_NODE) {
      // Concatenate text nodes
      nextSibling.data = oldNode.data.replace(INVISIBLE_SPACE_REG_EXP, "") + nextSibling.data.replace(INVISIBLE_SPACE_REG_EXP, "");
    } else {
      // \uFEFF = wysihtml5.INVISIBLE_SPACE (used as a hack in certain rich text editing situations)
      var data = oldNode.data.replace(INVISIBLE_SPACE_REG_EXP, "");
      return oldNode.ownerDocument.createTextNode(data);
    }
  }

  function _handleComment(oldNode) {
    if (currentRules.comments) {
      return oldNode.ownerDocument.createComment(oldNode.nodeValue);
    }
  }

  // ------------ attribute checks ------------ \\
  var attributeCheckMethods = {
    url: (function() {
      var REG_EXP = /^https?:\/\//i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    src: (function() {
      var REG_EXP = /^(\/|https?:\/\/)/i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    href: (function() {
      var REG_EXP = /^(#|\/|https?:\/\/|mailto:)/i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    alt: (function() {
      var REG_EXP = /[^ a-z0-9_\-]/gi;
      return function(attributeValue) {
        if (!attributeValue) {
          return "";
        }
        return attributeValue.replace(REG_EXP, "");
      };
    })(),

    numbers: (function() {
      var REG_EXP = /\D/g;
      return function(attributeValue) {
        attributeValue = (attributeValue || "").replace(REG_EXP, "");
        return attributeValue || null;
      };
    })(),

    any: (function() {
      return function(attributeValue) {
        return attributeValue;
      };
    })()
  };

  // ------------ style converter (converts an html attribute to a style) ------------ \\
  var addStyleMethods = {
    align_text: (function() {
      var mapping = {
        left:     "text-align: left;",
        right:    "text-align: right;",
        center:   "text-align: center;"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),
  };

  // ------------ class converter (converts an html attribute to a class name) ------------ \\
  var addClassMethods = {
    align_img: (function() {
      var mapping = {
        left:   "wysiwyg-float-left",
        right:  "wysiwyg-float-right"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),

    align_text: (function() {
      var mapping = {
        left:     "wysiwyg-text-align-left",
        right:    "wysiwyg-text-align-right",
        center:   "wysiwyg-text-align-center",
        justify:  "wysiwyg-text-align-justify"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),

    clear_br: (function() {
      var mapping = {
        left:   "wysiwyg-clear-left",
        right:  "wysiwyg-clear-right",
        both:   "wysiwyg-clear-both",
        all:    "wysiwyg-clear-both"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),

    size_font: (function() {
      var mapping = {
        "1": "wysiwyg-font-size-xx-small",
        "2": "wysiwyg-font-size-small",
        "3": "wysiwyg-font-size-medium",
        "4": "wysiwyg-font-size-large",
        "5": "wysiwyg-font-size-x-large",
        "6": "wysiwyg-font-size-xx-large",
        "7": "wysiwyg-font-size-xx-large",
        "-": "wysiwyg-font-size-smaller",
        "+": "wysiwyg-font-size-larger"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).charAt(0)];
      };
    })()
  };

  // checks if element is possibly visible
  var typeCeckMethods = {
    has_visible_contet: (function() {
      var txt,
          isVisible = false,
          visibleElements = ['img', 'video', 'picture', 'br', 'script', 'noscript',
                             'style', 'table', 'iframe', 'object', 'embed', 'audio',
                             'svg', 'input', 'button', 'select','textarea', 'canvas'];

      return function(el) {

        // has visible innertext. so is visible
        txt = (el.innerText || el.textContent).replace(/\s/g, '');
        if (txt && txt.length > 0) {
          return true;
        }

        // matches list of visible dimensioned elements
        for (var i = visibleElements.length; i--;) {
          if (el.querySelector(visibleElements[i])) {
            return true;
          }
        }

        // try to measure dimesions in last resort. (can find only of elements in dom)
        if (el.offsetWidth && el.offsetWidth > 0 && el.offsetHeight && el.offsetHeight > 0) {
          return true;
        }

        return false;
      };
    })()
  };

  var elementHandlingMethods = {
    unwrap: function (element) {
      wysihtml5.dom.unwrap(element);
    },

    remove: function (element) {
      element.parentNode.removeChild(element);
    }
  };

  return parse(elementOrHtml_current, config_current);
};
;/**
 * Checks for empty text node childs and removes them
 *
 * @param {Element} node The element in which to cleanup
 * @example
 *    wysihtml5.dom.removeEmptyTextNodes(element);
 */
wysihtml5.dom.removeEmptyTextNodes = function(node) {
  var childNode,
      childNodes        = wysihtml5.lang.array(node.childNodes).get(),
      childNodesLength  = childNodes.length,
      i                 = 0;
  for (; i<childNodesLength; i++) {
    childNode = childNodes[i];
    if (childNode.nodeType === wysihtml5.TEXT_NODE && childNode.data === "") {
      childNode.parentNode.removeChild(childNode);
    }
  }
};
;/**
 * Renames an element (eg. a <div> to a <p>) and keeps its childs
 *
 * @param {Element} element The list element which should be renamed
 * @param {Element} newNodeName The desired tag name
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <ul id="list">
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 *
 *    <script>
 *      wysihtml5.dom.renameElement(document.getElementById("list"), "ol");
 *    </script>
 *
 *    <!-- Will result in: -->
 *    <ol>
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ol>
 */
wysihtml5.dom.renameElement = function(element, newNodeName) {
  var newElement = element.ownerDocument.createElement(newNodeName),
      firstChild;
  while (firstChild = element.firstChild) {
    newElement.appendChild(firstChild);
  }
  wysihtml5.dom.copyAttributes(["align", "className"]).from(element).to(newElement);
  element.parentNode.replaceChild(newElement, element);
  return newElement;
};
;/**
 * Takes an element, removes it and replaces it with it's childs
 *
 * @param {Object} node The node which to replace with it's child nodes
 * @example
 *    <div id="foo">
 *      <span>hello</span>
 *    </div>
 *    <script>
 *      // Remove #foo and replace with it's children
 *      wysihtml5.dom.replaceWithChildNodes(document.getElementById("foo"));
 *    </script>
 */
wysihtml5.dom.replaceWithChildNodes = function(node) {
  if (!node.parentNode) {
    return;
  }

  if (!node.firstChild) {
    node.parentNode.removeChild(node);
    return;
  }

  var fragment = node.ownerDocument.createDocumentFragment();
  while (node.firstChild) {
    fragment.appendChild(node.firstChild);
  }
  node.parentNode.replaceChild(fragment, node);
  node = fragment = null;
};
;/**
 * Unwraps an unordered/ordered list
 *
 * @param {Element} element The list element which should be unwrapped
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <ul id="list">
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 *
 *    <script>
 *      wysihtml5.dom.resolveList(document.getElementById("list"));
 *    </script>
 *
 *    <!-- Will result in: -->
 *    eminem<br>
 *    dr. dre<br>
 *    50 Cent<br>
 */
(function(dom) {
  function _isBlockElement(node) {
    return dom.getStyle("display").from(node) === "block";
  }

  function _isLineBreak(node) {
    return node.nodeName === "BR";
  }

  function _appendLineBreak(element) {
    var lineBreak = element.ownerDocument.createElement("br");
    element.appendChild(lineBreak);
  }

  function resolveList(list, useLineBreaks) {
    if (!list.nodeName.match(/^(MENU|UL|OL)$/)) {
      return;
    }

    var doc             = list.ownerDocument,
        fragment        = doc.createDocumentFragment(),
        previousSibling = wysihtml5.dom.domNode(list).prev({ignoreBlankTexts: true}),
        firstChild,
        lastChild,
        isLastChild,
        shouldAppendLineBreak,
        paragraph,
        listItem;

    if (useLineBreaks) {
      // Insert line break if list is after a non-block element
      if (previousSibling && !_isBlockElement(previousSibling) && !_isLineBreak(previousSibling)) {
        _appendLineBreak(fragment);
      }

      while (listItem = (list.firstElementChild || list.firstChild)) {
        lastChild = listItem.lastChild;
        while (firstChild = listItem.firstChild) {
          isLastChild           = firstChild === lastChild;
          // This needs to be done before appending it to the fragment, as it otherwise will lose style information
          shouldAppendLineBreak = isLastChild && !_isBlockElement(firstChild) && !_isLineBreak(firstChild);
          fragment.appendChild(firstChild);
          if (shouldAppendLineBreak) {
            _appendLineBreak(fragment);
          }
        }

        listItem.parentNode.removeChild(listItem);
      }
    } else {
      while (listItem = (list.firstElementChild || list.firstChild)) {
        if (listItem.querySelector && listItem.querySelector("div, p, ul, ol, menu, blockquote, h1, h2, h3, h4, h5, h6")) {
          while (firstChild = listItem.firstChild) {
            fragment.appendChild(firstChild);
          }
        } else {
          paragraph = doc.createElement("p");
          while (firstChild = listItem.firstChild) {
            paragraph.appendChild(firstChild);
          }
          fragment.appendChild(paragraph);
        }
        listItem.parentNode.removeChild(listItem);
      }
    }

    list.parentNode.replaceChild(fragment, list);
  }

  dom.resolveList = resolveList;
})(wysihtml5.dom);
;/**
 * Sandbox for executing javascript, parsing css styles and doing dom operations in a secure way
 *
 * Browser Compatibility:
 *  - Secure in MSIE 6+, but only when the user hasn't made changes to his security level "restricted"
 *  - Partially secure in other browsers (Firefox, Opera, Safari, Chrome, ...)
 *
 * Please note that this class can't benefit from the HTML5 sandbox attribute for the following reasons:
 *    - sandboxing doesn't work correctly with inlined content (src="javascript:'<html>...</html>'")
 *    - sandboxing of physical documents causes that the dom isn't accessible anymore from the outside (iframe.contentWindow, ...)
 *    - setting the "allow-same-origin" flag would fix that, but then still javascript and dom events refuse to fire
 *    - therefore the "allow-scripts" flag is needed, which then would deactivate any security, as the js executed inside the iframe
 *      can do anything as if the sandbox attribute wasn't set
 *
 * @param {Function} [readyCallback] Method that gets invoked when the sandbox is ready
 * @param {Object} [config] Optional parameters
 *
 * @example
 *    new wysihtml5.dom.Sandbox(function(sandbox) {
 *      sandbox.getWindow().document.body.innerHTML = '<img src=foo.gif onerror="alert(document.cookie)">';
 *    });
 */
(function(wysihtml5) {
  var /**
       * Default configuration
       */
      doc                 = document,
      /**
       * Properties to unset/protect on the window object
       */
      windowProperties    = [
        "parent", "top", "opener", "frameElement", "frames",
        "localStorage", "globalStorage", "sessionStorage", "indexedDB"
      ],
      /**
       * Properties on the window object which are set to an empty function
       */
      windowProperties2   = [
        "open", "close", "openDialog", "showModalDialog",
        "alert", "confirm", "prompt",
        "openDatabase", "postMessage",
        "XMLHttpRequest", "XDomainRequest"
      ],
      /**
       * Properties to unset/protect on the document object
       */
      documentProperties  = [
        "referrer",
        "write", "open", "close"
      ];

  wysihtml5.dom.Sandbox = Base.extend(
    /** @scope wysihtml5.dom.Sandbox.prototype */ {

    constructor: function(readyCallback, config) {
      this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;
      this.config   = wysihtml5.lang.object({}).merge(config).get();
      this.editableArea   = this._createIframe();
    },

    insertInto: function(element) {
      if (typeof(element) === "string") {
        element = doc.getElementById(element);
      }

      element.appendChild(this.editableArea);
    },

    getIframe: function() {
      return this.editableArea;
    },

    getWindow: function() {
      this._readyError();
    },

    getDocument: function() {
      this._readyError();
    },

    destroy: function() {
      var iframe = this.getIframe();
      iframe.parentNode.removeChild(iframe);
    },

    _readyError: function() {
      throw new Error("wysihtml5.Sandbox: Sandbox iframe isn't loaded yet");
    },

    /**
     * Creates the sandbox iframe
     *
     * Some important notes:
     *  - We can't use HTML5 sandbox for now:
     *    setting it causes that the iframe's dom can't be accessed from the outside
     *    Therefore we need to set the "allow-same-origin" flag which enables accessing the iframe's dom
     *    But then there's another problem, DOM events (focus, blur, change, keypress, ...) aren't fired.
     *    In order to make this happen we need to set the "allow-scripts" flag.
     *    A combination of allow-scripts and allow-same-origin is almost the same as setting no sandbox attribute at all.
     *  - Chrome & Safari, doesn't seem to support sandboxing correctly when the iframe's html is inlined (no physical document)
     *  - IE needs to have the security="restricted" attribute set before the iframe is
     *    inserted into the dom tree
     *  - Believe it or not but in IE "security" in document.createElement("iframe") is false, even
     *    though it supports it
     *  - When an iframe has security="restricted", in IE eval() & execScript() don't work anymore
     *  - IE doesn't fire the onload event when the content is inlined in the src attribute, therefore we rely
     *    on the onreadystatechange event
     */
    _createIframe: function() {
      var that   = this,
          iframe = doc.createElement("iframe");
      iframe.className = "wysihtml5-sandbox";
      wysihtml5.dom.setAttributes({
        "security":           "restricted",
        "allowtransparency":  "true",
        "frameborder":        0,
        "width":              0,
        "height":             0,
        "marginwidth":        0,
        "marginheight":       0
      }).on(iframe);

      // Setting the src like this prevents ssl warnings in IE6
      if (wysihtml5.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty()) {
        iframe.src = "javascript:'<html></html>'";
      }

      iframe.onload = function() {
        iframe.onreadystatechange = iframe.onload = null;
        that._onLoadIframe(iframe);
      };

      iframe.onreadystatechange = function() {
        if (/loaded|complete/.test(iframe.readyState)) {
          iframe.onreadystatechange = iframe.onload = null;
          that._onLoadIframe(iframe);
        }
      };

      return iframe;
    },

    /**
     * Callback for when the iframe has finished loading
     */
    _onLoadIframe: function(iframe) {
      // don't resume when the iframe got unloaded (eg. by removing it from the dom)
      if (!wysihtml5.dom.contains(doc.documentElement, iframe)) {
        return;
      }

      var that           = this,
          iframeWindow   = iframe.contentWindow,
          iframeDocument = iframe.contentWindow.document,
          charset        = doc.characterSet || doc.charset || "utf-8",
          sandboxHtml    = this._getHtml({
            charset:      charset,
            stylesheets:  this.config.stylesheets
          });

      // Create the basic dom tree including proper DOCTYPE and charset
      iframeDocument.open("text/html", "replace");
      iframeDocument.write(sandboxHtml);
      iframeDocument.close();

      this.getWindow = function() { return iframe.contentWindow; };
      this.getDocument = function() { return iframe.contentWindow.document; };

      // Catch js errors and pass them to the parent's onerror event
      // addEventListener("error") doesn't work properly in some browsers
      // TODO: apparently this doesn't work in IE9!
      iframeWindow.onerror = function(errorMessage, fileName, lineNumber) {
        throw new Error("wysihtml5.Sandbox: " + errorMessage, fileName, lineNumber);
      };

      if (!wysihtml5.browser.supportsSandboxedIframes()) {
        // Unset a bunch of sensitive variables
        // Please note: This isn't hack safe!
        // It more or less just takes care of basic attacks and prevents accidental theft of sensitive information
        // IE is secure though, which is the most important thing, since IE is the only browser, who
        // takes over scripts & styles into contentEditable elements when copied from external websites
        // or applications (Microsoft Word, ...)
        var i, length;
        for (i=0, length=windowProperties.length; i<length; i++) {
          this._unset(iframeWindow, windowProperties[i]);
        }
        for (i=0, length=windowProperties2.length; i<length; i++) {
          this._unset(iframeWindow, windowProperties2[i], wysihtml5.EMPTY_FUNCTION);
        }
        for (i=0, length=documentProperties.length; i<length; i++) {
          this._unset(iframeDocument, documentProperties[i]);
        }
        // This doesn't work in Safari 5
        // See http://stackoverflow.com/questions/992461/is-it-possible-to-override-document-cookie-in-webkit
        this._unset(iframeDocument, "cookie", "", true);
      }

      this.loaded = true;

      // Trigger the callback
      setTimeout(function() { that.callback(that); }, 0);
    },

    _getHtml: function(templateVars) {
      var stylesheets = templateVars.stylesheets,
          html        = "",
          i           = 0,
          length;
      stylesheets = typeof(stylesheets) === "string" ? [stylesheets] : stylesheets;
      if (stylesheets) {
        length = stylesheets.length;
        for (; i<length; i++) {
          html += '<link rel="stylesheet" href="' + stylesheets[i] + '">';
        }
      }
      templateVars.stylesheets = html;

      return wysihtml5.lang.string(
        '<!DOCTYPE html><html><head>'
        + '<meta charset="#{charset}">#{stylesheets}</head>'
        + '<body></body></html>'
      ).interpolate(templateVars);
    },

    /**
     * Method to unset/override existing variables
     * @example
     *    // Make cookie unreadable and unwritable
     *    this._unset(document, "cookie", "", true);
     */
    _unset: function(object, property, value, setter) {
      try { object[property] = value; } catch(e) {}

      try { object.__defineGetter__(property, function() { return value; }); } catch(e) {}
      if (setter) {
        try { object.__defineSetter__(property, function() {}); } catch(e) {}
      }

      if (!wysihtml5.browser.crashesWhenDefineProperty(property)) {
        try {
          var config = {
            get: function() { return value; }
          };
          if (setter) {
            config.set = function() {};
          }
          Object.defineProperty(object, property, config);
        } catch(e) {}
      }
    }
  });
})(wysihtml5);
;(function(wysihtml5) {
  var doc = document;
  wysihtml5.dom.ContentEditableArea = Base.extend({
      getContentEditable: function() {
        return this.element;
      },

      getWindow: function() {
        return this.element.ownerDocument.defaultView;
      },

      getDocument: function() {
        return this.element.ownerDocument;
      },

      constructor: function(readyCallback, config, contentEditable) {
        this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;
        this.config   = wysihtml5.lang.object({}).merge(config).get();
        if (contentEditable) {
            this.element = this._bindElement(contentEditable);
        } else {
            this.element = this._createElement();
        }
      },

      // creates a new contenteditable and initiates it
      _createElement: function() {
        var element = doc.createElement("div");
        element.className = "wysihtml5-sandbox";
        this._loadElement(element);
        return element;
      },

      // initiates an allready existent contenteditable
      _bindElement: function(contentEditable) {
        contentEditable.className = (contentEditable.className && contentEditable.className != '') ? contentEditable.className + " wysihtml5-sandbox" : "wysihtml5-sandbox";
        this._loadElement(contentEditable, true);
        return contentEditable;
      },

      _loadElement: function(element, contentExists) {
          var that = this;
        if (!contentExists) {
            var sandboxHtml = this._getHtml();
            element.innerHTML = sandboxHtml;
        }

        this.getWindow = function() { return element.ownerDocument.defaultView; };
        this.getDocument = function() { return element.ownerDocument; };

        // Catch js errors and pass them to the parent's onerror event
        // addEventListener("error") doesn't work properly in some browsers
        // TODO: apparently this doesn't work in IE9!
        // TODO: figure out and bind the errors logic for contenteditble mode
        /*iframeWindow.onerror = function(errorMessage, fileName, lineNumber) {
          throw new Error("wysihtml5.Sandbox: " + errorMessage, fileName, lineNumber);
        }
        */
        this.loaded = true;
        // Trigger the callback
        setTimeout(function() { that.callback(that); }, 0);
      },

      _getHtml: function(templateVars) {
        return '';
      }

  });
})(wysihtml5);
;(function() {
  var mapping = {
    "className": "class"
  };
  wysihtml5.dom.setAttributes = function(attributes) {
    return {
      on: function(element) {
        for (var i in attributes) {
          element.setAttribute(mapping[i] || i, attributes[i]);
        }
      }
    };
  };
})();
;wysihtml5.dom.setStyles = function(styles) {
  return {
    on: function(element) {
      var style = element.style;
      if (typeof(styles) === "string") {
        style.cssText += ";" + styles;
        return;
      }
      for (var i in styles) {
        if (i === "float") {
          style.cssFloat = styles[i];
          style.styleFloat = styles[i];
        } else {
          style[i] = styles[i];
        }
      }
    }
  };
};
;/**
 * Simulate HTML5 placeholder attribute
 *
 * Needed since
 *    - div[contentEditable] elements don't support it
 *    - older browsers (such as IE8 and Firefox 3.6) don't support it at all
 *
 * @param {Object} parent Instance of main wysihtml5.Editor class
 * @param {Element} view Instance of wysihtml5.views.* class
 * @param {String} placeholderText
 *
 * @example
 *    wysihtml.dom.simulatePlaceholder(this, composer, "Foobar");
 */
(function(dom) {
  dom.simulatePlaceholder = function(editor, view, placeholderText) {
    var CLASS_NAME = "placeholder",
        unset = function() {
          var composerIsVisible   = view.element.offsetWidth > 0 && view.element.offsetHeight > 0;
          if (view.hasPlaceholderSet()) {
            view.clear();
            view.element.focus();
            if (composerIsVisible ) {
              setTimeout(function() {
                var sel = view.selection.getSelection();
                if (!sel.focusNode || !sel.anchorNode) {
                  view.selection.selectNode(view.element.firstChild || view.element);
                }
              }, 0);
            }
          }
          view.placeholderSet = false;
          dom.removeClass(view.element, CLASS_NAME);
        },
        set = function() {
          if (view.isEmpty()) {
            view.placeholderSet = true;
            view.setValue(placeholderText);
            dom.addClass(view.element, CLASS_NAME);
          }
        };

    editor
      .on("set_placeholder", set)
      .on("unset_placeholder", unset)
      .on("focus:composer", unset)
      .on("paste:composer", unset)
      .on("blur:composer", set);

    set();
  };
})(wysihtml5.dom);
;(function(dom) {
  var documentElement = document.documentElement;
  if ("textContent" in documentElement) {
    dom.setTextContent = function(element, text) {
      element.textContent = text;
    };

    dom.getTextContent = function(element) {
      return element.textContent;
    };
  } else if ("innerText" in documentElement) {
    dom.setTextContent = function(element, text) {
      element.innerText = text;
    };

    dom.getTextContent = function(element) {
      return element.innerText;
    };
  } else {
    dom.setTextContent = function(element, text) {
      element.nodeValue = text;
    };

    dom.getTextContent = function(element) {
      return element.nodeValue;
    };
  }
})(wysihtml5.dom);

;/**
 * Get a set of attribute from one element
 *
 * IE gives wrong results for hasAttribute/getAttribute, for example:
 *    var td = document.createElement("td");
 *    td.getAttribute("rowspan"); // => "1" in IE
 *
 * Therefore we have to check the element's outerHTML for the attribute
*/

wysihtml5.dom.getAttribute = function(node, attributeName) {
  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly();
  attributeName = attributeName.toLowerCase();
  var nodeName = node.nodeName;
  if (nodeName == "IMG" && attributeName == "src" && wysihtml5.dom.isLoadedImage(node) === true) {
    // Get 'src' attribute value via object property since this will always contain the
    // full absolute url (http://...)
    // this fixes a very annoying bug in firefox (ver 3.6 & 4) and IE 8 where images copied from the same host
    // will have relative paths, which the sanitizer strips out (see attributeCheckMethods.url)
    return node.src;
  } else if (HAS_GET_ATTRIBUTE_BUG && "outerHTML" in node) {
    // Don't trust getAttribute/hasAttribute in IE 6-8, instead check the element's outerHTML
    var outerHTML      = node.outerHTML.toLowerCase(),
        // TODO: This might not work for attributes without value: <input disabled>
        hasAttribute   = outerHTML.indexOf(" " + attributeName +  "=") != -1;

    return hasAttribute ? node.getAttribute(attributeName) : null;
  } else{
    return node.getAttribute(attributeName);
  }
};
;/**
 * Get all attributes of an element
 *
 * IE gives wrong results for hasAttribute/getAttribute, for example:
 *    var td = document.createElement("td");
 *    td.getAttribute("rowspan"); // => "1" in IE
 *
 * Therefore we have to check the element's outerHTML for the attribute
*/

wysihtml5.dom.getAttributes = function(node) {
  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly(),
      nodeName = node.nodeName,
      attributes = [],
      attr;

  for (attr in node.attributes) {
    if ((node.attributes.hasOwnProperty && node.attributes.hasOwnProperty(attr)) || (!node.attributes.hasOwnProperty && Object.prototype.hasOwnProperty.call(node.attributes, attr)))  {
      if (node.attributes[attr].specified) {
        if (nodeName == "IMG" && node.attributes[attr].name.toLowerCase() == "src" && wysihtml5.dom.isLoadedImage(node) === true) {
          attributes['src'] = node.src;
        } else if (wysihtml5.lang.array(['rowspan', 'colspan']).contains(node.attributes[attr].name.toLowerCase()) && HAS_GET_ATTRIBUTE_BUG) {
          if (node.attributes[attr].value !== 1) {
            attributes[node.attributes[attr].name] = node.attributes[attr].value;
          }
        } else {
          attributes[node.attributes[attr].name] = node.attributes[attr].value;
        }
      }
    }
  }
  return attributes;
};;/**
   * Check whether the given node is a proper loaded image
   * FIXME: Returns undefined when unknown (Chrome, Safari)
*/

wysihtml5.dom.isLoadedImage = function (node) {
  try {
    return node.complete && !node.mozMatchesSelector(":-moz-broken");
  } catch(e) {
    if (node.complete && node.readyState === "complete") {
      return true;
    }
  }
};
;(function(wysihtml5) {

    var api = wysihtml5.dom;

    var MapCell = function(cell) {
      this.el = cell;
      this.isColspan= false;
      this.isRowspan= false;
      this.firstCol= true;
      this.lastCol= true;
      this.firstRow= true;
      this.lastRow= true;
      this.isReal= true;
      this.spanCollection= [];
      this.modified = false;
    };

    var TableModifyerByCell = function (cell, table) {
        if (cell) {
            this.cell = cell;
            this.table = api.getParentElement(cell, { nodeName: ["TABLE"] });
        } else if (table) {
            this.table = table;
            this.cell = this.table.querySelectorAll('th, td')[0];
        }
    };

    function queryInList(list, query) {
        var ret = [],
            q;
        for (var e = 0, len = list.length; e < len; e++) {
            q = list[e].querySelectorAll(query);
            if (q) {
                for(var i = q.length; i--; ret.unshift(q[i]));
            }
        }
        return ret;
    }

    function removeElement(el) {
        el.parentNode.removeChild(el);
    }

    function insertAfter(referenceNode, newNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    }

    function nextNode(node, tag) {
        var element = node.nextSibling;
        while (element.nodeType !=1) {
            element = element.nextSibling;
            if (!tag || tag == element.tagName.toLowerCase()) {
                return element;
            }
        }
        return null;
    }

    TableModifyerByCell.prototype = {

        addSpannedCellToMap: function(cell, map, r, c, cspan, rspan) {
            var spanCollect = [],
                rmax = r + ((rspan) ? parseInt(rspan, 10) - 1 : 0),
                cmax = c + ((cspan) ? parseInt(cspan, 10) - 1 : 0);

            for (var rr = r; rr <= rmax; rr++) {
                if (typeof map[rr] == "undefined") { map[rr] = []; }
                for (var cc = c; cc <= cmax; cc++) {
                    map[rr][cc] = new MapCell(cell);
                    map[rr][cc].isColspan = (cspan && parseInt(cspan, 10) > 1);
                    map[rr][cc].isRowspan = (rspan && parseInt(rspan, 10) > 1);
                    map[rr][cc].firstCol = cc == c;
                    map[rr][cc].lastCol = cc == cmax;
                    map[rr][cc].firstRow = rr == r;
                    map[rr][cc].lastRow = rr == rmax;
                    map[rr][cc].isReal = cc == c && rr == r;
                    map[rr][cc].spanCollection = spanCollect;

                    spanCollect.push(map[rr][cc]);
                }
            }
        },

        setCellAsModified: function(cell) {
            cell.modified = true;
            if (cell.spanCollection.length > 0) {
              for (var s = 0, smax = cell.spanCollection.length; s < smax; s++) {
                cell.spanCollection[s].modified = true;
              }
            }
        },

        setTableMap: function() {
            var map = [];
            var tableRows = this.getTableRows(),
                ridx, row, cells, cidx, cell,
                c,
                cspan, rspan;

            for (ridx = 0; ridx < tableRows.length; ridx++) {
                row = tableRows[ridx];
                cells = this.getRowCells(row);
                c = 0;
                if (typeof map[ridx] == "undefined") { map[ridx] = []; }
                for (cidx = 0; cidx < cells.length; cidx++) {
                    cell = cells[cidx];

                    // If cell allready set means it is set by col or rowspan,
                    // so increase cols index until free col is found
                    while (typeof map[ridx][c] != "undefined") { c++; }

                    cspan = api.getAttribute(cell, 'colspan');
                    rspan = api.getAttribute(cell, 'rowspan');

                    if (cspan || rspan) {
                        this.addSpannedCellToMap(cell, map, ridx, c, cspan, rspan);
                        c = c + ((cspan) ? parseInt(cspan, 10) : 1);
                    } else {
                        map[ridx][c] = new MapCell(cell);
                        c++;
                    }
                }
            }
            this.map = map;
            return map;
        },

        getRowCells: function(row) {
            var inlineTables = this.table.querySelectorAll('table'),
                inlineCells = (inlineTables) ? queryInList(inlineTables, 'th, td') : [],
                allCells = row.querySelectorAll('th, td'),
                tableCells = (inlineCells.length > 0) ? wysihtml5.lang.array(allCells).without(inlineCells) : allCells;

            return tableCells;
        },

        getTableRows: function() {
          var inlineTables = this.table.querySelectorAll('table'),
              inlineRows = (inlineTables) ? queryInList(inlineTables, 'tr') : [],
              allRows = this.table.querySelectorAll('tr'),
              tableRows = (inlineRows.length > 0) ? wysihtml5.lang.array(allRows).without(inlineRows) : allRows;

          return tableRows;
        },

        getMapIndex: function(cell) {
          var r_length = this.map.length,
              c_length = (this.map && this.map[0]) ? this.map[0].length : 0;

          for (var r_idx = 0;r_idx < r_length; r_idx++) {
              for (var c_idx = 0;c_idx < c_length; c_idx++) {
                  if (this.map[r_idx][c_idx].el === cell) {
                      return {'row': r_idx, 'col': c_idx};
                  }
              }
          }
          return false;
        },

        getElementAtIndex: function(idx) {
            this.setTableMap();
            if (this.map[idx.row] && this.map[idx.row][idx.col] && this.map[idx.row][idx.col].el) {
                return this.map[idx.row][idx.col].el;
            }
            return null;
        },

        getMapElsTo: function(to_cell) {
            var els = [];
            this.setTableMap();
            this.idx_start = this.getMapIndex(this.cell);
            this.idx_end = this.getMapIndex(to_cell);

            // switch indexes if start is bigger than end
            if (this.idx_start.row > this.idx_end.row || (this.idx_start.row == this.idx_end.row && this.idx_start.col > this.idx_end.col)) {
                var temp_idx = this.idx_start;
                this.idx_start = this.idx_end;
                this.idx_end = temp_idx;
            }
            if (this.idx_start.col > this.idx_end.col) {
                var temp_cidx = this.idx_start.col;
                this.idx_start.col = this.idx_end.col;
                this.idx_end.col = temp_cidx;
            }

            if (this.idx_start != null && this.idx_end != null) {
                for (var row = this.idx_start.row, maxr = this.idx_end.row; row <= maxr; row++) {
                    for (var col = this.idx_start.col, maxc = this.idx_end.col; col <= maxc; col++) {
                        els.push(this.map[row][col].el);
                    }
                }
            }
            return els;
        },

        orderSelectionEnds: function(secondcell) {
            this.setTableMap();
            this.idx_start = this.getMapIndex(this.cell);
            this.idx_end = this.getMapIndex(secondcell);

            // switch indexes if start is bigger than end
            if (this.idx_start.row > this.idx_end.row || (this.idx_start.row == this.idx_end.row && this.idx_start.col > this.idx_end.col)) {
                var temp_idx = this.idx_start;
                this.idx_start = this.idx_end;
                this.idx_end = temp_idx;
            }
            if (this.idx_start.col > this.idx_end.col) {
                var temp_cidx = this.idx_start.col;
                this.idx_start.col = this.idx_end.col;
                this.idx_end.col = temp_cidx;
            }

            return {
                "start": this.map[this.idx_start.row][this.idx_start.col].el,
                "end": this.map[this.idx_end.row][this.idx_end.col].el
            };
        },

        createCells: function(tag, nr, attrs) {
            var doc = this.table.ownerDocument,
                frag = doc.createDocumentFragment(),
                cell;
            for (var i = 0; i < nr; i++) {
                cell = doc.createElement(tag);

                if (attrs) {
                    for (var attr in attrs) {
                        if (attrs.hasOwnProperty(attr)) {
                            cell.setAttribute(attr, attrs[attr]);
                        }
                    }
                }

                // add non breaking space
                cell.appendChild(document.createTextNode("\u00a0"));

                frag.appendChild(cell);
            }
            return frag;
        },

        // Returns next real cell (not part of spanned cell unless first) on row if selected index is not real. I no real cells -1 will be returned
        correctColIndexForUnreals: function(col, row) {
            var r = this.map[row],
                corrIdx = -1;
            for (var i = 0, max = col; i < col; i++) {
                if (r[i].isReal){
                    corrIdx++;
                }
            }
            return corrIdx;
        },

        getLastNewCellOnRow: function(row, rowLimit) {
            var cells = this.getRowCells(row),
                cell, idx;

            for (var cidx = 0, cmax = cells.length; cidx < cmax; cidx++) {
                cell = cells[cidx];
                idx = this.getMapIndex(cell);
                if (idx === false || (typeof rowLimit != "undefined" && idx.row != rowLimit)) {
                    return cell;
                }
            }
            return null;
        },

        removeEmptyTable: function() {
            var cells = this.table.querySelectorAll('td, th');
            if (!cells || cells.length == 0) {
                removeElement(this.table);
                return true;
            } else {
                return false;
            }
        },

        // Splits merged cell on row to unique cells
        splitRowToCells: function(cell) {
            if (cell.isColspan) {
                var colspan = parseInt(api.getAttribute(cell.el, 'colspan') || 1, 10),
                    cType = cell.el.tagName.toLowerCase();
                if (colspan > 1) {
                    var newCells = this.createCells(cType, colspan -1);
                    insertAfter(cell.el, newCells);
                }
                cell.el.removeAttribute('colspan');
            }
        },

        getRealRowEl: function(force, idx) {
            var r = null,
                c = null;

            idx = idx || this.idx;

            for (var cidx = 0, cmax = this.map[idx.row].length; cidx < cmax; cidx++) {
                c = this.map[idx.row][cidx];
                if (c.isReal) {
                    r = api.getParentElement(c.el, { nodeName: ["TR"] });
                    if (r) {
                        return r;
                    }
                }
            }

            if (r === null && force) {
                r = api.getParentElement(this.map[idx.row][idx.col].el, { nodeName: ["TR"] }) || null;
            }

            return r;
        },

        injectRowAt: function(row, col, colspan, cType, c) {
            var r = this.getRealRowEl(false, {'row': row, 'col': col}),
                new_cells = this.createCells(cType, colspan);

            if (r) {
                var n_cidx = this.correctColIndexForUnreals(col, row);
                if (n_cidx >= 0) {
                    insertAfter(this.getRowCells(r)[n_cidx], new_cells);
                } else {
                    r.insertBefore(new_cells, r.firstChild);
                }
            } else {
                var rr = this.table.ownerDocument.createElement('tr');
                rr.appendChild(new_cells);
                insertAfter(api.getParentElement(c.el, { nodeName: ["TR"] }), rr);
            }
        },

        canMerge: function(to) {
            this.to = to;
            this.setTableMap();
            this.idx_start = this.getMapIndex(this.cell);
            this.idx_end = this.getMapIndex(this.to);

            // switch indexes if start is bigger than end
            if (this.idx_start.row > this.idx_end.row || (this.idx_start.row == this.idx_end.row && this.idx_start.col > this.idx_end.col)) {
                var temp_idx = this.idx_start;
                this.idx_start = this.idx_end;
                this.idx_end = temp_idx;
            }
            if (this.idx_start.col > this.idx_end.col) {
                var temp_cidx = this.idx_start.col;
                this.idx_start.col = this.idx_end.col;
                this.idx_end.col = temp_cidx;
            }

            for (var row = this.idx_start.row, maxr = this.idx_end.row; row <= maxr; row++) {
                for (var col = this.idx_start.col, maxc = this.idx_end.col; col <= maxc; col++) {
                    if (this.map[row][col].isColspan || this.map[row][col].isRowspan) {
                        return false;
                    }
                }
            }
            return true;
        },

        decreaseCellSpan: function(cell, span) {
            var nr = parseInt(api.getAttribute(cell.el, span), 10) - 1;
            if (nr >= 1) {
                cell.el.setAttribute(span, nr);
            } else {
                cell.el.removeAttribute(span);
                if (span == 'colspan') {
                    cell.isColspan = false;
                }
                if (span == 'rowspan') {
                    cell.isRowspan = false;
                }
                cell.firstCol = true;
                cell.lastCol = true;
                cell.firstRow = true;
                cell.lastRow = true;
                cell.isReal = true;
            }
        },

        removeSurplusLines: function() {
            var row, cell, ridx, rmax, cidx, cmax, allRowspan;

            this.setTableMap();
            if (this.map) {
                ridx = 0;
                rmax = this.map.length;
                for (;ridx < rmax; ridx++) {
                    row = this.map[ridx];
                    allRowspan = true;
                    cidx = 0;
                    cmax = row.length;
                    for (; cidx < cmax; cidx++) {
                        cell = row[cidx];
                        if (!(api.getAttribute(cell.el, "rowspan") && parseInt(api.getAttribute(cell.el, "rowspan"), 10) > 1 && cell.firstRow !== true)) {
                            allRowspan = false;
                            break;
                        }
                    }
                    if (allRowspan) {
                        cidx = 0;
                        for (; cidx < cmax; cidx++) {
                            this.decreaseCellSpan(row[cidx], 'rowspan');
                        }
                    }
                }

                // remove rows without cells
                var tableRows = this.getTableRows();
                ridx = 0;
                rmax = tableRows.length;
                for (;ridx < rmax; ridx++) {
                    row = tableRows[ridx];
                    if (row.childNodes.length == 0 && (/^\s*$/.test(row.textContent || row.innerText))) {
                        removeElement(row);
                    }
                }
            }
        },

        fillMissingCells: function() {
            var r_max = 0,
                c_max = 0,
                prevcell = null;

            this.setTableMap();
            if (this.map) {

                // find maximal dimensions of broken table
                r_max = this.map.length;
                for (var ridx = 0; ridx < r_max; ridx++) {
                    if (this.map[ridx].length > c_max) { c_max = this.map[ridx].length; }
                }

                for (var row = 0; row < r_max; row++) {
                    for (var col = 0; col < c_max; col++) {
                        if (this.map[row] && !this.map[row][col]) {
                            if (col > 0) {
                                this.map[row][col] = new MapCell(this.createCells('td', 1));
                                prevcell = this.map[row][col-1];
                                if (prevcell && prevcell.el && prevcell.el.parent) { // if parent does not exist element is removed from dom
                                    insertAfter(this.map[row][col-1].el, this.map[row][col].el);
                                }
                            }
                        }
                    }
                }
            }
        },

        rectify: function() {
            if (!this.removeEmptyTable()) {
                this.removeSurplusLines();
                this.fillMissingCells();
                return true;
            } else {
                return false;
            }
        },

        unmerge: function() {
            if (this.rectify()) {
                this.setTableMap();
                this.idx = this.getMapIndex(this.cell);

                if (this.idx) {
                    var thisCell = this.map[this.idx.row][this.idx.col],
                        colspan = (api.getAttribute(thisCell.el, "colspan")) ? parseInt(api.getAttribute(thisCell.el, "colspan"), 10) : 1,
                        cType = thisCell.el.tagName.toLowerCase();

                    if (thisCell.isRowspan) {
                        var rowspan = parseInt(api.getAttribute(thisCell.el, "rowspan"), 10);
                        if (rowspan > 1) {
                            for (var nr = 1, maxr = rowspan - 1; nr <= maxr; nr++){
                                this.injectRowAt(this.idx.row + nr, this.idx.col, colspan, cType, thisCell);
                            }
                        }
                        thisCell.el.removeAttribute('rowspan');
                    }
                    this.splitRowToCells(thisCell);
                }
            }
        },

        // merges cells from start cell (defined in creating obj) to "to" cell
        merge: function(to) {
            if (this.rectify()) {
                if (this.canMerge(to)) {
                    var rowspan = this.idx_end.row - this.idx_start.row + 1,
                        colspan = this.idx_end.col - this.idx_start.col + 1;

                    for (var row = this.idx_start.row, maxr = this.idx_end.row; row <= maxr; row++) {
                        for (var col = this.idx_start.col, maxc = this.idx_end.col; col <= maxc; col++) {

                            if (row == this.idx_start.row && col == this.idx_start.col) {
                                if (rowspan > 1) {
                                    this.map[row][col].el.setAttribute('rowspan', rowspan);
                                }
                                if (colspan > 1) {
                                    this.map[row][col].el.setAttribute('colspan', colspan);
                                }
                            } else {
                                // transfer content
                                if (!(/^\s*<br\/?>\s*$/.test(this.map[row][col].el.innerHTML.toLowerCase()))) {
                                    this.map[this.idx_start.row][this.idx_start.col].el.innerHTML += ' ' + this.map[row][col].el.innerHTML;
                                }
                                removeElement(this.map[row][col].el);
                            }
                        }
                    }
                    this.rectify();
                } else {
                    if (window.console) {
                        console.log('Do not know how to merge allready merged cells.');
                    }
                }
            }
        },

        // Decreases rowspan of a cell if it is done on first cell of rowspan row (real cell)
        // Cell is moved to next row (if it is real)
        collapseCellToNextRow: function(cell) {
            var cellIdx = this.getMapIndex(cell.el),
                newRowIdx = cellIdx.row + 1,
                newIdx = {'row': newRowIdx, 'col': cellIdx.col};

            if (newRowIdx < this.map.length) {

                var row = this.getRealRowEl(false, newIdx);
                if (row !== null) {
                    var n_cidx = this.correctColIndexForUnreals(newIdx.col, newIdx.row);
                    if (n_cidx >= 0) {
                        insertAfter(this.getRowCells(row)[n_cidx], cell.el);
                    } else {
                        var lastCell = this.getLastNewCellOnRow(row, newRowIdx);
                        if (lastCell !== null) {
                            insertAfter(lastCell, cell.el);
                        } else {
                            row.insertBefore(cell.el, row.firstChild);
                        }
                    }
                    if (parseInt(api.getAttribute(cell.el, 'rowspan'), 10) > 2) {
                        cell.el.setAttribute('rowspan', parseInt(api.getAttribute(cell.el, 'rowspan'), 10) - 1);
                    } else {
                        cell.el.removeAttribute('rowspan');
                    }
                }
            }
        },

        // Removes a cell when removing a row
        // If is rowspan cell then decreases the rowspan
        // and moves cell to next row if needed (is first cell of rowspan)
        removeRowCell: function(cell) {
            if (cell.isReal) {
               if (cell.isRowspan) {
                   this.collapseCellToNextRow(cell);
               } else {
                   removeElement(cell.el);
               }
            } else {
                if (parseInt(api.getAttribute(cell.el, 'rowspan'), 10) > 2) {
                    cell.el.setAttribute('rowspan', parseInt(api.getAttribute(cell.el, 'rowspan'), 10) - 1);
                } else {
                    cell.el.removeAttribute('rowspan');
                }
            }
        },

        getRowElementsByCell: function() {
            var cells = [];
            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (this.idx !== false) {
                var modRow = this.map[this.idx.row];
                for (var cidx = 0, cmax = modRow.length; cidx < cmax; cidx++) {
                    if (modRow[cidx].isReal) {
                        cells.push(modRow[cidx].el);
                    }
                }
            }
            return cells;
        },

        getColumnElementsByCell: function() {
            var cells = [];
            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (this.idx !== false) {
                for (var ridx = 0, rmax = this.map.length; ridx < rmax; ridx++) {
                    if (this.map[ridx][this.idx.col] && this.map[ridx][this.idx.col].isReal) {
                        cells.push(this.map[ridx][this.idx.col].el);
                    }
                }
            }
            return cells;
        },

        // Removes the row of selected cell
        removeRow: function() {
            var oldRow = api.getParentElement(this.cell, { nodeName: ["TR"] });
            if (oldRow) {
                this.setTableMap();
                this.idx = this.getMapIndex(this.cell);
                if (this.idx !== false) {
                    var modRow = this.map[this.idx.row];
                    for (var cidx = 0, cmax = modRow.length; cidx < cmax; cidx++) {
                        if (!modRow[cidx].modified) {
                            this.setCellAsModified(modRow[cidx]);
                            this.removeRowCell(modRow[cidx]);
                        }
                    }
                }
                removeElement(oldRow);
            }
        },

        removeColCell: function(cell) {
            if (cell.isColspan) {
                if (parseInt(api.getAttribute(cell.el, 'colspan'), 10) > 2) {
                    cell.el.setAttribute('colspan', parseInt(api.getAttribute(cell.el, 'colspan'), 10) - 1);
                } else {
                    cell.el.removeAttribute('colspan');
                }
            } else if (cell.isReal) {
                removeElement(cell.el);
            }
        },

        removeColumn: function() {
            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (this.idx !== false) {
                for (var ridx = 0, rmax = this.map.length; ridx < rmax; ridx++) {
                    if (!this.map[ridx][this.idx.col].modified) {
                        this.setCellAsModified(this.map[ridx][this.idx.col]);
                        this.removeColCell(this.map[ridx][this.idx.col]);
                    }
                }
            }
        },

        // removes row or column by selected cell element
        remove: function(what) {
            if (this.rectify()) {
                switch (what) {
                    case 'row':
                        this.removeRow();
                    break;
                    case 'column':
                        this.removeColumn();
                    break;
                }
                this.rectify();
            }
        },

        addRow: function(where) {
            var doc = this.table.ownerDocument;

            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (where == "below" && api.getAttribute(this.cell, 'rowspan')) {
                this.idx.row = this.idx.row + parseInt(api.getAttribute(this.cell, 'rowspan'), 10) - 1;
            }

            if (this.idx !== false) {
                var modRow = this.map[this.idx.row],
                    newRow = doc.createElement('tr');

                for (var ridx = 0, rmax = modRow.length; ridx < rmax; ridx++) {
                    if (!modRow[ridx].modified) {
                        this.setCellAsModified(modRow[ridx]);
                        this.addRowCell(modRow[ridx], newRow, where);
                    }
                }

                switch (where) {
                    case 'below':
                        insertAfter(this.getRealRowEl(true), newRow);
                    break;
                    case 'above':
                        var cr = api.getParentElement(this.map[this.idx.row][this.idx.col].el, { nodeName: ["TR"] });
                        if (cr) {
                            cr.parentNode.insertBefore(newRow, cr);
                        }
                    break;
                }
            }
        },

        addRowCell: function(cell, row, where) {
            var colSpanAttr = (cell.isColspan) ? {"colspan" : api.getAttribute(cell.el, 'colspan')} : null;
            if (cell.isReal) {
                if (where != 'above' && cell.isRowspan) {
                    cell.el.setAttribute('rowspan', parseInt(api.getAttribute(cell.el,'rowspan'), 10) + 1);
                } else {
                    row.appendChild(this.createCells('td', 1, colSpanAttr));
                }
            } else {
                if (where != 'above' && cell.isRowspan && cell.lastRow) {
                    row.appendChild(this.createCells('td', 1, colSpanAttr));
                } else if (c.isRowspan) {
                    cell.el.attr('rowspan', parseInt(api.getAttribute(cell.el, 'rowspan'), 10) + 1);
                }
            }
        },

        add: function(where) {
            if (this.rectify()) {
                if (where == 'below' || where == 'above') {
                    this.addRow(where);
                }
                if (where == 'before' || where == 'after') {
                    this.addColumn(where);
                }
            }
        },

        addColCell: function (cell, ridx, where) {
            var doAdd,
                cType = cell.el.tagName.toLowerCase();

            // defines add cell vs expand cell conditions
            // true means add
            switch (where) {
                case "before":
                    doAdd = (!cell.isColspan || cell.firstCol);
                break;
                case "after":
                    doAdd = (!cell.isColspan || cell.lastCol || (cell.isColspan && c.el == this.cell));
                break;
            }

            if (doAdd){
                // adds a cell before or after current cell element
                switch (where) {
                    case "before":
                        cell.el.parentNode.insertBefore(this.createCells(cType, 1), cell.el);
                    break;
                    case "after":
                        insertAfter(cell.el, this.createCells(cType, 1));
                    break;
                }

                // handles if cell has rowspan
                if (cell.isRowspan) {
                    this.handleCellAddWithRowspan(cell, ridx+1, where);
                }

            } else {
                // expands cell
                cell.el.setAttribute('colspan',  parseInt(api.getAttribute(cell.el, 'colspan'), 10) + 1);
            }
        },

        addColumn: function(where) {
            var row, modCell;

            this.setTableMap();
            this.idx = this.getMapIndex(this.cell);
            if (where == "after" && api.getAttribute(this.cell, 'colspan')) {
              this.idx.col = this.idx.col + parseInt(api.getAttribute(this.cell, 'colspan'), 10) - 1;
            }

            if (this.idx !== false) {
                for (var ridx = 0, rmax = this.map.length; ridx < rmax; ridx++ ) {
                    row = this.map[ridx];
                    if (row[this.idx.col]) {
                        modCell = row[this.idx.col];
                        if (!modCell.modified) {
                            this.setCellAsModified(modCell);
                            this.addColCell(modCell, ridx , where);
                        }
                    }
                }
            }
        },

        handleCellAddWithRowspan: function (cell, ridx, where) {
            var addRowsNr = parseInt(api.getAttribute(this.cell, 'rowspan'), 10) - 1,
                crow = api.getParentElement(cell.el, { nodeName: ["TR"] }),
                cType = cell.el.tagName.toLowerCase(),
                cidx, temp_r_cells,
                doc = this.table.ownerDocument,
                nrow;

            for (var i = 0; i < addRowsNr; i++) {
                cidx = this.correctColIndexForUnreals(this.idx.col, (ridx + i));
                crow = nextNode(crow, 'tr');
                if (crow) {
                    if (cidx > 0) {
                        switch (where) {
                            case "before":
                                temp_r_cells = this.getRowCells(crow);
                                if (cidx > 0 && this.map[ridx + i][this.idx.col].el != temp_r_cells[cidx] && cidx == temp_r_cells.length - 1) {
                                     insertAfter(temp_r_cells[cidx], this.createCells(cType, 1));
                                } else {
                                    temp_r_cells[cidx].parentNode.insertBefore(this.createCells(cType, 1), temp_r_cells[cidx]);
                                }

                            break;
                            case "after":
                                insertAfter(this.getRowCells(crow)[cidx], this.createCells(cType, 1));
                            break;
                        }
                    } else {
                        crow.insertBefore(this.createCells(cType, 1), crow.firstChild);
                    }
                } else {
                    nrow = doc.createElement('tr');
                    nrow.appendChild(this.createCells(cType, 1));
                    this.table.appendChild(nrow);
                }
            }
        }
    };

    api.table = {
        getCellsBetween: function(cell1, cell2) {
            var c1 = new TableModifyerByCell(cell1);
            return c1.getMapElsTo(cell2);
        },

        addCells: function(cell, where) {
            var c = new TableModifyerByCell(cell);
            c.add(where);
        },

        removeCells: function(cell, what) {
            var c = new TableModifyerByCell(cell);
            c.remove(what);
        },

        mergeCellsBetween: function(cell1, cell2) {
            var c1 = new TableModifyerByCell(cell1);
            c1.merge(cell2);
        },

        unmergeCell: function(cell) {
            var c = new TableModifyerByCell(cell);
            c.unmerge();
        },

        orderSelectionEnds: function(cell, cell2) {
            var c = new TableModifyerByCell(cell);
            return c.orderSelectionEnds(cell2);
        },

        indexOf: function(cell) {
            var c = new TableModifyerByCell(cell);
            c.setTableMap();
            return c.getMapIndex(cell);
        },

        findCell: function(table, idx) {
            var c = new TableModifyerByCell(null, table);
            return c.getElementAtIndex(idx);
        },

        findRowByCell: function(cell) {
            var c = new TableModifyerByCell(cell);
            return c.getRowElementsByCell();
        },

        findColumnByCell: function(cell) {
            var c = new TableModifyerByCell(cell);
            return c.getColumnElementsByCell();
        },

        canMerge: function(cell1, cell2) {
            var c = new TableModifyerByCell(cell1);
            return c.canMerge(cell2);
        }
    };



})(wysihtml5);
;// does a selector query on element or array of elements

wysihtml5.dom.query = function(elements, query) {
    var ret = [],
        q;

    if (elements.nodeType) {
        elements = [elements];
    }

    for (var e = 0, len = elements.length; e < len; e++) {
        q = elements[e].querySelectorAll(query);
        if (q) {
            for(var i = q.length; i--; ret.unshift(q[i]));
        }
    }
    return ret;
};
;wysihtml5.dom.compareDocumentPosition = (function() {
  var documentElement = document.documentElement;
  if (documentElement.compareDocumentPosition) {
    return function(container, element) {
      return container.compareDocumentPosition(element);
    };
  } else {
    return function( container, element ) {
      // implementation borrowed from https://github.com/tmpvar/jsdom/blob/681a8524b663281a0f58348c6129c8c184efc62c/lib/jsdom/level3/core.js // MIT license
      var thisOwner, otherOwner;

      if( container.nodeType === 9) // Node.DOCUMENT_NODE
        thisOwner = container;
      else
        thisOwner = container.ownerDocument;

      if( element.nodeType === 9) // Node.DOCUMENT_NODE
        otherOwner = element;
      else
        otherOwner = element.ownerDocument;

      if( container === element ) return 0;
      if( container === element.ownerDocument ) return 4 + 16; //Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;
      if( container.ownerDocument === element ) return 2 + 8;  //Node.DOCUMENT_POSITION_PRECEDING + Node.DOCUMENT_POSITION_CONTAINS;
      if( thisOwner !== otherOwner ) return 1; // Node.DOCUMENT_POSITION_DISCONNECTED;

      // Text nodes for attributes does not have a _parentNode. So we need to find them as attribute child.
      if( container.nodeType === 2 /*Node.ATTRIBUTE_NODE*/ && container.childNodes && wysihtml5.lang.array(container.childNodes).indexOf( element ) !== -1)
        return 4 + 16; //Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;

      if( element.nodeType === 2 /*Node.ATTRIBUTE_NODE*/ && element.childNodes && wysihtml5.lang.array(element.childNodes).indexOf( container ) !== -1)
        return 2 + 8; //Node.DOCUMENT_POSITION_PRECEDING + Node.DOCUMENT_POSITION_CONTAINS;

      var point = container;
      var parents = [ ];
      var previous = null;
      while( point ) {
        if( point == element ) return 2 + 8; //Node.DOCUMENT_POSITION_PRECEDING + Node.DOCUMENT_POSITION_CONTAINS;
        parents.push( point );
        point = point.parentNode;
      }
      point = element;
      previous = null;
      while( point ) {
        if( point == container ) return 4 + 16; //Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;
        var location_index = wysihtml5.lang.array(parents).indexOf( point );
        if( location_index !== -1) {
         var smallest_common_ancestor = parents[ location_index ];
         var this_index = wysihtml5.lang.array(smallest_common_ancestor.childNodes).indexOf( parents[location_index - 1]);//smallest_common_ancestor.childNodes.toArray().indexOf( parents[location_index - 1] );
         var other_index = wysihtml5.lang.array(smallest_common_ancestor.childNodes).indexOf( previous ); //smallest_common_ancestor.childNodes.toArray().indexOf( previous );
         if( this_index > other_index ) {
               return 2; //Node.DOCUMENT_POSITION_PRECEDING;
         }
         else {
           return 4; //Node.DOCUMENT_POSITION_FOLLOWING;
         }
        }
        previous = point;
        point = point.parentNode;
      }
      return 1; //Node.DOCUMENT_POSITION_DISCONNECTED;
    };
  }
})();
;wysihtml5.dom.unwrap = function(node) {
  if (node.parentNode) {
    while (node.lastChild) {
      wysihtml5.dom.insert(node.lastChild).after(node);
    }
    node.parentNode.removeChild(node);
  }
};;/* 
 * Methods for fetching pasted html before it gets inserted into content
**/

/* Modern event.clipboardData driven approach.
 * Advantage is that it does not have to loose selection or modify dom to catch the data. 
 * IE does not support though.
**/
wysihtml5.dom.getPastedHtml = function(event) {
  var html;
  if (event.clipboardData) {
    if (wysihtml5.lang.array(event.clipboardData.types).contains('text/html')) {
      html = event.clipboardData.getData('text/html');
    } else if (wysihtml5.lang.array(event.clipboardData.types).contains('text/plain')) {
      html = wysihtml5.lang.string(event.clipboardData.getData('text/plain')).escapeHTML(true, true);
    }
  }
  return html;
};

/* Older temprorary contenteditable as paste source catcher method for fallbacks */
wysihtml5.dom.getPastedHtmlWithDiv = function (composer, f) {
  var selBookmark = composer.selection.getBookmark(),
      doc = composer.element.ownerDocument,
      cleanerDiv = doc.createElement('DIV');
  
  doc.body.appendChild(cleanerDiv);

  cleanerDiv.style.width = "1px";
  cleanerDiv.style.height = "1px";
  cleanerDiv.style.overflow = "hidden";

  cleanerDiv.setAttribute('contenteditable', 'true');
  cleanerDiv.focus();

  setTimeout(function () {
    composer.selection.setBookmark(selBookmark);
    f(cleanerDiv.innerHTML);
    cleanerDiv.parentNode.removeChild(cleanerDiv);
  }, 0);
};;/**
 * Fix most common html formatting misbehaviors of browsers implementation when inserting
 * content via copy & paste contentEditable
 *
 * @author Christopher Blum
 */
wysihtml5.quirks.cleanPastedHTML = (function() {

  var styleToRegex = function (styleStr) {
    var trimmedStr = wysihtml5.lang.string(styleStr).trim(),
        escapedStr = trimmedStr.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");

    return new RegExp("^((?!^" + escapedStr + "$).)*$", "i");
  };

  var extendRulesWithStyleExceptions = function (rules, exceptStyles) {
    var newRules = wysihtml5.lang.object(rules).clone(true),
        tag, style;

    for (tag in newRules.tags) {

      if (newRules.tags.hasOwnProperty(tag)) {
        if (newRules.tags[tag].keep_styles) {
          for (style in newRules.tags[tag].keep_styles) {
            if (newRules.tags[tag].keep_styles.hasOwnProperty(style)) {
              if (exceptStyles[style]) {
                newRules.tags[tag].keep_styles[style] = styleToRegex(exceptStyles[style]);
              }
            }
          }
        }
      }
    }

    return newRules;
  };

  var pickRuleset = function(ruleset, html) {
    var pickedSet, defaultSet;

    if (!ruleset) {
      return null;
    }

    for (var i = 0, max = ruleset.length; i < max; i++) {
      if (!ruleset[i].condition) {
        defaultSet = ruleset[i].set;
      }
      if (ruleset[i].condition && ruleset[i].condition.test(html)) {
        return ruleset[i].set;
      }
    }

    return defaultSet;
  };

  return function(html, options) {
    var exceptStyles = {
          'color': wysihtml5.dom.getStyle("color").from(options.referenceNode),
          'fontSize': wysihtml5.dom.getStyle("font-size").from(options.referenceNode)
        },
        rules = extendRulesWithStyleExceptions(pickRuleset(options.rules, html) || {}, exceptStyles),
        newHtml;

    newHtml = wysihtml5.dom.parse(html, {
      "rules": rules,
      "cleanUp": true, // <span> elements, empty or without attributes, should be removed/replaced with their content
      "context": options.referenceNode.ownerDocument,
      "uneditableClass": options.uneditableClass,
      "clearInternals" : true, // don't paste temprorary selection and other markings
      "unjoinNbsps" : true
    });

    return newHtml;
  };

})();;/**
 * IE and Opera leave an empty paragraph in the contentEditable element after clearing it
 *
 * @param {Object} contentEditableElement The contentEditable element to observe for clearing events
 * @exaple
 *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);
 */
wysihtml5.quirks.ensureProperClearing = (function() {
  var clearIfNecessary = function() {
    var element = this;
    setTimeout(function() {
      var innerHTML = element.innerHTML.toLowerCase();
      if (innerHTML == "<p>&nbsp;</p>" ||
          innerHTML == "<p>&nbsp;</p><p>&nbsp;</p>") {
        element.innerHTML = "";
      }
    }, 0);
  };

  return function(composer) {
    wysihtml5.dom.observe(composer.element, ["cut", "keydown"], clearIfNecessary);
  };
})();
;// See https://bugzilla.mozilla.org/show_bug.cgi?id=664398
//
// In Firefox this:
//      var d = document.createElement("div");
//      d.innerHTML ='<a href="~"></a>';
//      d.innerHTML;
// will result in:
//      <a href="%7E"></a>
// which is wrong
(function(wysihtml5) {
  var TILDE_ESCAPED = "%7E";
  wysihtml5.quirks.getCorrectInnerHTML = function(element) {
    var innerHTML = element.innerHTML;
    if (innerHTML.indexOf(TILDE_ESCAPED) === -1) {
      return innerHTML;
    }

    var elementsWithTilde = element.querySelectorAll("[href*='~'], [src*='~']"),
        url,
        urlToSearch,
        length,
        i;
    for (i=0, length=elementsWithTilde.length; i<length; i++) {
      url         = elementsWithTilde[i].href || elementsWithTilde[i].src;
      urlToSearch = wysihtml5.lang.string(url).replace("~").by(TILDE_ESCAPED);
      innerHTML   = wysihtml5.lang.string(innerHTML).replace(urlToSearch).by(url);
    }
    return innerHTML;
  };
})(wysihtml5);
;/**
 * Force rerendering of a given element
 * Needed to fix display misbehaviors of IE
 *
 * @param {Element} element The element object which needs to be rerendered
 * @example
 *    wysihtml5.quirks.redraw(document.body);
 */
(function(wysihtml5) {
  var CLASS_NAME = "wysihtml5-quirks-redraw";

  wysihtml5.quirks.redraw = function(element) {
    wysihtml5.dom.addClass(element, CLASS_NAME);
    wysihtml5.dom.removeClass(element, CLASS_NAME);

    // Following hack is needed for firefox to make sure that image resize handles are properly removed
    try {
      var doc = element.ownerDocument;
      doc.execCommand("italic", false, null);
      doc.execCommand("italic", false, null);
    } catch(e) {}
  };
})(wysihtml5);
;wysihtml5.quirks.tableCellsSelection = function(editable, editor) {

    var dom = wysihtml5.dom,
        select = {
            table: null,
            start: null,
            end: null,
            cells: null,
            select: selectCells
        },
        selection_class = "wysiwyg-tmp-selected-cell",
        moveHandler = null,
        upHandler = null;

    function init () {

        dom.observe(editable, "mousedown", function(event) {
          var target = wysihtml5.dom.getParentElement(event.target, { nodeName: ["TD", "TH"] });
          if (target) {
              handleSelectionMousedown(target);
          }
        });

        return select;
    }

    function handleSelectionMousedown (target) {
      select.start = target;
      select.end = target;
      select.cells = [target];
      select.table = dom.getParentElement(select.start, { nodeName: ["TABLE"] });

      if (select.table) {
        removeCellSelections();
        dom.addClass(target, selection_class);
        moveHandler = dom.observe(editable, "mousemove", handleMouseMove);
        upHandler = dom.observe(editable, "mouseup", handleMouseUp);
        editor.fire("tableselectstart").fire("tableselectstart:composer");
      }
    }

    // remove all selection classes
    function removeCellSelections () {
        if (editable) {
            var selectedCells = editable.querySelectorAll('.' + selection_class);
            if (selectedCells.length > 0) {
              for (var i = 0; i < selectedCells.length; i++) {
                  dom.removeClass(selectedCells[i], selection_class);
              }
            }
        }
    }

    function addSelections (cells) {
      for (var i = 0; i < cells.length; i++) {
        dom.addClass(cells[i], selection_class);
      }
    }

    function handleMouseMove (event) {
      var curTable = null,
          cell = dom.getParentElement(event.target, { nodeName: ["TD","TH"] }),
          oldEnd;

      if (cell && select.table && select.start) {
        curTable =  dom.getParentElement(cell, { nodeName: ["TABLE"] });
        if (curTable && curTable === select.table) {
          removeCellSelections();
          oldEnd = select.end;
          select.end = cell;
          select.cells = dom.table.getCellsBetween(select.start, cell);
          if (select.cells.length > 1) {
            editor.composer.selection.deselect();
          }
          addSelections(select.cells);
          if (select.end !== oldEnd) {
            editor.fire("tableselectchange").fire("tableselectchange:composer");
          }
        }
      }
    }

    function handleMouseUp (event) {
      moveHandler.stop();
      upHandler.stop();
      editor.fire("tableselect").fire("tableselect:composer");
      setTimeout(function() {
        bindSideclick();
      },0);
    }

    function bindSideclick () {
        var sideClickHandler = dom.observe(editable.ownerDocument, "click", function(event) {
          sideClickHandler.stop();
          if (dom.getParentElement(event.target, { nodeName: ["TABLE"] }) != select.table) {
              removeCellSelections();
              select.table = null;
              select.start = null;
              select.end = null;
              editor.fire("tableunselect").fire("tableunselect:composer");
          }
        });
    }

    function selectCells (start, end) {
        select.start = start;
        select.end = end;
        select.table = dom.getParentElement(select.start, { nodeName: ["TABLE"] });
        selectedCells = dom.table.getCellsBetween(select.start, select.end);
        addSelections(selectedCells);
        bindSideclick();
        editor.fire("tableselect").fire("tableselect:composer");
    }

    return init();

};
;(function(wysihtml5) {
  var RGBA_REGEX     = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([\d\.]+)\s*\)/i,
      RGB_REGEX      = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/i,
      HEX6_REGEX     = /^#([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])/i,
      HEX3_REGEX     = /^#([0-9a-f])([0-9a-f])([0-9a-f])/i;

  var param_REGX = function (p) {
    return new RegExp("(^|\\s|;)" + p + "\\s*:\\s*[^;$]+" , "gi");
  };

  wysihtml5.quirks.styleParser = {

    parseColor: function(stylesStr, paramName) {
      var paramRegex = param_REGX(paramName),
          params = stylesStr.match(paramRegex),
          radix = 10,
          str, colorMatch;

      if (params) {
        for (var i = params.length; i--;) {
          params[i] = wysihtml5.lang.string(params[i].split(':')[1]).trim();
        }
        str = params[params.length-1];

        if (RGBA_REGEX.test(str)) {
          colorMatch = str.match(RGBA_REGEX);
        } else if (RGB_REGEX.test(str)) {
          colorMatch = str.match(RGB_REGEX);
        } else if (HEX6_REGEX.test(str)) {
          colorMatch = str.match(HEX6_REGEX);
          radix = 16;
        } else if (HEX3_REGEX.test(str)) {
          colorMatch = str.match(HEX3_REGEX);
          colorMatch.shift();
          colorMatch.push(1);
          return wysihtml5.lang.array(colorMatch).map(function(d, idx) {
            return (idx < 3) ? (parseInt(d, 16) * 16) + parseInt(d, 16): parseFloat(d);
          });
        }

        if (colorMatch) {
          colorMatch.shift();
          if (!colorMatch[3]) {
            colorMatch.push(1);
          }
          return wysihtml5.lang.array(colorMatch).map(function(d, idx) {
            return (idx < 3) ? parseInt(d, radix): parseFloat(d);
          });
        }
      }
      return false;
    },

    unparseColor: function(val, props) {
      if (props) {
        if (props == "hex") {
          return (val[0].toString(16).toUpperCase()) + (val[1].toString(16).toUpperCase()) + (val[2].toString(16).toUpperCase());
        } else if (props == "hash") {
          return "#" + (val[0].toString(16).toUpperCase()) + (val[1].toString(16).toUpperCase()) + (val[2].toString(16).toUpperCase());
        } else if (props == "rgb") {
          return "rgb(" + val[0] + "," + val[1] + "," + val[2] + ")";
        } else if (props == "rgba") {
          return "rgba(" + val[0] + "," + val[1] + "," + val[2] + "," + val[3] + ")";
        } else if (props == "csv") {
          return  val[0] + "," + val[1] + "," + val[2] + "," + val[3];
        }
      }

      if (val[3] && val[3] !== 1) {
        return "rgba(" + val[0] + "," + val[1] + "," + val[2] + "," + val[3] + ")";
      } else {
        return "rgb(" + val[0] + "," + val[1] + "," + val[2] + ")";
      }
    },

    parseFontSize: function(stylesStr) {
      var params = stylesStr.match(param_REGX('font-size'));
      if (params) {
        return wysihtml5.lang.string(params[params.length - 1].split(':')[1]).trim();
      }
      return false;
    }
  };

})(wysihtml5);
;/**
 * Selection API
 *
 * @example
 *    var selection = new wysihtml5.Selection(editor);
 */
(function(wysihtml5) {
  var dom = wysihtml5.dom;

  function _getCumulativeOffsetTop(element) {
    var top = 0;
    if (element.parentNode) {
      do {
        top += element.offsetTop || 0;
        element = element.offsetParent;
      } while (element);
    }
    return top;
  }

  // Provides the depth of ``descendant`` relative to ``ancestor``
  function getDepth(ancestor, descendant) {
      var ret = 0;
      while (descendant !== ancestor) {
          ret++;
          descendant = descendant.parentNode;
          if (!descendant)
              throw new Error("not a descendant of ancestor!");
      }
      return ret;
  }

  // Should fix the obtained ranges that cannot surrond contents normally to apply changes upon
  // Being considerate to firefox that sets range start start out of span and end inside on doubleclick initiated selection
  function expandRangeToSurround(range) {
      if (range.canSurroundContents()) return;

      var common = range.commonAncestorContainer,
          start_depth = getDepth(common, range.startContainer),
          end_depth = getDepth(common, range.endContainer);

      while(!range.canSurroundContents()) {
        // In the following branches, we cannot just decrement the depth variables because the setStartBefore/setEndAfter may move the start or end of the range more than one level relative to ``common``. So we need to recompute the depth.
        if (start_depth > end_depth) {
            range.setStartBefore(range.startContainer);
            start_depth = getDepth(common, range.startContainer);
        }
        else {
            range.setEndAfter(range.endContainer);
            end_depth = getDepth(common, range.endContainer);
        }
      }
  }

  wysihtml5.Selection = Base.extend(
    /** @scope wysihtml5.Selection.prototype */ {
    constructor: function(editor, contain, unselectableClass) {
      // Make sure that our external range library is initialized
      window.rangy.init();

      this.editor   = editor;
      this.composer = editor.composer;
      this.doc      = this.composer.doc;
      this.contain = contain;
      this.unselectableClass = unselectableClass || false;
    },

    /**
     * Get the current selection as a bookmark to be able to later restore it
     *
     * @return {Object} An object that represents the current selection
     */
    getBookmark: function() {
      var range = this.getRange();
      if (range) expandRangeToSurround(range);
      return range && range.cloneRange();
    },

    /**
     * Restore a selection retrieved via wysihtml5.Selection.prototype.getBookmark
     *
     * @param {Object} bookmark An object that represents the current selection
     */
    setBookmark: function(bookmark) {
      if (!bookmark) {
        return;
      }

      this.setSelection(bookmark);
    },

    /**
     * Set the caret in front of the given node
     *
     * @param {Object} node The element or text node where to position the caret in front of
     * @example
     *    selection.setBefore(myElement);
     */
    setBefore: function(node) {
      var range = rangy.createRange(this.doc);
      range.setStartBefore(node);
      range.setEndBefore(node);
      return this.setSelection(range);
    },

    /**
     * Set the caret after the given node
     *
     * @param {Object} node The element or text node where to position the caret in front of
     * @example
     *    selection.setBefore(myElement);
     */
    setAfter: function(node) {
      var range = rangy.createRange(this.doc);

      range.setStartAfter(node);
      range.setEndAfter(node);
      return this.setSelection(range);
    },

    /**
     * Ability to select/mark nodes
     *
     * @param {Element} node The node/element to select
     * @example
     *    selection.selectNode(document.getElementById("my-image"));
     */
    selectNode: function(node, avoidInvisibleSpace) {
      var range           = rangy.createRange(this.doc),
          isElement       = node.nodeType === wysihtml5.ELEMENT_NODE,
          canHaveHTML     = "canHaveHTML" in node ? node.canHaveHTML : (node.nodeName !== "IMG"),
          content         = isElement ? node.innerHTML : node.data,
          isEmpty         = (content === "" || content === wysihtml5.INVISIBLE_SPACE),
          displayStyle    = dom.getStyle("display").from(node),
          isBlockElement  = (displayStyle === "block" || displayStyle === "list-item");

      if (isEmpty && isElement && canHaveHTML && !avoidInvisibleSpace) {
        // Make sure that caret is visible in node by inserting a zero width no breaking space
        try { node.innerHTML = wysihtml5.INVISIBLE_SPACE; } catch(e) {}
      }

      if (canHaveHTML) {
        range.selectNodeContents(node);
      } else {
        range.selectNode(node);
      }

      if (canHaveHTML && isEmpty && isElement) {
        range.collapse(isBlockElement);
      } else if (canHaveHTML && isEmpty) {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }

      this.setSelection(range);
    },

    /**
     * Get the node which contains the selection
     *
     * @param {Boolean} [controlRange] (only IE) Whether it should return the selected ControlRange element when the selection type is a "ControlRange"
     * @return {Object} The node that contains the caret
     * @example
     *    var nodeThatContainsCaret = selection.getSelectedNode();
     */
    getSelectedNode: function(controlRange) {
      var selection,
          range;

      if (controlRange && this.doc.selection && this.doc.selection.type === "Control") {
        range = this.doc.selection.createRange();
        if (range && range.length) {
          return range.item(0);
        }
      }

      selection = this.getSelection(this.doc);
      if (selection.focusNode === selection.anchorNode) {
        return selection.focusNode;
      } else {
        range = this.getRange(this.doc);
        return range ? range.commonAncestorContainer : this.doc.body;
      }
    },

    fixSelBorders: function() {
      var range = this.getRange();
      expandRangeToSurround(range);
      this.setSelection(range);
    },

    getSelectedOwnNodes: function(controlRange) {
      var selection,
          ranges = this.getOwnRanges(),
          ownNodes = [];

      for (var i = 0, maxi = ranges.length; i < maxi; i++) {
          ownNodes.push(ranges[i].commonAncestorContainer || this.doc.body);
      }
      return ownNodes;
    },

    findNodesInSelection: function(nodeTypes) {
      var ranges = this.getOwnRanges(),
          nodes = [], curNodes;
      for (var i = 0, maxi = ranges.length; i < maxi; i++) {
        curNodes = ranges[i].getNodes([1], function(node) {
            return wysihtml5.lang.array(nodeTypes).contains(node.nodeName);
        });
        nodes = nodes.concat(curNodes);
      }
      return nodes;
    },

    containsUneditable: function() {
      var uneditables = this.getOwnUneditables(),
          selection = this.getSelection();

      for (var i = 0, maxi = uneditables.length; i < maxi; i++) {
        if (selection.containsNode(uneditables[i])) {
          return true;
        }
      }

      return false;
    },

    deleteContents: function()  {
      var ranges = this.getOwnRanges();
      for (var i = ranges.length; i--;) {
        ranges[i].deleteContents();
      }
      this.setSelection(ranges[0]);
    },

    getPreviousNode: function(node, ignoreEmpty) {
      if (!node) {
        var selection = this.getSelection();
        node = selection.anchorNode;
      }

      if (node === this.contain) {
          return false;
      }

      var ret = node.previousSibling,
          parent;

      if (ret === this.contain) {
          return false;
      }

      if (ret && ret.nodeType !== 3 && ret.nodeType !== 1) {
         // do not count comments and other node types
         ret = this.getPreviousNode(ret, ignoreEmpty);
      } else if (ret && ret.nodeType === 3 && (/^\s*$/).test(ret.textContent)) {
        // do not count empty textnodes as previus nodes
        ret = this.getPreviousNode(ret, ignoreEmpty);
      } else if (ignoreEmpty && ret && ret.nodeType === 1 && !wysihtml5.lang.array(["BR", "HR", "IMG"]).contains(ret.nodeName) && (/^[\s]*$/).test(ret.innerHTML)) {
        // Do not count empty nodes if param set.
        // Contenteditable tends to bypass and delete these silently when deleting with caret
        ret = this.getPreviousNode(ret, ignoreEmpty);
      } else if (!ret && node !== this.contain) {
        parent = node.parentNode;
        if (parent !== this.contain) {
            ret = this.getPreviousNode(parent, ignoreEmpty);
        }
      }

      return (ret !== this.contain) ? ret : false;
    },

    getSelectionParentsByTag: function(tagName) {
      var nodes = this.getSelectedOwnNodes(),
          curEl, parents = [];

      for (var i = 0, maxi = nodes.length; i < maxi; i++) {
        curEl = (nodes[i].nodeName &&  nodes[i].nodeName === 'LI') ? nodes[i] : wysihtml5.dom.getParentElement(nodes[i], { nodeName: ['LI']}, false, this.contain);
        if (curEl) {
          parents.push(curEl);
        }
      }
      return (parents.length) ? parents : null;
    },

    getRangeToNodeEnd: function() {
      if (this.isCollapsed()) {
        var range = this.getRange(),
            sNode = range.startContainer,
            pos = range.startOffset,
            lastR = rangy.createRange(this.doc);

        lastR.selectNodeContents(sNode);
        lastR.setStart(sNode, pos);
        return lastR;
      }
    },

    caretIsLastInSelection: function() {
      var r = rangy.createRange(this.doc),
          s = this.getSelection(),
          endc = this.getRangeToNodeEnd().cloneContents(),
          endtxt = endc.textContent;

      return (/^\s*$/).test(endtxt);
    },

    caretIsFirstInSelection: function() {
      var r = rangy.createRange(this.doc),
          s = this.getSelection(),
          range = this.getRange(),
          startNode = range.startContainer;
      
      if (startNode.nodeType === wysihtml5.TEXT_NODE) {
        return this.isCollapsed() && (startNode.nodeType === wysihtml5.TEXT_NODE && (/^\s*$/).test(startNode.data.substr(0,range.startOffset)));
      } else {
        r.selectNodeContents(this.getRange().commonAncestorContainer);
        r.collapse(true);
        return (this.isCollapsed() && (r.startContainer === s.anchorNode || r.endContainer === s.anchorNode) && r.startOffset === s.anchorOffset);
      }
    },

    caretIsInTheBeginnig: function(ofNode) {
        var selection = this.getSelection(),
            node = selection.anchorNode,
            offset = selection.anchorOffset;
        if (ofNode) {
          return (offset === 0 && (node.nodeName && node.nodeName === ofNode.toUpperCase() || wysihtml5.dom.getParentElement(node.parentNode, { nodeName: ofNode }, 1)));
        } else {
          return (offset === 0 && !this.getPreviousNode(node, true));
        }
    },

    caretIsBeforeUneditable: function() {
      var selection = this.getSelection(),
          node = selection.anchorNode,
          offset = selection.anchorOffset;

      if (offset === 0) {
        var prevNode = this.getPreviousNode(node, true);
        if (prevNode) {
          var uneditables = this.getOwnUneditables();
          for (var i = 0, maxi = uneditables.length; i < maxi; i++) {
            if (prevNode === uneditables[i]) {
              return uneditables[i];
            }
          }
        }
      }
      return false;
    },

    // TODO: Figure out a method from following 2 that would work universally
    executeAndRestoreRangy: function(method, restoreScrollPosition) {
      var win = this.doc.defaultView || this.doc.parentWindow,
          sel = rangy.saveSelection(win);

      if (!sel) {
        method();
      } else {
        try {
          method();
        } catch(e) {
          setTimeout(function() { throw e; }, 0);
        }
      }
      rangy.restoreSelection(sel);
    },

    // TODO: has problems in chrome 12. investigate block level and uneditable area inbetween
    executeAndRestore: function(method, restoreScrollPosition) {
      var body                  = this.doc.body,
          oldScrollTop          = restoreScrollPosition && body.scrollTop,
          oldScrollLeft         = restoreScrollPosition && body.scrollLeft,
          className             = "_wysihtml5-temp-placeholder",
          placeholderHtml       = '<span class="' + className + '">' + wysihtml5.INVISIBLE_SPACE + '</span>',
          range                 = this.getRange(true),
          caretPlaceholder,
          newCaretPlaceholder,
          nextSibling, prevSibling,
          node, node2, range2,
          newRange;

      // Nothing selected, execute and say goodbye
      if (!range) {
        method(body, body);
        return;
      }

      if (!range.collapsed) {
        range2 = range.cloneRange();
        node2 = range2.createContextualFragment(placeholderHtml);
        range2.collapse(false);
        range2.insertNode(node2);
        range2.detach();
      }

      node = range.createContextualFragment(placeholderHtml);
      range.insertNode(node);

      if (node2) {
        caretPlaceholder = this.contain.querySelectorAll("." + className);
        range.setStartBefore(caretPlaceholder[0]);
        range.setEndAfter(caretPlaceholder[caretPlaceholder.length -1]);
      }
      this.setSelection(range);

      // Make sure that a potential error doesn't cause our placeholder element to be left as a placeholder
      try {
        method(range.startContainer, range.endContainer);
      } catch(e) {
        setTimeout(function() { throw e; }, 0);
      }
      caretPlaceholder = this.contain.querySelectorAll("." + className);
      if (caretPlaceholder && caretPlaceholder.length) {
        newRange = rangy.createRange(this.doc);
        nextSibling = caretPlaceholder[0].nextSibling;
        if (caretPlaceholder.length > 1) {
          prevSibling = caretPlaceholder[caretPlaceholder.length -1].previousSibling;
        }
        if (prevSibling && nextSibling) {
          newRange.setStartBefore(nextSibling);
          newRange.setEndAfter(prevSibling);
        } else {
          newCaretPlaceholder = this.doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
          dom.insert(newCaretPlaceholder).after(caretPlaceholder[0]);
          newRange.setStartBefore(newCaretPlaceholder);
          newRange.setEndAfter(newCaretPlaceholder);
        }
        this.setSelection(newRange);
        for (var i = caretPlaceholder.length; i--;) {
         caretPlaceholder[i].parentNode.removeChild(caretPlaceholder[i]);
        }

      } else {
        // fallback for when all hell breaks loose
        this.contain.focus();
      }

      if (restoreScrollPosition) {
        body.scrollTop  = oldScrollTop;
        body.scrollLeft = oldScrollLeft;
      }

      // Remove it again, just to make sure that the placeholder is definitely out of the dom tree
      try {
        caretPlaceholder.parentNode.removeChild(caretPlaceholder);
      } catch(e2) {}
    },

    set: function(node, offset) {
      var newRange = rangy.createRange(this.doc);
      newRange.setStart(node, offset || 0);
      this.setSelection(newRange);
    },

    /**
     * Insert html at the caret position and move the cursor after the inserted html
     *
     * @param {String} html HTML string to insert
     * @example
     *    selection.insertHTML("<p>foobar</p>");
     */
    insertHTML: function(html) {
      var range     = rangy.createRange(this.doc),
          node = this.doc.createElement('DIV'),
          fragment = this.doc.createDocumentFragment(),
          lastChild;

      node.innerHTML = html;
      lastChild = node.lastChild;

      while (node.firstChild) {
        fragment.appendChild(node.firstChild);
      }
      this.insertNode(fragment);

      if (lastChild) {
        this.setAfter(lastChild);
      }
    },

    /**
     * Insert a node at the caret position and move the cursor behind it
     *
     * @param {Object} node HTML string to insert
     * @example
     *    selection.insertNode(document.createTextNode("foobar"));
     */
    insertNode: function(node) {
      var range = this.getRange();
      if (range) {
        range.insertNode(node);
      }
    },

    /**
     * Wraps current selection with the given node
     *
     * @param {Object} node The node to surround the selected elements with
     */
    surround: function(nodeOptions) {
      var ranges = this.getOwnRanges(),
          node, nodes = [];
      if (ranges.length == 0) {
        return nodes;
      }

      for (var i = ranges.length; i--;) {
        node = this.doc.createElement(nodeOptions.nodeName);
        nodes.push(node);
        if (nodeOptions.className) {
          node.className = nodeOptions.className;
        }
        if (nodeOptions.cssStyle) {
          node.setAttribute('style', nodeOptions.cssStyle);
        }
        try {
          // This only works when the range boundaries are not overlapping other elements
          ranges[i].surroundContents(node);
          this.selectNode(node);
        } catch(e) {
          // fallback
          node.appendChild(ranges[i].extractContents());
          ranges[i].insertNode(node);
        }
      }
      return nodes;
    },

    deblockAndSurround: function(nodeOptions) {
      var tempElement = this.doc.createElement('div'),
          range = rangy.createRange(this.doc),
          tempDivElements,
          tempElements,
          firstChild;

      tempElement.className = nodeOptions.className;

      this.composer.commands.exec("formatBlock", nodeOptions.nodeName, nodeOptions.className);
      tempDivElements = this.contain.querySelectorAll("." + nodeOptions.className);
      if (tempDivElements[0]) {
        tempDivElements[0].parentNode.insertBefore(tempElement, tempDivElements[0]);

        range.setStartBefore(tempDivElements[0]);
        range.setEndAfter(tempDivElements[tempDivElements.length - 1]);
        tempElements = range.extractContents();

        while (tempElements.firstChild) {
          firstChild = tempElements.firstChild;
          if (firstChild.nodeType == 1 && wysihtml5.dom.hasClass(firstChild, nodeOptions.className)) {
            while (firstChild.firstChild) {
              tempElement.appendChild(firstChild.firstChild);
            }
            if (firstChild.nodeName !== "BR") { tempElement.appendChild(this.doc.createElement('br')); }
            tempElements.removeChild(firstChild);
          } else {
            tempElement.appendChild(firstChild);
          }
        }
      } else {
        tempElement = null;
      }

      return tempElement;
    },

    /**
     * Scroll the current caret position into the view
     * FIXME: This is a bit hacky, there might be a smarter way of doing this
     *
     * @example
     *    selection.scrollIntoView();
     */
    scrollIntoView: function() {
      var doc           = this.doc,
          tolerance     = 5, // px
          hasScrollBars = doc.documentElement.scrollHeight > doc.documentElement.offsetHeight,
          tempElement   = doc._wysihtml5ScrollIntoViewElement = doc._wysihtml5ScrollIntoViewElement || (function() {
            var element = doc.createElement("span");
            // The element needs content in order to be able to calculate it's position properly
            element.innerHTML = wysihtml5.INVISIBLE_SPACE;
            return element;
          })(),
          offsetTop;

      if (hasScrollBars) {
        this.insertNode(tempElement);
        offsetTop = _getCumulativeOffsetTop(tempElement);
        tempElement.parentNode.removeChild(tempElement);
        if (offsetTop >= (doc.body.scrollTop + doc.documentElement.offsetHeight - tolerance)) {
          doc.body.scrollTop = offsetTop;
        }
      }
    },

    /**
     * Select line where the caret is in
     */
    selectLine: function() {
      if (wysihtml5.browser.supportsSelectionModify()) {
        this._selectLine_W3C();
      } else if (this.doc.selection) {
        this._selectLine_MSIE();
      }
    },

    /**
     * See https://developer.mozilla.org/en/DOM/Selection/modify
     */
    _selectLine_W3C: function() {
      var win       = this.doc.defaultView,
          selection = win.getSelection();
      selection.modify("move", "left", "lineboundary");
      selection.modify("extend", "right", "lineboundary");
    },

    _selectLine_MSIE: function() {
      var range       = this.doc.selection.createRange(),
          rangeTop    = range.boundingTop,
          scrollWidth = this.doc.body.scrollWidth,
          rangeBottom,
          rangeEnd,
          measureNode,
          i,
          j;

      if (!range.moveToPoint) {
        return;
      }

      if (rangeTop === 0) {
        // Don't know why, but when the selection ends at the end of a line
        // range.boundingTop is 0
        measureNode = this.doc.createElement("span");
        this.insertNode(measureNode);
        rangeTop = measureNode.offsetTop;
        measureNode.parentNode.removeChild(measureNode);
      }

      rangeTop += 1;

      for (i=-10; i<scrollWidth; i+=2) {
        try {
          range.moveToPoint(i, rangeTop);
          break;
        } catch(e1) {}
      }

      // Investigate the following in order to handle multi line selections
      // rangeBottom = rangeTop + (rangeHeight ? (rangeHeight - 1) : 0);
      rangeBottom = rangeTop;
      rangeEnd = this.doc.selection.createRange();
      for (j=scrollWidth; j>=0; j--) {
        try {
          rangeEnd.moveToPoint(j, rangeBottom);
          break;
        } catch(e2) {}
      }

      range.setEndPoint("EndToEnd", rangeEnd);
      range.select();
    },

    getText: function() {
      var selection = this.getSelection();
      return selection ? selection.toString() : "";
    },

    getNodes: function(nodeType, filter) {
      var range = this.getRange();
      if (range) {
        return range.getNodes([nodeType], filter);
      } else {
        return [];
      }
    },

    fixRangeOverflow: function(range) {
      if (this.contain && this.contain.firstChild && range) {
        var containment = range.compareNode(this.contain);
        if (containment !== 2) {
          if (containment === 1) {
            range.setStartBefore(this.contain.firstChild);
          }
          if (containment === 0) {
            range.setEndAfter(this.contain.lastChild);
          }
          if (containment === 3) {
            range.setStartBefore(this.contain.firstChild);
            range.setEndAfter(this.contain.lastChild);
          }
        } else if (this._detectInlineRangeProblems(range)) {
          var previousElementSibling = range.endContainer.previousElementSibling;
          if (previousElementSibling) {
            range.setEnd(previousElementSibling, this._endOffsetForNode(previousElementSibling));
          }
        }
      }
    },

    _endOffsetForNode: function(node) {
      var range = document.createRange();
      range.selectNodeContents(node);
      return range.endOffset;
    },

    _detectInlineRangeProblems: function(range) {
      var position = dom.compareDocumentPosition(range.startContainer, range.endContainer);
      return (
        range.endOffset == 0 &&
        position & 4 //Node.DOCUMENT_POSITION_FOLLOWING
      );
    },

    getRange: function(dontFix) {
      var selection = this.getSelection(),
          range = selection && selection.rangeCount && selection.getRangeAt(0);

      if (dontFix !== true) {
        this.fixRangeOverflow(range);
      }

      return range;
    },

    getOwnUneditables: function() {
      var allUneditables = dom.query(this.contain, '.' + this.unselectableClass),
          deepUneditables = dom.query(allUneditables, '.' + this.unselectableClass);

      return wysihtml5.lang.array(allUneditables).without(deepUneditables);
    },

    // Returns an array of ranges that belong only to this editable
    // Needed as uneditable block in contenteditabel can split range into pieces
    // If manipulating content reverse loop is usually needed as manipulation can shift subsequent ranges
    getOwnRanges: function()  {
      var ranges = [],
          r = this.getRange(),
          tmpRanges;

      if (r) { ranges.push(r); }

      if (this.unselectableClass && this.contain && r) {
          var uneditables = this.getOwnUneditables(),
              tmpRange;
          if (uneditables.length > 0) {
            for (var i = 0, imax = uneditables.length; i < imax; i++) {
              tmpRanges = [];
              for (var j = 0, jmax = ranges.length; j < jmax; j++) {
                if (ranges[j]) {
                  switch (ranges[j].compareNode(uneditables[i])) {
                    case 2:
                      // all selection inside uneditable. remove
                    break;
                    case 3:
                      //section begins before and ends after uneditable. spilt
                      tmpRange = ranges[j].cloneRange();
                      tmpRange.setEndBefore(uneditables[i]);
                      tmpRanges.push(tmpRange);

                      tmpRange = ranges[j].cloneRange();
                      tmpRange.setStartAfter(uneditables[i]);
                      tmpRanges.push(tmpRange);
                    break;
                    default:
                      // in all other cases uneditable does not touch selection. dont modify
                      tmpRanges.push(ranges[j]);
                  }
                }
                ranges = tmpRanges;
              }
            }
          }
      }
      return ranges;
    },

    getSelection: function() {
      return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow);
    },

    setSelection: function(range) {
      var win       = this.doc.defaultView || this.doc.parentWindow,
          selection = rangy.getSelection(win);
      return selection.setSingleRange(range);
    },

    createRange: function() {
      return rangy.createRange(this.doc);
    },

    isCollapsed: function() {
        return this.getSelection().isCollapsed;
    },

    getHtml: function() {
      return this.getSelection().toHtml();
    },

    isEndToEndInNode: function(nodeNames) {
      var range = this.getRange(),
          parentElement = range.commonAncestorContainer,
          startNode = range.startContainer,
          endNode = range.endContainer;


        if (parentElement.nodeType === wysihtml5.TEXT_NODE) {
          parentElement = parentElement.parentNode;
        }

        if (startNode.nodeType === wysihtml5.TEXT_NODE && !(/^\s*$/).test(startNode.data.substr(range.startOffset))) {
          return false;
        }

        if (endNode.nodeType === wysihtml5.TEXT_NODE && !(/^\s*$/).test(endNode.data.substr(range.endOffset))) {
          return false;
        }

        while (startNode && startNode !== parentElement) {
          if (startNode.nodeType !== wysihtml5.TEXT_NODE && !wysihtml5.dom.contains(parentElement, startNode)) {
            return false;
          }
          if (wysihtml5.dom.domNode(startNode).prev({ignoreBlankTexts: true})) {
            return false;
          }
          startNode = startNode.parentNode;
        }

        while (endNode && endNode !== parentElement) {
          if (endNode.nodeType !== wysihtml5.TEXT_NODE && !wysihtml5.dom.contains(parentElement, endNode)) {
            return false;
          }
          if (wysihtml5.dom.domNode(endNode).next({ignoreBlankTexts: true})) {
            return false;
          }
          endNode = endNode.parentNode;
        }

        return (wysihtml5.lang.array(nodeNames).contains(parentElement.nodeName)) ? parentElement : false;
    },

    deselect: function() {
      var sel = this.getSelection();
      sel && sel.removeAllRanges();
    }
  });

})(wysihtml5);
;/**
 * Inspired by the rangy CSS Applier module written by Tim Down and licensed under the MIT license.
 * http://code.google.com/p/rangy/
 *
 * changed in order to be able ...
 *    - to use custom tags
 *    - to detect and replace similar css classes via reg exp
 */
(function(wysihtml5, rangy) {
  var defaultTagName = "span";

  var REG_EXP_WHITE_SPACE = /\s+/g;

  function hasClass(el, cssClass, regExp) {
    if (!el.className) {
      return false;
    }

    var matchingClassNames = el.className.match(regExp) || [];
    return matchingClassNames[matchingClassNames.length - 1] === cssClass;
  }

  function hasStyleAttr(el, regExp) {
    if (!el.getAttribute || !el.getAttribute('style')) {
      return false;
    }
    var matchingStyles = el.getAttribute('style').match(regExp);
    return  (el.getAttribute('style').match(regExp)) ? true : false;
  }

  function addStyle(el, cssStyle, regExp) {
    if (el.getAttribute('style')) {
      removeStyle(el, regExp);
      if (el.getAttribute('style') && !(/^\s*$/).test(el.getAttribute('style'))) {
        el.setAttribute('style', cssStyle + ";" + el.getAttribute('style'));
      } else {
        el.setAttribute('style', cssStyle);
      }
    } else {
      el.setAttribute('style', cssStyle);
    }
  }

  function addClass(el, cssClass, regExp) {
    if (el.className) {
      removeClass(el, regExp);
      el.className += " " + cssClass;
    } else {
      el.className = cssClass;
    }
  }

  function removeClass(el, regExp) {
    if (el.className) {
      el.className = el.className.replace(regExp, "");
    }
  }

  function removeStyle(el, regExp) {
    var s,
        s2 = [];
    if (el.getAttribute('style')) {
      s = el.getAttribute('style').split(';');
      for (var i = s.length; i--;) {
        if (!s[i].match(regExp) && !(/^\s*$/).test(s[i])) {
          s2.push(s[i]);
        }
      }
      if (s2.length) {
        el.setAttribute('style', s2.join(';'));
      } else {
        el.removeAttribute('style');
      }
    }
  }

  function getMatchingStyleRegexp(el, style) {
    var regexes = [],
        sSplit = style.split(';'),
        elStyle = el.getAttribute('style');

    if (elStyle) {
      elStyle = elStyle.replace(/\s/gi, '').toLowerCase();
      regexes.push(new RegExp("(^|\\s|;)" + style.replace(/\s/gi, '').replace(/([\(\)])/gi, "\\$1").toLowerCase().replace(";", ";?").replace(/rgb\\\((\d+),(\d+),(\d+)\\\)/gi, "\\s?rgb\\($1,\\s?$2,\\s?$3\\)"), "gi"));

      for (var i = sSplit.length; i-- > 0;) {
        if (!(/^\s*$/).test(sSplit[i])) {
          regexes.push(new RegExp("(^|\\s|;)" + sSplit[i].replace(/\s/gi, '').replace(/([\(\)])/gi, "\\$1").toLowerCase().replace(";", ";?").replace(/rgb\\\((\d+),(\d+),(\d+)\\\)/gi, "\\s?rgb\\($1,\\s?$2,\\s?$3\\)"), "gi"));
        }
      }
      for (var j = 0, jmax = regexes.length; j < jmax; j++) {
        if (elStyle.match(regexes[j])) {
          return regexes[j];
        }
      }
    }

    return false;
  }

  function isMatchingAllready(node, tags, style, className) {
    if (style) {
      return getMatchingStyleRegexp(node, style);
    } else if (className) {
      return wysihtml5.dom.hasClass(node, className);
    } else {
      return rangy.dom.arrayContains(tags, node.tagName.toLowerCase());
    }
  }

  function areMatchingAllready(nodes, tags, style, className) {
    for (var i = nodes.length; i--;) {
      if (!isMatchingAllready(nodes[i], tags, style, className)) {
        return false;
      }
    }
    return nodes.length ? true : false;
  }

  function removeOrChangeStyle(el, style, regExp) {

    var exactRegex = getMatchingStyleRegexp(el, style);
    if (exactRegex) {
      // adding same style value on property again removes style
      removeStyle(el, exactRegex);
      return "remove";
    } else {
      // adding new style value changes value
      addStyle(el, style, regExp);
      return "change";
    }
  }

  function hasSameClasses(el1, el2) {
    return el1.className.replace(REG_EXP_WHITE_SPACE, " ") == el2.className.replace(REG_EXP_WHITE_SPACE, " ");
  }

  function replaceWithOwnChildren(el) {
    var parent = el.parentNode;
    while (el.firstChild) {
      parent.insertBefore(el.firstChild, el);
    }
    parent.removeChild(el);
  }

  function elementsHaveSameNonClassAttributes(el1, el2) {
    if (el1.attributes.length != el2.attributes.length) {
      return false;
    }
    for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {
      attr1 = el1.attributes[i];
      name = attr1.name;
      if (name != "class") {
        attr2 = el2.attributes.getNamedItem(name);
        if (attr1.specified != attr2.specified) {
          return false;
        }
        if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) {
          return false;
        }
      }
    }
    return true;
  }

  function isSplitPoint(node, offset) {
    if (rangy.dom.isCharacterDataNode(node)) {
      if (offset == 0) {
        return !!node.previousSibling;
      } else if (offset == node.length) {
        return !!node.nextSibling;
      } else {
        return true;
      }
    }

    return offset > 0 && offset < node.childNodes.length;
  }

  function splitNodeAt(node, descendantNode, descendantOffset, container) {
    var newNode;
    if (rangy.dom.isCharacterDataNode(descendantNode)) {
      if (descendantOffset == 0) {
        descendantOffset = rangy.dom.getNodeIndex(descendantNode);
        descendantNode = descendantNode.parentNode;
      } else if (descendantOffset == descendantNode.length) {
        descendantOffset = rangy.dom.getNodeIndex(descendantNode) + 1;
        descendantNode = descendantNode.parentNode;
      } else {
        newNode = rangy.dom.splitDataNode(descendantNode, descendantOffset);
      }
    }
    if (!newNode) {
      if (!container || descendantNode !== container) {

        newNode = descendantNode.cloneNode(false);
        if (newNode.id) {
          newNode.removeAttribute("id");
        }
        var child;
        while ((child = descendantNode.childNodes[descendantOffset])) {
          newNode.appendChild(child);
        }
        rangy.dom.insertAfter(newNode, descendantNode);

      }
    }
    return (descendantNode == node) ? newNode :  splitNodeAt(node, newNode.parentNode, rangy.dom.getNodeIndex(newNode), container);
  }

  function Merge(firstNode) {
    this.isElementMerge = (firstNode.nodeType == wysihtml5.ELEMENT_NODE);
    this.firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;
    this.textNodes = [this.firstTextNode];
  }

  Merge.prototype = {
    doMerge: function() {
      var textBits = [], textNode, parent, text;
      for (var i = 0, len = this.textNodes.length; i < len; ++i) {
        textNode = this.textNodes[i];
        parent = textNode.parentNode;
        textBits[i] = textNode.data;
        if (i) {
          parent.removeChild(textNode);
          if (!parent.hasChildNodes()) {
            parent.parentNode.removeChild(parent);
          }
        }
      }
      this.firstTextNode.data = text = textBits.join("");
      return text;
    },

    getLength: function() {
      var i = this.textNodes.length, len = 0;
      while (i--) {
        len += this.textNodes[i].length;
      }
      return len;
    },

    toString: function() {
      var textBits = [];
      for (var i = 0, len = this.textNodes.length; i < len; ++i) {
        textBits[i] = "'" + this.textNodes[i].data + "'";
      }
      return "[Merge(" + textBits.join(",") + ")]";
    }
  };

  function HTMLApplier(tagNames, cssClass, similarClassRegExp, normalize, cssStyle, similarStyleRegExp, container) {
    this.tagNames = tagNames || [defaultTagName];
    this.cssClass = cssClass || ((cssClass === false) ? false : "");
    this.similarClassRegExp = similarClassRegExp;
    this.cssStyle = cssStyle || "";
    this.similarStyleRegExp = similarStyleRegExp;
    this.normalize = normalize;
    this.applyToAnyTagName = false;
    this.container = container;
  }

  HTMLApplier.prototype = {
    getAncestorWithClass: function(node) {
      var cssClassMatch;
      while (node) {
        cssClassMatch = this.cssClass ? hasClass(node, this.cssClass, this.similarClassRegExp) : (this.cssStyle !== "") ? false : true;
        if (node.nodeType == wysihtml5.ELEMENT_NODE && node.getAttribute("contenteditable") != "false" &&  rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssClassMatch) {
          return node;
        }
        node = node.parentNode;
      }
      return false;
    },

    // returns parents of node with given style attribute
    getAncestorWithStyle: function(node) {
      var cssStyleMatch;
      while (node) {
        cssStyleMatch = this.cssStyle ? hasStyleAttr(node, this.similarStyleRegExp) : false;

        if (node.nodeType == wysihtml5.ELEMENT_NODE && node.getAttribute("contenteditable") != "false" && rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssStyleMatch) {
          return node;
        }
        node = node.parentNode;
      }
      return false;
    },

    getMatchingAncestor: function(node) {
      var ancestor = this.getAncestorWithClass(node),
          matchType = false;

      if (!ancestor) {
        ancestor = this.getAncestorWithStyle(node);
        if (ancestor) {
          matchType = "style";
        }
      } else {
        if (this.cssStyle) {
          matchType = "class";
        }
      }

      return {
        "element": ancestor,
        "type": matchType
      };
    },

    // Normalizes nodes after applying a CSS class to a Range.
    postApply: function(textNodes, range) {
      var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];

      var merges = [], currentMerge;

      var rangeStartNode = firstNode, rangeEndNode = lastNode;
      var rangeStartOffset = 0, rangeEndOffset = lastNode.length;

      var textNode, precedingTextNode;

      for (var i = 0, len = textNodes.length; i < len; ++i) {
        textNode = textNodes[i];
        precedingTextNode = null;
        if (textNode && textNode.parentNode) {
          precedingTextNode = this.getAdjacentMergeableTextNode(textNode.parentNode, false);
        }
        if (precedingTextNode) {
          if (!currentMerge) {
            currentMerge = new Merge(precedingTextNode);
            merges.push(currentMerge);
          }
          currentMerge.textNodes.push(textNode);
          if (textNode === firstNode) {
            rangeStartNode = currentMerge.firstTextNode;
            rangeStartOffset = rangeStartNode.length;
          }
          if (textNode === lastNode) {
            rangeEndNode = currentMerge.firstTextNode;
            rangeEndOffset = currentMerge.getLength();
          }
        } else {
          currentMerge = null;
        }
      }
      // Test whether the first node after the range needs merging
      if(lastNode && lastNode.parentNode) {
        var nextTextNode = this.getAdjacentMergeableTextNode(lastNode.parentNode, true);
        if (nextTextNode) {
          if (!currentMerge) {
            currentMerge = new Merge(lastNode);
            merges.push(currentMerge);
          }
          currentMerge.textNodes.push(nextTextNode);
        }
      }
      // Do the merges
      if (merges.length) {
        for (i = 0, len = merges.length; i < len; ++i) {
          merges[i].doMerge();
        }
        // Set the range boundaries
        range.setStart(rangeStartNode, rangeStartOffset);
        range.setEnd(rangeEndNode, rangeEndOffset);
      }
    },

    getAdjacentMergeableTextNode: function(node, forward) {
        var isTextNode = (node.nodeType == wysihtml5.TEXT_NODE);
        var el = isTextNode ? node.parentNode : node;
        var adjacentNode;
        var propName = forward ? "nextSibling" : "previousSibling";
        if (isTextNode) {
          // Can merge if the node's previous/next sibling is a text node
          adjacentNode = node[propName];
          if (adjacentNode && adjacentNode.nodeType == wysihtml5.TEXT_NODE) {
            return adjacentNode;
          }
        } else {
          // Compare element with its sibling
          adjacentNode = el[propName];
          if (adjacentNode && this.areElementsMergeable(node, adjacentNode)) {
            return adjacentNode[forward ? "firstChild" : "lastChild"];
          }
        }
        return null;
    },

    areElementsMergeable: function(el1, el2) {
      return rangy.dom.arrayContains(this.tagNames, (el1.tagName || "").toLowerCase())
        && rangy.dom.arrayContains(this.tagNames, (el2.tagName || "").toLowerCase())
        && hasSameClasses(el1, el2)
        && elementsHaveSameNonClassAttributes(el1, el2);
    },

    createContainer: function(doc) {
      var el = doc.createElement(this.tagNames[0]);
      if (this.cssClass) {
        el.className = this.cssClass;
      }
      if (this.cssStyle) {
        el.setAttribute('style', this.cssStyle);
      }
      return el;
    },

    applyToTextNode: function(textNode) {
      var parent = textNode.parentNode;
      if (parent.childNodes.length == 1 && rangy.dom.arrayContains(this.tagNames, parent.tagName.toLowerCase())) {

        if (this.cssClass) {
          addClass(parent, this.cssClass, this.similarClassRegExp);
        }
        if (this.cssStyle) {
          addStyle(parent, this.cssStyle, this.similarStyleRegExp);
        }
      } else {
        var el = this.createContainer(rangy.dom.getDocument(textNode));
        textNode.parentNode.insertBefore(el, textNode);
        el.appendChild(textNode);
      }
    },

    isRemovable: function(el) {
      return rangy.dom.arrayContains(this.tagNames, el.tagName.toLowerCase()) &&
              wysihtml5.lang.string(el.className).trim() === "" &&
              (
                !el.getAttribute('style') ||
                wysihtml5.lang.string(el.getAttribute('style')).trim() === ""
              );
    },

    undoToTextNode: function(textNode, range, ancestorWithClass, ancestorWithStyle) {
      var styleMode = (ancestorWithClass) ? false : true,
          ancestor = ancestorWithClass || ancestorWithStyle,
          styleChanged = false;
      if (!range.containsNode(ancestor)) {
        // Split out the portion of the ancestor from which we can remove the CSS class
        var ancestorRange = range.cloneRange();
            ancestorRange.selectNode(ancestor);

        if (ancestorRange.isPointInRange(range.endContainer, range.endOffset) && isSplitPoint(range.endContainer, range.endOffset)) {
            splitNodeAt(ancestor, range.endContainer, range.endOffset, this.container);
            range.setEndAfter(ancestor);
        }
        if (ancestorRange.isPointInRange(range.startContainer, range.startOffset) && isSplitPoint(range.startContainer, range.startOffset)) {
            ancestor = splitNodeAt(ancestor, range.startContainer, range.startOffset, this.container);
        }
      }

      if (!styleMode && this.similarClassRegExp) {
        removeClass(ancestor, this.similarClassRegExp);
      }

      if (styleMode && this.similarStyleRegExp) {
        styleChanged = (removeOrChangeStyle(ancestor, this.cssStyle, this.similarStyleRegExp) === "change");
      }
      if (this.isRemovable(ancestor) && !styleChanged) {
        replaceWithOwnChildren(ancestor);
      }
    },

    applyToRange: function(range) {
        var textNodes;
        for (var ri = range.length; ri--;) {
            textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);

            if (!textNodes.length) {
              try {
                var node = this.createContainer(range[ri].endContainer.ownerDocument);
                range[ri].surroundContents(node);
                this.selectNode(range[ri], node);
                return;
              } catch(e) {}
            }

            range[ri].splitBoundaries();
            textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
            if (textNodes.length) {
              var textNode;

              for (var i = 0, len = textNodes.length; i < len; ++i) {
                textNode = textNodes[i];
                if (!this.getMatchingAncestor(textNode).element) {
                  this.applyToTextNode(textNode);
                }
              }

              range[ri].setStart(textNodes[0], 0);
              textNode = textNodes[textNodes.length - 1];
              range[ri].setEnd(textNode, textNode.length);

              if (this.normalize) {
                this.postApply(textNodes, range[ri]);
              }
            }

        }
    },

    undoToRange: function(range) {
      var textNodes, textNode, ancestorWithClass, ancestorWithStyle, ancestor;
      for (var ri = range.length; ri--;) {

          textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
          if (textNodes.length) {
            range[ri].splitBoundaries();
            textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
          } else {
            var doc = range[ri].endContainer.ownerDocument,
                node = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
            range[ri].insertNode(node);
            range[ri].selectNode(node);
            textNodes = [node];
          }

          for (var i = 0, len = textNodes.length; i < len; ++i) {
            if (range[ri].isValid()) {
              textNode = textNodes[i];

              ancestor = this.getMatchingAncestor(textNode);
              if (ancestor.type === "style") {
                this.undoToTextNode(textNode, range[ri], false, ancestor.element);
              } else if (ancestor.element) {
                this.undoToTextNode(textNode, range[ri], ancestor.element);
              }
            }
          }

          if (len == 1) {
            this.selectNode(range[ri], textNodes[0]);
          } else {
            range[ri].setStart(textNodes[0], 0);
            textNode = textNodes[textNodes.length - 1];
            range[ri].setEnd(textNode, textNode.length);

            if (this.normalize) {
              this.postApply(textNodes, range[ri]);
            }
          }

      }
    },

    selectNode: function(range, node) {
      var isElement       = node.nodeType === wysihtml5.ELEMENT_NODE,
          canHaveHTML     = "canHaveHTML" in node ? node.canHaveHTML : true,
          content         = isElement ? node.innerHTML : node.data,
          isEmpty         = (content === "" || content === wysihtml5.INVISIBLE_SPACE);

      if (isEmpty && isElement && canHaveHTML) {
        // Make sure that caret is visible in node by inserting a zero width no breaking space
        try { node.innerHTML = wysihtml5.INVISIBLE_SPACE; } catch(e) {}
      }
      range.selectNodeContents(node);
      if (isEmpty && isElement) {
        range.collapse(false);
      } else if (isEmpty) {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }
    },

    getTextSelectedByRange: function(textNode, range) {
      var textRange = range.cloneRange();
      textRange.selectNodeContents(textNode);

      var intersectionRange = textRange.intersection(range);
      var text = intersectionRange ? intersectionRange.toString() : "";
      textRange.detach();

      return text;
    },

    isAppliedToRange: function(range) {
      var ancestors = [],
          appliedType = "full",
          ancestor, styleAncestor, textNodes;

      for (var ri = range.length; ri--;) {

        textNodes = range[ri].getNodes([wysihtml5.TEXT_NODE]);
        if (!textNodes.length) {
          ancestor = this.getMatchingAncestor(range[ri].startContainer).element;

          return (ancestor) ? {
            "elements": [ancestor],
            "coverage": appliedType
          } : false;
        }

        for (var i = 0, len = textNodes.length, selectedText; i < len; ++i) {
          selectedText = this.getTextSelectedByRange(textNodes[i], range[ri]);
          ancestor = this.getMatchingAncestor(textNodes[i]).element;
          if (ancestor && selectedText != "") {
            ancestors.push(ancestor);

            if (wysihtml5.dom.getTextNodes(ancestor, true).length === 1) {
              appliedType = "full";
            } else if (appliedType === "full") {
              appliedType = "inline";
            }
          } else if (!ancestor) {
            appliedType = "partial";
          }
        }

      }

      return (ancestors.length) ? {
        "elements": ancestors,
        "coverage": appliedType
      } : false;
    },

    toggleRange: function(range) {
      var isApplied = this.isAppliedToRange(range),
          parentsExactMatch;

      if (isApplied) {
        if (isApplied.coverage === "full") {
          this.undoToRange(range);
        } else if (isApplied.coverage === "inline") {
          parentsExactMatch = areMatchingAllready(isApplied.elements, this.tagNames, this.cssStyle, this.cssClass);
          this.undoToRange(range);
          if (!parentsExactMatch) {
            this.applyToRange(range);
          }
        } else {
          // partial
          if (!areMatchingAllready(isApplied.elements, this.tagNames, this.cssStyle, this.cssClass)) {
            this.undoToRange(range);
          }
          this.applyToRange(range);
        }
      } else {
        this.applyToRange(range);
      }
    }
  };

  wysihtml5.selection.HTMLApplier = HTMLApplier;

})(wysihtml5, rangy);
;/**
 * Rich Text Query/Formatting Commands
 *
 * @example
 *    var commands = new wysihtml5.Commands(editor);
 */
wysihtml5.Commands = Base.extend(
  /** @scope wysihtml5.Commands.prototype */ {
  constructor: function(editor) {
    this.editor   = editor;
    this.composer = editor.composer;
    this.doc      = this.composer.doc;
  },

  /**
   * Check whether the browser supports the given command
   *
   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")
   * @example
   *    commands.supports("createLink");
   */
  support: function(command) {
    return wysihtml5.browser.supportsCommand(this.doc, command);
  },

  /**
   * Check whether the browser supports the given command
   *
   * @param {String} command The command string which to execute (eg. "bold", "italic", "insertUnorderedList")
   * @param {String} [value] The command value parameter, needed for some commands ("createLink", "insertImage", ...), optional for commands that don't require one ("bold", "underline", ...)
   * @example
   *    commands.exec("insertImage", "http://a1.twimg.com/profile_images/113868655/schrei_twitter_reasonably_small.jpg");
   */
  exec: function(command, value) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.exec,
        result  = null;

    this.editor.fire("beforecommand:composer");

    if (method) {
      args.unshift(this.composer);
      result = method.apply(obj, args);
    } else {
      try {
        // try/catch for buggy firefox
        result = this.doc.execCommand(command, false, value);
      } catch(e) {}
    }

    this.editor.fire("aftercommand:composer");
    return result;
  },

  /**
   * Check whether the current command is active
   * If the caret is within a bold text, then calling this with command "bold" should return true
   *
   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")
   * @param {String} [commandValue] The command value parameter (eg. for "insertImage" the image src)
   * @return {Boolean} Whether the command is active
   * @example
   *    var isCurrentSelectionBold = commands.state("bold");
   */
  state: function(command, commandValue) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.state;
    if (method) {
      args.unshift(this.composer);
      return method.apply(obj, args);
    } else {
      try {
        // try/catch for buggy firefox
        return this.doc.queryCommandState(command);
      } catch(e) {
        return false;
      }
    }
  },

  /* Get command state parsed value if command has stateValue parsing function */
  stateValue: function(command) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.stateValue;
    if (method) {
      args.unshift(this.composer);
      return method.apply(obj, args);
    } else {
      return false;
    }
  }
});
;wysihtml5.commands.bold = {
  exec: function(composer, command) {
    wysihtml5.commands.formatInline.execWithToggle(composer, command, "b");
  },

  state: function(composer, command) {
    // element.ownerDocument.queryCommandState("bold") results:
    // firefox: only <b>
    // chrome:  <b>, <strong>, <h1>, <h2>, ...
    // ie:      <b>, <strong>
    // opera:   <b>, <strong>
    return wysihtml5.commands.formatInline.state(composer, command, "b");
  }
};

;(function(wysihtml5) {
  var undef,
      NODE_NAME = "A",
      dom       = wysihtml5.dom;

  function _format(composer, attributes) {
    var doc             = composer.doc,
        tempClass       = "_wysihtml5-temp-" + (+new Date()),
        tempClassRegExp = /non-matching-class/g,
        i               = 0,
        length,
        anchors,
        anchor,
        hasElementChild,
        isEmpty,
        elementToSetCaretAfter,
        textContent,
        whiteSpace,
        j;
    wysihtml5.commands.formatInline.exec(composer, undef, NODE_NAME, tempClass, tempClassRegExp, undef, undef, true, true);
    anchors = doc.querySelectorAll(NODE_NAME + "." + tempClass);
    length  = anchors.length;
    for (; i<length; i++) {
      anchor = anchors[i];
      anchor.removeAttribute("class");
      for (j in attributes) {
        // Do not set attribute "text" as it is meant for setting string value if created link has no textual data
        if (j !== "text") {
          anchor.setAttribute(j, attributes[j]);
        }
      }
    }

    elementToSetCaretAfter = anchor;
    if (length === 1) {
      textContent = dom.getTextContent(anchor);
      hasElementChild = !!anchor.querySelector("*");
      isEmpty = textContent === "" || textContent === wysihtml5.INVISIBLE_SPACE;
      if (!hasElementChild && isEmpty) {
        dom.setTextContent(anchor, attributes.text || anchor.href);
        whiteSpace = doc.createTextNode(" ");
        composer.selection.setAfter(anchor);
        dom.insert(whiteSpace).after(anchor);
        elementToSetCaretAfter = whiteSpace;
      }
    }
    composer.selection.setAfter(elementToSetCaretAfter);
  }

  // Changes attributes of links
  function _changeLinks(composer, anchors, attributes) {
    var oldAttrs;
    for (var a = anchors.length; a--;) {

      // Remove all old attributes
      oldAttrs = anchors[a].attributes;
      for (var oa = oldAttrs.length; oa--;) {
        anchors[a].removeAttribute(oldAttrs.item(oa).name);
      }

      // Set new attributes
      for (var j in attributes) {
        if (attributes.hasOwnProperty(j)) {
          anchors[a].setAttribute(j, attributes[j]);
        }
      }

    }
  }

  wysihtml5.commands.createLink = {
    /**
     * TODO: Use HTMLApplier or formatInline here
     *
     * Turns selection into a link
     * If selection is already a link, it just changes the attributes
     *
     * @example
     *    // either ...
     *    wysihtml5.commands.createLink.exec(composer, "createLink", "http://www.google.de");
     *    // ... or ...
     *    wysihtml5.commands.createLink.exec(composer, "createLink", { href: "http://www.google.de", target: "_blank" });
     */
    exec: function(composer, command, value) {
      var anchors = this.state(composer, command);
      if (anchors) {
        // Selection contains links then change attributes of these links
        composer.selection.executeAndRestore(function() {
          _changeLinks(composer, anchors, value);
        });
      } else {
        // Create links
        value = typeof(value) === "object" ? value : { href: value };
        _format(composer, value);
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "A");
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var dom = wysihtml5.dom;

  function _removeFormat(composer, anchors) {
    var length  = anchors.length,
        i       = 0,
        anchor,
        codeElement,
        textContent;
    for (; i<length; i++) {
      anchor      = anchors[i];
      codeElement = dom.getParentElement(anchor, { nodeName: "code" });
      textContent = dom.getTextContent(anchor);

      // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking
      // else replace <a> with its childNodes
      if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {
        // <code> element is used to prevent later auto-linking of the content
        codeElement = dom.renameElement(anchor, "code");
      } else {
        dom.replaceWithChildNodes(anchor);
      }
    }
  }

  wysihtml5.commands.removeLink = {
    /*
     * If selection is a link, it removes the link and wraps it with a <code> element
     * The <code> element is needed to avoid auto linking
     *
     * @example
     *    wysihtml5.commands.createLink.exec(composer, "removeLink");
     */

    exec: function(composer, command) {
      var anchors = this.state(composer, command);
      if (anchors) {
        composer.selection.executeAndRestore(function() {
          _removeFormat(composer, anchors);
        });
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "A");
    }
  };
})(wysihtml5);
;/**
 * document.execCommand("fontSize") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var REG_EXP = /wysiwyg-font-size-[0-9a-z\-]+/g;

  wysihtml5.commands.fontSize = {
    exec: function(composer, command, size) {
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);
    },

    state: function(composer, command, size) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);
    }
  };
})(wysihtml5);
;/* In case font size adjustment to any number defined by user is preferred, we cannot use classes and must use inline styles. */
(function(wysihtml5) {
  var REG_EXP = /(\s|^)font-size\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.fontSizeStyle = {
    exec: function(composer, command, size) {
      size = (typeof(size) == "object") ? size.size : size;
      if (!(/^\s*$/).test(size)) {
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", false, false, "font-size:" + size, REG_EXP);
      }
    },

    state: function(composer, command, size) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", false, false, "font-size", REG_EXP);
    },

    stateValue: function(composer, command) {
      var st = this.state(composer, command),
          styleStr, fontsizeMatches,
          val = false;

      if (st && wysihtml5.lang.object(st).isArray()) {
          st = st[0];
      }
      if (st) {
        styleStr = st.getAttribute('style');
        if (styleStr) {
          return wysihtml5.quirks.styleParser.parseFontSize(styleStr);
        }
      }
      return false;
    }
  };
})(wysihtml5);
;/**
 * document.execCommand("foreColor") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var REG_EXP = /wysiwyg-color-[0-9a-z]+/g;

  wysihtml5.commands.foreColor = {
    exec: function(composer, command, color) {
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);
    },

    state: function(composer, command, color) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);
    }
  };
})(wysihtml5);
;/**
 * document.execCommand("foreColor") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var REG_EXP = /(\s|^)color\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.foreColorStyle = {
    exec: function(composer, command, color) {
      var colorVals  = wysihtml5.quirks.styleParser.parseColor((typeof(color) == "object") ? "color:" + color.color : "color:" + color, "color"),
          colString;

      if (colorVals) {
        colString = "color: rgb(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ');';
        if (colorVals[3] !== 1) {
          colString += "color: rgba(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ',' + colorVals[3] + ');';
        }
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", false, false, colString, REG_EXP);
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", false, false, "color", REG_EXP);
    },

    stateValue: function(composer, command, props) {
      var st = this.state(composer, command),
          colorStr;

      if (st && wysihtml5.lang.object(st).isArray()) {
        st = st[0];
      }

      if (st) {
        colorStr = st.getAttribute('style');
        if (colorStr) {
          if (colorStr) {
            val = wysihtml5.quirks.styleParser.parseColor(colorStr, "color");
            return wysihtml5.quirks.styleParser.unparseColor(val, props);
          }
        }
      }
      return false;
    }

  };
})(wysihtml5);
;/* In case background adjustment to any color defined by user is preferred, we cannot use classes and must use inline styles. */
(function(wysihtml5) {
  var REG_EXP = /(\s|^)background-color\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.bgColorStyle = {
    exec: function(composer, command, color) {
      var colorVals  = wysihtml5.quirks.styleParser.parseColor((typeof(color) == "object") ? "background-color:" + color.color : "background-color:" + color, "background-color"),
          colString;

      if (colorVals) {
        colString = "background-color: rgb(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ');';
        if (colorVals[3] !== 1) {
          colString += "background-color: rgba(" + colorVals[0] + ',' + colorVals[1] + ',' + colorVals[2] + ',' + colorVals[3] + ');';
        }
        wysihtml5.commands.formatInline.execWithToggle(composer, command, "span", false, false, colString, REG_EXP);
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", false, false, "background-color", REG_EXP);
    },

    stateValue: function(composer, command, props) {
      var st = this.state(composer, command),
          colorStr,
          val = false;

      if (st && wysihtml5.lang.object(st).isArray()) {
        st = st[0];
      }

      if (st) {
        colorStr = st.getAttribute('style');
        if (colorStr) {
          val = wysihtml5.quirks.styleParser.parseColor(colorStr, "background-color");
          return wysihtml5.quirks.styleParser.unparseColor(val, props);
        }
      }
      return false;
    }

  };
})(wysihtml5);
;(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      // Following elements are grouped
      // when the caret is within a H1 and the H4 is invoked, the H1 should turn into H4
      // instead of creating a H4 within a H1 which would result in semantically invalid html
      BLOCK_ELEMENTS_GROUP    = ["H1", "H2", "H3", "H4", "H5", "H6", "P", "PRE", "DIV"];

  /**
   * Remove similiar classes (based on classRegExp)
   * and add the desired class name
   */
  function _addClass(element, className, classRegExp) {
    if (element.className) {
      _removeClass(element, classRegExp);
      element.className = wysihtml5.lang.string(element.className + " " + className).trim();
    } else {
      element.className = className;
    }
  }

  function _addStyle(element, cssStyle, styleRegExp) {
    _removeStyle(element, styleRegExp);
    if (element.getAttribute('style')) {
      element.setAttribute('style', wysihtml5.lang.string(element.getAttribute('style') + " " + cssStyle).trim());
    } else {
      element.setAttribute('style', cssStyle);
    }
  }

  function _removeClass(element, classRegExp) {
    var ret = classRegExp.test(element.className);
    element.className = element.className.replace(classRegExp, "");
    if (wysihtml5.lang.string(element.className).trim() == '') {
        element.removeAttribute('class');
    }
    return ret;
  }

  function _removeStyle(element, styleRegExp) {
    var ret = styleRegExp.test(element.getAttribute('style'));
    element.setAttribute('style', (element.getAttribute('style') || "").replace(styleRegExp, ""));
    if (wysihtml5.lang.string(element.getAttribute('style') || "").trim() == '') {
      element.removeAttribute('style');
    }
    return ret;
  }

  function _removeLastChildIfLineBreak(node) {
    var lastChild = node.lastChild;
    if (lastChild && _isLineBreak(lastChild)) {
      lastChild.parentNode.removeChild(lastChild);
    }
  }

  function _isLineBreak(node) {
    return node.nodeName === "BR";
  }

  /**
   * Execute native query command
   * and if necessary modify the inserted node's className
   */
  function _execCommand(doc, composer, command, nodeName, className) {
    var ranges = composer.selection.getOwnRanges();
    for (var i = ranges.length; i--;){
      composer.selection.getSelection().removeAllRanges();
      composer.selection.setSelection(ranges[i]);
      if (className) {
        var eventListener = dom.observe(doc, "DOMNodeInserted", function(event) {
          var target = event.target,
              displayStyle;
          if (target.nodeType !== wysihtml5.ELEMENT_NODE) {
            return;
          }
          displayStyle = dom.getStyle("display").from(target);
          if (displayStyle.substr(0, 6) !== "inline") {
            // Make sure that only block elements receive the given class
            target.className += " " + className;
          }
        });
      }
      doc.execCommand(command, false, nodeName);

      if (eventListener) {
        eventListener.stop();
      }
    }
  }

  function _selectionWrap(composer, options) {
    if (composer.selection.isCollapsed()) {
        composer.selection.selectLine();
    }

    var surroundedNodes = composer.selection.surround(options);
    for (var i = 0, imax = surroundedNodes.length; i < imax; i++) {
      wysihtml5.dom.lineBreaks(surroundedNodes[i]).remove();
      _removeLastChildIfLineBreak(surroundedNodes[i]);
    }

    // rethink restoring selection
    // composer.selection.selectNode(element, wysihtml5.browser.displaysCaretInEmptyContentEditableCorrectly());
  }

  function _hasClasses(element) {
    return !!wysihtml5.lang.string(element.className).trim();
  }

  function _hasStyles(element) {
    return !!wysihtml5.lang.string(element.getAttribute('style') || '').trim();
  }

  wysihtml5.commands.formatBlock = {
    exec: function(composer, command, nodeName, className, classRegExp, cssStyle, styleRegExp) {
      var doc             = composer.doc,
          blockElements    = this.state(composer, command, nodeName, className, classRegExp, cssStyle, styleRegExp),
          useLineBreaks   = composer.config.useLineBreaks,
          defaultNodeName = useLineBreaks ? "DIV" : "P",
          selectedNodes, classRemoveAction, blockRenameFound, styleRemoveAction, blockElement;
      nodeName = typeof(nodeName) === "string" ? nodeName.toUpperCase() : nodeName;

      if (blockElements.length) {
        composer.selection.executeAndRestoreRangy(function() {
          for (var b = blockElements.length; b--;) {
            if (classRegExp) {
              classRemoveAction = _removeClass(blockElements[b], classRegExp);
            }
            if (styleRegExp) {
              styleRemoveAction = _removeStyle(blockElements[b], styleRegExp);
            }

            if ((styleRemoveAction || classRemoveAction) && nodeName === null && blockElements[b].nodeName != defaultNodeName) {
              // dont rename or remove element when just setting block formating class or style
              return;
            }

            var hasClasses = _hasClasses(blockElements[b]),
                hasStyles = _hasStyles(blockElements[b]);

            if (!hasClasses && !hasStyles && (useLineBreaks || nodeName === "P")) {
              // Insert a line break afterwards and beforewards when there are siblings
              // that are not of type line break or block element
              wysihtml5.dom.lineBreaks(blockElements[b]).add();
              dom.replaceWithChildNodes(blockElements[b]);
            } else {
              // Make sure that styling is kept by renaming the element to a <div> or <p> and copying over the class name
              dom.renameElement(blockElements[b], nodeName === "P" ? "DIV" : defaultNodeName);
            }
          }
        });

        return;
      }

      // Find similiar block element and rename it (<h2 class="foo"></h2>  =>  <h1 class="foo"></h1>)
      if (nodeName === null || wysihtml5.lang.array(BLOCK_ELEMENTS_GROUP).contains(nodeName)) {
        selectedNodes = composer.selection.findNodesInSelection(BLOCK_ELEMENTS_GROUP).concat(composer.selection.getSelectedOwnNodes());
        composer.selection.executeAndRestoreRangy(function() {
          for (var n = selectedNodes.length; n--;) {
            blockElement = dom.getParentElement(selectedNodes[n], {
              nodeName: BLOCK_ELEMENTS_GROUP
            });
            if (blockElement == composer.element) {
              blockElement = null;
            }
            if (blockElement) {
                // Rename current block element to new block element and add class
                if (nodeName) {
                  blockElement = dom.renameElement(blockElement, nodeName);
                }
                if (className) {
                  _addClass(blockElement, className, classRegExp);
                }
                if (cssStyle) {
                  _addStyle(blockElement, cssStyle, styleRegExp);
                }
              blockRenameFound = true;
            }
          }

        });

        if (blockRenameFound) {
          return;
        }
      }

      _selectionWrap(composer, {
        "nodeName": (nodeName || defaultNodeName),
        "className": className || null,
        "cssStyle": cssStyle || null
      });
    },

    state: function(composer, command, nodeName, className, classRegExp, cssStyle, styleRegExp) {
      var nodes = composer.selection.getSelectedOwnNodes(),
          parents = [],
          parent;

      nodeName = typeof(nodeName) === "string" ? nodeName.toUpperCase() : nodeName;

      //var selectedNode = composer.selection.getSelectedNode();
      for (var i = 0, maxi = nodes.length; i < maxi; i++) {
        parent = dom.getParentElement(nodes[i], {
          nodeName:     nodeName,
          className:    className,
          classRegExp:  classRegExp,
          cssStyle:     cssStyle,
          styleRegExp:  styleRegExp
        });
        if (parent && wysihtml5.lang.array(parents).indexOf(parent) == -1) {
          parents.push(parent);
        }
      }
      if (parents.length == 0) {
        return false;
      }
      return parents;
    }


  };
})(wysihtml5);
;/* Formats block for as a <pre><code class="classname"></code></pre> block
 * Useful in conjuction for sytax highlight utility: highlight.js
 *
 * Usage:
 *
 * editorInstance.composer.commands.exec("formatCode", "language-html");
*/

wysihtml5.commands.formatCode = {

  exec: function(composer, command, classname) {
    var pre = this.state(composer),
        code, range, selectedNodes;
    if (pre) {
      // caret is already within a <pre><code>...</code></pre>
      composer.selection.executeAndRestore(function() {
        code = pre.querySelector("code");
        wysihtml5.dom.replaceWithChildNodes(pre);
        if (code) {
          wysihtml5.dom.replaceWithChildNodes(code);
        }
      });
    } else {
      // Wrap in <pre><code>...</code></pre>
      range = composer.selection.getRange();
      selectedNodes = range.extractContents();
      pre = composer.doc.createElement("pre");
      code = composer.doc.createElement("code");

      if (classname) {
        code.className = classname;
      }

      pre.appendChild(code);
      code.appendChild(selectedNodes);
      range.insertNode(pre);
      composer.selection.selectNode(pre);
    }
  },

  state: function(composer) {
    var selectedNode = composer.selection.getSelectedNode();
    if (selectedNode && selectedNode.nodeName && selectedNode.nodeName == "PRE"&&
        selectedNode.firstChild && selectedNode.firstChild.nodeName && selectedNode.firstChild.nodeName == "CODE") {
      return selectedNode;
    } else {
      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "CODE" }) && wysihtml5.dom.getParentElement(selectedNode, { nodeName: "PRE" });
    }
  }
};;/**
 * formatInline scenarios for tag "B" (| = caret, |foo| = selected text)
 *
 *   #1 caret in unformatted text:
 *      abcdefg|
 *   output:
 *      abcdefg<b>|</b>
 *
 *   #2 unformatted text selected:
 *      abc|deg|h
 *   output:
 *      abc<b>|deg|</b>h
 *
 *   #3 unformatted text selected across boundaries:
 *      ab|c <span>defg|h</span>
 *   output:
 *      ab<b>|c </b><span><b>defg</b>|h</span>
 *
 *   #4 formatted text entirely selected
 *      <b>|abc|</b>
 *   output:
 *      |abc|
 *
 *   #5 formatted text partially selected
 *      <b>ab|c|</b>
 *   output:
 *      <b>ab</b>|c|
 *
 *   #6 formatted text selected across boundaries
 *      <span>ab|c</span> <b>de|fgh</b>
 *   output:
 *      <span>ab|c</span> de|<b>fgh</b>
 */
(function(wysihtml5) {
  var // Treat <b> as <strong> and vice versa
      ALIAS_MAPPING = {
        "strong": "b",
        "em":     "i",
        "b":      "strong",
        "i":      "em"
      },
      htmlApplier = {};

  function _getTagNames(tagName) {
    var alias = ALIAS_MAPPING[tagName];
    return alias ? [tagName.toLowerCase(), alias.toLowerCase()] : [tagName.toLowerCase()];
  }

  function _getApplier(tagName, className, classRegExp, cssStyle, styleRegExp, container) {
    var identifier = tagName;
    
    if (className) {
      identifier += ":" + className;
    }
    if (cssStyle) {
      identifier += ":" + cssStyle;
    }

    if (!htmlApplier[identifier]) {
      htmlApplier[identifier] = new wysihtml5.selection.HTMLApplier(_getTagNames(tagName), className, classRegExp, true, cssStyle, styleRegExp, container);
    }

    return htmlApplier[identifier];
  }

  wysihtml5.commands.formatInline = {
    exec: function(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp, dontRestoreSelect, noCleanup) {
      var range = composer.selection.createRange(),
          ownRanges = composer.selection.getOwnRanges();

      if (!ownRanges || ownRanges.length == 0) {
        return false;
      }
      composer.selection.getSelection().removeAllRanges();

      _getApplier(tagName, className, classRegExp, cssStyle, styleRegExp, composer.element).toggleRange(ownRanges);

      if (!dontRestoreSelect) {
        range.setStart(ownRanges[0].startContainer,  ownRanges[0].startOffset);
        range.setEnd(
          ownRanges[ownRanges.length - 1].endContainer,
          ownRanges[ownRanges.length - 1].endOffset
        );
        composer.selection.setSelection(range);
        composer.selection.executeAndRestore(function() {
          if (!noCleanup) {
            composer.cleanUp();
          }
        }, true, true);
      } else if (!noCleanup) {
        composer.cleanUp();
      }
    },

    // Executes so that if collapsed caret is in a state and executing that state it should unformat that state
    // It is achieved by selecting the entire state element before executing.
    // This works on built in contenteditable inline format commands
    execWithToggle: function(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) {
      var that = this;

      if (this.state(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) &&
        composer.selection.isCollapsed() &&
        !composer.selection.caretIsLastInSelection() &&
        !composer.selection.caretIsFirstInSelection()
      ) {
        var state_element = that.state(composer, command, tagName, className, classRegExp)[0];
        composer.selection.executeAndRestoreRangy(function() {
          var parent = state_element.parentNode;
          composer.selection.selectNode(state_element, true);
          wysihtml5.commands.formatInline.exec(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp, true, true);
        });
      } else {
        if (this.state(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) && !composer.selection.isCollapsed()) {
          composer.selection.executeAndRestoreRangy(function() {
            wysihtml5.commands.formatInline.exec(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp, true, true);
          });
        } else {
          wysihtml5.commands.formatInline.exec(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp);
        }
      }
    },

    state: function(composer, command, tagName, className, classRegExp, cssStyle, styleRegExp) {
      var doc           = composer.doc,
          aliasTagName  = ALIAS_MAPPING[tagName] || tagName,
          ownRanges, isApplied;

      // Check whether the document contains a node with the desired tagName
      if (!wysihtml5.dom.hasElementWithTagName(doc, tagName) &&
          !wysihtml5.dom.hasElementWithTagName(doc, aliasTagName)) {
        return false;
      }

       // Check whether the document contains a node with the desired className
      if (className && !wysihtml5.dom.hasElementWithClassName(doc, className)) {
         return false;
      }

      ownRanges = composer.selection.getOwnRanges();

      if (!ownRanges || ownRanges.length === 0) {
        return false;
      }

      isApplied = _getApplier(tagName, className, classRegExp, cssStyle, styleRegExp, composer.element).isAppliedToRange(ownRanges);

      return (isApplied && isApplied.elements) ? isApplied.elements : false;
    }
  };
})(wysihtml5);
;(function(wysihtml5) {

  wysihtml5.commands.insertBlockQuote = {
    exec: function(composer, command) {
      var state = this.state(composer, command),
          endToEndParent = composer.selection.isEndToEndInNode(['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P']),
          prevNode, nextNode;

      composer.selection.executeAndRestore(function() {
        if (state) {
          if (composer.config.useLineBreaks) {
             wysihtml5.dom.lineBreaks(state).add();
          }
          wysihtml5.dom.unwrap(state);
        } else {
          if (composer.selection.isCollapsed()) {
            composer.selection.selectLine();
          }
          
          if (endToEndParent) {
            var qouteEl = endToEndParent.ownerDocument.createElement('blockquote');
            wysihtml5.dom.insert(qouteEl).after(endToEndParent);
            qouteEl.appendChild(endToEndParent);
          } else {
            composer.selection.surround({nodeName: "blockquote"});
          }
        }
      });
    },
    state: function(composer, command) {
      var selectedNode  = composer.selection.getSelectedNode(),
          node = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "BLOCKQUOTE" }, false, composer.element);

      return (node) ? node : false;
    }
  };

})(wysihtml5);;wysihtml5.commands.insertHTML = {
  exec: function(composer, command, html) {
    if (composer.commands.support(command)) {
      composer.doc.execCommand(command, false, html);
    } else {
      composer.selection.insertHTML(html);
    }
  },

  state: function() {
    return false;
  }
};
;(function(wysihtml5) {
  var NODE_NAME = "IMG";

  wysihtml5.commands.insertImage = {
    /**
     * Inserts an <img>
     * If selection is already an image link, it removes it
     *
     * @example
     *    // either ...
     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", "http://www.google.de/logo.jpg");
     *    // ... or ...
     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", { src: "http://www.google.de/logo.jpg", title: "foo" });
     */
    exec: function(composer, command, value) {
      value = typeof(value) === "object" ? value : { src: value };

      var doc     = composer.doc,
          image   = this.state(composer),
          textNode,
          parent;

      if (image) {
        // Image already selected, set the caret before it and delete it
        composer.selection.setBefore(image);
        parent = image.parentNode;
        parent.removeChild(image);

        // and it's parent <a> too if it hasn't got any other relevant child nodes
        wysihtml5.dom.removeEmptyTextNodes(parent);
        if (parent.nodeName === "A" && !parent.firstChild) {
          composer.selection.setAfter(parent);
          parent.parentNode.removeChild(parent);
        }

        // firefox and ie sometimes don't remove the image handles, even though the image got removed
        wysihtml5.quirks.redraw(composer.element);
        return;
      }

      image = doc.createElement(NODE_NAME);

      for (var i in value) {
        image.setAttribute(i === "className" ? "class" : i, value[i]);
      }

      composer.selection.insertNode(image);
      if (wysihtml5.browser.hasProblemsSettingCaretAfterImg()) {
        textNode = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
        composer.selection.insertNode(textNode);
        composer.selection.setAfter(textNode);
      } else {
        composer.selection.setAfter(image);
      }
    },

    state: function(composer) {
      var doc = composer.doc,
          selectedNode,
          text,
          imagesInSelection;

      if (!wysihtml5.dom.hasElementWithTagName(doc, NODE_NAME)) {
        return false;
      }

      selectedNode = composer.selection.getSelectedNode();
      if (!selectedNode) {
        return false;
      }

      if (selectedNode.nodeName === NODE_NAME) {
        // This works perfectly in IE
        return selectedNode;
      }

      if (selectedNode.nodeType !== wysihtml5.ELEMENT_NODE) {
        return false;
      }

      text = composer.selection.getText();
      text = wysihtml5.lang.string(text).trim();
      if (text) {
        return false;
      }

      imagesInSelection = composer.selection.getNodes(wysihtml5.ELEMENT_NODE, function(node) {
        return node.nodeName === "IMG";
      });

      if (imagesInSelection.length !== 1) {
        return false;
      }

      return imagesInSelection[0];
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var LINE_BREAK = "<br>" + (wysihtml5.browser.needsSpaceAfterLineBreak() ? " " : "");

  wysihtml5.commands.insertLineBreak = {
    exec: function(composer, command) {
      if (composer.commands.support(command)) {
        composer.doc.execCommand(command, false, null);
        if (!wysihtml5.browser.autoScrollsToCaret()) {
          composer.selection.scrollIntoView();
        }
      } else {
        composer.commands.exec("insertHTML", LINE_BREAK);
      }
    },

    state: function() {
      return false;
    }
  };
})(wysihtml5);
;wysihtml5.commands.insertOrderedList = {
  exec: function(composer, command) {
    wysihtml5.commands.insertList.exec(composer, command, "OL");
  },

  state: function(composer, command) {
    return wysihtml5.commands.insertList.state(composer, command, "OL");
  }
};
;wysihtml5.commands.insertUnorderedList = {
  exec: function(composer, command) {
    wysihtml5.commands.insertList.exec(composer, command, "UL");
  },

  state: function(composer, command) {
    return wysihtml5.commands.insertList.state(composer, command, "UL");
  }
};
;wysihtml5.commands.insertList = (function(wysihtml5) {

  var isNode = function(node, name) {
    if (node && node.nodeName) {
      if (typeof name === 'string') {
        name = [name];
      }
      for (var n = name.length; n--;) {
        if (node.nodeName === name[n]) {
          return true;
        }
      }
    }
    return false;
  };

  var findListEl = function(node, nodeName, composer) {
    var ret = {
          el: null,
          other: false
        };

    if (node) {
      var parentLi = wysihtml5.dom.getParentElement(node, { nodeName: "LI" }),
          otherNodeName = (nodeName === "UL") ? "OL" : "UL";

      if (isNode(node, nodeName)) {
        ret.el = node;
      } else if (isNode(node, otherNodeName)) {
        ret = {
          el: node,
          other: true
        };
      } else if (parentLi) {
        if (isNode(parentLi.parentNode, nodeName)) {
          ret.el = parentLi.parentNode;
        } else if (isNode(parentLi.parentNode, otherNodeName)) {
          ret = {
            el : parentLi.parentNode,
            other: true
          };
        }
      }
    }

    // do not count list elements outside of composer
    if (ret.el && !composer.element.contains(ret.el)) {
      ret.el = null;
    }

    return ret;
  };

  var handleSameTypeList = function(el, nodeName, composer) {
    var otherNodeName = (nodeName === "UL") ? "OL" : "UL",
        otherLists, innerLists;
    // Unwrap list
    // <ul><li>foo</li><li>bar</li></ul>
    // becomes:
    // foo<br>bar<br>
    composer.selection.executeAndRestore(function() {
      var otherLists = getListsInSelection(otherNodeName, composer);
      if (otherLists.length) {
        for (var l = otherLists.length; l--;) {
          wysihtml5.dom.renameElement(otherLists[l], nodeName.toLowerCase());
        }
      } else {
        innerLists = getListsInSelection(['OL', 'UL'], composer);
        for (var i = innerLists.length; i--;) {
          wysihtml5.dom.resolveList(innerLists[i], composer.config.useLineBreaks);
        }
        wysihtml5.dom.resolveList(el, composer.config.useLineBreaks);
      }
    });
  };

  var handleOtherTypeList =  function(el, nodeName, composer) {
    var otherNodeName = (nodeName === "UL") ? "OL" : "UL";
    // Turn an ordered list into an unordered list
    // <ol><li>foo</li><li>bar</li></ol>
    // becomes:
    // <ul><li>foo</li><li>bar</li></ul>
    // Also rename other lists in selection
    composer.selection.executeAndRestore(function() {
      var renameLists = [el].concat(getListsInSelection(otherNodeName, composer));

      // All selection inner lists get renamed too
      for (var l = renameLists.length; l--;) {
        wysihtml5.dom.renameElement(renameLists[l], nodeName.toLowerCase());
      }
    });
  };

  var getListsInSelection = function(nodeName, composer) {
      var ranges = composer.selection.getOwnRanges(),
          renameLists = [];

      for (var r = ranges.length; r--;) {
        renameLists = renameLists.concat(ranges[r].getNodes([1], function(node) {
          return isNode(node, nodeName);
        }));
      }

      return renameLists;
  };

  var createListFallback = function(nodeName, composer) {
    // Fallback for Create list
    composer.selection.executeAndRestoreRangy(function() {
      var tempClassName =  "_wysihtml5-temp-" + new Date().getTime(),
          tempElement = composer.selection.deblockAndSurround({
            "nodeName": "div",
            "className": tempClassName
          }),
          isEmpty, list;

      // This space causes new lists to never break on enter 
      var INVISIBLE_SPACE_REG_EXP = /\uFEFF/g;
      tempElement.innerHTML = tempElement.innerHTML.replace(INVISIBLE_SPACE_REG_EXP, "");
      
      if (tempElement) {
        isEmpty = wysihtml5.lang.array(["", "<br>", wysihtml5.INVISIBLE_SPACE]).contains(tempElement.innerHTML);
        list = wysihtml5.dom.convertToList(tempElement, nodeName.toLowerCase(), composer.parent.config.uneditableContainerClassname);
        if (isEmpty) {
          composer.selection.selectNode(list.querySelector("li"), true);
        }
      }
    });
  };

  return {
    exec: function(composer, command, nodeName) {
      var doc           = composer.doc,
          cmd           = (nodeName === "OL") ? "insertOrderedList" : "insertUnorderedList",
          selectedNode  = composer.selection.getSelectedNode(),
          list          = findListEl(selectedNode, nodeName, composer);

      if (!list.el) {
        if (composer.commands.support(cmd)) {
          doc.execCommand(cmd, false, null);
        } else {
          createListFallback(nodeName, composer);
        }
      } else if (list.other) {
        handleOtherTypeList(list.el, nodeName, composer);
      } else {
        handleSameTypeList(list.el, nodeName, composer);
      }
    },

    state: function(composer, command, nodeName) {
      var selectedNode = composer.selection.getSelectedNode(),
          list         = findListEl(selectedNode, nodeName, composer);

      return (list.el && !list.other) ? list.el : false;
    }
  };

})(wysihtml5);;wysihtml5.commands.italic = {
  exec: function(composer, command) {
    wysihtml5.commands.formatInline.execWithToggle(composer, command, "i");
  },

  state: function(composer, command) {
    // element.ownerDocument.queryCommandState("italic") results:
    // firefox: only <i>
    // chrome:  <i>, <em>, <blockquote>, ...
    // ie:      <i>, <em>
    // opera:   only <i>
    return wysihtml5.commands.formatInline.state(composer, command, "i");
  }
};
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-center",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyCenter = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-left",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyLeft = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-right",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyRight = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-justify",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;

  wysihtml5.commands.justifyFull = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var STYLE_STR  = "text-align: right;",
      REG_EXP = /(\s|^)text-align\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.alignRightStyle = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var STYLE_STR  = "text-align: left;",
      REG_EXP = /(\s|^)text-align\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.alignLeftStyle = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    }
  };
})(wysihtml5);
;(function(wysihtml5) {
  var STYLE_STR  = "text-align: center;",
      REG_EXP = /(\s|^)text-align\s*:\s*[^;\s]+;?/gi;

  wysihtml5.commands.alignCenterStyle = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, null, null, STYLE_STR, REG_EXP);
    }
  };
})(wysihtml5);
;wysihtml5.commands.redo = {
  exec: function(composer) {
    return composer.undoManager.redo();
  },

  state: function(composer) {
    return false;
  }
};
;wysihtml5.commands.underline = {
  exec: function(composer, command) {
    wysihtml5.commands.formatInline.execWithToggle(composer, command, "u");
  },

  state: function(composer, command) {
    return wysihtml5.commands.formatInline.state(composer, command, "u");
  }
};
;wysihtml5.commands.undo = {
  exec: function(composer) {
    return composer.undoManager.undo();
  },

  state: function(composer) {
    return false;
  }
};
;wysihtml5.commands.createTable = {
  exec: function(composer, command, value) {
      var col, row, html;
      if (value && value.cols && value.rows && parseInt(value.cols, 10) > 0 && parseInt(value.rows, 10) > 0) {
          if (value.tableStyle) {
            html = "<table style=\"" + value.tableStyle + "\">";
          } else {
            html = "<table>";
          }
          html += "<tbody>";
          for (row = 0; row < value.rows; row ++) {
              html += '<tr>';
              for (col = 0; col < value.cols; col ++) {
                  html += "<td>&nbsp;</td>";
              }
              html += '</tr>';
          }
          html += "</tbody></table>";
          composer.commands.exec("insertHTML", html);
          //composer.selection.insertHTML(html);
      }


  },

  state: function(composer, command) {
      return false;
  }
};
;wysihtml5.commands.mergeTableCells = {
  exec: function(composer, command) {
      if (composer.tableSelection && composer.tableSelection.start && composer.tableSelection.end) {
          if (this.state(composer, command)) {
              wysihtml5.dom.table.unmergeCell(composer.tableSelection.start);
          } else {
              wysihtml5.dom.table.mergeCellsBetween(composer.tableSelection.start, composer.tableSelection.end);
          }
      }
  },

  state: function(composer, command) {
      if (composer.tableSelection) {
          var start = composer.tableSelection.start,
              end = composer.tableSelection.end;
          if (start && end && start == end &&
              ((
                  wysihtml5.dom.getAttribute(start, "colspan") &&
                  parseInt(wysihtml5.dom.getAttribute(start, "colspan"), 10) > 1
              ) || (
                  wysihtml5.dom.getAttribute(start, "rowspan") &&
                  parseInt(wysihtml5.dom.getAttribute(start, "rowspan"), 10) > 1
              ))
          ) {
              return [start];
          }
      }
      return false;
  }
};
;wysihtml5.commands.addTableCells = {
  exec: function(composer, command, value) {
      if (composer.tableSelection && composer.tableSelection.start && composer.tableSelection.end) {

          // switches start and end if start is bigger than end (reverse selection)
          var tableSelect = wysihtml5.dom.table.orderSelectionEnds(composer.tableSelection.start, composer.tableSelection.end);
          if (value == "before" || value == "above") {
              wysihtml5.dom.table.addCells(tableSelect.start, value);
          } else if (value == "after" || value == "below") {
              wysihtml5.dom.table.addCells(tableSelect.end, value);
          }
          setTimeout(function() {
              composer.tableSelection.select(tableSelect.start, tableSelect.end);
          },0);
      }
  },

  state: function(composer, command) {
      return false;
  }
};
;wysihtml5.commands.deleteTableCells = {
  exec: function(composer, command, value) {
      if (composer.tableSelection && composer.tableSelection.start && composer.tableSelection.end) {
          var tableSelect = wysihtml5.dom.table.orderSelectionEnds(composer.tableSelection.start, composer.tableSelection.end),
              idx = wysihtml5.dom.table.indexOf(tableSelect.start),
              selCell,
              table = composer.tableSelection.table;

          wysihtml5.dom.table.removeCells(tableSelect.start, value);
          setTimeout(function() {
              // move selection to next or previous if not present
              selCell = wysihtml5.dom.table.findCell(table, idx);

              if (!selCell){
                  if (value == "row") {
                      selCell = wysihtml5.dom.table.findCell(table, {
                          "row": idx.row - 1,
                          "col": idx.col
                      });
                  }

                  if (value == "column") {
                      selCell = wysihtml5.dom.table.findCell(table, {
                          "row": idx.row,
                          "col": idx.col - 1
                      });
                  }
              }
              if (selCell) {
                  composer.tableSelection.select(selCell, selCell);
              }
          }, 0);

      }
  },

  state: function(composer, command) {
      return false;
  }
};
;wysihtml5.commands.indentList = {
  exec: function(composer, command, value) {
    var listEls = composer.selection.getSelectionParentsByTag('LI');
    if (listEls) {
      return this.tryToPushLiLevel(listEls, composer.selection);
    }
    return false;
  },

  state: function(composer, command) {
      return false;
  },

  tryToPushLiLevel: function(liNodes, selection) {
    var listTag, list, prevLi, liNode, prevLiList,
        found = false;

    selection.executeAndRestoreRangy(function() {

      for (var i = liNodes.length; i--;) {
        liNode = liNodes[i];
        listTag = (liNode.parentNode.nodeName === 'OL') ? 'OL' : 'UL';
        list = liNode.ownerDocument.createElement(listTag);
        prevLi = wysihtml5.dom.domNode(liNode).prev({nodeTypes: [wysihtml5.ELEMENT_NODE]});
        prevLiList = (prevLi) ? prevLi.querySelector('ul, ol') : null;

        if (prevLi) {
          if (prevLiList) {
            prevLiList.appendChild(liNode);
          } else {
            list.appendChild(liNode);
            prevLi.appendChild(list);
          }
          found = true;
        }
      }

    });
    return found;
  }
};
;wysihtml5.commands.outdentList = {
  exec: function(composer, command, value) {
    var listEls = composer.selection.getSelectionParentsByTag('LI');
    if (listEls) {
      return this.tryToPullLiLevel(listEls, composer);
    }
    return false;
  },

  state: function(composer, command) {
      return false;
  },

  tryToPullLiLevel: function(liNodes, composer) {
    var listNode, outerListNode, outerLiNode, list, prevLi, liNode, afterList,
        found = false,
        that = this;

    composer.selection.executeAndRestoreRangy(function() {

      for (var i = liNodes.length; i--;) {
        liNode = liNodes[i];
        if (liNode.parentNode) {
          listNode = liNode.parentNode;

          if (listNode.tagName === 'OL' || listNode.tagName === 'UL') {
            found = true;

            outerListNode = wysihtml5.dom.getParentElement(listNode.parentNode, { nodeName: ['OL', 'UL']}, false, composer.element);
            outerLiNode = wysihtml5.dom.getParentElement(listNode.parentNode, { nodeName: ['LI']}, false, composer.element);

            if (outerListNode && outerLiNode) {

              if (liNode.nextSibling) {
                afterList = that.getAfterList(listNode, liNode);
                liNode.appendChild(afterList);
              }
              outerListNode.insertBefore(liNode, outerLiNode.nextSibling);

            } else {

              if (liNode.nextSibling) {
                afterList = that.getAfterList(listNode, liNode);
                liNode.appendChild(afterList);
              }

              for (var j = liNode.childNodes.length; j--;) {
                listNode.parentNode.insertBefore(liNode.childNodes[j], listNode.nextSibling);
              }

              listNode.parentNode.insertBefore(document.createElement('br'), listNode.nextSibling);
              liNode.parentNode.removeChild(liNode);

            }

            // cleanup
            if (listNode.childNodes.length === 0) {
                listNode.parentNode.removeChild(listNode);
            }
          }
        }
      }

    });
    return found;
  },

  getAfterList: function(listNode, liNode) {
    var nodeName = listNode.nodeName,
        newList = document.createElement(nodeName);

    while (liNode.nextSibling) {
      newList.appendChild(liNode.nextSibling);
    }
    return newList;
  }

};;/**
 * Undo Manager for wysihtml5
 * slightly inspired by http://rniwa.com/editing/undomanager.html#the-undomanager-interface
 */
(function(wysihtml5) {
  var Z_KEY               = 90,
      Y_KEY               = 89,
      BACKSPACE_KEY       = 8,
      DELETE_KEY          = 46,
      MAX_HISTORY_ENTRIES = 25,
      DATA_ATTR_NODE      = "data-wysihtml5-selection-node",
      DATA_ATTR_OFFSET    = "data-wysihtml5-selection-offset",
      UNDO_HTML           = '<span id="_wysihtml5-undo" class="_wysihtml5-temp">' + wysihtml5.INVISIBLE_SPACE + '</span>',
      REDO_HTML           = '<span id="_wysihtml5-redo" class="_wysihtml5-temp">' + wysihtml5.INVISIBLE_SPACE + '</span>',
      dom                 = wysihtml5.dom;

  function cleanTempElements(doc) {
    var tempElement;
    while (tempElement = doc.querySelector("._wysihtml5-temp")) {
      tempElement.parentNode.removeChild(tempElement);
    }
  }

  wysihtml5.UndoManager = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.UndoManager.prototype */ {
    constructor: function(editor) {
      this.editor = editor;
      this.composer = editor.composer;
      this.element = this.composer.element;

      this.position = 0;
      this.historyStr = [];
      this.historyDom = [];

      this.transact();

      this._observe();
    },

    _observe: function() {
      var that      = this,
          doc       = this.composer.sandbox.getDocument(),
          lastKey;

      // Catch CTRL+Z and CTRL+Y
      dom.observe(this.element, "keydown", function(event) {
        if (event.altKey || (!event.ctrlKey && !event.metaKey)) {
          return;
        }

        var keyCode = event.keyCode,
            isUndo = keyCode === Z_KEY && !event.shiftKey,
            isRedo = (keyCode === Z_KEY && event.shiftKey) || (keyCode === Y_KEY);

        if (isUndo) {
          that.undo();
          event.preventDefault();
        } else if (isRedo) {
          that.redo();
          event.preventDefault();
        }
      });

      // Catch delete and backspace
      dom.observe(this.element, "keydown", function(event) {
        var keyCode = event.keyCode;
        if (keyCode === lastKey) {
          return;
        }

        lastKey = keyCode;

        if (keyCode === BACKSPACE_KEY || keyCode === DELETE_KEY) {
          that.transact();
        }
      });

      this.editor
        .on("newword:composer", function() {
          that.transact();
        })

        .on("beforecommand:composer", function() {
          that.transact();
        });
    },

    transact: function() {
      var previousHtml      = this.historyStr[this.position - 1],
          currentHtml       = this.composer.getValue(false, false),
          composerIsVisible   = this.element.offsetWidth > 0 && this.element.offsetHeight > 0,
          range, node, offset, element, position;

      if (currentHtml === previousHtml) {
        return;
      }

      var length = this.historyStr.length = this.historyDom.length = this.position;
      if (length > MAX_HISTORY_ENTRIES) {
        this.historyStr.shift();
        this.historyDom.shift();
        this.position--;
      }

      this.position++;

      if (composerIsVisible) {
        // Do not start saving selection if composer is not visible
        range   = this.composer.selection.getRange();
        node    = (range && range.startContainer) ? range.startContainer : this.element;
        offset  = (range && range.startOffset) ? range.startOffset : 0;

        if (node.nodeType === wysihtml5.ELEMENT_NODE) {
          element = node;
        } else {
          element  = node.parentNode;
          position = this.getChildNodeIndex(element, node);
        }

        element.setAttribute(DATA_ATTR_OFFSET, offset);
        if (typeof(position) !== "undefined") {
          element.setAttribute(DATA_ATTR_NODE, position);
        }
      }

      var clone = this.element.cloneNode(!!currentHtml);
      this.historyDom.push(clone);
      this.historyStr.push(currentHtml);

      if (element) {
        element.removeAttribute(DATA_ATTR_OFFSET);
        element.removeAttribute(DATA_ATTR_NODE);
      }

    },

    undo: function() {
      this.transact();

      if (!this.undoPossible()) {
        return;
      }

      this.set(this.historyDom[--this.position - 1]);
      this.editor.fire("undo:composer");
    },

    redo: function() {
      if (!this.redoPossible()) {
        return;
      }

      this.set(this.historyDom[++this.position - 1]);
      this.editor.fire("redo:composer");
    },

    undoPossible: function() {
      return this.position > 1;
    },

    redoPossible: function() {
      return this.position < this.historyStr.length;
    },

    set: function(historyEntry) {
      this.element.innerHTML = "";

      var i = 0,
          childNodes = historyEntry.childNodes,
          length = historyEntry.childNodes.length;

      for (; i<length; i++) {
        this.element.appendChild(childNodes[i].cloneNode(true));
      }

      // Restore selection
      var offset,
          node,
          position;

      if (historyEntry.hasAttribute(DATA_ATTR_OFFSET)) {
        offset    = historyEntry.getAttribute(DATA_ATTR_OFFSET);
        position  = historyEntry.getAttribute(DATA_ATTR_NODE);
        node      = this.element;
      } else {
        node      = this.element.querySelector("[" + DATA_ATTR_OFFSET + "]") || this.element;
        offset    = node.getAttribute(DATA_ATTR_OFFSET);
        position  = node.getAttribute(DATA_ATTR_NODE);
        node.removeAttribute(DATA_ATTR_OFFSET);
        node.removeAttribute(DATA_ATTR_NODE);
      }

      if (position !== null) {
        node = this.getChildNodeByIndex(node, +position);
      }

      this.composer.selection.set(node, offset);
    },

    getChildNodeIndex: function(parent, child) {
      var i           = 0,
          childNodes  = parent.childNodes,
          length      = childNodes.length;
      for (; i<length; i++) {
        if (childNodes[i] === child) {
          return i;
        }
      }
    },

    getChildNodeByIndex: function(parent, index) {
      return parent.childNodes[index];
    }
  });
})(wysihtml5);
;/**
 * TODO: the following methods still need unit test coverage
 */
wysihtml5.views.View = Base.extend(
  /** @scope wysihtml5.views.View.prototype */ {
  constructor: function(parent, textareaElement, config) {
    this.parent   = parent;
    this.element  = textareaElement;
    this.config   = config;
    if (!this.config.noTextarea) {
        this._observeViewChange();
    }
  },

  _observeViewChange: function() {
    var that = this;
    this.parent.on("beforeload", function() {
      that.parent.on("change_view", function(view) {
        if (view === that.name) {
          that.parent.currentView = that;
          that.show();
          // Using tiny delay here to make sure that the placeholder is set before focusing
          setTimeout(function() { that.focus(); }, 0);
        } else {
          that.hide();
        }
      });
    });
  },

  focus: function() {
    if (this.element.ownerDocument.querySelector(":focus") === this.element) {
      return;
    }

    try { this.element.focus(); } catch(e) {}
  },

  hide: function() {
    this.element.style.display = "none";
  },

  show: function() {
    this.element.style.display = "";
  },

  disable: function() {
    this.element.setAttribute("disabled", "disabled");
  },

  enable: function() {
    this.element.removeAttribute("disabled");
  }
});
;(function(wysihtml5) {
  var dom       = wysihtml5.dom,
      browser   = wysihtml5.browser;

  wysihtml5.views.Composer = wysihtml5.views.View.extend(
    /** @scope wysihtml5.views.Composer.prototype */ {
    name: "composer",

    // Needed for firefox in order to display a proper caret in an empty contentEditable
    CARET_HACK: "<br>",

    constructor: function(parent, editableElement, config) {
      this.base(parent, editableElement, config);
      if (!this.config.noTextarea) {
          this.textarea = this.parent.textarea;
      } else {
          this.editableArea = editableElement;
      }
      if (this.config.contentEditableMode) {
          this._initContentEditableArea();
      } else {
          this._initSandbox();
      }
    },

    clear: function() {
      this.element.innerHTML = browser.displaysCaretInEmptyContentEditableCorrectly() ? "" : this.CARET_HACK;
    },

    getValue: function(parse, clearInternals) {
      var value = this.isEmpty() ? "" : wysihtml5.quirks.getCorrectInnerHTML(this.element);
      if (parse !== false) {
        value = this.parent.parse(value, (clearInternals === false) ? false : true);
      }

      return value;
    },

    setValue: function(html, parse) {
      if (parse) {
        html = this.parent.parse(html);
      }

      try {
        this.element.innerHTML = html;
      } catch (e) {
        this.element.innerText = html;
      }
    },

    cleanUp: function() {
        this.parent.parse(this.element);
    },

    show: function() {
      this.editableArea.style.display = this._displayStyle || "";

      if (!this.config.noTextarea && !this.textarea.element.disabled) {
        // Firefox needs this, otherwise contentEditable becomes uneditable
        this.disable();
        this.enable();
      }
    },

    hide: function() {
      this._displayStyle = dom.getStyle("display").from(this.editableArea);
      if (this._displayStyle === "none") {
        this._displayStyle = null;
      }
      this.editableArea.style.display = "none";
    },

    disable: function() {
      this.parent.fire("disable:composer");
      this.element.removeAttribute("contentEditable");
    },

    enable: function() {
      this.parent.fire("enable:composer");
      this.element.setAttribute("contentEditable", "true");
    },

    focus: function(setToEnd) {
      // IE 8 fires the focus event after .focus()
      // This is needed by our simulate_placeholder.js to work
      // therefore we clear it ourselves this time
      if (wysihtml5.browser.doesAsyncFocus() && this.hasPlaceholderSet()) {
        this.clear();
      }

      this.base();

      var lastChild = this.element.lastChild;
      if (setToEnd && lastChild && this.selection) {
        if (lastChild.nodeName === "BR") {
          this.selection.setBefore(this.element.lastChild);
        } else {
          this.selection.setAfter(this.element.lastChild);
        }
      }
    },

    getTextContent: function() {
      return dom.getTextContent(this.element);
    },

    hasPlaceholderSet: function() {
      return this.getTextContent() == ((this.config.noTextarea) ? this.editableArea.getAttribute("data-placeholder") : this.textarea.element.getAttribute("placeholder")) && this.placeholderSet;
    },

    isEmpty: function() {
      var innerHTML = this.element.innerHTML.toLowerCase();
      return (/^(\s|<br>|<\/br>|<p>|<\/p>)*$/i).test(innerHTML)  ||
             innerHTML === ""            ||
             innerHTML === "<br>"        ||
             innerHTML === "<p></p>"     ||
             innerHTML === "<p><br></p>" ||
             this.hasPlaceholderSet();
    },

    _initContentEditableArea: function() {
        var that = this;

        if (this.config.noTextarea) {
            this.sandbox = new dom.ContentEditableArea(function() {
                that._create();
            }, {}, this.editableArea);
        } else {
            this.sandbox = new dom.ContentEditableArea(function() {
                that._create();
            });
            this.editableArea = this.sandbox.getContentEditable();
            dom.insert(this.editableArea).after(this.textarea.element);
            this._createWysiwygFormField();
        }
    },

    _initSandbox: function() {
      var that = this;

      this.sandbox = new dom.Sandbox(function() {
        that._create();
      }, {
        stylesheets:  this.config.stylesheets
      });
      this.editableArea  = this.sandbox.getIframe();

      var textareaElement = this.textarea.element;
      dom.insert(this.editableArea).after(textareaElement);

      this._createWysiwygFormField();
    },

    // Creates hidden field which tells the server after submit, that the user used an wysiwyg editor
    _createWysiwygFormField: function() {
        if (this.textarea.element.form) {
          var hiddenField = document.createElement("input");
          hiddenField.type   = "hidden";
          hiddenField.name   = "_wysihtml5_mode";
          hiddenField.value  = 1;
          dom.insert(hiddenField).after(this.textarea.element);
        }
    },

    _create: function() {
      var that = this;
      this.doc                = this.sandbox.getDocument();
      this.element            = (this.config.contentEditableMode) ? this.sandbox.getContentEditable() : this.doc.body;
      if (!this.config.noTextarea) {
          this.textarea           = this.parent.textarea;
          this.element.innerHTML  = this.textarea.getValue(true, false);
      } else {
          this.cleanUp(); // cleans contenteditable on initiation as it may contain html
      }

      // Make sure our selection handler is ready
      this.selection = new wysihtml5.Selection(this.parent, this.element, this.config.uneditableContainerClassname);

      // Make sure commands dispatcher is ready
      this.commands  = new wysihtml5.Commands(this.parent);

      if (!this.config.noTextarea) {
          dom.copyAttributes([
              "className", "spellcheck", "title", "lang", "dir", "accessKey"
          ]).from(this.textarea.element).to(this.element);
      }

      dom.addClass(this.element, this.config.composerClassName);
      //
      // Make the editor look like the original textarea, by syncing styles
      if (this.config.style && !this.config.contentEditableMode) {
        this.style();
      }

      this.observe();

      var name = this.config.name;
      if (name) {
        dom.addClass(this.element, name);
        if (!this.config.contentEditableMode) { dom.addClass(this.editableArea, name); }
      }

      this.enable();

      if (!this.config.noTextarea && this.textarea.element.disabled) {
        this.disable();
      }

      // Simulate html5 placeholder attribute on contentEditable element
      var placeholderText = typeof(this.config.placeholder) === "string"
        ? this.config.placeholder
        : ((this.config.noTextarea) ? this.editableArea.getAttribute("data-placeholder") : this.textarea.element.getAttribute("placeholder"));
      if (placeholderText) {
        dom.simulatePlaceholder(this.parent, this, placeholderText);
      }

      // Make sure that the browser avoids using inline styles whenever possible
      this.commands.exec("styleWithCSS", false);

      this._initAutoLinking();
      this._initObjectResizing();
      this._initUndoManager();
      this._initLineBreaking();

      // Simulate html5 autofocus on contentEditable element
      // This doesn't work on IOS (5.1.1)
      if (!this.config.noTextarea && (this.textarea.element.hasAttribute("autofocus") || document.querySelector(":focus") == this.textarea.element) && !browser.isIos()) {
        setTimeout(function() { that.focus(true); }, 100);
      }

      // IE sometimes leaves a single paragraph, which can't be removed by the user
      if (!browser.clearsContentEditableCorrectly()) {
        wysihtml5.quirks.ensureProperClearing(this);
      }

      // Set up a sync that makes sure that textarea and editor have the same content
      if (this.initSync && this.config.sync) {
        this.initSync();
      }

      // Okay hide the textarea, we are ready to go
      if (!this.config.noTextarea) { this.textarea.hide(); }

      // Fire global (before-)load event
      this.parent.fire("beforeload").fire("load");
    },

    _initAutoLinking: function() {
      var that                           = this,
          supportsDisablingOfAutoLinking = browser.canDisableAutoLinking(),
          supportsAutoLinking            = browser.doesAutoLinkingInContentEditable();
      if (supportsDisablingOfAutoLinking) {
        this.commands.exec("autoUrlDetect", false);
      }

      if (!this.config.autoLink) {
        return;
      }

      // Only do the auto linking by ourselves when the browser doesn't support auto linking
      // OR when he supports auto linking but we were able to turn it off (IE9+)
      if (!supportsAutoLinking || (supportsAutoLinking && supportsDisablingOfAutoLinking)) {
        this.parent.on("newword:composer", function() {
          if (dom.getTextContent(that.element).match(dom.autoLink.URL_REG_EXP)) {
            that.selection.executeAndRestore(function(startContainer, endContainer) {
              var uneditables = that.element.querySelectorAll("." + that.config.uneditableContainerClassname),
                  isInUneditable = false;

              for (var i = uneditables.length; i--;) {
                if (wysihtml5.dom.contains(uneditables[i], endContainer)) {
                  isInUneditable = true;
                }
              }

              if (!isInUneditable) dom.autoLink(endContainer.parentNode, [that.config.uneditableContainerClassname]);
            });
          }
        });

        dom.observe(this.element, "blur", function() {
          dom.autoLink(that.element, [that.config.uneditableContainerClassname]);
        });
      }

      // Assuming we have the following:
      //  <a href="http://www.google.de">http://www.google.de</a>
      // If a user now changes the url in the innerHTML we want to make sure that
      // it's synchronized with the href attribute (as long as the innerHTML is still a url)
      var // Use a live NodeList to check whether there are any links in the document
          links           = this.sandbox.getDocument().getElementsByTagName("a"),
          // The autoLink helper method reveals a reg exp to detect correct urls
          urlRegExp       = dom.autoLink.URL_REG_EXP,
          getTextContent  = function(element) {
            var textContent = wysihtml5.lang.string(dom.getTextContent(element)).trim();
            if (textContent.substr(0, 4) === "www.") {
              textContent = "http://" + textContent;
            }
            return textContent;
          };

      dom.observe(this.element, "keydown", function(event) {
        if (!links.length) {
          return;
        }

        var selectedNode = that.selection.getSelectedNode(event.target.ownerDocument),
            link         = dom.getParentElement(selectedNode, { nodeName: "A" }, 4),
            textContent;

        if (!link) {
          return;
        }

        textContent = getTextContent(link);
        // keydown is fired before the actual content is changed
        // therefore we set a timeout to change the href
        setTimeout(function() {
          var newTextContent = getTextContent(link);
          if (newTextContent === textContent) {
            return;
          }

          // Only set href when new href looks like a valid url
          if (newTextContent.match(urlRegExp)) {
            link.setAttribute("href", newTextContent);
          }
        }, 0);
      });
    },

    _initObjectResizing: function() {
      this.commands.exec("enableObjectResizing", true);

      // IE sets inline styles after resizing objects
      // The following lines make sure that the width/height css properties
      // are copied over to the width/height attributes
      if (browser.supportsEvent("resizeend")) {
        var properties        = ["width", "height"],
            propertiesLength  = properties.length,
            element           = this.element;

        dom.observe(element, "resizeend", function(event) {
          var target = event.target || event.srcElement,
              style  = target.style,
              i      = 0,
              property;

          if (target.nodeName !== "IMG") {
            return;
          }

          for (; i<propertiesLength; i++) {
            property = properties[i];
            if (style[property]) {
              target.setAttribute(property, parseInt(style[property], 10));
              style[property] = "";
            }
          }

          // After resizing IE sometimes forgets to remove the old resize handles
          wysihtml5.quirks.redraw(element);
        });
      }
    },

    _initUndoManager: function() {
      this.undoManager = new wysihtml5.UndoManager(this.parent);
    },

    _initLineBreaking: function() {
      var that                              = this,
          USE_NATIVE_LINE_BREAK_INSIDE_TAGS = ["LI", "P", "H1", "H2", "H3", "H4", "H5", "H6"],
          LIST_TAGS                         = ["UL", "OL", "MENU"];

      function adjust(selectedNode) {
        var parentElement = dom.getParentElement(selectedNode, { nodeName: ["P", "DIV"] }, 2);
        if (parentElement && dom.contains(that.element, parentElement)) {
          that.selection.executeAndRestore(function() {
            if (that.config.useLineBreaks) {
              dom.replaceWithChildNodes(parentElement);
            } else if (parentElement.nodeName !== "P") {
              dom.renameElement(parentElement, "p");
            }
          });
        }
      }

      if (!this.config.useLineBreaks) {
        dom.observe(this.element, ["focus", "keydown"], function() {
          if (that.isEmpty()) {
            var paragraph = that.doc.createElement("P");
            that.element.innerHTML = "";
            that.element.appendChild(paragraph);
            if (!browser.displaysCaretInEmptyContentEditableCorrectly()) {
              paragraph.innerHTML = "<br>";
              that.selection.setBefore(paragraph.firstChild);
            } else {
              that.selection.selectNode(paragraph, true);
            }
          }
        });
      }

      // Under certain circumstances Chrome + Safari create nested <p> or <hX> tags after paste
      // Inserting an invisible white space in front of it fixes the issue
      // This is too hacky and causes selection not to replace content on paste in chrome
     /* if (browser.createsNestedInvalidMarkupAfterPaste()) {
        dom.observe(this.element, "paste", function(event) {
          var invisibleSpace = that.doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
          that.selection.insertNode(invisibleSpace);
        });
      }*/


      dom.observe(this.element, "keydown", function(event) {
        var keyCode = event.keyCode;

        if (event.shiftKey) {
          return;
        }

        if (keyCode !== wysihtml5.ENTER_KEY && keyCode !== wysihtml5.BACKSPACE_KEY) {
          return;
        }
        var blockElement = dom.getParentElement(that.selection.getSelectedNode(), { nodeName: USE_NATIVE_LINE_BREAK_INSIDE_TAGS }, 4);
        if (blockElement) {
          setTimeout(function() {
            // Unwrap paragraph after leaving a list or a H1-6
            var selectedNode = that.selection.getSelectedNode(),
                list;

            if (blockElement.nodeName === "LI") {
              if (!selectedNode) {
                return;
              }

              list = dom.getParentElement(selectedNode, { nodeName: LIST_TAGS }, 2);

              if (!list) {
                adjust(selectedNode);
              }
            }

            if (keyCode === wysihtml5.ENTER_KEY && blockElement.nodeName.match(/^H[1-6]$/)) {
              adjust(selectedNode);
            }
          }, 0);
          return;
        }

        if (that.config.useLineBreaks && keyCode === wysihtml5.ENTER_KEY && !wysihtml5.browser.insertsLineBreaksOnReturn()) {
          event.preventDefault();
          that.commands.exec("insertLineBreak");

        }
      });
    }
  });
})(wysihtml5);
;(function(wysihtml5) {
  var dom             = wysihtml5.dom,
      doc             = document,
      win             = window,
      HOST_TEMPLATE   = doc.createElement("div"),
      /**
       * Styles to copy from textarea to the composer element
       */
      TEXT_FORMATTING = [
        "background-color",
        "color", "cursor",
        "font-family", "font-size", "font-style", "font-variant", "font-weight",
        "line-height", "letter-spacing",
        "text-align", "text-decoration", "text-indent", "text-rendering",
        "word-break", "word-wrap", "word-spacing"
      ],
      /**
       * Styles to copy from textarea to the iframe
       */
      BOX_FORMATTING = [
        "background-color",
        "border-collapse",
        "border-bottom-color", "border-bottom-style", "border-bottom-width",
        "border-left-color", "border-left-style", "border-left-width",
        "border-right-color", "border-right-style", "border-right-width",
        "border-top-color", "border-top-style", "border-top-width",
        "clear", "display", "float",
        "margin-bottom", "margin-left", "margin-right", "margin-top",
        "outline-color", "outline-offset", "outline-width", "outline-style",
        "padding-left", "padding-right", "padding-top", "padding-bottom",
        "position", "top", "left", "right", "bottom", "z-index",
        "vertical-align", "text-align",
        "-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing",
        "-webkit-box-shadow", "-moz-box-shadow", "-ms-box-shadow","box-shadow",
        "-webkit-border-top-right-radius", "-moz-border-radius-topright", "border-top-right-radius",
        "-webkit-border-bottom-right-radius", "-moz-border-radius-bottomright", "border-bottom-right-radius",
        "-webkit-border-bottom-left-radius", "-moz-border-radius-bottomleft", "border-bottom-left-radius",
        "-webkit-border-top-left-radius", "-moz-border-radius-topleft", "border-top-left-radius",
        "width", "height"
      ],
      ADDITIONAL_CSS_RULES = [
        "html                 { height: 100%; }",
        "body                 { height: 100%; padding: 1px 0 0 0; margin: -1px 0 0 0; }",
        "body > p:first-child { margin-top: 0; }",
        "._wysihtml5-temp     { display: none; }",
        wysihtml5.browser.isGecko ?
          "body.placeholder { color: graytext !important; }" :
          "body.placeholder { color: #a9a9a9 !important; }",
        // Ensure that user see's broken images and can delete them
        "img:-moz-broken      { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }"
      ];

  /**
   * With "setActive" IE offers a smart way of focusing elements without scrolling them into view:
   * http://msdn.microsoft.com/en-us/library/ms536738(v=vs.85).aspx
   *
   * Other browsers need a more hacky way: (pssst don't tell my mama)
   * In order to prevent the element being scrolled into view when focusing it, we simply
   * move it out of the scrollable area, focus it, and reset it's position
   */
  var focusWithoutScrolling = function(element) {
    if (element.setActive) {
      // Following line could cause a js error when the textarea is invisible
      // See https://github.com/xing/wysihtml5/issues/9
      try { element.setActive(); } catch(e) {}
    } else {
      var elementStyle = element.style,
          originalScrollTop = doc.documentElement.scrollTop || doc.body.scrollTop,
          originalScrollLeft = doc.documentElement.scrollLeft || doc.body.scrollLeft,
          originalStyles = {
            position:         elementStyle.position,
            top:              elementStyle.top,
            left:             elementStyle.left,
            WebkitUserSelect: elementStyle.WebkitUserSelect
          };

      dom.setStyles({
        position:         "absolute",
        top:              "-99999px",
        left:             "-99999px",
        // Don't ask why but temporarily setting -webkit-user-select to none makes the whole thing performing smoother
        WebkitUserSelect: "none"
      }).on(element);

      element.focus();

      dom.setStyles(originalStyles).on(element);

      if (win.scrollTo) {
        // Some browser extensions unset this method to prevent annoyances
        // "Better PopUp Blocker" for Chrome http://code.google.com/p/betterpopupblocker/source/browse/trunk/blockStart.js#100
        // Issue: http://code.google.com/p/betterpopupblocker/issues/detail?id=1
        win.scrollTo(originalScrollLeft, originalScrollTop);
      }
    }
  };


  wysihtml5.views.Composer.prototype.style = function() {
    var that                  = this,
        originalActiveElement = doc.querySelector(":focus"),
        textareaElement       = this.textarea.element,
        hasPlaceholder        = textareaElement.hasAttribute("placeholder"),
        originalPlaceholder   = hasPlaceholder && textareaElement.getAttribute("placeholder"),
        originalDisplayValue  = textareaElement.style.display,
        originalDisabled      = textareaElement.disabled,
        displayValueForCopying;

    this.focusStylesHost      = HOST_TEMPLATE.cloneNode(false);
    this.blurStylesHost       = HOST_TEMPLATE.cloneNode(false);
    this.disabledStylesHost   = HOST_TEMPLATE.cloneNode(false);

    // Remove placeholder before copying (as the placeholder has an affect on the computed style)
    if (hasPlaceholder) {
      textareaElement.removeAttribute("placeholder");
    }

    if (textareaElement === originalActiveElement) {
      textareaElement.blur();
    }

    // enable for copying styles
    textareaElement.disabled = false;

    // set textarea to display="none" to get cascaded styles via getComputedStyle
    textareaElement.style.display = displayValueForCopying = "none";

    if ((textareaElement.getAttribute("rows") && dom.getStyle("height").from(textareaElement) === "auto") ||
        (textareaElement.getAttribute("cols") && dom.getStyle("width").from(textareaElement) === "auto")) {
      textareaElement.style.display = displayValueForCopying = originalDisplayValue;
    }

    // --------- iframe styles (has to be set before editor styles, otherwise IE9 sets wrong fontFamily on blurStylesHost) ---------
    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.editableArea).andTo(this.blurStylesHost);

    // --------- editor styles ---------
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.element).andTo(this.blurStylesHost);

    // --------- apply standard rules ---------
    dom.insertCSS(ADDITIONAL_CSS_RULES).into(this.element.ownerDocument);

    // --------- :disabled styles ---------
    textareaElement.disabled = true;
    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.disabledStylesHost);
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.disabledStylesHost);
    textareaElement.disabled = originalDisabled;

    // --------- :focus styles ---------
    textareaElement.style.display = originalDisplayValue;
    focusWithoutScrolling(textareaElement);
    textareaElement.style.display = displayValueForCopying;

    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.focusStylesHost);
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.focusStylesHost);

    // reset textarea
    textareaElement.style.display = originalDisplayValue;

    dom.copyStyles(["display"]).from(textareaElement).to(this.editableArea);

    // Make sure that we don't change the display style of the iframe when copying styles oblur/onfocus
    // this is needed for when the change_view event is fired where the iframe is hidden and then
    // the blur event fires and re-displays it
    var boxFormattingStyles = wysihtml5.lang.array(BOX_FORMATTING).without(["display"]);

    // --------- restore focus ---------
    if (originalActiveElement) {
      originalActiveElement.focus();
    } else {
      textareaElement.blur();
    }

    // --------- restore placeholder ---------
    if (hasPlaceholder) {
      textareaElement.setAttribute("placeholder", originalPlaceholder);
    }

    // --------- Sync focus/blur styles ---------
    this.parent.on("focus:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.focusStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.focusStylesHost).to(that.element);
    });

    this.parent.on("blur:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.blurStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.blurStylesHost).to(that.element);
    });

    this.parent.observe("disable:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.disabledStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.disabledStylesHost).to(that.element);
    });

    this.parent.observe("enable:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.blurStylesHost).to(that.editableArea);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.blurStylesHost).to(that.element);
    });

    return this;
  };
})(wysihtml5);
;/**
 * Taking care of events
 *  - Simulating 'change' event on contentEditable element
 *  - Handling drag & drop logic
 *  - Catch paste events
 *  - Dispatch proprietary newword:composer event
 *  - Keyboard shortcuts
 */
(function(wysihtml5) {
  var dom       = wysihtml5.dom,
      browser   = wysihtml5.browser,
      /**
       * Map keyCodes to query commands
       */
      shortcuts = {
        "66": "bold",     // B
        "73": "italic",   // I
        "85": "underline" // U
      };

  var deleteAroundEditable = function(selection, uneditable, element) {
    // merge node with previous node from uneditable
    var prevNode = selection.getPreviousNode(uneditable, true),
        curNode = selection.getSelectedNode();

    if (curNode.nodeType !== 1 && curNode.parentNode !== element) { curNode = curNode.parentNode; }
    if (prevNode) {
      if (curNode.nodeType == 1) {
        var first = curNode.firstChild;

        if (prevNode.nodeType == 1) {
          while (curNode.firstChild) {
            prevNode.appendChild(curNode.firstChild);
          }
        } else {
          while (curNode.firstChild) {
            uneditable.parentNode.insertBefore(curNode.firstChild, uneditable);
          }
        }
        if (curNode.parentNode) {
          curNode.parentNode.removeChild(curNode);
        }
        selection.setBefore(first);
      } else {
        if (prevNode.nodeType == 1) {
          prevNode.appendChild(curNode);
        } else {
          uneditable.parentNode.insertBefore(curNode, uneditable);
        }
        selection.setBefore(curNode);
      }
    }
  };

  var handleDeleteKeyPress = function(event, selection, element, composer) {
    if (selection.isCollapsed()) {
      if (selection.caretIsInTheBeginnig('LI')) {
        event.preventDefault();
        composer.commands.exec('outdentList');
      } else if (selection.caretIsInTheBeginnig()) {
        event.preventDefault();
      } else {

        if (selection.caretIsFirstInSelection() &&
            selection.getPreviousNode() &&
            selection.getPreviousNode().nodeName &&
            (/^H\d$/gi).test(selection.getPreviousNode().nodeName)
        ) {
          var prevNode = selection.getPreviousNode();
          event.preventDefault();
          if ((/^\s*$/).test(prevNode.textContent || prevNode.innerText)) {
            // heading is empty
            prevNode.parentNode.removeChild(prevNode);
          } else {
            var range = prevNode.ownerDocument.createRange();
            range.selectNodeContents(prevNode);
            range.collapse(false);
            selection.setSelection(range);
          }
        }

        var beforeUneditable = selection.caretIsBeforeUneditable();
        // Do a special delete if caret would delete uneditable
        if (beforeUneditable) {
          event.preventDefault();
          deleteAroundEditable(selection, beforeUneditable, element);
        }
      }
    } else {
      if (selection.containsUneditable()) {
        event.preventDefault();
        selection.deleteContents();
      }
    }
  };

  var handleTabKeyDown = function(composer, element) {
    if (!composer.selection.isCollapsed()) {
      composer.selection.deleteContents();
    } else if (composer.selection.caretIsInTheBeginnig('LI')) {
      if (composer.commands.exec('indentList')) return;
    }

    // Is &emsp; close enough to tab. Could not find enough counter arguments for now.
    composer.commands.exec("insertHTML", "&emsp;");
  };

  wysihtml5.views.Composer.prototype.observe = function() {
    var that                = this,
        state               = this.getValue(false, false),
        container           = (this.sandbox.getIframe) ? this.sandbox.getIframe() : this.sandbox.getContentEditable(),
        element             = this.element,
        focusBlurElement    = (browser.supportsEventsInIframeCorrectly() || this.sandbox.getContentEditable) ? element : this.sandbox.getWindow(),
        pasteEvents         = ["drop", "paste", "beforepaste"],
        interactionEvents   = ["drop", "paste", "mouseup", "focus", "keyup"];

    // --------- destroy:composer event ---------
    dom.observe(container, "DOMNodeRemoved", function() {
      clearInterval(domNodeRemovedInterval);
      that.parent.fire("destroy:composer");
    });

    // DOMNodeRemoved event is not supported in IE 8
    if (!browser.supportsMutationEvents()) {
        var domNodeRemovedInterval = setInterval(function() {
          if (!dom.contains(document.documentElement, container)) {
            clearInterval(domNodeRemovedInterval);
            that.parent.fire("destroy:composer");
          }
        }, 250);
    }

    // --------- User interaction tracking --

    dom.observe(focusBlurElement, interactionEvents, function() {
      setTimeout(function() {
        that.parent.fire("interaction").fire("interaction:composer");
      }, 0);
    });


    if (this.config.handleTables) {
      if(!this.tableClickHandle && this.doc.execCommand && wysihtml5.browser.supportsCommand(this.doc, "enableObjectResizing") && wysihtml5.browser.supportsCommand(this.doc, "enableInlineTableEditing")) {
        if (this.sandbox.getIframe) {
          this.tableClickHandle = dom.observe(container , ["focus", "mouseup", "mouseover"], function() {
            that.doc.execCommand("enableObjectResizing", false, "false");
            that.doc.execCommand("enableInlineTableEditing", false, "false");
            that.tableClickHandle.stop();
          });
        } else {
          setTimeout(function() {
            that.doc.execCommand("enableObjectResizing", false, "false");
            that.doc.execCommand("enableInlineTableEditing", false, "false");
          }, 0);
        }
      }
      this.tableSelection = wysihtml5.quirks.tableCellsSelection(element, that.parent);
    }

    // --------- Focus & blur logic ---------
    dom.observe(focusBlurElement, "focus", function(event) {
      that.parent.fire("focus", event).fire("focus:composer", event);

      // Delay storing of state until all focus handler are fired
      // especially the one which resets the placeholder
      setTimeout(function() { state = that.getValue(false, false); }, 0);
    });

    dom.observe(focusBlurElement, "blur", function(event) {
      if (state !== that.getValue(false, false)) {
        //create change event if supported (all except IE8)
        var changeevent = event;
        if(typeof Object.create == 'function') {
          changeevent = Object.create(event, { type: { value: 'change' } });
        }
        that.parent.fire("change", changeevent).fire("change:composer", changeevent);
      }
      that.parent.fire("blur", event).fire("blur:composer", event);
    });

    // --------- Drag & Drop logic ---------
    dom.observe(element, "dragenter", function() {
      that.parent.fire("unset_placeholder");
    });

    dom.observe(element, pasteEvents, function(event) {
      that.parent.fire(event.type, event).fire(event.type + ":composer", event);
    });


    if (this.config.copyedFromMarking) {
      // If supported the copied source is based directly on selection
      // Very useful for webkit based browsers where copy will otherwise contain a lot of code and styles based on whatever and not actually in selection.
      dom.observe(element, "copy", function(event) {
        if (event.clipboardData) {
          event.clipboardData.setData("text/html", that.config.copyedFromMarking + that.selection.getHtml());
          event.preventDefault();
        }
        that.parent.fire(event.type, event).fire(event.type + ":composer", event);
      });
    }

    // --------- neword event ---------
    dom.observe(element, "keyup", function(event) {
      var keyCode = event.keyCode;
      if (keyCode === wysihtml5.SPACE_KEY || keyCode === wysihtml5.ENTER_KEY) {
        that.parent.fire("newword:composer");
      }
    });

    this.parent.on("paste:composer", function() {
      setTimeout(function() { that.parent.fire("newword:composer"); }, 0);
    });

    // --------- Make sure that images are selected when clicking on them ---------
    if (!browser.canSelectImagesInContentEditable()) {
      dom.observe(element, "mousedown", function(event) {
        var target = event.target;
        var allImages = element.querySelectorAll('img'),
            notMyImages = element.querySelectorAll('.' + that.config.uneditableContainerClassname + ' img'),
            myImages = wysihtml5.lang.array(allImages).without(notMyImages);

        if (target.nodeName === "IMG" && wysihtml5.lang.array(myImages).contains(target)) {
          that.selection.selectNode(target);
        }
      });
    }

    if (!browser.canSelectImagesInContentEditable()) {
        dom.observe(element, "drop", function(event) {
            // TODO: if I knew how to get dropped elements list from event I could limit it to only IMG element case
            setTimeout(function() {
                that.selection.getSelection().removeAllRanges();
            }, 0);
        });
    }

    if (browser.hasHistoryIssue() && browser.supportsSelectionModify()) {
      dom.observe(element, "keydown", function(event) {
        if (!event.metaKey && !event.ctrlKey) {
          return;
        }

        var keyCode   = event.keyCode,
            win       = element.ownerDocument.defaultView,
            selection = win.getSelection();

        if (keyCode === 37 || keyCode === 39) {
          if (keyCode === 37) {
            selection.modify("extend", "left", "lineboundary");
            if (!event.shiftKey) {
              selection.collapseToStart();
            }
          }
          if (keyCode === 39) {
            selection.modify("extend", "right", "lineboundary");
            if (!event.shiftKey) {
              selection.collapseToEnd();
            }
          }
          event.preventDefault();
        }
      });
    }

    // --------- Shortcut logic ---------
    dom.observe(element, "keydown", function(event) {
      var keyCode  = event.keyCode,
          command  = shortcuts[keyCode];
      if ((event.ctrlKey || event.metaKey) && !event.altKey && command) {
        that.commands.exec(command);
        event.preventDefault();
      }
      if (keyCode === 8) {
        // delete key
        handleDeleteKeyPress(event, that.selection, element, that);
      } else if (that.config.handleTabKey && keyCode === 9) {
        event.preventDefault();
        handleTabKeyDown(that, element);
      }
    });

    // --------- Make sure that when pressing backspace/delete on selected images deletes the image and it's anchor ---------
    dom.observe(element, "keydown", function(event) {
      var target  = that.selection.getSelectedNode(true),
          keyCode = event.keyCode,
          parent;
      if (target && target.nodeName === "IMG" && (keyCode === wysihtml5.BACKSPACE_KEY || keyCode === wysihtml5.DELETE_KEY)) { // 8 => backspace, 46 => delete
        parent = target.parentNode;
        // delete the <img>
        parent.removeChild(target);
        // and it's parent <a> too if it hasn't got any other child nodes
        if (parent.nodeName === "A" && !parent.firstChild) {
          parent.parentNode.removeChild(parent);
        }

        setTimeout(function() { wysihtml5.quirks.redraw(element); }, 0);
        event.preventDefault();
      }
    });

    // --------- IE 8+9 focus the editor when the iframe is clicked (without actually firing the 'focus' event on the <body>) ---------
    if (!this.config.contentEditableMode && browser.hasIframeFocusIssue()) {
      dom.observe(container, "focus", function() {
        setTimeout(function() {
          if (that.doc.querySelector(":focus") !== that.element) {
            that.focus();
          }
        }, 0);
      });

      dom.observe(this.element, "blur", function() {
        setTimeout(function() {
          that.selection.getSelection().removeAllRanges();
        }, 0);
      });
    }

    // --------- Show url in tooltip when hovering links or images ---------
    var titlePrefixes = {
      IMG: "Image: ",
      A:   "Link: "
    };

    dom.observe(element, "mouseover", function(event) {
      var target   = event.target,
          nodeName = target.nodeName,
          title;
      if (nodeName !== "A" && nodeName !== "IMG") {
        return;
      }
      var hasTitle = target.hasAttribute("title");
      if(!hasTitle){
        title = titlePrefixes[nodeName] + (target.getAttribute("href") || target.getAttribute("src"));
        target.setAttribute("title", title);
      }
    });
  };
})(wysihtml5);
;/**
 * Class that takes care that the value of the composer and the textarea is always in sync
 */
(function(wysihtml5) {
  var INTERVAL = 400;

  wysihtml5.views.Synchronizer = Base.extend(
    /** @scope wysihtml5.views.Synchronizer.prototype */ {

    constructor: function(editor, textarea, composer) {
      this.editor   = editor;
      this.textarea = textarea;
      this.composer = composer;

      this._observe();
    },

    /**
     * Sync html from composer to textarea
     * Takes care of placeholders
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the textarea
     */
    fromComposerToTextarea: function(shouldParseHtml) {
      this.textarea.setValue(wysihtml5.lang.string(this.composer.getValue(false, false)).trim(), shouldParseHtml);
    },

    /**
     * Sync value of textarea to composer
     * Takes care of placeholders
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer
     */
    fromTextareaToComposer: function(shouldParseHtml) {
      var textareaValue = this.textarea.getValue(false, false);
      if (textareaValue) {
        this.composer.setValue(textareaValue, shouldParseHtml);
      } else {
        this.composer.clear();
        this.editor.fire("set_placeholder");
      }
    },

    /**
     * Invoke syncing based on view state
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer/textarea
     */
    sync: function(shouldParseHtml) {
      if (this.editor.currentView.name === "textarea") {
        this.fromTextareaToComposer(shouldParseHtml);
      } else {
        this.fromComposerToTextarea(shouldParseHtml);
      }
    },

    /**
     * Initializes interval-based syncing
     * also makes sure that on-submit the composer's content is synced with the textarea
     * immediately when the form gets submitted
     */
    _observe: function() {
      var interval,
          that          = this,
          form          = this.textarea.element.form,
          startInterval = function() {
            interval = setInterval(function() { that.fromComposerToTextarea(); }, INTERVAL);
          },
          stopInterval  = function() {
            clearInterval(interval);
            interval = null;
          };

      startInterval();

      if (form) {
        // If the textarea is in a form make sure that after onreset and onsubmit the composer
        // has the correct state
        wysihtml5.dom.observe(form, "submit", function() {
          that.sync(true);
        });
        wysihtml5.dom.observe(form, "reset", function() {
          setTimeout(function() { that.fromTextareaToComposer(); }, 0);
        });
      }

      this.editor.on("change_view", function(view) {
        if (view === "composer" && !interval) {
          that.fromTextareaToComposer(true);
          startInterval();
        } else if (view === "textarea") {
          that.fromComposerToTextarea(true);
          stopInterval();
        }
      });

      this.editor.on("destroy:composer", stopInterval);
    }
  });
})(wysihtml5);
;wysihtml5.views.Textarea = wysihtml5.views.View.extend(
  /** @scope wysihtml5.views.Textarea.prototype */ {
  name: "textarea",

  constructor: function(parent, textareaElement, config) {
    this.base(parent, textareaElement, config);

    this._observe();
  },

  clear: function() {
    this.element.value = "";
  },

  getValue: function(parse) {
    var value = this.isEmpty() ? "" : this.element.value;
    if (parse !== false) {
      value = this.parent.parse(value);
    }
    return value;
  },

  setValue: function(html, parse) {
    if (parse) {
      html = this.parent.parse(html);
    }
    this.element.value = html;
  },

  cleanUp: function() {
      var html = this.parent.parse(this.element.value);
      this.element.value = html;
  },

  hasPlaceholderSet: function() {
    var supportsPlaceholder = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element),
        placeholderText     = this.element.getAttribute("placeholder") || null,
        value               = this.element.value,
        isEmpty             = !value;
    return (supportsPlaceholder && isEmpty) || (value === placeholderText);
  },

  isEmpty: function() {
    return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet();
  },

  _observe: function() {
    var element = this.element,
        parent  = this.parent,
        eventMapping = {
          focusin:  "focus",
          focusout: "blur"
        },
        /**
         * Calling focus() or blur() on an element doesn't synchronously trigger the attached focus/blur events
         * This is the case for focusin and focusout, so let's use them whenever possible, kkthxbai
         */
        events = wysihtml5.browser.supportsEvent("focusin") ? ["focusin", "focusout", "change"] : ["focus", "blur", "change"];

    parent.on("beforeload", function() {
      wysihtml5.dom.observe(element, events, function(event) {
        var eventName = eventMapping[event.type] || event.type;
        parent.fire(eventName).fire(eventName + ":textarea");
      });

      wysihtml5.dom.observe(element, ["paste", "drop"], function() {
        setTimeout(function() { parent.fire("paste").fire("paste:textarea"); }, 0);
      });
    });
  }
});
;/**
 * WYSIHTML5 Editor
 *
 * @param {Element} editableElement Reference to the textarea which should be turned into a rich text interface
 * @param {Object} [config] See defaultConfig object below for explanation of each individual config option
 *
 * @events
 *    load
 *    beforeload (for internal use only)
 *    focus
 *    focus:composer
 *    focus:textarea
 *    blur
 *    blur:composer
 *    blur:textarea
 *    change
 *    change:composer
 *    change:textarea
 *    paste
 *    paste:composer
 *    paste:textarea
 *    newword:composer
 *    destroy:composer
 *    undo:composer
 *    redo:composer
 *    beforecommand:composer
 *    aftercommand:composer
 *    enable:composer
 *    disable:composer
 *    change_view
 */
(function(wysihtml5) {
  var undef;

  var defaultConfig = {
    // Give the editor a name, the name will also be set as class name on the iframe and on the iframe's body
    name:                 undef,
    // Whether the editor should look like the textarea (by adopting styles)
    style:                true,
    // Id of the toolbar element, pass falsey value if you don't want any toolbar logic
    toolbar:              undef,
    // Whether toolbar is displayed after init by script automatically.
    // Can be set to false if toolobar is set to display only on editable area focus
    showToolbarAfterInit: true,
    // Whether urls, entered by the user should automatically become clickable-links
    autoLink:             true,
    // Includes table editing events and cell selection tracking
    handleTables:         true,
    // Tab key inserts tab into text as default behaviour. It can be disabled to regain keyboard navigation
    handleTabKey:         true,
    // Object which includes parser rules to apply when html gets cleaned
    // See parser_rules/*.js for examples
    parserRules:          { tags: { br: {}, span: {}, div: {}, p: {} }, classes: {} },
    // Object which includes parser when the user inserts content via copy & paste. If null parserRules will be used instead
    pasteParserRulesets: null,
    // Parser method to use when the user inserts content
    parser:               wysihtml5.dom.parse,
    // Class name which should be set on the contentEditable element in the created sandbox iframe, can be styled via the 'stylesheets' option
    composerClassName:    "wysihtml5-editor",
    // Class name to add to the body when the wysihtml5 editor is supported
    bodyClassName:        "wysihtml5-supported",
    // By default wysihtml5 will insert a <br> for line breaks, set this to false to use <p>
    useLineBreaks:        true,
    // Array (or single string) of stylesheet urls to be loaded in the editor's iframe
    stylesheets:          [],
    // Placeholder text to use, defaults to the placeholder attribute on the textarea element
    placeholderText:      undef,
    // Whether the rich text editor should be rendered on touch devices (wysihtml5 >= 0.3.0 comes with basic support for iOS 5)
    supportTouchDevices:  true,
    // Whether senseless <span> elements (empty or without attributes) should be removed/replaced with their content
    cleanUp:              true,
    // Whether to use div instead of secure iframe
    contentEditableMode: false,
    // Classname of container that editor should not touch and pass through
    // Pass false to disable
    uneditableContainerClassname: "wysihtml5-uneditable-container",
    // Browsers that support copied source handling will get a marking of the origin of the copied source (for determinig code cleanup rules on paste)
    // Also copied source is based directly on selection - 
    // (very useful for webkit based browsers where copy will otherwise contain a lot of code and styles based on whatever and not actually in selection).
    // If falsy value is passed source override is also disabled
    copyedFromMarking: '<meta name="copied-from" content="wysihtml5">'
  };

  wysihtml5.Editor = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.Editor.prototype */ {
    constructor: function(editableElement, config) {
      this.editableElement  = typeof(editableElement) === "string" ? document.getElementById(editableElement) : editableElement;
      this.config           = wysihtml5.lang.object({}).merge(defaultConfig).merge(config).get();
      this._isCompatible    = wysihtml5.browser.supported();

      if (this.editableElement.nodeName.toLowerCase() != "textarea") {
          this.config.contentEditableMode = true;
          this.config.noTextarea = true;
      }
      if (!this.config.noTextarea) {
          this.textarea         = new wysihtml5.views.Textarea(this, this.editableElement, this.config);
          this.currentView      = this.textarea;
      }

      // Sort out unsupported/unwanted browsers here
      if (!this._isCompatible || (!this.config.supportTouchDevices && wysihtml5.browser.isTouchDevice())) {
        var that = this;
        setTimeout(function() { that.fire("beforeload").fire("load"); }, 0);
        return;
      }

      // Add class name to body, to indicate that the editor is supported
      wysihtml5.dom.addClass(document.body, this.config.bodyClassName);

      this.composer = new wysihtml5.views.Composer(this, this.editableElement, this.config);
      this.currentView = this.composer;

      if (typeof(this.config.parser) === "function") {
        this._initParser();
      }

      this.on("beforeload", this.handleBeforeLoad);
    },

    handleBeforeLoad: function() {
        if (!this.config.noTextarea) {
            this.synchronizer = new wysihtml5.views.Synchronizer(this, this.textarea, this.composer);
        }
        if (this.config.toolbar) {
          this.toolbar = new wysihtml5.toolbar.Toolbar(this, this.config.toolbar, this.config.showToolbarAfterInit);
        }
    },

    isCompatible: function() {
      return this._isCompatible;
    },

    clear: function() {
      this.currentView.clear();
      return this;
    },

    getValue: function(parse, clearInternals) {
      return this.currentView.getValue(parse, clearInternals);
    },

    setValue: function(html, parse) {
      this.fire("unset_placeholder");

      if (!html) {
        return this.clear();
      }

      this.currentView.setValue(html, parse);
      return this;
    },

    cleanUp: function() {
        this.currentView.cleanUp();
    },

    focus: function(setToEnd) {
      this.currentView.focus(setToEnd);
      return this;
    },

    /**
     * Deactivate editor (make it readonly)
     */
    disable: function() {
      this.currentView.disable();
      return this;
    },

    /**
     * Activate editor
     */
    enable: function() {
      this.currentView.enable();
      return this;
    },

    isEmpty: function() {
      return this.currentView.isEmpty();
    },

    hasPlaceholderSet: function() {
      return this.currentView.hasPlaceholderSet();
    },

    parse: function(htmlOrElement, clearInternals) {
      var parseContext = (this.config.contentEditableMode) ? document : ((this.composer) ? this.composer.sandbox.getDocument() : null);
      var returnValue = this.config.parser(htmlOrElement, {
        "rules": this.config.parserRules,
        "cleanUp": this.config.cleanUp,
        "context": parseContext,
        "uneditableClass": this.config.uneditableContainerClassname,
        "clearInternals" : clearInternals
      });
      if (typeof(htmlOrElement) === "object") {
        wysihtml5.quirks.redraw(htmlOrElement);
      }
      return returnValue;
    },

    /**
     * Prepare html parser logic
     *  - Observes for paste and drop
     */
    _initParser: function() {
      var that = this,
          oldHtml,
          cleanHtml;

      if (wysihtml5.browser.supportsModenPaste()) {
        this.on("paste:composer", function(event) {
          event.preventDefault();
          oldHtml = wysihtml5.dom.getPastedHtml(event);
          if (oldHtml) {
            that._cleanAndPaste(oldHtml);
          }
        });

      } else {
        this.on("beforepaste:composer", function(event) {
          event.preventDefault();
          wysihtml5.dom.getPastedHtmlWithDiv(that.composer, function(pastedHTML) {
            if (pastedHTML) {
              that._cleanAndPaste(pastedHTML);
            }
          });
        });

      }
    },

    _cleanAndPaste: function (oldHtml) {
      var cleanHtml = wysihtml5.quirks.cleanPastedHTML(oldHtml, {
        "referenceNode": this.composer.element,
        "rules": this.config.pasteParserRulesets || [{"set": this.config.parserRules}],
        "uneditableClass": this.config.uneditableContainerClassname
      });
      this.composer.selection.deleteContents();
      this.composer.selection.insertHTML(cleanHtml);
    }
  });
})(wysihtml5);
;/**
 * Toolbar Dialog
 *
 * @param {Element} link The toolbar link which causes the dialog to show up
 * @param {Element} container The dialog container
 *
 * @example
 *    <!-- Toolbar link -->
 *    <a data-wysihtml5-command="insertImage">insert an image</a>
 *
 *    <!-- Dialog -->
 *    <div data-wysihtml5-dialog="insertImage" style="display: none;">
 *      <label>
 *        URL: <input data-wysihtml5-dialog-field="src" value="http://">
 *      </label>
 *      <label>
 *        Alternative text: <input data-wysihtml5-dialog-field="alt" value="">
 *      </label>
 *    </div>
 *
 *    <script>
 *      var dialog = new wysihtml5.toolbar.Dialog(
 *        document.querySelector("[data-wysihtml5-command='insertImage']"),
 *        document.querySelector("[data-wysihtml5-dialog='insertImage']")
 *      );
 *      dialog.observe("save", function(attributes) {
 *        // do something
 *      });
 *    </script>
 */
(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      CLASS_NAME_OPENED       = "wysihtml5-command-dialog-opened",
      SELECTOR_FORM_ELEMENTS  = "input, select, textarea",
      SELECTOR_FIELDS         = "[data-wysihtml5-dialog-field]",
      ATTRIBUTE_FIELDS        = "data-wysihtml5-dialog-field";


  wysihtml5.toolbar.Dialog = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.toolbar.Dialog.prototype */ {
    constructor: function(link, container) {
      this.link       = link;
      this.container  = container;
    },

    _observe: function() {
      if (this._observed) {
        return;
      }

      var that = this,
          callbackWrapper = function(event) {
            var attributes = that._serialize();
            if (attributes == that.elementToChange) {
              that.fire("edit", attributes);
            } else {
              that.fire("save", attributes);
            }
            that.hide();
            event.preventDefault();
            event.stopPropagation();
          };

      dom.observe(that.link, "click", function() {
        if (dom.hasClass(that.link, CLASS_NAME_OPENED)) {
          setTimeout(function() { that.hide(); }, 0);
        }
      });

      dom.observe(this.container, "keydown", function(event) {
        var keyCode = event.keyCode;
        if (keyCode === wysihtml5.ENTER_KEY) {
          callbackWrapper(event);
        }
        if (keyCode === wysihtml5.ESCAPE_KEY) {
          that.fire("cancel");
          that.hide();
        }
      });

      dom.delegate(this.container, "[data-wysihtml5-dialog-action=save]", "click", callbackWrapper);

      dom.delegate(this.container, "[data-wysihtml5-dialog-action=cancel]", "click", function(event) {
        that.fire("cancel");
        that.hide();
        event.preventDefault();
        event.stopPropagation();
      });

      var formElements  = this.container.querySelectorAll(SELECTOR_FORM_ELEMENTS),
          i             = 0,
          length        = formElements.length,
          _clearInterval = function() { clearInterval(that.interval); };
      for (; i<length; i++) {
        dom.observe(formElements[i], "change", _clearInterval);
      }

      this._observed = true;
    },

    /**
     * Grabs all fields in the dialog and puts them in key=>value style in an object which
     * then gets returned
     */
    _serialize: function() {
      var data    = this.elementToChange || {},
          fields  = this.container.querySelectorAll(SELECTOR_FIELDS),
          length  = fields.length,
          i       = 0;

      for (; i<length; i++) {
        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;
      }
      return data;
    },

    /**
     * Takes the attributes of the "elementToChange"
     * and inserts them in their corresponding dialog input fields
     *
     * Assume the "elementToChange" looks like this:
     *    <a href="http://www.google.com" target="_blank">foo</a>
     *
     * and we have the following dialog:
     *    <input type="text" data-wysihtml5-dialog-field="href" value="">
     *    <input type="text" data-wysihtml5-dialog-field="target" value="">
     *
     * after calling _interpolate() the dialog will look like this
     *    <input type="text" data-wysihtml5-dialog-field="href" value="http://www.google.com">
     *    <input type="text" data-wysihtml5-dialog-field="target" value="_blank">
     *
     * Basically it adopted the attribute values into the corresponding input fields
     *
     */
    _interpolate: function(avoidHiddenFields) {
      var field,
          fieldName,
          newValue,
          focusedElement = document.querySelector(":focus"),
          fields         = this.container.querySelectorAll(SELECTOR_FIELDS),
          length         = fields.length,
          i              = 0;
      for (; i<length; i++) {
        field = fields[i];

        // Never change elements where the user is currently typing in
        if (field === focusedElement) {
          continue;
        }

        // Don't update hidden fields
        // See https://github.com/xing/wysihtml5/pull/14
        if (avoidHiddenFields && field.type === "hidden") {
          continue;
        }

        fieldName = field.getAttribute(ATTRIBUTE_FIELDS);
        newValue  = (this.elementToChange && typeof(this.elementToChange) !== 'boolean') ? (this.elementToChange.getAttribute(fieldName) || "") : field.defaultValue;
        field.value = newValue;
      }
    },

    /**
     * Show the dialog element
     */
    show: function(elementToChange) {
      if (dom.hasClass(this.link, CLASS_NAME_OPENED)) {
        return;
      }

      var that        = this,
          firstField  = this.container.querySelector(SELECTOR_FORM_ELEMENTS);
      this.elementToChange = elementToChange;
      this._observe();
      this._interpolate();
      if (elementToChange) {
        this.interval = setInterval(function() { that._interpolate(true); }, 500);
      }
      dom.addClass(this.link, CLASS_NAME_OPENED);
      this.container.style.display = "";
      this.fire("show");
      if (firstField && !elementToChange) {
        try {
          firstField.focus();
        } catch(e) {}
      }
    },

    /**
     * Hide the dialog element
     */
    hide: function() {
      clearInterval(this.interval);
      this.elementToChange = null;
      dom.removeClass(this.link, CLASS_NAME_OPENED);
      this.container.style.display = "none";
      this.fire("hide");
    }
  });
})(wysihtml5);
;/**
 * Converts speech-to-text and inserts this into the editor
 * As of now (2011/03/25) this only is supported in Chrome >= 11
 *
 * Note that it sends the recorded audio to the google speech recognition api:
 * http://stackoverflow.com/questions/4361826/does-chrome-have-buil-in-speech-recognition-for-input-type-text-x-webkit-speec
 *
 * Current HTML5 draft can be found here
 * http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html
 *
 * "Accessing Google Speech API Chrome 11"
 * http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/
 */
(function(wysihtml5) {
  var dom = wysihtml5.dom;

  var linkStyles = {
    position: "relative"
  };

  var wrapperStyles = {
    left:     0,
    margin:   0,
    opacity:  0,
    overflow: "hidden",
    padding:  0,
    position: "absolute",
    top:      0,
    zIndex:   1
  };

  var inputStyles = {
    cursor:     "inherit",
    fontSize:   "50px",
    height:     "50px",
    marginTop:  "-25px",
    outline:    0,
    padding:    0,
    position:   "absolute",
    right:      "-4px",
    top:        "50%"
  };

  var inputAttributes = {
    "x-webkit-speech": "",
    "speech":          ""
  };

  wysihtml5.toolbar.Speech = function(parent, link) {
    var input = document.createElement("input");
    if (!wysihtml5.browser.supportsSpeechApiOn(input)) {
      link.style.display = "none";
      return;
    }
    var lang = parent.editor.textarea.element.getAttribute("lang");
    if (lang) {
      inputAttributes.lang = lang;
    }

    var wrapper = document.createElement("div");

    wysihtml5.lang.object(wrapperStyles).merge({
      width:  link.offsetWidth  + "px",
      height: link.offsetHeight + "px"
    });

    dom.insert(input).into(wrapper);
    dom.insert(wrapper).into(link);

    dom.setStyles(inputStyles).on(input);
    dom.setAttributes(inputAttributes).on(input);

    dom.setStyles(wrapperStyles).on(wrapper);
    dom.setStyles(linkStyles).on(link);

    var eventName = "onwebkitspeechchange" in input ? "webkitspeechchange" : "speechchange";
    dom.observe(input, eventName, function() {
      parent.execCommand("insertText", input.value);
      input.value = "";
    });

    dom.observe(input, "click", function(event) {
      if (dom.hasClass(link, "wysihtml5-command-disabled")) {
        event.preventDefault();
      }

      event.stopPropagation();
    });
  };
})(wysihtml5);
;/**
 * Toolbar
 *
 * @param {Object} parent Reference to instance of Editor instance
 * @param {Element} container Reference to the toolbar container element
 *
 * @example
 *    <div id="toolbar">
 *      <a data-wysihtml5-command="createLink">insert link</a>
 *      <a data-wysihtml5-command="formatBlock" data-wysihtml5-command-value="h1">insert h1</a>
 *    </div>
 *
 *    <script>
 *      var toolbar = new wysihtml5.toolbar.Toolbar(editor, document.getElementById("toolbar"));
 *    </script>
 */
(function(wysihtml5) {
  var CLASS_NAME_COMMAND_DISABLED   = "wysihtml5-command-disabled",
      CLASS_NAME_COMMANDS_DISABLED  = "wysihtml5-commands-disabled",
      CLASS_NAME_COMMAND_ACTIVE     = "wysihtml5-command-active",
      CLASS_NAME_ACTION_ACTIVE      = "wysihtml5-action-active",
      dom                           = wysihtml5.dom;

  wysihtml5.toolbar.Toolbar = Base.extend(
    /** @scope wysihtml5.toolbar.Toolbar.prototype */ {
    constructor: function(editor, container, showOnInit) {
      this.editor     = editor;
      this.container  = typeof(container) === "string" ? document.getElementById(container) : container;
      this.composer   = editor.composer;

      this._getLinks("command");
      this._getLinks("action");

      this._observe();
      if (showOnInit) { this.show(); }

      if (editor.config.classNameCommandDisabled != null) {
        CLASS_NAME_COMMAND_DISABLED = editor.config.classNameCommandDisabled;
      }
      if (editor.config.classNameCommandsDisabled != null) {
        CLASS_NAME_COMMANDS_DISABLED = editor.config.classNameCommandsDisabled;
      }
      if (editor.config.classNameCommandActive != null) {
        CLASS_NAME_COMMAND_ACTIVE = editor.config.classNameCommandActive;
      }
      if (editor.config.classNameActionActive != null) {
        CLASS_NAME_ACTION_ACTIVE = editor.config.classNameActionActive;
      }

      var speechInputLinks  = this.container.querySelectorAll("[data-wysihtml5-command=insertSpeech]"),
          length            = speechInputLinks.length,
          i                 = 0;
      for (; i<length; i++) {
        new wysihtml5.toolbar.Speech(this, speechInputLinks[i]);
      }
    },

    _getLinks: function(type) {
      var links   = this[type + "Links"] = wysihtml5.lang.array(this.container.querySelectorAll("[data-wysihtml5-" + type + "]")).get(),
          length  = links.length,
          i       = 0,
          mapping = this[type + "Mapping"] = {},
          link,
          group,
          name,
          value,
          dialog;
      for (; i<length; i++) {
        link    = links[i];
        name    = link.getAttribute("data-wysihtml5-" + type);
        value   = link.getAttribute("data-wysihtml5-" + type + "-value");
        group   = this.container.querySelector("[data-wysihtml5-" + type + "-group='" + name + "']");
        dialog  = this._getDialog(link, name);

        mapping[name + ":" + value] = {
          link:   link,
          group:  group,
          name:   name,
          value:  value,
          dialog: dialog,
          state:  false
        };
      }
    },

    _getDialog: function(link, command) {
      var that          = this,
          dialogElement = this.container.querySelector("[data-wysihtml5-dialog='" + command + "']"),
          dialog,
          caretBookmark;

      if (dialogElement) {
        if (wysihtml5.toolbar["Dialog_" + command]) {
            dialog = new wysihtml5.toolbar["Dialog_" + command](link, dialogElement);
        } else {
            dialog = new wysihtml5.toolbar.Dialog(link, dialogElement);
        }

        dialog.on("show", function() {
          caretBookmark = that.composer.selection.getBookmark();

          that.editor.fire("show:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });

        dialog.on("save", function(attributes) {
          if (caretBookmark) {
            that.composer.selection.setBookmark(caretBookmark);
          }
          that._execCommand(command, attributes);

          that.editor.fire("save:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });

        dialog.on("cancel", function() {
          that.editor.focus(false);
          that.editor.fire("cancel:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });
      }
      return dialog;
    },

    /**
     * @example
     *    var toolbar = new wysihtml5.Toolbar();
     *    // Insert a <blockquote> element or wrap current selection in <blockquote>
     *    toolbar.execCommand("formatBlock", "blockquote");
     */
    execCommand: function(command, commandValue) {
      if (this.commandsDisabled) {
        return;
      }

      var commandObj = this.commandMapping[command + ":" + commandValue];

      // Show dialog when available
      if (commandObj && commandObj.dialog && !commandObj.state) {
        commandObj.dialog.show();
      } else {
        this._execCommand(command, commandValue);
      }
    },

    _execCommand: function(command, commandValue) {
      // Make sure that composer is focussed (false => don't move caret to the end)
      this.editor.focus(false);

      this.composer.commands.exec(command, commandValue);
      this._updateLinkStates();
    },

    execAction: function(action) {
      var editor = this.editor;
      if (action === "change_view") {
        if (editor.textarea) {
            if (editor.currentView === editor.textarea) {
              editor.fire("change_view", "composer");
            } else {
              editor.fire("change_view", "textarea");
            }
        }
      }
      if (action == "showSource") {
          editor.fire("showSource");
      }
    },

    _observe: function() {
      var that      = this,
          editor    = this.editor,
          container = this.container,
          links     = this.commandLinks.concat(this.actionLinks),
          length    = links.length,
          i         = 0;

      for (; i<length; i++) {
        // 'javascript:;' and unselectable=on Needed for IE, but done in all browsers to make sure that all get the same css applied
        // (you know, a:link { ... } doesn't match anchors with missing href attribute)
        if (links[i].nodeName === "A") {
          dom.setAttributes({
            href:         "javascript:;",
            unselectable: "on"
          }).on(links[i]);
        } else {
          dom.setAttributes({ unselectable: "on" }).on(links[i]);
        }
      }

      // Needed for opera and chrome
      dom.delegate(container, "[data-wysihtml5-command], [data-wysihtml5-action]", "mousedown", function(event) { event.preventDefault(); });

      dom.delegate(container, "[data-wysihtml5-command]", "click", function(event) {
        var link          = this,
            command       = link.getAttribute("data-wysihtml5-command"),
            commandValue  = link.getAttribute("data-wysihtml5-command-value");
        that.execCommand(command, commandValue);
        event.preventDefault();
      });

      dom.delegate(container, "[data-wysihtml5-action]", "click", function(event) {
        var action = this.getAttribute("data-wysihtml5-action");
        that.execAction(action);
        event.preventDefault();
      });

      editor.on("interaction:composer", function() {
          that._updateLinkStates();
      });

      editor.on("focus:composer", function() {
        that.bookmark = null;
      });

      if (this.editor.config.handleTables) {
          editor.on("tableselect:composer", function() {
              that.container.querySelectorAll('[data-wysihtml5-hiddentools="table"]')[0].style.display = "";
          });
          editor.on("tableunselect:composer", function() {
              that.container.querySelectorAll('[data-wysihtml5-hiddentools="table"]')[0].style.display = "none";
          });
      }

      editor.on("change_view", function(currentView) {
        // Set timeout needed in order to let the blur event fire first
        if (editor.textarea) {
            setTimeout(function() {
              that.commandsDisabled = (currentView !== "composer");
              that._updateLinkStates();
              if (that.commandsDisabled) {
                dom.addClass(container, CLASS_NAME_COMMANDS_DISABLED);
              } else {
                dom.removeClass(container, CLASS_NAME_COMMANDS_DISABLED);
              }
            }, 0);
        }
      });
    },

    _updateLinkStates: function() {

      var commandMapping    = this.commandMapping,
          actionMapping     = this.actionMapping,
          i,
          state,
          action,
          command;
      // every millisecond counts... this is executed quite often
      for (i in commandMapping) {
        command = commandMapping[i];
        if (this.commandsDisabled) {
          state = false;
          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            command.dialog.hide();
          }
        } else {
          state = this.composer.commands.state(command.name, command.value);
          dom.removeClass(command.link, CLASS_NAME_COMMAND_DISABLED);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_DISABLED);
          }
        }
        if (command.state === state) {
          continue;
        }

        command.state = state;
        if (state) {
          dom.addClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.addClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            if (typeof(state) === "object" || wysihtml5.lang.object(state).isArray()) {

              if (!command.dialog.multiselect && wysihtml5.lang.object(state).isArray()) {
                // Grab first and only object/element in state array, otherwise convert state into boolean
                // to avoid showing a dialog for multiple selected elements which may have different attributes
                // eg. when two links with different href are selected, the state will be an array consisting of both link elements
                // but the dialog interface can only update one
                state = state.length === 1 ? state[0] : true;
                command.state = state;
              }
              command.dialog.show(state);
            } else {
              command.dialog.hide();
            }
          }
        } else {
          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            command.dialog.hide();
          }
        }
      }

      for (i in actionMapping) {
        action = actionMapping[i];

        if (action.name === "change_view") {
          action.state = this.editor.currentView === this.editor.textarea;
          if (action.state) {
            dom.addClass(action.link, CLASS_NAME_ACTION_ACTIVE);
          } else {
            dom.removeClass(action.link, CLASS_NAME_ACTION_ACTIVE);
          }
        }
      }
    },

    show: function() {
      this.container.style.display = "";
    },

    hide: function() {
      this.container.style.display = "none";
    }
  });

})(wysihtml5);
;(function(wysihtml5) {
    wysihtml5.toolbar.Dialog_createTable = wysihtml5.toolbar.Dialog.extend({
        show: function(elementToChange) {
            this.base(elementToChange);

        }

    });
})(wysihtml5);
;(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      SELECTOR_FIELDS         = "[data-wysihtml5-dialog-field]",
      ATTRIBUTE_FIELDS        = "data-wysihtml5-dialog-field";

  wysihtml5.toolbar.Dialog_foreColorStyle = wysihtml5.toolbar.Dialog.extend({
    multiselect: true,

    _serialize: function() {
      var data    = {},
          fields  = this.container.querySelectorAll(SELECTOR_FIELDS),
          length  = fields.length,
          i       = 0;

      for (; i<length; i++) {
        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;
      }
      return data;
    },

    _interpolate: function(avoidHiddenFields) {
      var field,
          fieldName,
          newValue,
          focusedElement = document.querySelector(":focus"),
          fields         = this.container.querySelectorAll(SELECTOR_FIELDS),
          length         = fields.length,
          i              = 0,
          firstElement   = (this.elementToChange) ? ((wysihtml5.lang.object(this.elementToChange).isArray()) ? this.elementToChange[0] : this.elementToChange) : null,
          colorStr       = (firstElement) ? firstElement.getAttribute('style') : null,
          color          = (colorStr) ? wysihtml5.quirks.styleParser.parseColor(colorStr, "color") : null;

      for (; i<length; i++) {
        field = fields[i];
        // Never change elements where the user is currently typing in
        if (field === focusedElement) {
          continue;
        }
        // Don't update hidden fields3
        if (avoidHiddenFields && field.type === "hidden") {
          continue;
        }
        if (field.getAttribute(ATTRIBUTE_FIELDS) === "color") {
          if (color) {
            if (color[3] && color[3] != 1) {
              field.value = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + color[3] + ");";
            } else {
              field.value = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ");";
            }
          } else {
            field.value = "rgb(0,0,0);";
          }
        }
      }
    }

  });
})(wysihtml5);
;(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      SELECTOR_FIELDS         = "[data-wysihtml5-dialog-field]",
      ATTRIBUTE_FIELDS        = "data-wysihtml5-dialog-field";

  wysihtml5.toolbar.Dialog_fontSizeStyle = wysihtml5.toolbar.Dialog.extend({
    multiselect: true,

    _serialize: function() {
      return {"size" : this.container.querySelector('[data-wysihtml5-dialog-field="size"]').value};
    },

    _interpolate: function(avoidHiddenFields) {
      var focusedElement = document.querySelector(":focus"),
          field          = this.container.querySelector("[data-wysihtml5-dialog-field='size']"),
          firstElement   = (this.elementToChange) ? ((wysihtml5.lang.object(this.elementToChange).isArray()) ? this.elementToChange[0] : this.elementToChange) : null,
          styleStr       = (firstElement) ? firstElement.getAttribute('style') : null,
          size           = (styleStr) ? wysihtml5.quirks.styleParser.parseFontSize(styleStr) : null;

      if (field && field !== focusedElement && size && !(/^\s*$/).test(size)) {
        field.value = size;
      }
    }

  });
})(wysihtml5);
/*!

 handlebars v1.3.0

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
var Handlebars=function(){var a=function(){"use strict";function a(a){this.string=a}var b;return a.prototype.toString=function(){return""+this.string},b=a}(),b=function(a){"use strict";function b(a){return h[a]||"&amp;"}function c(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])}function d(a){return a instanceof g?a.toString():a||0===a?(a=""+a,j.test(a)?a.replace(i,b):a):""}function e(a){return a||0===a?m(a)&&0===a.length?!0:!1:!0}var f={},g=a,h={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},i=/[&<>"'`]/g,j=/[&<>"'`]/;f.extend=c;var k=Object.prototype.toString;f.toString=k;var l=function(a){return"function"==typeof a};l(/x/)&&(l=function(a){return"function"==typeof a&&"[object Function]"===k.call(a)});var l;f.isFunction=l;var m=Array.isArray||function(a){return a&&"object"==typeof a?"[object Array]"===k.call(a):!1};return f.isArray=m,f.escapeExpression=d,f.isEmpty=e,f}(a),c=function(){"use strict";function a(a,b){var d;b&&b.firstLine&&(d=b.firstLine,a+=" - "+d+":"+b.firstColumn);for(var e=Error.prototype.constructor.call(this,a),f=0;f<c.length;f++)this[c[f]]=e[c[f]];d&&(this.lineNumber=d,this.column=b.firstColumn)}var b,c=["description","fileName","lineNumber","message","name","number","stack"];return a.prototype=new Error,b=a}(),d=function(a,b){"use strict";function c(a,b){this.helpers=a||{},this.partials=b||{},d(this)}function d(a){a.registerHelper("helperMissing",function(a){if(2===arguments.length)return void 0;throw new h("Missing helper: '"+a+"'")}),a.registerHelper("blockHelperMissing",function(b,c){var d=c.inverse||function(){},e=c.fn;return m(b)&&(b=b.call(this)),b===!0?e(this):b===!1||null==b?d(this):l(b)?b.length>0?a.helpers.each(b,c):d(this):e(b)}),a.registerHelper("each",function(a,b){var c,d=b.fn,e=b.inverse,f=0,g="";if(m(a)&&(a=a.call(this)),b.data&&(c=q(b.data)),a&&"object"==typeof a)if(l(a))for(var h=a.length;h>f;f++)c&&(c.index=f,c.first=0===f,c.last=f===a.length-1),g+=d(a[f],{data:c});else for(var i in a)a.hasOwnProperty(i)&&(c&&(c.key=i,c.index=f,c.first=0===f),g+=d(a[i],{data:c}),f++);return 0===f&&(g=e(this)),g}),a.registerHelper("if",function(a,b){return m(a)&&(a=a.call(this)),!b.hash.includeZero&&!a||g.isEmpty(a)?b.inverse(this):b.fn(this)}),a.registerHelper("unless",function(b,c){return a.helpers["if"].call(this,b,{fn:c.inverse,inverse:c.fn,hash:c.hash})}),a.registerHelper("with",function(a,b){return m(a)&&(a=a.call(this)),g.isEmpty(a)?void 0:b.fn(a)}),a.registerHelper("log",function(b,c){var d=c.data&&null!=c.data.level?parseInt(c.data.level,10):1;a.log(d,b)})}function e(a,b){p.log(a,b)}var f={},g=a,h=b,i="1.3.0";f.VERSION=i;var j=4;f.COMPILER_REVISION=j;var k={1:"<= 1.0.rc.2",2:"== 1.0.0-rc.3",3:"== 1.0.0-rc.4",4:">= 1.0.0"};f.REVISION_CHANGES=k;var l=g.isArray,m=g.isFunction,n=g.toString,o="[object Object]";f.HandlebarsEnvironment=c,c.prototype={constructor:c,logger:p,log:e,registerHelper:function(a,b,c){if(n.call(a)===o){if(c||b)throw new h("Arg not supported with multiple helpers");g.extend(this.helpers,a)}else c&&(b.not=c),this.helpers[a]=b},registerPartial:function(a,b){n.call(a)===o?g.extend(this.partials,a):this.partials[a]=b}};var p={methodMap:{0:"debug",1:"info",2:"warn",3:"error"},DEBUG:0,INFO:1,WARN:2,ERROR:3,level:3,log:function(a,b){if(p.level<=a){var c=p.methodMap[a];"undefined"!=typeof console&&console[c]&&console[c].call(console,b)}}};f.logger=p,f.log=e;var q=function(a){var b={};return g.extend(b,a),b};return f.createFrame=q,f}(b,c),e=function(a,b,c){"use strict";function d(a){var b=a&&a[0]||1,c=m;if(b!==c){if(c>b){var d=n[c],e=n[b];throw new l("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version ("+d+") or downgrade your runtime to an older version ("+e+").")}throw new l("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version ("+a[1]+").")}}function e(a,b){if(!b)throw new l("No environment passed to template");var c=function(a,c,d,e,f,g){var h=b.VM.invokePartial.apply(this,arguments);if(null!=h)return h;if(b.compile){var i={helpers:e,partials:f,data:g};return f[c]=b.compile(a,{data:void 0!==g},b),f[c](d,i)}throw new l("The partial "+c+" could not be compiled when running in runtime-only mode")},d={escapeExpression:k.escapeExpression,invokePartial:c,programs:[],program:function(a,b,c){var d=this.programs[a];return c?d=g(a,b,c):d||(d=this.programs[a]=g(a,b)),d},merge:function(a,b){var c=a||b;return a&&b&&a!==b&&(c={},k.extend(c,b),k.extend(c,a)),c},programWithDepth:b.VM.programWithDepth,noop:b.VM.noop,compilerInfo:null};return function(c,e){e=e||{};var f,g,h=e.partial?e:b;e.partial||(f=e.helpers,g=e.partials);var i=a.call(d,h,c,f,g,e.data);return e.partial||b.VM.checkRevision(d.compilerInfo),i}}function f(a,b,c){var d=Array.prototype.slice.call(arguments,3),e=function(a,e){return e=e||{},b.apply(this,[a,e.data||c].concat(d))};return e.program=a,e.depth=d.length,e}function g(a,b,c){var d=function(a,d){return d=d||{},b(a,d.data||c)};return d.program=a,d.depth=0,d}function h(a,b,c,d,e,f){var g={partial:!0,helpers:d,partials:e,data:f};if(void 0===a)throw new l("The partial "+b+" could not be found");return a instanceof Function?a(c,g):void 0}function i(){return""}var j={},k=a,l=b,m=c.COMPILER_REVISION,n=c.REVISION_CHANGES;return j.checkRevision=d,j.template=e,j.programWithDepth=f,j.program=g,j.invokePartial=h,j.noop=i,j}(b,c,d),f=function(a,b,c,d,e){"use strict";var f,g=a,h=b,i=c,j=d,k=e,l=function(){var a=new g.HandlebarsEnvironment;return j.extend(a,g),a.SafeString=h,a.Exception=i,a.Utils=j,a.VM=k,a.template=function(b){return k.template(b,a)},a},m=l();return m.create=l,f=m}(d,a,c,b,e);return f}();this["wysihtml5"] = this["wysihtml5"] || {};
this["wysihtml5"]["tpl"] = this["wysihtml5"]["tpl"] || {};

this["wysihtml5"]["tpl"]["blockquote"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program3(depth0,data) {
  
  
  return " \n      <span class=\"fa fa-quote-left\"></span>\n    ";
  }

function program5(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-quote\"></span>\n    ";
  }

  buffer += "<li>\n  <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"blockquote\" data-wysihtml5-display-format-name=\"false\" tabindex=\"-1\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </a>\n</li>\n";
  return buffer;
  });

this["wysihtml5"]["tpl"]["color"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

  buffer += "<li class=\"dropdown\">\n  <a class=\"btn btn-default dropdown-toggle ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-toggle=\"dropdown\" tabindex=\"-1\">\n    <span class=\"current-color\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.black)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span>\n    <b class=\"caret\"></b>\n  </a>\n  <ul class=\"dropdown-menu\">\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"black\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"black\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.black)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"silver\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"silver\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.silver)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"gray\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"gray\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.gray)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"maroon\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"maroon\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.maroon)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"red\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"red\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.red)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"purple\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"purple\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.purple)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"green\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"green\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.green)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"olive\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"olive\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.olive)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"navy\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"navy\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.navy)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"blue\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"blue\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.blue)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><div class=\"wysihtml5-colors\" data-wysihtml5-command-value=\"orange\"></div><a class=\"wysihtml5-colors-title\" data-wysihtml5-command=\"foreColor\" data-wysihtml5-command-value=\"orange\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.colours)),stack1 == null || stack1 === false ? stack1 : stack1.orange)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n  </ul>\n</li>\n";
  return buffer;
  });

this["wysihtml5"]["tpl"]["emphasis"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"small\" title=\"CTRL+S\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.emphasis)),stack1 == null || stack1 === false ? stack1 : stack1.small)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n    ";
  return buffer;
  }

  buffer += "<li>\n  <div class=\"btn-group\">\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"bold\" title=\"CTRL+B\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.emphasis)),stack1 == null || stack1 === false ? stack1 : stack1.bold)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"italic\" title=\"CTRL+I\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.emphasis)),stack1 == null || stack1 === false ? stack1 : stack1.italic)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"underline\" title=\"CTRL+U\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.emphasis)),stack1 == null || stack1 === false ? stack1 : stack1.underline)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.emphasis)),stack1 == null || stack1 === false ? stack1 : stack1.small), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</li>\n";
  return buffer;
  });

this["wysihtml5"]["tpl"]["font-styles"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "\n      <span class=\"fa fa-font\"></span>\n    ";
  }

function program5(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-font\"></span>\n    ";
  }

  buffer += "<li class=\"dropdown\">\n  <a class=\"btn btn-default dropdown-toggle ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-toggle=\"dropdown\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <span class=\"current-font\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.normal)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span>\n    <b class=\"caret\"></b>\n  </a>\n  <ul class=\"dropdown-menu\">\n    <li><a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"p\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.normal)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h1\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.h1)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h2\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.h2)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h3\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.h3)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h4\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.h4)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h5\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.h5)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n    <li><a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h6\" tabindex=\"-1\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.font_styles)),stack1 == null || stack1 === false ? stack1 : stack1.h6)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a></li>\n  </ul>\n</li>\n";
  return buffer;
  });

this["wysihtml5"]["tpl"]["html"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "\n        <span class=\"fa fa-pencil\"></span>\n      ";
  }

function program5(depth0,data) {
  
  
  return "\n        <span class=\"glyphicon glyphicon-pencil\"></span>\n      ";
  }

  buffer += "<li>\n  <div class=\"btn-group\">\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-action=\"change_view\" title=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.html)),stack1 == null || stack1 === false ? stack1 : stack1.edit)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"-1\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </a>\n  </div>\n</li>\n";
  return buffer;
  });

this["wysihtml5"]["tpl"]["image"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "modal-sm";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program5(depth0,data) {
  
  
  return "\n      <span class=\"fa fa-file-image-o\"></span>\n    ";
  }

function program7(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-picture\"></span>\n    ";
  }

  buffer += "<li>\n  <div class=\"bootstrap-wysihtml5-insert-image-modal modal fade\" data-wysihtml5-dialog=\"insertImage\">\n    <div class=\"modal-dialog ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.smallmodals), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <a class=\"close\" data-dismiss=\"modal\">&times;</a>\n          <h3>"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.image)),stack1 == null || stack1 === false ? stack1 : stack1.insert)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</h3>\n        </div>\n        <div class=\"modal-body\">\n          <div class=\"form-group\">\n            <input value=\"http://\" class=\"bootstrap-wysihtml5-insert-image-url form-control\" data-wysihtml5-dialog-field=\"src\">\n          </div> \n        </div>\n        <div class=\"modal-footer\">\n          <a class=\"btn btn-default\" data-dismiss=\"modal\" data-wysihtml5-dialog-action=\"cancel\" href=\"#\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.image)),stack1 == null || stack1 === false ? stack1 : stack1.cancel)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n          <a class=\"btn btn-primary\" data-dismiss=\"modal\"  data-wysihtml5-dialog-action=\"save\" href=\"#\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.image)),stack1 == null || stack1 === false ? stack1 : stack1.insert)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n        </div>\n      </div>\n    </div>\n  </div>\n  <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"insertImage\" title=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.image)),stack1 == null || stack1 === false ? stack1 : stack1.insert)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"-1\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </a>\n</li>\n";
  return buffer;
  });

this["wysihtml5"]["tpl"]["link"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "modal-sm";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program5(depth0,data) {
  
  
  return "\n      <span class=\"fa fa-share-square-o\"></span>\n    ";
  }

function program7(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-share\"></span>\n    ";
  }

  buffer += "<li>\n  <div class=\"bootstrap-wysihtml5-insert-link-modal modal fade\" data-wysihtml5-dialog=\"createLink\">\n    <div class=\"modal-dialog ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.smallmodals), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <a class=\"close\" data-dismiss=\"modal\">&times;</a>\n          <h3>"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.link)),stack1 == null || stack1 === false ? stack1 : stack1.insert)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</h3>\n        </div>\n        <div class=\"modal-body\">\n          <div class=\"form-group\">\n            <input value=\"http://\" class=\"bootstrap-wysihtml5-insert-link-url form-control\" data-wysihtml5-dialog-field=\"href\">\n          </div> \n          <div class=\"checkbox\">\n            <label> \n              <input type=\"checkbox\" class=\"bootstrap-wysihtml5-insert-link-target\" checked>"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.link)),stack1 == null || stack1 === false ? stack1 : stack1.target)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n            </label>\n          </div>\n        </div>\n        <div class=\"modal-footer\">\n          <a class=\"btn btn-default\" data-dismiss=\"modal\" data-wysihtml5-dialog-action=\"cancel\" href=\"#\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.link)),stack1 == null || stack1 === false ? stack1 : stack1.cancel)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n          <a href=\"#\" class=\"btn btn-primary\" data-dismiss=\"modal\" data-wysihtml5-dialog-action=\"save\">"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.link)),stack1 == null || stack1 === false ? stack1 : stack1.insert)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</a>\n        </div>\n      </div>\n    </div>\n  </div>\n  <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"createLink\" title=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.link)),stack1 == null || stack1 === false ? stack1 : stack1.insert)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"-1\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </a>\n</li>\n";
  return buffer;
  });

this["wysihtml5"]["tpl"]["lists"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-"
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "\n      <span class=\"fa fa-list-ul\"></span>\n    ";
  }

function program5(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-list\"></span>\n    ";
  }

function program7(depth0,data) {
  
  
  return "\n      <span class=\"fa fa-list-ol\"></span>\n    ";
  }

function program9(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-th-list\"></span>\n    ";
  }

function program11(depth0,data) {
  
  
  return "\n      <span class=\"fa fa-outdent\"></span>\n    ";
  }

function program13(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-indent-right\"></span>\n    ";
  }

function program15(depth0,data) {
  
  
  return "\n      <span class=\"fa fa-indent\"></span>\n    ";
  }

function program17(depth0,data) {
  
  
  return "\n      <span class=\"glyphicon glyphicon-indent-left\"></span>\n    ";
  }

  buffer += "<li>\n  <div class=\"btn-group\">\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"insertUnorderedList\" title=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.lists)),stack1 == null || stack1 === false ? stack1 : stack1.unordered)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"-1\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </a>\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"insertOrderedList\" title=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.lists)),stack1 == null || stack1 === false ? stack1 : stack1.ordered)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"-1\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </a>\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"Outdent\" title=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.lists)),stack1 == null || stack1 === false ? stack1 : stack1.outdent)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"-1\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </a>\n    <a class=\"btn ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.size), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " btn-default\" data-wysihtml5-command=\"Indent\" title=\""
    + escapeExpression(((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.locale)),stack1 == null || stack1 === false ? stack1 : stack1.lists)),stack1 == null || stack1 === false ? stack1 : stack1.indent)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" tabindex=\"-1\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.options)),stack1 == null || stack1 === false ? stack1 : stack1.toolbar)),stack1 == null || stack1 === false ? stack1 : stack1.fa), {hash:{},inverse:self.program(17, program17, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </a>\n  </div>\n</li>\n";
  return buffer;
  });(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('bootstrap.wysihtml5', ['jquery', 'wysihtml5', 'bootstrap', 'bootstrap.wysihtml5.templates', 'bootstrap.wysihtml5.commands'], factory);
  } else {
    // Browser globals
    factory(jQuery, wysihtml5); // jshint ignore:line
  }
}(function ($, wysihtml5) {
  'use strict';
  var bsWysihtml5 = function($, wysihtml5) {

    var templates = function(key, locale, options) {
      if(wysihtml5.tpl[key]) {
        return wysihtml5.tpl[key]({locale: locale, options: options});
      }
    };

    var Wysihtml5 = function(el, options) {
      this.el = el;
      var toolbarOpts = $.extend(true, {}, defaultOptions, options);
      for(var t in toolbarOpts.customTemplates) {
        if (toolbarOpts.customTemplates.hasOwnProperty(t)) {
          wysihtml5.tpl[t] = toolbarOpts.customTemplates[t];
        }
      }
      this.toolbar = this.createToolbar(el, toolbarOpts);
      this.editor =  this.createEditor(toolbarOpts);
    };

    Wysihtml5.prototype = {

      constructor: Wysihtml5,

      createEditor: function(options) {
        options = options || {};

        // Add the toolbar to a clone of the options object so multiple instances
        // of the WYISYWG don't break because 'toolbar' is already defined
        options = $.extend(true, {}, options);
        options.toolbar = this.toolbar[0];
        
        this.initializeEditor(this.el[0], options);
      },


      initializeEditor: function(el, options) {
        var editor = new wysihtml5.Editor(this.el[0], options);

        editor.on('beforeload', this.syncBootstrapDialogEvents);
        editor.on('beforeload', this.loadParserRules);

        // #30 - body is in IE 10 not created by default, which leads to nullpointer
        // 2014/02/13 - adapted to wysihtml5-0.4, does not work in IE
        if(editor.composer.editableArea.contentDocument) {
          this.addMoreShortcuts(editor, 
                                editor.composer.editableArea.contentDocument.body || editor.composer.editableArea.contentDocument, 
                                options.shortcuts);
        } else {
          this.addMoreShortcuts(editor, editor.composer.editableArea, options.shortcuts);    
        }

        if(options && options.events) {
          for(var eventName in options.events) {
            if (options.events.hasOwnProperty(eventName)) {
              editor.on(eventName, options.events[eventName]);
            }
          }
        }

        return editor;
      },

      loadParserRules: function() {
        if($.type(this.config.parserRules) === 'string') {
          $.ajax({
            dataType: 'json',
            url: this.config.parserRules,
            context: this,
            error: function (jqXHR, textStatus, errorThrown) {
              console.log(errorThrown);
            },
            success: function (parserRules) {
              this.config.parserRules = parserRules;
              console.log('parserrules loaded');
            }
          });
        }

        if(this.config.pasteParserRulesets && $.type(this.config.pasteParserRulesets) === 'string') {
          $.ajax({
            dataType: 'json',
            url: this.config.pasteParserRulesets,
            context: this,
            error: function (jqXHR, textStatus, errorThrown) {
              console.log(errorThrown);
            },
            success: function (pasteParserRulesets) {
              this.config.pasteParserRulesets = pasteParserRulesets;
            }
          });
        }
      },

      //sync wysihtml5 events for dialogs with bootstrap events
      syncBootstrapDialogEvents: function() {
        var editor = this;
        $.map(this.toolbar.commandMapping, function(value) {
          return [value];
        }).filter(function(commandObj) {
          return commandObj.dialog;
        }).map(function(commandObj) {
          return commandObj.dialog;
        }).forEach(function(dialog) {
          dialog.on('show', function() {
            $(this.container).modal('show');
          });
          dialog.on('hide', function() {
            $(this.container).modal('hide');
            setTimeout(editor.composer.focus, 0);
          });
          $(dialog.container).on('shown.bs.modal', function () {
            $(this).find('input, select, textarea').first().focus();
          });
        });
        this.on('change_view', function() {
          $(this.toolbar.container.children).find('a.btn').not('[data-wysihtml5-action="change_view"]').toggleClass('disabled');
        });
      },

      createToolbar: function(el, options) {
        var self = this;
        var toolbar = $('<ul/>', {
          'class' : 'wysihtml5-toolbar',
          'style': 'display:none'
        });
        var culture = options.locale || defaultOptions.locale || 'en';
        if(!locale.hasOwnProperty(culture)) {
          console.debug('Locale \'' + culture + '\' not found. Available locales are: ' + Object.keys(locale) + '. Falling back to \'en\'.');
          culture = 'en';
        }
        var localeObject = $.extend(true, {}, locale.en, locale[culture]);
        for(var key in options.toolbar) {
          if(options.toolbar[key]) {
            toolbar.append(templates(key, localeObject, options));
          }
        }

        toolbar.find('a[data-wysihtml5-command="formatBlock"]').click(function(e) {
          var target = e.delegateTarget || e.target || e.srcElement,
          el = $(target),
          showformat = el.data('wysihtml5-display-format-name'),
          formatname = el.data('wysihtml5-format-name') || el.html();
          if(showformat === undefined || showformat === 'true') {
            self.toolbar.find('.current-font').text(formatname);
          }
        });

        toolbar.find('a[data-wysihtml5-command="foreColor"]').click(function(e) {
          var target = e.target || e.srcElement;
          var el = $(target);
          self.toolbar.find('.current-color').text(el.html());
        });

        this.el.before(toolbar);

        return toolbar;
      },

      addMoreShortcuts: function(editor, el, shortcuts) {
        /* some additional shortcuts */
        wysihtml5.dom.observe(el, 'keydown', function(event) {
          var keyCode  = event.keyCode,
          command  = shortcuts[keyCode];
          if ((event.ctrlKey || event.metaKey || event.altKey) && command && wysihtml5.commands[command]) {
            var commandObj = editor.toolbar.commandMapping[command + ':null'];
            if (commandObj && commandObj.dialog && !commandObj.state) {
              commandObj.dialog.show();
            } else {
              wysihtml5.commands[command].exec(editor.composer, command);
            }
            event.preventDefault();
          }
        });
      }
    };

    // these define our public api
    var methods = {
      resetDefaults: function() {
        $.fn.wysihtml5.defaultOptions = $.extend(true, {}, $.fn.wysihtml5.defaultOptionsCache);
      },
      bypassDefaults: function(options) {
        return this.each(function () {
          var $this = $(this);
          $this.data('wysihtml5', new Wysihtml5($this, options));
        });
      },
      shallowExtend: function (options) {
        var settings = $.extend({}, $.fn.wysihtml5.defaultOptions, options || {}, $(this).data());
        var that = this;
        return methods.bypassDefaults.apply(that, [settings]);
      },
      deepExtend: function(options) {
        var settings = $.extend(true, {}, $.fn.wysihtml5.defaultOptions, options || {});
        var that = this;
        return methods.bypassDefaults.apply(that, [settings]);
      },
      init: function(options) {
        var that = this;
        return methods.shallowExtend.apply(that, [options]);
      }
    };

    $.fn.wysihtml5 = function ( method ) {
      if ( methods[method] ) {
        return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
      } else if ( typeof method === 'object' || ! method ) {
        return methods.init.apply( this, arguments );
      } else {
        $.error( 'Method ' +  method + ' does not exist on jQuery.wysihtml5' );
      }    
    };

    $.fn.wysihtml5.Constructor = Wysihtml5;

    var defaultOptions = $.fn.wysihtml5.defaultOptions = {
      toolbar: {
        'font-styles': true,
        'color': false,
        'emphasis': {
          'small': true
        },
        'blockquote': true,
        'lists': true,
        'html': false,
        'link': true,
        'image': true,
        'smallmodals': false
      },
      useLineBreaks: false,
      parserRules: {
        classes: {
          'wysiwyg-color-silver' : 1,
          'wysiwyg-color-gray' : 1,
          'wysiwyg-color-white' : 1,
          'wysiwyg-color-maroon' : 1,
          'wysiwyg-color-red' : 1,
          'wysiwyg-color-purple' : 1,
          'wysiwyg-color-fuchsia' : 1,
          'wysiwyg-color-green' : 1,
          'wysiwyg-color-lime' : 1,
          'wysiwyg-color-olive' : 1,
          'wysiwyg-color-yellow' : 1,
          'wysiwyg-color-navy' : 1,
          'wysiwyg-color-blue' : 1,
          'wysiwyg-color-teal' : 1,
          'wysiwyg-color-aqua' : 1,
          'wysiwyg-color-orange' : 1
        },
        tags: {
          'b':  {},
          'i':  {},
          'strong': {},
          'em': {},
          'p': {},
          'br': {},
          'ol': {},
          'ul': {},
          'li': {},
          'h1': {},
          'h2': {},
          'h3': {},
          'h4': {},
          'h5': {},
          'h6': {},
          'blockquote': {},
          'u': 1,
          'img': {
            'check_attributes': {
              'width': 'numbers',
              'alt': 'alt',
              'src': 'url',
              'height': 'numbers'
            }
          },
          'a':  {
            'check_attributes': {
              'href': 'url'
            },
            'set_attributes': {
              'target': '_blank',
              'rel': 'nofollow'
            }
          },
          'span': 1,
          'div': 1,
          'small': 1,
          'code': 1,
          'pre': 1
        }
      },
      locale: 'en',
      shortcuts: {
        '83': 'small',// S
        '75': 'createLink'// K
      }
    };

    if (typeof $.fn.wysihtml5.defaultOptionsCache === 'undefined') {
      $.fn.wysihtml5.defaultOptionsCache = $.extend(true, {}, $.fn.wysihtml5.defaultOptions);
    }

    var locale = $.fn.wysihtml5.locale = {};
  };
  bsWysihtml5($, wysihtml5);
}));
(function(wysihtml5) {
  wysihtml5.commands.small = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatInline.exec(composer, command, "small");
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "small");
    }
  };
})(wysihtml5);

/**
 * English translation for bootstrap-wysihtml5
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('bootstrap.wysihtml5.en-US', ['jquery', 'bootstrap.wysihtml5'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
  $.fn.wysihtml5.locale.en = $.fn.wysihtml5.locale['en-US'] = {
    font_styles: {
      normal: 'Normal text',
      h1: 'Heading 1',
      h2: 'Heading 2',
      h3: 'Heading 3',
      h4: 'Heading 4',
      h5: 'Heading 5',
      h6: 'Heading 6'
    },
    emphasis: {
      bold: 'Bold',
      italic: 'Italic',
      underline: 'Underline',
      small: 'Small'
    },
    lists: {
      unordered: 'Unordered list',
      ordered: 'Ordered list',
      outdent: 'Outdent',
      indent: 'Indent'
    },
    link: {
      insert: 'Insert link',
      cancel: 'Cancel',
      target: 'Open link in new window'
    },
    image: {
      insert: 'Insert image',
      cancel: 'Cancel'
    },
    html: {
      edit: 'Edit HTML'
    },
    colours: {
      black: 'Black',
      silver: 'Silver',
      gray: 'Grey',
      maroon: 'Maroon',
      red: 'Red',
      purple: 'Purple',
      green: 'Green',
      olive: 'Olive',
      navy: 'Navy',
      blue: 'Blue',
      orange: 'Orange'
    }
  };
}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJvb3RzdHJhcDMtd3lzaWh0bWw1LmFsbC5qcyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJnZXQiLCJpbm5lclRleHQiLCJjYWxsIiwidGhpcyIsInNldCIsInMiLCJBcnJheSIsImlzQXJyYXkiLCJhcmciLCJ0b1N0cmluZyIsInd5c2lodG1sNSIsInZlcnNpb24iLCJjb21tYW5kcyIsImRvbSIsInF1aXJrcyIsInRvb2xiYXIiLCJsYW5nIiwic2VsZWN0aW9uIiwidmlld3MiLCJJTlZJU0lCTEVfU1BBQ0UiLCJFTVBUWV9GVU5DVElPTiIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkJBQ0tTUEFDRV9LRVkiLCJFTlRFUl9LRVkiLCJFU0NBUEVfS0VZIiwiU1BBQ0VfS0VZIiwiREVMRVRFX0tFWSIsImZhY3RvcnkiLCJnbG9iYWwiLCJkZWZpbmUiLCJhbWQiLCJyYW5neSIsImlzSG9zdE1ldGhvZCIsIm8iLCJwIiwidCIsIkZVTkNUSU9OIiwiT0JKRUNUIiwiaXNIb3N0T2JqZWN0IiwiaXNIb3N0UHJvcGVydHkiLCJVTkRFRklORUQiLCJjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdCIsInRlc3RGdW5jIiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiaXNUZXh0UmFuZ2UiLCJyYW5nZSIsImFyZUhvc3RNZXRob2RzIiwidGV4dFJhbmdlTWV0aG9kcyIsImFyZUhvc3RQcm9wZXJ0aWVzIiwidGV4dFJhbmdlUHJvcGVydGllcyIsImdldEJvZHkiLCJkb2MiLCJib2R5IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjb25zb2xlTG9nIiwibXNnIiwid2luZG93IiwiY29uc29sZSIsImxvZyIsImFsZXJ0T3JMb2ciLCJzaG91bGRBbGVydCIsImFsZXJ0IiwiZmFpbCIsInJlYXNvbiIsImFwaSIsImluaXRpYWxpemVkIiwic3VwcG9ydGVkIiwiY29uZmlnIiwiYWxlcnRPbkZhaWwiLCJ3YXJuIiwiYWxlcnRPbldhcm4iLCJnZXRFcnJvckRlc2MiLCJleCIsIm1lc3NhZ2UiLCJkZXNjcmlwdGlvbiIsIlN0cmluZyIsImluaXQiLCJ0ZXN0UmFuZ2UiLCJpbXBsZW1lbnRzRG9tUmFuZ2UiLCJpbXBsZW1lbnRzVGV4dFJhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsImRvbVJhbmdlTWV0aG9kcyIsImRvbVJhbmdlUHJvcGVydGllcyIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJmZWF0dXJlcyIsIm1vZHVsZSIsImVycm9yTWVzc2FnZSIsIm1vZHVsZU5hbWUiLCJtb2R1bGVzIiwiTW9kdWxlIiwibGVuIiwiaW5pdExpc3RlbmVycyIsInNoaW0iLCJ3aW4iLCJzaGltTGlzdGVuZXJzIiwibmFtZSIsImRlcGVuZGVuY2llcyIsImluaXRpYWxpemVyIiwiY3JlYXRlTW9kdWxlIiwiaXNDb3JlIiwiaW5pdEZ1bmMiLCJuZXdNb2R1bGUiLCJSYW5nZVByb3RvdHlwZSIsIlNlbGVjdGlvblByb3RvdHlwZSIsImFyZUhvc3RPYmplY3RzIiwidXRpbCIsInByZWZlclRleHRSYW5nZSIsImF1dG9Jbml0aWFsaXplIiwicmFuZ3lBdXRvSW5pdGlhbGl6ZSIsImhhc093blByb3BlcnR5IiwiZXh0ZW5kIiwib2JqIiwiZGVlcCIsImVsIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwidG9BcnJheSIsInNsaWNlIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwiYXJyYXlMaWtlIiwiZSIsImFyciIsImFkZExpc3RlbmVyIiwiZXZlbnRUeXBlIiwibGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJhZGRJbml0TGlzdGVuZXIiLCJwdXNoIiwiYWRkU2hpbUxpc3RlbmVyIiwiY3JlYXRlTWlzc2luZ05hdGl2ZUFwaSIsInJlcXVpcmVkTW9kdWxlIiwicmVxdWlyZWRNb2R1bGVOYW1lcyIsIkVycm9yIiwiZGVwcmVjYXRpb25Ob3RpY2UiLCJkZXByZWNhdGVkIiwicmVwbGFjZW1lbnQiLCJjcmVhdGVFcnJvciIsImFyZ3VtZW50cyIsImNyZWF0ZUNvcmVNb2R1bGUiLCJyYW5nZVByb3RvdHlwZSIsInNlbGVjdGlvblByb3RvdHlwZSIsImRvY1JlYWR5IiwibG9hZEhhbmRsZXIiLCJpc0h0bWxOYW1lc3BhY2UiLCJub2RlIiwibnMiLCJuYW1lc3BhY2VVUkkiLCJVTkRFRiIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwiZ2V0Tm9kZUluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwiZ2V0Tm9kZUxlbmd0aCIsImdldENvbW1vbkFuY2VzdG9yIiwibm9kZTEiLCJub2RlMiIsIm4iLCJhbmNlc3RvcnMiLCJhcnJheUNvbnRhaW5zIiwiaXNBbmNlc3Rvck9mIiwiYW5jZXN0b3IiLCJkZXNjZW5kYW50Iiwic2VsZklzQW5jZXN0b3IiLCJpc09ySXNBbmNlc3Rvck9mIiwiZ2V0Q2xvc2VzdEFuY2VzdG9ySW4iLCJpc0NoYXJhY3RlckRhdGFOb2RlIiwiaXNUZXh0T3JDb21tZW50Tm9kZSIsImluc2VydEFmdGVyIiwicHJlY2VkaW5nTm9kZSIsIm5leHROb2RlIiwibmV4dFNpYmxpbmciLCJpbnNlcnRCZWZvcmUiLCJzcGxpdERhdGFOb2RlIiwiaW5kZXgiLCJwb3NpdGlvbnNUb1ByZXNlcnZlIiwibmV3Tm9kZSIsImNsb25lTm9kZSIsImRlbGV0ZURhdGEiLCJwb3NpdGlvbiIsIm9mZnNldCIsImdldERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImdldFdpbmRvdyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiZ2V0SWZyYW1lRG9jdW1lbnQiLCJpZnJhbWVFbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJnZXRJZnJhbWVXaW5kb3ciLCJpc1dpbmRvdyIsImdldENvbnRlbnREb2N1bWVudCIsIm1ldGhvZE5hbWUiLCJ0YWdOYW1lIiwiZ2V0Um9vdENvbnRhaW5lciIsImNvbXBhcmVQb2ludHMiLCJub2RlQSIsIm9mZnNldEEiLCJub2RlQiIsIm9mZnNldEIiLCJub2RlQyIsInJvb3QiLCJjaGlsZEEiLCJjaGlsZEIiLCJmaXJzdENoaWxkIiwiaXNCcm9rZW5Ob2RlIiwiaW5zcGVjdE5vZGUiLCJjcmFzaHlUZXh0Tm9kZXMiLCJkYXRhIiwiaWRBdHRyIiwiaWQiLCJpbm5lckhUTUwiLCJmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4iLCJjaGlsZCIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIk5vZGVJdGVyYXRvciIsIl9uZXh0IiwiY3JlYXRlSXRlcmF0b3IiLCJEb21Qb3NpdGlvbiIsIkRPTUV4Y2VwdGlvbiIsImNvZGVOYW1lIiwiY29kZSIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJ2YWwiLCJnZXRDb21wdXRlZFN0eWxlUHJvcGVydHkiLCJnZXRDb21wdXRlZFN0eWxlIiwicHJvcE5hbWUiLCJkb2N1bWVudEVsZW1lbnQiLCJjdXJyZW50U3R5bGUiLCJfY3VycmVudCIsImhhc05leHQiLCJuZXh0IiwiZGV0YWNoIiwiZXF1YWxzIiwicG9zIiwiaW5zcGVjdCIsIklOREVYX1NJWkVfRVJSIiwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSIiwiV1JPTkdfRE9DVU1FTlRfRVJSIiwiTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSIiwiTk9UX0ZPVU5EX0VSUiIsIk5PVF9TVVBQT1JURURfRVJSIiwiSU5WQUxJRF9TVEFURV9FUlIiLCJJTlZBTElEX05PREVfVFlQRV9FUlIiLCJpc05vblRleHRQYXJ0aWFsbHlTZWxlY3RlZCIsInN0YXJ0Q29udGFpbmVyIiwiZW5kQ29udGFpbmVyIiwiZ2V0UmFuZ2VEb2N1bWVudCIsImdldEJvdW5kYXJ5QmVmb3JlTm9kZSIsImdldEJvdW5kYXJ5QWZ0ZXJOb2RlIiwiaW5zZXJ0Tm9kZUF0UG9zaXRpb24iLCJmaXJzdE5vZGVJbnNlcnRlZCIsInJhbmdlc0ludGVyc2VjdCIsInJhbmdlQSIsInJhbmdlQiIsInRvdWNoaW5nSXNJbnRlcnNlY3RpbmciLCJhc3NlcnRSYW5nZVZhbGlkIiwic3RhcnRDb21wYXJpc29uIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJlbmRDb21wYXJpc29uIiwiY2xvbmVTdWJ0cmVlIiwiaXRlcmF0b3IiLCJwYXJ0aWFsbHlTZWxlY3RlZCIsInN1Ykl0ZXJhdG9yIiwiZnJhZyIsImlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlIiwiZ2V0U3VidHJlZUl0ZXJhdG9yIiwiaXRlcmF0ZVN1YnRyZWUiLCJyYW5nZUl0ZXJhdG9yIiwiZnVuYyIsIml0ZXJhdG9yU3RhdGUiLCJpdCIsInN0b3AiLCJzdWJSYW5nZUl0ZXJhdG9yIiwiZGVsZXRlU3VidHJlZSIsInJlbW92ZSIsImV4dHJhY3RTdWJ0cmVlIiwiZ2V0Tm9kZXNJblJhbmdlIiwibm9kZVR5cGVzIiwiZmlsdGVyIiwicmVnZXgiLCJmaWx0ZXJOb2RlVHlwZXMiLCJmaWx0ZXJFeGlzdHMiLCJSZWdFeHAiLCJqb2luIiwibm9kZXMiLCJSYW5nZUl0ZXJhdG9yIiwidGVzdCIsInNjIiwiZWMiLCJnZXROYW1lIiwiY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2RlcyIsImNvbGxhcHNlZCIsInNvIiwiZW8iLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUiLCJfZmlyc3QiLCJfbGFzdCIsImNyZWF0ZUFuY2VzdG9yRmluZGVyIiwiYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciIsImFsbG93U2VsZiIsImdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yIiwiYXNzZXJ0VmFsaWROb2RlVHlwZSIsImludmFsaWRUeXBlcyIsImFzc2VydFZhbGlkT2Zmc2V0IiwiYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudCIsImdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lciIsImFzc2VydE5vZGVOb3RSZWFkT25seSIsImdldFJlYWRvbmx5QW5jZXN0b3IiLCJhc3NlcnROb2RlIiwiaXNPcnBoYW4iLCJyb290Q29udGFpbmVyTm9kZVR5cGVzIiwiaXNWYWxpZE9mZnNldCIsImlzUmFuZ2VWYWxpZCIsInNwbGl0UmFuZ2VCb3VuZGFyaWVzIiwic3RhcnRFbmRTYW1lIiwic2V0U3RhcnRBbmRFbmQiLCJyYW5nZVRvSHRtbCIsImNvbnRhaW5lciIsImNsb25lQ29udGVudHMiLCJjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0IiwiU1RBUlRfVE9fU1RBUlQiLCJzMnMiLCJTVEFSVF9UT19FTkQiLCJzMmUiLCJFTkRfVE9fRU5EIiwiZTJlIiwiRU5EX1RPX1NUQVJUIiwiZTJzIiwiTk9ERV9CRUZPUkUiLCJuX2IiLCJOT0RFX0FGVEVSIiwibl9hIiwiTk9ERV9CRUZPUkVfQU5EX0FGVEVSIiwibl9iX2EiLCJOT0RFX0lOU0lERSIsIm5faSIsImNvcHlDb21wYXJpc29uQ29uc3RhbnRzIiwiY29uc3RydWN0b3IiLCJjcmVhdGVSYW5nZUNvbnRlbnRSZW1vdmVyIiwicmVtb3ZlciIsImJvdW5kYXJ5VXBkYXRlciIsImJvdW5kYXJ5IiwicmVzZXQiLCJyZXR1cm5WYWx1ZSIsImNyZWF0ZVByb3RvdHlwZVJhbmdlIiwiY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyIiwiaXNCZWZvcmUiLCJpc1N0YXJ0IiwiYmVmb3JlQWZ0ZXJOb2RlVHlwZXMiLCJzZXRSYW5nZVN0YXJ0Iiwic2V0UmFuZ2VFbmQiLCJGIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJhcmdzIiwic2V0Qm91bmRhcnkiLCJzZXRTdGFydEJlZm9yZSIsInNldFN0YXJ0QWZ0ZXIiLCJzZXRFbmRCZWZvcmUiLCJzZXRFbmRBZnRlciIsImNvbGxhcHNlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwic2VsZWN0Tm9kZSIsInN0YXJ0IiwiZW5kIiwiZXh0cmFjdENvbnRlbnRzIiwiZGVsZXRlQ29udGVudHMiLCJjYW5TdXJyb3VuZENvbnRlbnRzIiwiYm91bmRhcmllc0ludmFsaWQiLCJzcGxpdEJvdW5kYXJpZXMiLCJzcGxpdEJvdW5kYXJpZXNQcmVzZXJ2aW5nUG9zaXRpb25zIiwibm9ybWFsaXplQm91bmRhcmllcyIsIm1lcmdlRm9yd2FyZCIsInNpYmxpbmciLCJhcHBlbmREYXRhIiwicmVtb3ZlQ2hpbGQiLCJtZXJnZUJhY2t3YXJkIiwibm9kZUxlbmd0aCIsImluc2VydERhdGEiLCJub2RlSW5kZXgiLCJub3JtYWxpemVTdGFydCIsImVuZE5vZGUiLCJzdGFydE5vZGUiLCJjb2xsYXBzZVRvUG9pbnQiLCJ1cGRhdGVDb2xsYXBzZWRBbmRDb21tb25BbmNlc3RvciIsInVwZGF0ZUJvdW5kYXJpZXMiLCJSYW5nZSIsImN1cnJlbnQiLCJzdWJSYW5nZSIsImNsb25lUmFuZ2UiLCJyZWFkb25seU5vZGVUeXBlcyIsImluc2VydGFibGVOb2RlVHlwZXMiLCJzdXJyb3VuZE5vZGVUeXBlcyIsInN0eWxlRWwiLCJodG1sUGFyc2luZ0NvbmZvcm1zIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiZnJhZ21lbnRTdHIiLCJyYW5nZVByb3BlcnRpZXMiLCJjb21wYXJlQm91bmRhcnlQb2ludHMiLCJob3ciLCJwcmVmaXhBIiwicHJlZml4QiIsImluc2VydE5vZGUiLCJjbG9uZSIsInN1cnJvdW5kQ29udGVudHMiLCJjb250ZW50IiwiaGFzQ2hpbGROb2RlcyIsImxhc3RDaGlsZCIsInByb3AiLCJ0ZXh0UGFydHMiLCJjb21wYXJlTm9kZSIsImNvbXBhcmVQb2ludCIsInRvSHRtbCIsImludGVyc2VjdHNOb2RlIiwiaXNQb2ludEluUmFuZ2UiLCJpbnRlcnNlY3RzUmFuZ2UiLCJpbnRlcnNlY3RzT3JUb3VjaGVzUmFuZ2UiLCJpbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Rpb25SYW5nZSIsInVuaW9uIiwidW5pb25SYW5nZSIsImNvbnRhaW5zTm9kZSIsImFsbG93UGFydGlhbCIsImNvbnRhaW5zTm9kZUNvbnRlbnRzIiwiY29udGFpbnNSYW5nZSIsImNvbnRhaW5zTm9kZVRleHQiLCJub2RlUmFuZ2UiLCJ0ZXh0Tm9kZXMiLCJnZXROb2RlcyIsImxhc3RUZXh0Tm9kZSIsInBvcCIsImNvbGxhcHNlQmVmb3JlIiwiY29sbGFwc2VBZnRlciIsImdldEJvb2ttYXJrIiwiY29udGFpbmVyTm9kZSIsInByZVNlbGVjdGlvblJhbmdlIiwibW92ZVRvQm9va21hcmsiLCJib29rbWFyayIsImNoYXJJbmRleCIsIm5leHRDaGFySW5kZXgiLCJub2RlU3RhY2siLCJmb3VuZFN0YXJ0IiwicmFuZ2VzRXF1YWwiLCJpc1ZhbGlkIiwicjEiLCJyMiIsIkRvbVJhbmdlIiwiV3JhcHBlZFJhbmdlIiwiV3JhcHBlZFRleHRSYW5nZSIsInVwZGF0ZVJhbmdlUHJvcGVydGllcyIsIm5hdGl2ZVJhbmdlIiwidXBkYXRlTmF0aXZlUmFuZ2UiLCJzdGFydE1vdmVkIiwiZW5kTW92ZWQiLCJuYXRpdmVSYW5nZURpZmZlcmVudCIsInJhbmdlUHJvdG8iLCJyZWZyZXNoIiwidGVzdFRleHROb2RlIiwib3Bwb3NpdGVOYW1lIiwicmFuZ2UyIiwidHlwZSIsImNyZWF0ZU5hdGl2ZVJhbmdlIiwiZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCIsInRleHRSYW5nZSIsInBhcmVudEVsIiwiZHVwbGljYXRlIiwic3RhcnRFbCIsImVuZEVsIiwic3RhcnRFbmRDb250YWluZXIiLCJ0ZXh0UmFuZ2VJc0NvbGxhcHNlZCIsImNvbXBhcmVFbmRQb2ludHMiLCJnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uIiwid2hvbGVSYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJpc0NvbGxhcHNlZCIsInN0YXJ0SW5mbyIsIndvcmtpbmdSYW5nZSIsImNvbnRhaW5lckVsZW1lbnQiLCJjYW5IYXZlSFRNTCIsImJvdW5kYXJ5UG9zaXRpb24iLCJub2RlSW5mbyIsIndvcmtpbmdOb2RlIiwiY29tcGFyaXNvbiIsInByZXZpb3VzTm9kZSIsImJvdW5kYXJ5Tm9kZSIsIndvcmtpbmdDb21wYXJpc29uVHlwZSIsImNoaWxkTm9kZUNvdW50IiwibW92ZVRvRWxlbWVudFRleHQiLCJNYXRoIiwiZmxvb3IiLCJzZXRFbmRQb2ludCIsInRlbXBSYW5nZSIsInJhbmdlTGVuZ3RoIiwidGV4dCIsInJlcGxhY2UiLCJtb3ZlU3RhcnQiLCJjcmVhdGVCb3VuZGFyeVRleHRSYW5nZSIsImJvdW5kYXJ5UGFyZW50IiwiYm91bmRhcnlPZmZzZXQiLCJub2RlSXNEYXRhTm9kZSIsInN0YXJ0Qm91bmRhcnkiLCJyYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJyYW5nZVRvVGV4dFJhbmdlIiwic3RhcnRSYW5nZSIsImVuZFJhbmdlIiwidG9UZXh0UmFuZ2UiLCJnbG9iYWxPYmoiLCJjcmVhdGVSYW5neVJhbmdlIiwiY3JlYXRlSWZyYW1lUmFuZ2UiLCJjcmVhdGVJZnJhbWVSYW5neVJhbmdlIiwiaXNEaXJlY3Rpb25CYWNrd2FyZCIsImRpciIsIldyYXBwZWRTZWxlY3Rpb24iLCJnZXRXaW5TZWxlY3Rpb24iLCJ3aW5QYXJhbSIsImdldFNlbGVjdGlvbiIsImdldERvY1NlbGVjdGlvbiIsIndpblNlbGVjdGlvbklzQmFja3dhcmQiLCJzZWwiLCJiYWNrd2FyZCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsInVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlIiwiYW5jaG9yUHJlZml4IiwiZm9jdXNQcmVmaXgiLCJ1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21OYXRpdmVTZWxlY3Rpb24iLCJuYXRpdmVTZWwiLCJuYXRpdmVTZWxlY3Rpb24iLCJ1cGRhdGVFbXB0eVNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJfcmFuZ2VzIiwiZ2V0TmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5zU2luZ2xlRWxlbWVudCIsInJhbmdlTm9kZXMiLCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlIiwidXBkYXRlRnJvbVRleHRSYW5nZSIsIndyYXBwZWRSYW5nZSIsInVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24iLCJkb2NTZWxlY3Rpb24iLCJjb250cm9sUmFuZ2UiLCJpdGVtIiwiYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24iLCJyYW5nZUVsZW1lbnQiLCJuZXdDb250cm9sUmFuZ2UiLCJjcmVhdGVDb250cm9sUmFuZ2UiLCJhZGQiLCJzZWxlY3QiLCJkZWxldGVQcm9wZXJ0aWVzIiwiZGV0YWNoZWQiLCJhY3RPbkNhY2hlZFNlbGVjdGlvbiIsImFjdGlvbiIsImNhY2hlZCIsImNhY2hlZFJhbmd5U2VsZWN0aW9ucyIsInNwbGljZSIsImNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24iLCJyYW5nZXMiLCJhc3NlcnROb2RlSW5TYW1lRG9jdW1lbnQiLCJjcmVhdGVTdGFydE9yRW5kU2V0dGVyIiwiZ2V0UmFuZ2VBdCIsInNldFNpbmdsZVJhbmdlIiwiaXNCYWNrd2FyZCIsInJhbmdlSW5zcGVjdHMiLCJhbmNob3IiLCJmb2N1cyIsImNoZWNrU2VsZWN0aW9uUmFuZ2VzIiwiZ2V0TmF0aXZlU2VsZWN0aW9uIiwic2VsZWN0aW9uSXNDb2xsYXBzZWQiLCJCT09MRUFOIiwiTlVNQkVSIiwiQ09OVFJPTCIsImltcGxlbWVudHNXaW5HZXRTZWxlY3Rpb24iLCJpbXBsZW1lbnRzRG9jU2VsZWN0aW9uIiwidXNlRG9jdW1lbnRTZWxlY3Rpb24iLCJpc1NlbGVjdGlvblZhbGlkIiwidGVzdFNlbGVjdGlvbiIsInNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzIiwic2VsZWN0aW9uSGFzRXh0ZW5kIiwic2VsZWN0aW9uSGFzUmFuZ2VDb3VudCIsInNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMiLCJjb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQiLCJhZGRSYW5nZUJhY2t3YXJkVG9OYXRpdmUiLCJhZGRSYW5nZSIsIm9yaWdpbmFsU2VsZWN0aW9uUmFuZ2VDb3VudCIsInNlbGVjdGlvbkhhc011bHRpcGxlUmFuZ2VzIiwib3JpZ2luYWxTZWxlY3Rpb25SYW5nZXMiLCJvcmlnaW5hbFNlbGVjdGlvbkJhY2t3YXJkIiwidGVzdEVsIiwiY29udGVudEVkaXRhYmxlIiwicmVtb3ZlQWxsUmFuZ2VzIiwiY2hyb21lTWF0Y2giLCJuYXZpZ2F0b3IiLCJhcHBWZXJzaW9uIiwibWF0Y2giLCJwYXJzZUludCIsInRlc3RDb250cm9sUmFuZ2UiLCJpbXBsZW1lbnRzQ29udHJvbFJhbmdlIiwiZ2V0U2VsZWN0aW9uUmFuZ2VBdCIsImRvY1NlbCIsImdldElmcmFtZVNlbGVjdGlvbiIsInNlbFByb3RvIiwiYWRkUmFuZ2VCYWNrd2FyZCIsImRpcmVjdGlvbiIsInByZXZpb3VzUmFuZ2VDb3VudCIsInNlbGVjdGlvbklzQmFja3dhcmQiLCJzZXRSYW5nZXMiLCJlbXB0eSIsInJlZnJlc2hTZWxlY3Rpb24iLCJjaGVja0ZvckNoYW5nZXMiLCJvbGRSYW5nZXMiLCJvbGRBbmNob3JOb2RlIiwib2xkQW5jaG9yT2Zmc2V0IiwicmVtb3ZlUmFuZ2VNYW51YWxseSIsImdldEFsbFJhbmdlcyIsInJlbW92ZVJhbmdlIiwicmVtb3ZlZCIsImlzQmFja3dhcmRzIiwicmFuZ2VUZXh0cyIsImNvbGxhcHNlVG9TdGFydCIsImNvbGxhcHNlVG9FbmQiLCJzZWxlY3RBbGxDaGlsZHJlbiIsImRlbGV0ZUZyb21Eb2N1bWVudCIsImVsZW1lbnQiLCJlYWNoUmFuZ2UiLCJjYWxsTWV0aG9kT25FYWNoUmFuZ2UiLCJwYXJhbXMiLCJyZXN1bHRzIiwiYXBwbHkiLCJjaGFuZ2VFYWNoUmFuZ2UiLCJyYW5nZUJvb2ttYXJrcyIsInJhbmdlQm9va21hcmsiLCJzZWxSYW5nZXMiLCJyYW5nZUh0bWxzIiwiZ2V0TmF0aXZlVGV4dFJhbmdlIiwiZGV0YWNoQWxsIiwiU2VsZWN0aW9uIiwiZ0VCSSIsImdldEVsZW1lbnRCeUlkIiwiaW5zZXJ0UmFuZ2VCb3VuZGFyeU1hcmtlciIsImF0U3RhcnQiLCJtYXJrZXJFbCIsIm1hcmtlcklkIiwiRGF0ZSIsInJhbmRvbSIsImJvdW5kYXJ5UmFuZ2UiLCJzdHlsZSIsImxpbmVIZWlnaHQiLCJkaXNwbGF5IiwiY2xhc3NOYW1lIiwibWFya2VyVGV4dENoYXIiLCJzZXRSYW5nZUJvdW5kYXJ5IiwiY29tcGFyZVJhbmdlcyIsInNhdmVSYW5nZSIsInN0YXJ0TWFya2VySWQiLCJlbmRNYXJrZXJJZCIsInJlc3RvcmVSYW5nZSIsInJhbmdlSW5mbyIsIm5vcm1hbGl6ZSIsInNhdmVSYW5nZXMiLCJyYW5nZUluZm9zIiwic29ydCIsInNhdmVTZWxlY3Rpb24iLCJyZXN0b3JlZCIsInJlc3RvcmVSYW5nZXMiLCJyZXN0b3JlU2VsZWN0aW9uIiwic2F2ZWRTZWxlY3Rpb24iLCJwcmVzZXJ2ZURpcmVjdGlvbiIsInJlbW92ZU1hcmtlckVsZW1lbnQiLCJyZW1vdmVNYXJrZXJzIiwiQmFzZSIsIl9pbnN0YW5jZSIsIl9zdGF0aWMiLCJfcHJvdG90eXBpbmciLCJwcm90byIsImJhc2UiLCJrbGFzcyIsIl9jb25zdHJ1Y3RpbmciLCJmb3JFYWNoIiwiaW1wbGVtZW50IiwidmFsdWVPZiIsInNvdXJjZSIsInZhbHVlIiwibWV0aG9kIiwicHJldmlvdXMiLCJ0b1NvdXJjZSIsImhpZGRlbiIsImtleSIsIm9iamVjdCIsImJsb2NrIiwiY29udGV4dCIsInVuZGVmaW5lZCIsImJyb3dzZXIiLCJpb3NWZXJzaW9uIiwidXNlckFnZW50IiwiYW5kcm9pZFZlcnNpb24iLCJpc0lFIiwiZXF1YXRpb24iLCJyZSIsInJ2IiwiYXBwTmFtZSIsImV4ZWMiLCJwYXJzZUZsb2F0IiwiJDEiLCJ0ZXN0RWxlbWVudCIsImlzR2Vja28iLCJpbmRleE9mIiwiaXNXZWJLaXQiLCJpc0Nocm9tZSIsImlzT3BlcmEiLCJVU0VSX0FHRU5UIiwiaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydCIsImhhc0VkaXRpbmdBcGlTdXBwb3J0IiwiZXhlY0NvbW1hbmQiLCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWQiLCJxdWVyeUNvbW1hbmRTdGF0ZSIsImhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0IiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXIiLCJpc0lvcyIsImlzQW5kcm9pZCIsImlzVG91Y2hEZXZpY2UiLCJzdXBwb3J0c0V2ZW50Iiwic3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzIiwidGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5IiwiZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkiLCJoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSIsImhhc0hpc3RvcnlJc3N1ZSIsInBsYXRmb3JtIiwic3Vic3RyIiwiaW5zZXJ0c0xpbmVCcmVha3NPblJldHVybiIsInN1cHBvcnRzUGxhY2Vob2xkZXJBdHRyaWJ1dGVPbiIsImV2ZW50TmFtZSIsInNldEF0dHJpYnV0ZSIsInN1cHBvcnRzRXZlbnRzSW5JZnJhbWVDb3JyZWN0bHkiLCJzdXBwb3J0c0hUTUw1VGFncyIsImh0bWw1Iiwic3VwcG9ydHNDb21tYW5kIiwiYnVnZ3lDb21tYW5kcyIsImZvcm1hdEJsb2NrIiwiaW5zZXJ0VW5vcmRlcmVkTGlzdCIsImluc2VydE9yZGVyZWRMaXN0IiwiaW5zZXJ0SFRNTCIsImNvbW1hbmQiLCJpc0J1Z2d5IiwiZTEiLCJxdWVyeUNvbW1hbmRFbmFibGVkIiwiZTIiLCJkb2VzQXV0b0xpbmtpbmdJbkNvbnRlbnRFZGl0YWJsZSIsImNhbkRpc2FibGVBdXRvTGlua2luZyIsImNsZWFyc0NvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSIsInN1cHBvcnRzR2V0QXR0cmlidXRlQ29ycmVjdGx5IiwidGQiLCJnZXRBdHRyaWJ1dGUiLCJjYW5TZWxlY3RJbWFnZXNJbkNvbnRlbnRFZGl0YWJsZSIsImF1dG9TY3JvbGxzVG9DYXJldCIsImF1dG9DbG9zZXNVbmNsb3NlZFRhZ3MiLCJjbG9uZWRUZXN0RWxlbWVudCIsInN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSIsIm5lZWRzU3BhY2VBZnRlckxpbmVCcmVhayIsInN1cHBvcnRzU3BlZWNoQXBpT24iLCJpbnB1dCIsImNocm9tZVZlcnNpb24iLCJjcmFzaGVzV2hlbkRlZmluZVByb3BlcnR5IiwicHJvcGVydHkiLCJkb2VzQXN5bmNGb2N1cyIsImhhc1Byb2JsZW1zU2V0dGluZ0NhcmV0QWZ0ZXJJbWciLCJoYXNVbmRvSW5Db250ZXh0TWVudSIsImhhc0luc2VydE5vZGVJc3N1ZSIsImhhc0lmcmFtZUZvY3VzSXNzdWUiLCJjcmVhdGVzTmVzdGVkSW52YWxpZE1hcmt1cEFmdGVyUGFzdGUiLCJzdXBwb3J0c011dGF0aW9uRXZlbnRzIiwic3VwcG9ydHNNb2RlblBhc3RlIiwiYXJyYXkiLCJjb250YWlucyIsIm5lZWRsZSIsIndpdGhvdXQiLCJhcnJheVRvU3Vic3RyYWN0IiwibmV3QXJyIiwibmV3QXJyYXkiLCJtYXAiLCJjYWxsYmFjayIsInRoaXNBcmciLCJBIiwidW5pcXVlIiwidmFscyIsIm1heCIsImlkeCIsIkRpc3BhdGNoZXIiLCJvbiIsImhhbmRsZXIiLCJldmVudHMiLCJvZmYiLCJoYW5kbGVycyIsIm5ld0hhbmRsZXJzIiwiZmlyZSIsInBheWxvYWQiLCJvYnNlcnZlIiwic3RvcE9ic2VydmluZyIsIm1lcmdlIiwib3RoZXJPYmoiLCJuZXdPYmoiLCJpc1BsYWluT2JqZWN0IiwiaXNGdW5jdGlvbiIsIldISVRFX1NQQUNFX1NUQVJUIiwiV0hJVEVfU1BBQ0VfRU5EIiwiRU5USVRZX1JFR19FWFAiLCJFTlRJVFlfTUFQIiwiJiIsIjwiLCI+IiwiXCIiLCJcdCIsInN0cmluZyIsInN0ciIsInRyaW0iLCJpbnRlcnBvbGF0ZSIsInZhcnMiLCJieSIsInNlYXJjaCIsInNwbGl0IiwiZXNjYXBlSFRNTCIsImxpbmVicmVha3MiLCJjb252ZXJ0U3BhY2VzIiwiaHRtbCIsImMiLCJhdXRvTGluayIsImlnbm9yZUluQ2xhc3NlcyIsIl9oYXNQYXJlbnRUaGF0U2hvdWxkQmVJZ25vcmVkIiwiX3BhcnNlTm9kZSIsIl9jb252ZXJ0VXJsc1RvTGlua3MiLCJVUkxfUkVHX0VYUCIsInVybCIsInB1bmN0dWF0aW9uIiwiVFJBSUxJTkdfQ0hBUl9SRUdfRVhQIiwib3BlbmluZyIsIkJSQUNLRVRTIiwicmVhbFVybCIsImRpc3BsYXlVcmwiLCJNQVhfRElTUExBWV9MRU5HVEgiLCJfZ2V0VGVtcEVsZW1lbnQiLCJ0ZW1wRWxlbWVudCIsIl93eXNpaHRtbDVfdGVtcEVsZW1lbnQiLCJfd3JhcE1hdGNoZXNJbk5vZGUiLCJub2RlVmFsdWUiLCJJR05PUkVfVVJMU19JTiIsImNoaWxkTm9kZXNMZW5ndGgiLCIpIiwiXSIsIn0iLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImhhc0NsYXNzIiwicmVtb3ZlQ2xhc3MiLCJlbGVtZW50Q2xhc3NOYW1lIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJjb252ZXJ0VG9MaXN0IiwiX2NyZWF0ZUxpc3RJdGVtIiwibGlzdCIsImxpc3RJdGVtIiwiX2NyZWF0ZUxpc3QiLCJsaXN0VHlwZSIsInVuZWRpdGFibGVDbGFzcyIsImNoaWxkTm9kZSIsImxpbmVCcmVhayIsImlzQmxvY2tFbGVtZW50IiwiaXNMaW5lQnJlYWsiLCJjdXJyZW50TGlzdEl0ZW0iLCJsaW5lQnJlYWtzIiwibGluZUJyZWFrc0xlbmd0aCIsImdldFN0eWxlIiwiZnJvbSIsImluc2VydCIsImFmdGVyIiwicmVwbGFjZUNoaWxkIiwiY29weUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzVG9Db3B5IiwiZWxlbWVudFRvQ29weUZyb20iLCJ0byIsImVsZW1lbnRUb0NvcHlUbyIsImF0dHJpYnV0ZSIsImFuZFRvIiwiY2FsbGVlIiwiQk9YX1NJWklOR19QUk9QRVJUSUVTIiwic2hvdWxkSWdub3JlQm94U2l6aW5nQm9yZGVyQm94IiwiaGFzQm94U2l6aW5nQm9yZGVyQm94Iiwib2Zmc2V0V2lkdGgiLCJjb3B5U3R5bGVzIiwic3R5bGVzVG9Db3B5IiwiY3NzVGV4dCIsInNldFN0eWxlcyIsImRlbGVnYXRlIiwic2VsZWN0b3IiLCJldmVudCIsInRhcmdldCIsImRvbU5vZGUiLCJkZWZhdWx0Tm9kZVR5cGVzIiwiX2lzQmxhbmtUZXh0IiwicHJldiIsIm9wdGlvbnMiLCJwcmV2Tm9kZSIsInR5cGVzIiwiaWdub3JlQmxhbmtUZXh0cyIsImdldEFzRG9tIiwiX2lubmVySFRNTFNoaXYiLCJfZW5zdXJlSFRNTDVDb21wYXRpYmlsaXR5IiwiX3d5c2lodG1sNV9zdXBwb3J0c0hUTUw1VGFncyIsIkhUTUw1X0VMRU1FTlRTIiwiZ2V0UGFyZW50RWxlbWVudCIsIl9pc1NhbWVOb2RlTmFtZSIsImRlc2lyZWROb2RlTmFtZXMiLCJfaXNFbGVtZW50IiwiX2hhc0NsYXNzTmFtZSIsImNsYXNzUmVnRXhwIiwiY2xhc3NOYW1lcyIsIl9oYXNTdHlsZSIsImNzc1N0eWxlIiwic3R5bGVSZWdFeHAiLCJzdHlsZXMiLCJtYXRjaGluZ1NldCIsImxldmVscyIsImZpbmRCeVN0eWxlIiwiZmluZEJ5Q2xhc3MiLCJjYW1lbGl6ZSIsIlJFR19FWFBfQ0FNRUxJWkUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN0eWxlUHJvcGVydHlNYXBwaW5nIiwiZmxvYXQiLCJjYW1lbGl6ZWRQcm9wZXJ0eSIsInN0eWxlVmFsdWUiLCJvcmlnaW5hbE92ZXJmbG93IiwibmVlZHNPdmVyZmxvd1Jlc2V0Iiwib3ZlcmZsb3ciLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0VGV4dE5vZGVzIiwiaW5nb3JlRW1wdHkiLCJhbGwiLCJ0ZXh0Q29udGVudCIsImNvbmNhdCIsImhhc0VsZW1lbnRXaXRoVGFnTmFtZSIsIl9nZXREb2N1bWVudElkZW50aWZpZXIiLCJfd3lzaWh0bWw1X2lkZW50aWZpZXIiLCJET0NVTUVOVF9JREVOVElGSUVSIiwiTElWRV9DQUNIRSIsImNhY2hlRW50cnkiLCJoYXNFbGVtZW50V2l0aENsYXNzTmFtZSIsImVsZW1lbnRUb0luc2VydCIsImJlZm9yZSIsImludG8iLCJpbnNlcnRDU1MiLCJydWxlcyIsInN0eWxlRWxlbWVudCIsInN0eWxlU2hlZXQiLCJsaW5rIiwiaGVhZCIsIl9pc0xpbmVCcmVhayIsIl9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50IiwiZXZlbnROYW1lcyIsImhhbmRsZXJXcmFwcGVyIiwic3JjRWxlbWVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwicGFyc2UiLCJlbGVtZW50T3JIdG1sX2N1cnJlbnQiLCJjb25maWdfY3VycmVudCIsImVsZW1lbnRPckh0bWwiLCJjdXJyZW50UnVsZXMiLCJkZWZhdWx0UnVsZXMiLCJpc1N0cmluZyIsImNsZWFySW50ZXJuYWxzIiwic2VsZWN0b3JzIiwiX2FwcGx5U2VsZWN0b3JSdWxlcyIsIl9jb252ZXJ0IiwiY2xlYW5VcCIsInVuam9pbk5ic3BzIiwidHh0bm9kZXMiLCJnZXRDb3JyZWN0SW5uZXJIVE1MIiwib2xkTm9kZSIsIm5ld0NoaWxkIiwib2xkTm9kZVR5cGUiLCJvbGRDaGlsZHMiLCJvbGRDaGlsZHNMZW5ndGgiLCJOT0RFX1RZUEVfTUFQUElORyIsIkRFRkFVTFRfTk9ERV9OQU1FIiwiYXR0cmlidXRlcyIsInNlbGVjdG9yUnVsZXMiLCJlbHMiLCJlbGVtZW50SGFuZGxpbmdNZXRob2RzIiwiX2hhbmRsZUVsZW1lbnQiLCJydWxlIiwicmVuYW1lVGFnIiwidGFnUnVsZXMiLCJ0YWdzIiwic2NvcGVOYW1lIiwiX3d5c2lodG1sNSIsIm91dGVySFRNTCIsInVud3JhcCIsInJlbmFtZV90YWciLCJvbmVfb2ZfdHlwZSIsIl90ZXN0VHlwZXMiLCJyZW1vdmVfYWN0aW9uIiwicmVtb3ZlX2FjdGlvbl9yZW5hbWVfdG8iLCJfaGFuZGxlQXR0cmlidXRlcyIsIl9oYW5kbGVTdHlsZXMiLCJkZWZpbml0aW9uIiwidHlwZV9kZWZpbml0aW9ucyIsIl90ZXN0VHlwZSIsImNsYXNzZXNMZW5ndGgiLCJhIiwiYXR0ciIsInN0eWxlUHJvcCIsIm5vZGVDbGFzc2VzIiwibm9kZVN0eWxlcyIsIm1ldGhvZHMiLCJtIiwidHlwZUNlY2tNZXRob2RzIiwiY2xhc3NlcyIsIldISVRFX1NQQUNFX1JFR19FWFAiLCJzcCIsImF0dHJzIiwidiIsImtlZXBfc3R5bGVzIiwic3R5bGVGbG9hdCIsImNzc0Zsb2F0IiwiX2dldEF0dHJpYnV0ZXNCZWdpbm5pbmdXaXRoIiwiYmVnaW5uaW5nIiwicmV0dXJuQXR0cmlidXRlcyIsIl9jaGVja0F0dHJpYnV0ZSIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVWYWx1ZSIsIm5ld0F0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlQ2hlY2tNZXRob2RzIiwiX2NoZWNrQXR0cmlidXRlcyIsImxvY2FsX2F0dHJpYnV0ZXMiLCJuZXdWYWx1ZSIsIm1hdGNoaW5nQXR0cmlidXRlcyIsImdsb2JhbEF0dHJpYnV0ZXMiLCJjaGVja0F0dHJpYnV0ZXMiLCJvbGRBdHRyaWJ1dGVzIiwiZ2V0QXR0cmlidXRlcyIsImltYXgiLCJjdXJyZW50Q2xhc3MiLCJuZXdDbGFzcyIsInNldENsYXNzIiwic2V0X2NsYXNzIiwiYWRkX2NsYXNzIiwiYWRkU3R5bGUiLCJhZGRfc3R5bGUiLCJzZXRBdHRyaWJ1dGVzIiwic2V0X2F0dHJpYnV0ZXMiLCJhbGxvd2VkQ2xhc3NlcyIsIm5ld0NsYXNzZXMiLCJvbGRDbGFzc2VzIiwiY2hlY2tfYXR0cmlidXRlcyIsImFkZENsYXNzTWV0aG9kcyIsImFkZFN0eWxlTWV0aG9kcyIsIm5ld1N0eWxlIiwiY2xhc3Nlc19ibGFja2xpc3QiLCJzcmMiLCJ3aWR0aCIsImhlaWdodCIsIl9oYW5kbGVUZXh0IiwiSU5WSVNJQkxFX1NQQUNFX1JFR19FWFAiLCJfaGFuZGxlQ29tbWVudCIsImNvbW1lbnRzIiwiY3JlYXRlQ29tbWVudCIsIjEiLCIzIiwiOCIsIlJFR19FWFAiLCJocmVmIiwiYWx0IiwibnVtYmVycyIsImFueSIsImFsaWduX3RleHQiLCJtYXBwaW5nIiwibGVmdCIsInJpZ2h0IiwiY2VudGVyIiwiYWxpZ25faW1nIiwianVzdGlmeSIsImNsZWFyX2JyIiwiYm90aCIsInNpemVfZm9udCIsIjIiLCI0IiwiNSIsIjYiLCI3IiwiLSIsIisiLCJoYXNfdmlzaWJsZV9jb250ZXQiLCJ0eHQiLCJ2aXNpYmxlRWxlbWVudHMiLCJvZmZzZXRIZWlnaHQiLCJyZW1vdmVFbXB0eVRleHROb2RlcyIsInJlbmFtZUVsZW1lbnQiLCJuZXdOb2RlTmFtZSIsIm5ld0VsZW1lbnQiLCJyZXBsYWNlV2l0aENoaWxkTm9kZXMiLCJfaXNCbG9ja0VsZW1lbnQiLCJfYXBwZW5kTGluZUJyZWFrIiwicmVzb2x2ZUxpc3QiLCJ1c2VMaW5lQnJlYWtzIiwiaXNMYXN0Q2hpbGQiLCJzaG91bGRBcHBlbmRMaW5lQnJlYWsiLCJwYXJhZ3JhcGgiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIndpbmRvd1Byb3BlcnRpZXMiLCJ3aW5kb3dQcm9wZXJ0aWVzMiIsImRvY3VtZW50UHJvcGVydGllcyIsIlNhbmRib3giLCJyZWFkeUNhbGxiYWNrIiwiZWRpdGFibGVBcmVhIiwiX2NyZWF0ZUlmcmFtZSIsImluc2VydEludG8iLCJnZXRJZnJhbWUiLCJfcmVhZHlFcnJvciIsImRlc3Ryb3kiLCJpZnJhbWUiLCJ0aGF0Iiwic2VjdXJpdHkiLCJhbGxvd3RyYW5zcGFyZW5jeSIsImZyYW1lYm9yZGVyIiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJvbmxvYWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJfb25Mb2FkSWZyYW1lIiwicmVhZHlTdGF0ZSIsImlmcmFtZVdpbmRvdyIsImlmcmFtZURvY3VtZW50IiwiY2hhcnNldCIsImNoYXJhY3RlclNldCIsInNhbmRib3hIdG1sIiwiX2dldEh0bWwiLCJzdHlsZXNoZWV0cyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwib25lcnJvciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIl91bnNldCIsImxvYWRlZCIsInNldFRpbWVvdXQiLCJ0ZW1wbGF0ZVZhcnMiLCJzZXR0ZXIiLCJfX2RlZmluZUdldHRlcl9fIiwiX19kZWZpbmVTZXR0ZXJfXyIsIkNvbnRlbnRFZGl0YWJsZUFyZWEiLCJnZXRDb250ZW50RWRpdGFibGUiLCJfYmluZEVsZW1lbnQiLCJfY3JlYXRlRWxlbWVudCIsIl9sb2FkRWxlbWVudCIsImNvbnRlbnRFeGlzdHMiLCJzaW11bGF0ZVBsYWNlaG9sZGVyIiwiZWRpdG9yIiwidmlldyIsInBsYWNlaG9sZGVyVGV4dCIsIkNMQVNTX05BTUUiLCJ1bnNldCIsImNvbXBvc2VySXNWaXNpYmxlIiwiaGFzUGxhY2Vob2xkZXJTZXQiLCJjbGVhciIsInBsYWNlaG9sZGVyU2V0IiwiaXNFbXB0eSIsInNldFZhbHVlIiwic2V0VGV4dENvbnRlbnQiLCJnZXRUZXh0Q29udGVudCIsIkhBU19HRVRfQVRUUklCVVRFX0JVRyIsImlzTG9hZGVkSW1hZ2UiLCJoYXNBdHRyaWJ1dGUiLCJzcGVjaWZpZWQiLCJjb21wbGV0ZSIsIm1vek1hdGNoZXNTZWxlY3RvciIsInF1ZXJ5SW5MaXN0IiwicXVlcnkiLCJxIiwicmV0IiwidW5zaGlmdCIsInJlbW92ZUVsZW1lbnQiLCJyZWZlcmVuY2VOb2RlIiwidGFnIiwiTWFwQ2VsbCIsImNlbGwiLCJpc0NvbHNwYW4iLCJpc1Jvd3NwYW4iLCJmaXJzdENvbCIsImxhc3RDb2wiLCJmaXJzdFJvdyIsImxhc3RSb3ciLCJpc1JlYWwiLCJzcGFuQ29sbGVjdGlvbiIsIm1vZGlmaWVkIiwiVGFibGVNb2RpZnllckJ5Q2VsbCIsInRhYmxlIiwiYWRkU3Bhbm5lZENlbGxUb01hcCIsInIiLCJjc3BhbiIsInJzcGFuIiwic3BhbkNvbGxlY3QiLCJybWF4IiwiY21heCIsInJyIiwiY2MiLCJzZXRDZWxsQXNNb2RpZmllZCIsInNtYXgiLCJzZXRUYWJsZU1hcCIsInJpZHgiLCJyb3ciLCJjZWxscyIsImNpZHgiLCJ0YWJsZVJvd3MiLCJnZXRUYWJsZVJvd3MiLCJnZXRSb3dDZWxscyIsImlubGluZVRhYmxlcyIsImlubGluZUNlbGxzIiwiYWxsQ2VsbHMiLCJ0YWJsZUNlbGxzIiwiaW5saW5lUm93cyIsImFsbFJvd3MiLCJnZXRNYXBJbmRleCIsInJfbGVuZ3RoIiwiY19sZW5ndGgiLCJyX2lkeCIsImNfaWR4IiwiY29sIiwiZ2V0RWxlbWVudEF0SW5kZXgiLCJnZXRNYXBFbHNUbyIsInRvX2NlbGwiLCJpZHhfc3RhcnQiLCJpZHhfZW5kIiwidGVtcF9pZHgiLCJ0ZW1wX2NpZHgiLCJtYXhyIiwibWF4YyIsIm9yZGVyU2VsZWN0aW9uRW5kcyIsInNlY29uZGNlbGwiLCJjcmVhdGVDZWxscyIsIm5yIiwiY29ycmVjdENvbEluZGV4Rm9yVW5yZWFscyIsImNvcnJJZHgiLCJnZXRMYXN0TmV3Q2VsbE9uUm93Iiwicm93TGltaXQiLCJyZW1vdmVFbXB0eVRhYmxlIiwic3BsaXRSb3dUb0NlbGxzIiwiY29sc3BhbiIsImNUeXBlIiwibmV3Q2VsbHMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJnZXRSZWFsUm93RWwiLCJmb3JjZSIsImluamVjdFJvd0F0IiwibmV3X2NlbGxzIiwibl9jaWR4IiwiY2FuTWVyZ2UiLCJkZWNyZWFzZUNlbGxTcGFuIiwic3BhbiIsInJlbW92ZVN1cnBsdXNMaW5lcyIsImFsbFJvd3NwYW4iLCJmaWxsTWlzc2luZ0NlbGxzIiwicl9tYXgiLCJjX21heCIsInByZXZjZWxsIiwicmVjdGlmeSIsInVubWVyZ2UiLCJ0aGlzQ2VsbCIsInJvd3NwYW4iLCJjb2xsYXBzZUNlbGxUb05leHRSb3ciLCJjZWxsSWR4IiwibmV3Um93SWR4IiwibmV3SWR4IiwibGFzdENlbGwiLCJyZW1vdmVSb3dDZWxsIiwiZ2V0Um93RWxlbWVudHNCeUNlbGwiLCJtb2RSb3ciLCJnZXRDb2x1bW5FbGVtZW50c0J5Q2VsbCIsInJlbW92ZVJvdyIsIm9sZFJvdyIsInJlbW92ZUNvbENlbGwiLCJyZW1vdmVDb2x1bW4iLCJ3aGF0IiwiYWRkUm93Iiwid2hlcmUiLCJuZXdSb3ciLCJhZGRSb3dDZWxsIiwiY3IiLCJjb2xTcGFuQXR0ciIsImFkZENvbHVtbiIsImFkZENvbENlbGwiLCJkb0FkZCIsImhhbmRsZUNlbGxBZGRXaXRoUm93c3BhbiIsIm1vZENlbGwiLCJ0ZW1wX3JfY2VsbHMiLCJucm93IiwiYWRkUm93c05yIiwiY3JvdyIsImdldENlbGxzQmV0d2VlbiIsImNlbGwxIiwiY2VsbDIiLCJjMSIsImFkZENlbGxzIiwicmVtb3ZlQ2VsbHMiLCJtZXJnZUNlbGxzQmV0d2VlbiIsInVubWVyZ2VDZWxsIiwiZmluZENlbGwiLCJmaW5kUm93QnlDZWxsIiwiZmluZENvbHVtbkJ5Q2VsbCIsImVsZW1lbnRzIiwidGhpc093bmVyIiwib3RoZXJPd25lciIsInBvaW50IiwicGFyZW50cyIsImxvY2F0aW9uX2luZGV4Iiwic21hbGxlc3RfY29tbW9uX2FuY2VzdG9yIiwidGhpc19pbmRleCIsIm90aGVyX2luZGV4IiwiZ2V0UGFzdGVkSHRtbCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwiZ2V0UGFzdGVkSHRtbFdpdGhEaXYiLCJjb21wb3NlciIsImYiLCJzZWxCb29rbWFyayIsImNsZWFuZXJEaXYiLCJzZXRCb29rbWFyayIsImNsZWFuUGFzdGVkSFRNTCIsInN0eWxlVG9SZWdleCIsInN0eWxlU3RyIiwidHJpbW1lZFN0ciIsImVzY2FwZWRTdHIiLCJleHRlbmRSdWxlc1dpdGhTdHlsZUV4Y2VwdGlvbnMiLCJleGNlcHRTdHlsZXMiLCJuZXdSdWxlcyIsInBpY2tSdWxlc2V0IiwicnVsZXNldCIsImRlZmF1bHRTZXQiLCJjb25kaXRpb24iLCJuZXdIdG1sIiwiY29sb3IiLCJmb250U2l6ZSIsImVuc3VyZVByb3BlckNsZWFyaW5nIiwiY2xlYXJJZk5lY2Vzc2FyeSIsIlRJTERFX0VTQ0FQRUQiLCJ1cmxUb1NlYXJjaCIsImVsZW1lbnRzV2l0aFRpbGRlIiwicmVkcmF3IiwidGFibGVDZWxsc1NlbGVjdGlvbiIsImVkaXRhYmxlIiwiaGFuZGxlU2VsZWN0aW9uTW91c2Vkb3duIiwicmVtb3ZlQ2VsbFNlbGVjdGlvbnMiLCJzZWxlY3Rpb25fY2xhc3MiLCJtb3ZlSGFuZGxlciIsImhhbmRsZU1vdXNlTW92ZSIsInVwSGFuZGxlciIsImhhbmRsZU1vdXNlVXAiLCJzZWxlY3RlZENlbGxzIiwiYWRkU2VsZWN0aW9ucyIsIm9sZEVuZCIsImN1clRhYmxlIiwiZGVzZWxlY3QiLCJiaW5kU2lkZWNsaWNrIiwic2lkZUNsaWNrSGFuZGxlciIsInNlbGVjdENlbGxzIiwiUkdCQV9SRUdFWCIsIlJHQl9SRUdFWCIsIkhFWDZfUkVHRVgiLCJIRVgzX1JFR0VYIiwicGFyYW1fUkVHWCIsInN0eWxlUGFyc2VyIiwicGFyc2VDb2xvciIsInN0eWxlc1N0ciIsInBhcmFtTmFtZSIsImNvbG9yTWF0Y2giLCJwYXJhbVJlZ2V4IiwicmFkaXgiLCJzaGlmdCIsImQiLCJ1bnBhcnNlQ29sb3IiLCJwYXJzZUZvbnRTaXplIiwiX2dldEN1bXVsYXRpdmVPZmZzZXRUb3AiLCJ0b3AiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJnZXREZXB0aCIsImV4cGFuZFJhbmdlVG9TdXJyb3VuZCIsImNvbW1vbiIsInN0YXJ0X2RlcHRoIiwiZW5kX2RlcHRoIiwiY29udGFpbiIsInVuc2VsZWN0YWJsZUNsYXNzIiwiZ2V0UmFuZ2UiLCJzZXRTZWxlY3Rpb24iLCJzZXRCZWZvcmUiLCJzZXRBZnRlciIsImF2b2lkSW52aXNpYmxlU3BhY2UiLCJpc0VsZW1lbnQiLCJkaXNwbGF5U3R5bGUiLCJnZXRTZWxlY3RlZE5vZGUiLCJmaXhTZWxCb3JkZXJzIiwiZ2V0U2VsZWN0ZWRPd25Ob2RlcyIsImdldE93blJhbmdlcyIsIm93bk5vZGVzIiwibWF4aSIsImZpbmROb2Rlc0luU2VsZWN0aW9uIiwiY3VyTm9kZXMiLCJjb250YWluc1VuZWRpdGFibGUiLCJ1bmVkaXRhYmxlcyIsImdldE93blVuZWRpdGFibGVzIiwiZ2V0UHJldmlvdXNOb2RlIiwiaWdub3JlRW1wdHkiLCJnZXRTZWxlY3Rpb25QYXJlbnRzQnlUYWciLCJjdXJFbCIsImdldFJhbmdlVG9Ob2RlRW5kIiwic05vZGUiLCJsYXN0UiIsImNhcmV0SXNMYXN0SW5TZWxlY3Rpb24iLCJlbmRjIiwiZW5kdHh0IiwiY2FyZXRJc0ZpcnN0SW5TZWxlY3Rpb24iLCJjYXJldElzSW5UaGVCZWdpbm5pZyIsIm9mTm9kZSIsImNhcmV0SXNCZWZvcmVVbmVkaXRhYmxlIiwiZXhlY3V0ZUFuZFJlc3RvcmVSYW5neSIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsImV4ZWN1dGVBbmRSZXN0b3JlIiwiY2FyZXRQbGFjZWhvbGRlciIsIm5ld0NhcmV0UGxhY2Vob2xkZXIiLCJwcmV2U2libGluZyIsIm5ld1JhbmdlIiwib2xkU2Nyb2xsVG9wIiwic2Nyb2xsVG9wIiwib2xkU2Nyb2xsTGVmdCIsInNjcm9sbExlZnQiLCJwbGFjZWhvbGRlckh0bWwiLCJzdXJyb3VuZCIsIm5vZGVPcHRpb25zIiwiZGVibG9ja0FuZFN1cnJvdW5kIiwidGVtcERpdkVsZW1lbnRzIiwidGVtcEVsZW1lbnRzIiwic2Nyb2xsSW50b1ZpZXciLCJ0b2xlcmFuY2UiLCJoYXNTY3JvbGxCYXJzIiwic2Nyb2xsSGVpZ2h0IiwiX3d5c2lodG1sNVNjcm9sbEludG9WaWV3RWxlbWVudCIsInNlbGVjdExpbmUiLCJfc2VsZWN0TGluZV9XM0MiLCJfc2VsZWN0TGluZV9NU0lFIiwibW9kaWZ5IiwicmFuZ2VCb3R0b20iLCJyYW5nZUVuZCIsIm1lYXN1cmVOb2RlIiwiaiIsInJhbmdlVG9wIiwiYm91bmRpbmdUb3AiLCJzY3JvbGxXaWR0aCIsIm1vdmVUb1BvaW50IiwiZ2V0VGV4dCIsImZpeFJhbmdlT3ZlcmZsb3ciLCJjb250YWlubWVudCIsIl9kZXRlY3RJbmxpbmVSYW5nZVByb2JsZW1zIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsIl9lbmRPZmZzZXRGb3JOb2RlIiwiZG9udEZpeCIsImFsbFVuZWRpdGFibGVzIiwiZGVlcFVuZWRpdGFibGVzIiwidG1wUmFuZ2VzIiwidG1wUmFuZ2UiLCJqbWF4IiwiZ2V0SHRtbCIsImlzRW5kVG9FbmRJbk5vZGUiLCJub2RlTmFtZXMiLCJjc3NDbGFzcyIsInJlZ0V4cCIsIm1hdGNoaW5nQ2xhc3NOYW1lcyIsImhhc1N0eWxlQXR0ciIsInJlbW92ZVN0eWxlIiwiczIiLCJnZXRNYXRjaGluZ1N0eWxlUmVnZXhwIiwicmVnZXhlcyIsInNTcGxpdCIsImVsU3R5bGUiLCJpc01hdGNoaW5nQWxscmVhZHkiLCJhcmVNYXRjaGluZ0FsbHJlYWR5IiwicmVtb3ZlT3JDaGFuZ2VTdHlsZSIsImV4YWN0UmVnZXgiLCJoYXNTYW1lQ2xhc3NlcyIsImVsMSIsImVsMiIsIlJFR19FWFBfV0hJVEVfU1BBQ0UiLCJyZXBsYWNlV2l0aE93bkNoaWxkcmVuIiwiZWxlbWVudHNIYXZlU2FtZU5vbkNsYXNzQXR0cmlidXRlcyIsImF0dHIxIiwiYXR0cjIiLCJnZXROYW1lZEl0ZW0iLCJpc1NwbGl0UG9pbnQiLCJzcGxpdE5vZGVBdCIsImRlc2NlbmRhbnROb2RlIiwiZGVzY2VuZGFudE9mZnNldCIsIk1lcmdlIiwiZmlyc3ROb2RlIiwiaXNFbGVtZW50TWVyZ2UiLCJmaXJzdFRleHROb2RlIiwiSFRNTEFwcGxpZXIiLCJ0YWdOYW1lcyIsInNpbWlsYXJDbGFzc1JlZ0V4cCIsInNpbWlsYXJTdHlsZVJlZ0V4cCIsImRlZmF1bHRUYWdOYW1lIiwiYXBwbHlUb0FueVRhZ05hbWUiLCJkb01lcmdlIiwidGV4dEJpdHMiLCJnZXRMZW5ndGgiLCJnZXRBbmNlc3RvcldpdGhDbGFzcyIsImNzc0NsYXNzTWF0Y2giLCJnZXRBbmNlc3RvcldpdGhTdHlsZSIsImNzc1N0eWxlTWF0Y2giLCJnZXRNYXRjaGluZ0FuY2VzdG9yIiwibWF0Y2hUeXBlIiwicG9zdEFwcGx5IiwiY3VycmVudE1lcmdlIiwicHJlY2VkaW5nVGV4dE5vZGUiLCJsYXN0Tm9kZSIsIm1lcmdlcyIsInJhbmdlU3RhcnROb2RlIiwicmFuZ2VFbmROb2RlIiwicmFuZ2VTdGFydE9mZnNldCIsInJhbmdlRW5kT2Zmc2V0IiwiZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZSIsIm5leHRUZXh0Tm9kZSIsImZvcndhcmQiLCJhZGphY2VudE5vZGUiLCJpc1RleHROb2RlIiwiYXJlRWxlbWVudHNNZXJnZWFibGUiLCJjcmVhdGVDb250YWluZXIiLCJhcHBseVRvVGV4dE5vZGUiLCJpc1JlbW92YWJsZSIsInVuZG9Ub1RleHROb2RlIiwiYW5jZXN0b3JXaXRoQ2xhc3MiLCJhbmNlc3RvcldpdGhTdHlsZSIsInN0eWxlTW9kZSIsInN0eWxlQ2hhbmdlZCIsImFuY2VzdG9yUmFuZ2UiLCJhcHBseVRvUmFuZ2UiLCJyaSIsInVuZG9Ub1JhbmdlIiwiZ2V0VGV4dFNlbGVjdGVkQnlSYW5nZSIsImlzQXBwbGllZFRvUmFuZ2UiLCJhcHBsaWVkVHlwZSIsImNvdmVyYWdlIiwic2VsZWN0ZWRUZXh0IiwidG9nZ2xlUmFuZ2UiLCJwYXJlbnRzRXhhY3RNYXRjaCIsImlzQXBwbGllZCIsIkNvbW1hbmRzIiwic3VwcG9ydCIsInJlc3VsdCIsInN0YXRlIiwiY29tbWFuZFZhbHVlIiwic3RhdGVWYWx1ZSIsImJvbGQiLCJmb3JtYXRJbmxpbmUiLCJleGVjV2l0aFRvZ2dsZSIsIl9mb3JtYXQiLCJhbmNob3JzIiwiaGFzRWxlbWVudENoaWxkIiwiZWxlbWVudFRvU2V0Q2FyZXRBZnRlciIsIndoaXRlU3BhY2UiLCJ0ZW1wQ2xhc3MiLCJ0ZW1wQ2xhc3NSZWdFeHAiLCJ1bmRlZiIsIk5PREVfTkFNRSIsIl9jaGFuZ2VMaW5rcyIsIm9sZEF0dHJzIiwib2EiLCJjcmVhdGVMaW5rIiwiX3JlbW92ZUZvcm1hdCIsImNvZGVFbGVtZW50IiwicmVtb3ZlTGluayIsInNpemUiLCJmb250U2l6ZVN0eWxlIiwic3QiLCJmb3JlQ29sb3IiLCJmb3JlQ29sb3JTdHlsZSIsImNvbFN0cmluZyIsImNvbG9yVmFscyIsImNvbG9yU3RyIiwiYmdDb2xvclN0eWxlIiwiX2FkZENsYXNzIiwiX3JlbW92ZUNsYXNzIiwiX2FkZFN0eWxlIiwiX3JlbW92ZVN0eWxlIiwiX3JlbW92ZUxhc3RDaGlsZElmTGluZUJyZWFrIiwiX3NlbGVjdGlvbldyYXAiLCJzdXJyb3VuZGVkTm9kZXMiLCJfaGFzQ2xhc3NlcyIsIl9oYXNTdHlsZXMiLCJCTE9DS19FTEVNRU5UU19HUk9VUCIsInNlbGVjdGVkTm9kZXMiLCJjbGFzc1JlbW92ZUFjdGlvbiIsImJsb2NrUmVuYW1lRm91bmQiLCJzdHlsZVJlbW92ZUFjdGlvbiIsImJsb2NrRWxlbWVudCIsImJsb2NrRWxlbWVudHMiLCJkZWZhdWx0Tm9kZU5hbWUiLCJiIiwiaGFzQ2xhc3NlcyIsImhhc1N0eWxlcyIsImZvcm1hdENvZGUiLCJjbGFzc25hbWUiLCJwcmUiLCJzZWxlY3RlZE5vZGUiLCJfZ2V0VGFnTmFtZXMiLCJhbGlhcyIsIkFMSUFTX01BUFBJTkciLCJfZ2V0QXBwbGllciIsImlkZW50aWZpZXIiLCJodG1sQXBwbGllciIsInN0cm9uZyIsImVtIiwiZG9udFJlc3RvcmVTZWxlY3QiLCJub0NsZWFudXAiLCJvd25SYW5nZXMiLCJzdGF0ZV9lbGVtZW50IiwiYWxpYXNUYWdOYW1lIiwiaW5zZXJ0QmxvY2tRdW90ZSIsImVuZFRvRW5kUGFyZW50IiwicW91dGVFbCIsImluc2VydEltYWdlIiwiaW1hZ2UiLCJpbWFnZXNJblNlbGVjdGlvbiIsIkxJTkVfQlJFQUsiLCJpbnNlcnRMaW5lQnJlYWsiLCJpbnNlcnRMaXN0IiwiaXNOb2RlIiwiZmluZExpc3RFbCIsIm90aGVyIiwicGFyZW50TGkiLCJvdGhlck5vZGVOYW1lIiwiaGFuZGxlU2FtZVR5cGVMaXN0IiwiaW5uZXJMaXN0cyIsIm90aGVyTGlzdHMiLCJnZXRMaXN0c0luU2VsZWN0aW9uIiwibCIsImhhbmRsZU90aGVyVHlwZUxpc3QiLCJyZW5hbWVMaXN0cyIsImNyZWF0ZUxpc3RGYWxsYmFjayIsInRlbXBDbGFzc05hbWUiLCJnZXRUaW1lIiwidW5lZGl0YWJsZUNvbnRhaW5lckNsYXNzbmFtZSIsImNtZCIsIml0YWxpYyIsImp1c3RpZnlDZW50ZXIiLCJqdXN0aWZ5TGVmdCIsImp1c3RpZnlSaWdodCIsImp1c3RpZnlGdWxsIiwiU1RZTEVfU1RSIiwiYWxpZ25SaWdodFN0eWxlIiwiYWxpZ25MZWZ0U3R5bGUiLCJhbGlnbkNlbnRlclN0eWxlIiwicmVkbyIsInVuZG9NYW5hZ2VyIiwidW5kZXJsaW5lIiwidW5kbyIsImNyZWF0ZVRhYmxlIiwiY29scyIsInJvd3MiLCJ0YWJsZVN0eWxlIiwibWVyZ2VUYWJsZUNlbGxzIiwidGFibGVTZWxlY3Rpb24iLCJhZGRUYWJsZUNlbGxzIiwidGFibGVTZWxlY3QiLCJkZWxldGVUYWJsZUNlbGxzIiwic2VsQ2VsbCIsImluZGVudExpc3QiLCJsaXN0RWxzIiwidHJ5VG9QdXNoTGlMZXZlbCIsImxpTm9kZXMiLCJsaXN0VGFnIiwicHJldkxpIiwibGlOb2RlIiwicHJldkxpTGlzdCIsImZvdW5kIiwib3V0ZGVudExpc3QiLCJ0cnlUb1B1bGxMaUxldmVsIiwibGlzdE5vZGUiLCJvdXRlckxpc3ROb2RlIiwib3V0ZXJMaU5vZGUiLCJhZnRlckxpc3QiLCJnZXRBZnRlckxpc3QiLCJuZXdMaXN0IiwiWl9LRVkiLCJZX0tFWSIsIk1BWF9ISVNUT1JZX0VOVFJJRVMiLCJEQVRBX0FUVFJfTk9ERSIsIkRBVEFfQVRUUl9PRkZTRVQiLCJVbmRvTWFuYWdlciIsImhpc3RvcnlTdHIiLCJoaXN0b3J5RG9tIiwidHJhbnNhY3QiLCJfb2JzZXJ2ZSIsImxhc3RLZXkiLCJzYW5kYm94IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJrZXlDb2RlIiwiaXNVbmRvIiwic2hpZnRLZXkiLCJpc1JlZG8iLCJwcmV2aW91c0h0bWwiLCJjdXJyZW50SHRtbCIsImdldFZhbHVlIiwiZ2V0Q2hpbGROb2RlSW5kZXgiLCJ1bmRvUG9zc2libGUiLCJyZWRvUG9zc2libGUiLCJoaXN0b3J5RW50cnkiLCJnZXRDaGlsZE5vZGVCeUluZGV4IiwiVmlldyIsInRleHRhcmVhRWxlbWVudCIsIm5vVGV4dGFyZWEiLCJfb2JzZXJ2ZVZpZXdDaGFuZ2UiLCJjdXJyZW50VmlldyIsInNob3ciLCJoaWRlIiwiZGlzYWJsZSIsImVuYWJsZSIsIkNvbXBvc2VyIiwiQ0FSRVRfSEFDSyIsImVkaXRhYmxlRWxlbWVudCIsInRleHRhcmVhIiwiY29udGVudEVkaXRhYmxlTW9kZSIsIl9pbml0Q29udGVudEVkaXRhYmxlQXJlYSIsIl9pbml0U2FuZGJveCIsIl9kaXNwbGF5U3R5bGUiLCJkaXNhYmxlZCIsInNldFRvRW5kIiwiX2NyZWF0ZSIsIl9jcmVhdGVXeXNpd3lnRm9ybUZpZWxkIiwiZm9ybSIsImhpZGRlbkZpZWxkIiwiY29tcG9zZXJDbGFzc05hbWUiLCJwbGFjZWhvbGRlciIsIl9pbml0QXV0b0xpbmtpbmciLCJfaW5pdE9iamVjdFJlc2l6aW5nIiwiX2luaXRVbmRvTWFuYWdlciIsIl9pbml0TGluZUJyZWFraW5nIiwiaW5pdFN5bmMiLCJzeW5jIiwic3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nIiwic3VwcG9ydHNBdXRvTGlua2luZyIsImlzSW5VbmVkaXRhYmxlIiwibGlua3MiLCJ1cmxSZWdFeHAiLCJuZXdUZXh0Q29udGVudCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzTGVuZ3RoIiwiYWRqdXN0IiwiVVNFX05BVElWRV9MSU5FX0JSRUFLX0lOU0lERV9UQUdTIiwiTElTVF9UQUdTIiwiSE9TVF9URU1QTEFURSIsIlRFWFRfRk9STUFUVElORyIsIkJPWF9GT1JNQVRUSU5HIiwiQURESVRJT05BTF9DU1NfUlVMRVMiLCJmb2N1c1dpdGhvdXRTY3JvbGxpbmciLCJzZXRBY3RpdmUiLCJlbGVtZW50U3R5bGUiLCJvcmlnaW5hbFNjcm9sbFRvcCIsIm9yaWdpbmFsU2Nyb2xsTGVmdCIsIm9yaWdpbmFsU3R5bGVzIiwiV2Via2l0VXNlclNlbGVjdCIsInNjcm9sbFRvIiwiZGlzcGxheVZhbHVlRm9yQ29weWluZyIsIm9yaWdpbmFsQWN0aXZlRWxlbWVudCIsImhhc1BsYWNlaG9sZGVyIiwib3JpZ2luYWxQbGFjZWhvbGRlciIsIm9yaWdpbmFsRGlzcGxheVZhbHVlIiwib3JpZ2luYWxEaXNhYmxlZCIsImZvY3VzU3R5bGVzSG9zdCIsImJsdXJTdHlsZXNIb3N0IiwiZGlzYWJsZWRTdHlsZXNIb3N0IiwiYmx1ciIsImJveEZvcm1hdHRpbmdTdHlsZXMiLCJzaG9ydGN1dHMiLCI2NiIsIjczIiwiODUiLCJkZWxldGVBcm91bmRFZGl0YWJsZSIsInVuZWRpdGFibGUiLCJjdXJOb2RlIiwiZmlyc3QiLCJoYW5kbGVEZWxldGVLZXlQcmVzcyIsImJlZm9yZVVuZWRpdGFibGUiLCJoYW5kbGVUYWJLZXlEb3duIiwiZm9jdXNCbHVyRWxlbWVudCIsInBhc3RlRXZlbnRzIiwiaW50ZXJhY3Rpb25FdmVudHMiLCJjbGVhckludGVydmFsIiwiZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCIsInNldEludGVydmFsIiwiaGFuZGxlVGFibGVzIiwidGFibGVDbGlja0hhbmRsZSIsImNoYW5nZWV2ZW50IiwiY3JlYXRlIiwiY29weWVkRnJvbU1hcmtpbmciLCJzZXREYXRhIiwiYWxsSW1hZ2VzIiwibm90TXlJbWFnZXMiLCJteUltYWdlcyIsImhhbmRsZVRhYktleSIsInRpdGxlUHJlZml4ZXMiLCJJTUciLCJ0aXRsZSIsImhhc1RpdGxlIiwiSU5URVJWQUwiLCJTeW5jaHJvbml6ZXIiLCJmcm9tQ29tcG9zZXJUb1RleHRhcmVhIiwic2hvdWxkUGFyc2VIdG1sIiwiZnJvbVRleHRhcmVhVG9Db21wb3NlciIsInRleHRhcmVhVmFsdWUiLCJpbnRlcnZhbCIsInN0YXJ0SW50ZXJ2YWwiLCJzdG9wSW50ZXJ2YWwiLCJUZXh0YXJlYSIsInN1cHBvcnRzUGxhY2Vob2xkZXIiLCJldmVudE1hcHBpbmciLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJkZWZhdWx0Q29uZmlnIiwic2hvd1Rvb2xiYXJBZnRlckluaXQiLCJwYXJzZXJSdWxlcyIsImJyIiwiZGl2IiwicGFzdGVQYXJzZXJSdWxlc2V0cyIsInBhcnNlciIsImJvZHlDbGFzc05hbWUiLCJzdXBwb3J0VG91Y2hEZXZpY2VzIiwiRWRpdG9yIiwiX2lzQ29tcGF0aWJsZSIsIl9pbml0UGFyc2VyIiwiaGFuZGxlQmVmb3JlTG9hZCIsInN5bmNocm9uaXplciIsIlRvb2xiYXIiLCJpc0NvbXBhdGlibGUiLCJodG1sT3JFbGVtZW50IiwicGFyc2VDb250ZXh0Iiwib2xkSHRtbCIsIl9jbGVhbkFuZFBhc3RlIiwicGFzdGVkSFRNTCIsImNsZWFuSHRtbCIsIkNMQVNTX05BTUVfT1BFTkVEIiwiU0VMRUNUT1JfRk9STV9FTEVNRU5UUyIsIlNFTEVDVE9SX0ZJRUxEUyIsIkFUVFJJQlVURV9GSUVMRFMiLCJEaWFsb2ciLCJfb2JzZXJ2ZWQiLCJjYWxsYmFja1dyYXBwZXIiLCJfc2VyaWFsaXplIiwiZWxlbWVudFRvQ2hhbmdlIiwiZm9ybUVsZW1lbnRzIiwiX2NsZWFySW50ZXJ2YWwiLCJmaWVsZHMiLCJfaW50ZXJwb2xhdGUiLCJhdm9pZEhpZGRlbkZpZWxkcyIsImZpZWxkIiwiZmllbGROYW1lIiwiZm9jdXNlZEVsZW1lbnQiLCJkZWZhdWx0VmFsdWUiLCJmaXJzdEZpZWxkIiwibGlua1N0eWxlcyIsIndyYXBwZXJTdHlsZXMiLCJtYXJnaW4iLCJvcGFjaXR5IiwicGFkZGluZyIsInpJbmRleCIsImlucHV0U3R5bGVzIiwiY3Vyc29yIiwibWFyZ2luVG9wIiwib3V0bGluZSIsImlucHV0QXR0cmlidXRlcyIsIngtd2Via2l0LXNwZWVjaCIsInNwZWVjaCIsIlNwZWVjaCIsIndyYXBwZXIiLCJDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQiLCJDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEIiwiQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSIsIkNMQVNTX05BTUVfQUNUSU9OX0FDVElWRSIsInNob3dPbkluaXQiLCJfZ2V0TGlua3MiLCJjbGFzc05hbWVDb21tYW5kRGlzYWJsZWQiLCJjbGFzc05hbWVDb21tYW5kc0Rpc2FibGVkIiwiY2xhc3NOYW1lQ29tbWFuZEFjdGl2ZSIsImNsYXNzTmFtZUFjdGlvbkFjdGl2ZSIsInNwZWVjaElucHV0TGlua3MiLCJncm91cCIsImRpYWxvZyIsIl9nZXREaWFsb2ciLCJjYXJldEJvb2ttYXJrIiwiZGlhbG9nRWxlbWVudCIsImRpYWxvZ0NvbnRhaW5lciIsImNvbW1hbmRMaW5rIiwiX2V4ZWNDb21tYW5kIiwiY29tbWFuZHNEaXNhYmxlZCIsImNvbW1hbmRPYmoiLCJjb21tYW5kTWFwcGluZyIsIl91cGRhdGVMaW5rU3RhdGVzIiwiZXhlY0FjdGlvbiIsImNvbW1hbmRMaW5rcyIsImFjdGlvbkxpbmtzIiwidW5zZWxlY3RhYmxlIiwiYWN0aW9uTWFwcGluZyIsIm11bHRpc2VsZWN0IiwiRGlhbG9nX2NyZWF0ZVRhYmxlIiwiRGlhbG9nX2ZvcmVDb2xvclN0eWxlIiwiZmlyc3RFbGVtZW50IiwiRGlhbG9nX2ZvbnRTaXplU3R5bGUiLCJIYW5kbGViYXJzIiwiaCIsImciLCInIiwiYCIsImsiLCJlc2NhcGVFeHByZXNzaW9uIiwiZmlyc3RMaW5lIiwiZmlyc3RDb2x1bW4iLCJjb2x1bW4iLCJoZWxwZXJzIiwicGFydGlhbHMiLCJyZWdpc3RlckhlbHBlciIsImludmVyc2UiLCJmbiIsImVhY2giLCJsYXN0IiwiaGFzaCIsImluY2x1ZGVaZXJvIiwibGV2ZWwiLCJWRVJTSU9OIiwiQ09NUElMRVJfUkVWSVNJT04iLCJSRVZJU0lPTl9DSEFOR0VTIiwiSGFuZGxlYmFyc0Vudmlyb25tZW50IiwibG9nZ2VyIiwibm90IiwicmVnaXN0ZXJQYXJ0aWFsIiwibWV0aG9kTWFwIiwiMCIsIkRFQlVHIiwiSU5GTyIsIldBUk4iLCJFUlJPUiIsImNyZWF0ZUZyYW1lIiwiVk0iLCJpbnZva2VQYXJ0aWFsIiwiY29tcGlsZSIsInByb2dyYW1zIiwicHJvZ3JhbSIsInByb2dyYW1XaXRoRGVwdGgiLCJub29wIiwiY29tcGlsZXJJbmZvIiwicGFydGlhbCIsImNoZWNrUmV2aXNpb24iLCJkZXB0aCIsIkZ1bmN0aW9uIiwidGVtcGxhdGUiLCJTYWZlU3RyaW5nIiwiRXhjZXB0aW9uIiwiVXRpbHMiLCJkZXB0aDAiLCJwcm9ncmFtMSIsInN0YWNrMSIsImJ1ZmZlciIsImZ1bmN0aW9uVHlwZSIsInByb2dyYW0zIiwicHJvZ3JhbTUiLCJzZWxmIiwiZmEiLCJsb2NhbGUiLCJjb2xvdXJzIiwiYmxhY2siLCJzaWx2ZXIiLCJncmF5IiwibWFyb29uIiwicmVkIiwicHVycGxlIiwiZ3JlZW4iLCJvbGl2ZSIsIm5hdnkiLCJibHVlIiwib3JhbmdlIiwiZW1waGFzaXMiLCJzbWFsbCIsImZvbnRfc3R5bGVzIiwibm9ybWFsIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiZWRpdCIsInByb2dyYW03Iiwic21hbGxtb2RhbHMiLCJjYW5jZWwiLCJwcm9ncmFtOSIsInByb2dyYW0xMSIsInByb2dyYW0xMyIsInByb2dyYW0xNSIsInByb2dyYW0xNyIsImxpc3RzIiwidW5vcmRlcmVkIiwib3JkZXJlZCIsIm91dGRlbnQiLCJpbmRlbnQiLCJqUXVlcnkiLCIkIiwiYnNXeXNpaHRtbDUiLCJ0ZW1wbGF0ZXMiLCJ0cGwiLCJXeXNpaHRtbDUiLCJ0b29sYmFyT3B0cyIsImRlZmF1bHRPcHRpb25zIiwiY3VzdG9tVGVtcGxhdGVzIiwiY3JlYXRlVG9vbGJhciIsImNyZWF0ZUVkaXRvciIsImluaXRpYWxpemVFZGl0b3IiLCJzeW5jQm9vdHN0cmFwRGlhbG9nRXZlbnRzIiwibG9hZFBhcnNlclJ1bGVzIiwiYWRkTW9yZVNob3J0Y3V0cyIsImFqYXgiLCJkYXRhVHlwZSIsImVycm9yIiwianFYSFIiLCJ0ZXh0U3RhdHVzIiwiZXJyb3JUaHJvd24iLCJzdWNjZXNzIiwibW9kYWwiLCJmaW5kIiwiY2hpbGRyZW4iLCJ0b2dnbGVDbGFzcyIsImNsYXNzIiwiY3VsdHVyZSIsImRlYnVnIiwia2V5cyIsImxvY2FsZU9iamVjdCIsImVuIiwiYXBwZW5kIiwiY2xpY2siLCJkZWxlZ2F0ZVRhcmdldCIsInNob3dmb3JtYXQiLCJmb3JtYXRuYW1lIiwicmVzZXREZWZhdWx0cyIsImRlZmF1bHRPcHRpb25zQ2FjaGUiLCJieXBhc3NEZWZhdWx0cyIsIiR0aGlzIiwic2hhbGxvd0V4dGVuZCIsInNldHRpbmdzIiwiZGVlcEV4dGVuZCIsIkNvbnN0cnVjdG9yIiwiZm9udC1zdHlsZXMiLCJibG9ja3F1b3RlIiwid3lzaXd5Zy1jb2xvci1zaWx2ZXIiLCJ3eXNpd3lnLWNvbG9yLWdyYXkiLCJ3eXNpd3lnLWNvbG9yLXdoaXRlIiwid3lzaXd5Zy1jb2xvci1tYXJvb24iLCJ3eXNpd3lnLWNvbG9yLXJlZCIsInd5c2l3eWctY29sb3ItcHVycGxlIiwid3lzaXd5Zy1jb2xvci1mdWNoc2lhIiwid3lzaXd5Zy1jb2xvci1ncmVlbiIsInd5c2l3eWctY29sb3ItbGltZSIsInd5c2l3eWctY29sb3Itb2xpdmUiLCJ3eXNpd3lnLWNvbG9yLXllbGxvdyIsInd5c2l3eWctY29sb3ItbmF2eSIsInd5c2l3eWctY29sb3ItYmx1ZSIsInd5c2l3eWctY29sb3ItdGVhbCIsInd5c2l3eWctY29sb3ItYXF1YSIsInd5c2l3eWctY29sb3Itb3JhbmdlIiwib2wiLCJ1bCIsImxpIiwidSIsImltZyIsInJlbCIsIjgzIiwiNzUiXSwibWFwcGluZ3MiOiJBQUtJQSxPQUFPQyxnQkFBa0JELE9BQU9FLDBCQUE0QkYsT0FBT0UseUJBQXlCQyxRQUFRQyxVQUFXLGlCQUFtQkosT0FBT0UseUJBQXlCQyxRQUFRQyxVQUFXLGVBQWVDLE1BQ3ZNLFdBQ0MsR0FBSUMsR0FBWU4sT0FBT0UseUJBQXlCQyxRQUFRQyxVQUFXLFlBQ25FSixRQUFPQyxlQUFlRSxRQUFRQyxVQUFXLGVBRXZDQyxJQUFLLFdBQ0osTUFBT0MsR0FBVUQsSUFBSUUsS0FBS0MsT0FFM0JDLElBQUssU0FBU0MsR0FDYixNQUFPSixHQUFVRyxJQUFJRixLQUFLQyxLQUFNRSxTQVFqQ0MsTUFBTUMsVUFDUkQsTUFBTUMsUUFBVSxTQUFTQyxHQUN2QixNQUErQyxtQkFBeENiLE9BQU9JLFVBQVVVLFNBQVNQLEtBQUtNLElBYTFDLElBQUlFLFlBQ0ZDLFFBQVMsU0FHVEMsWUFDQUMsT0FDQUMsVUFDQUMsV0FDQUMsUUFDQUMsYUFDQUMsU0FFQUMsZ0JBQWlCLFNBRWpCQyxlQUFnQixhQUVoQkMsYUFBYyxFQUNkQyxVQUFjLEVBRWRDLGNBQWdCLEVBQ2hCQyxVQUFnQixHQUNoQkMsV0FBZ0IsR0FDaEJD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QUFVazhELE9BQU8sVUFDL0NlLGFBQ0VDLE9BQVEsY0FDUkMsR0FBSSxZQUNKQyxHQUFJLFlBQ0pDLEdBQUksWUFDSkMsR0FBSSxZQUNKQyxHQUFJLFlBQ0pDLEdBQUksYUFFTlQsVUFDRTdhLEtBQU0sT0FDTjJGLE9BQVEsU0FDUlcsVUFBVyxZQUNYd1UsTUFBTyxTQUVUa0IsT0FDRUMsVUFBVyxpQkFDWEMsUUFBUyxlQUNUQyxRQUFTLFVBQ1RDLE9BQVEsVUFFVnRpQyxNQUNFbEYsT0FBUSxjQUNSOG1DLE9BQVEsU0FDUnhsQyxPQUFRLDJCQUVWbXVCLE9BQ0V6dkIsT0FBUSxlQUNSOG1DLE9BQVEsVUFFVjlwQyxNQUNFMnBDLEtBQU0sYUFFUnRCLFNBQ0VDLE1BQU8sUUFDUEMsT0FBUSxTQUNSQyxLQUFNLE9BQ05DLE9BQVEsU0FDUkMsSUFBSyxNQUNMQyxPQUFRLFNBQ1JDLE1BQU8sUUFDUEMsTUFBTyxRQUNQQyxLQUFNLE9BQ05DLEtBQU0sT0FDTkMsT0FBUSIsImZpbGUiOiJib290c3RyYXAzLXd5c2lodG1sNS5hbGwtZGVidWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBpbiBmdXR1cmUgdHJ5IHRvIHJlcGxhY2UgbW9zdCBpbmxpbmUgY29tcGFiaWxpdHkgY2hlY2tzIHdpdGggcG9seWZpbGxzIGZvciBjb2RlIHJlYWRhYmlsaXR5IFxuXG4vLyBlbGVtZW50LnRleHRDb250ZW50IHBvbHlmaWxsLlxuLy8gVW5zdXBwb3J0aW5nIGJyb3dzZXJzOiBJRThcblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwidGV4dENvbnRlbnRcIikgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwidGV4dENvbnRlbnRcIikuZ2V0KSB7XG5cdChmdW5jdGlvbigpIHtcblx0XHR2YXIgaW5uZXJUZXh0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgXCJpbm5lclRleHRcIik7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEVsZW1lbnQucHJvdG90eXBlLCBcInRleHRDb250ZW50XCIsXG5cdFx0XHR7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlubmVyVGV4dC5nZXQuY2FsbCh0aGlzKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlubmVyVGV4dC5zZXQuY2FsbCh0aGlzLCBzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0pKCk7XG59XG5cbi8vIGlzQXJyYXkgcG9seWZpbGwgZm9yIGllOFxuaWYoIUFycmF5LmlzQXJyYXkpIHtcbiAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn07LyoqXG4gKiBAbGljZW5zZSB3eXNpaHRtbDV4IHYwLjQuMTVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9FZGljeS93eXNpaHRtbDVcbiAqXG4gKiBBdXRob3I6IENocmlzdG9waGVyIEJsdW0gKGh0dHBzOi8vZ2l0aHViLmNvbS90aWZmKVxuICogU2Vjb25kYXJ5IGF1dGhvciBvZiBleHRlbmRlZCBmZWF0dXJlczogT2xpdmVyIFB1bGdlcyAoaHR0cHM6Ly9naXRodWIuY29tL3B1bGdlcylcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgWElORyBBR1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIChNSVQpXG4gKlxuICovXG52YXIgd3lzaWh0bWw1ID0ge1xuICB2ZXJzaW9uOiBcIjAuNC4xNVwiLFxuXG4gIC8vIG5hbWVzcGFjZXNcbiAgY29tbWFuZHM6ICAge30sXG4gIGRvbTogICAgICAgIHt9LFxuICBxdWlya3M6ICAgICB7fSxcbiAgdG9vbGJhcjogICAge30sXG4gIGxhbmc6ICAgICAgIHt9LFxuICBzZWxlY3Rpb246ICB7fSxcbiAgdmlld3M6ICAgICAge30sXG5cbiAgSU5WSVNJQkxFX1NQQUNFOiBcIlxcdUZFRkZcIixcblxuICBFTVBUWV9GVU5DVElPTjogZnVuY3Rpb24oKSB7fSxcblxuICBFTEVNRU5UX05PREU6IDEsXG4gIFRFWFRfTk9ERTogICAgMyxcblxuICBCQUNLU1BBQ0VfS0VZOiAgOCxcbiAgRU5URVJfS0VZOiAgICAgIDEzLFxuICBFU0NBUEVfS0VZOiAgICAgMjcsXG4gIFNQQUNFX0tFWTogICAgICAzMixcbiAgREVMRVRFX0tFWTogICAgIDQ2XG59O1xuOy8qKlxuICogUmFuZ3ksIGEgY3Jvc3MtYnJvd3NlciBKYXZhU2NyaXB0IHJhbmdlIGFuZCBzZWxlY3Rpb24gbGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Jhbmd5L1xuICpcbiAqIENvcHlyaWdodCAyMDE0LCBUaW0gRG93blxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogVmVyc2lvbjogMS4zYWxwaGEuMjAxNDA4MDRcbiAqIEJ1aWxkIGRhdGU6IDQgQXVndXN0IDIwMTRcbiAqL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSwgZ2xvYmFsKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4vKlxuICAgIFRPRE86IGxvb2sgaW50byB0aGlzIHByb3Blcmx5LlxuICAgIFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTIHN0eWxlIGZvciBCcm93c2VyaWZ5XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gQU1EIG9yIENvbW1vbkpTIHN1cHBvcnQgc28gd2UgcGxhY2UgUmFuZ3kgaW4gYSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgZ2xvYmFsLnJhbmd5ID0gZmFjdG9yeSgpO1xuICAgIH1cbn0pKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIE9CSkVDVCA9IFwib2JqZWN0XCIsIEZVTkNUSU9OID0gXCJmdW5jdGlvblwiLCBVTkRFRklORUQgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgLy8gTWluaW1hbCBzZXQgb2YgcHJvcGVydGllcyByZXF1aXJlZCBmb3IgRE9NIExldmVsIDIgUmFuZ2UgY29tcGxpYW5jZS4gQ29tcGFyaXNvbiBjb25zdGFudHMgc3VjaCBhcyBTVEFSVF9UT19TVEFSVFxuICAgIC8vIGFyZSBvbWl0dGVkIGJlY2F1c2UgcmFuZ2VzIGluIEtIVE1MIGRvIG5vdCBoYXZlIHRoZW0gYnV0IG90aGVyd2lzZSB3b3JrIHBlcmZlY3RseSB3ZWxsLiBTZWUgaXNzdWUgMTEzLlxuICAgIHZhciBkb21SYW5nZVByb3BlcnRpZXMgPSBbXCJzdGFydENvbnRhaW5lclwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwiZW5kQ29udGFpbmVyXCIsIFwiZW5kT2Zmc2V0XCIsIFwiY29sbGFwc2VkXCIsXG4gICAgICAgIFwiY29tbW9uQW5jZXN0b3JDb250YWluZXJcIl07XG5cbiAgICAvLyBNaW5pbWFsIHNldCBvZiBtZXRob2RzIHJlcXVpcmVkIGZvciBET00gTGV2ZWwgMiBSYW5nZSBjb21wbGlhbmNlXG4gICAgdmFyIGRvbVJhbmdlTWV0aG9kcyA9IFtcInNldFN0YXJ0XCIsIFwic2V0U3RhcnRCZWZvcmVcIiwgXCJzZXRTdGFydEFmdGVyXCIsIFwic2V0RW5kXCIsIFwic2V0RW5kQmVmb3JlXCIsXG4gICAgICAgIFwic2V0RW5kQWZ0ZXJcIiwgXCJjb2xsYXBzZVwiLCBcInNlbGVjdE5vZGVcIiwgXCJzZWxlY3ROb2RlQ29udGVudHNcIiwgXCJjb21wYXJlQm91bmRhcnlQb2ludHNcIiwgXCJkZWxldGVDb250ZW50c1wiLFxuICAgICAgICBcImV4dHJhY3RDb250ZW50c1wiLCBcImNsb25lQ29udGVudHNcIiwgXCJpbnNlcnROb2RlXCIsIFwic3Vycm91bmRDb250ZW50c1wiLCBcImNsb25lUmFuZ2VcIiwgXCJ0b1N0cmluZ1wiLCBcImRldGFjaFwiXTtcblxuICAgIHZhciB0ZXh0UmFuZ2VQcm9wZXJ0aWVzID0gW1wiYm91bmRpbmdIZWlnaHRcIiwgXCJib3VuZGluZ0xlZnRcIiwgXCJib3VuZGluZ1RvcFwiLCBcImJvdW5kaW5nV2lkdGhcIiwgXCJodG1sVGV4dFwiLCBcInRleHRcIl07XG5cbiAgICAvLyBTdWJzZXQgb2YgVGV4dFJhbmdlJ3MgZnVsbCBzZXQgb2YgbWV0aG9kcyB0aGF0IHdlJ3JlIGludGVyZXN0ZWQgaW5cbiAgICB2YXIgdGV4dFJhbmdlTWV0aG9kcyA9IFtcImNvbGxhcHNlXCIsIFwiY29tcGFyZUVuZFBvaW50c1wiLCBcImR1cGxpY2F0ZVwiLCBcIm1vdmVUb0VsZW1lbnRUZXh0XCIsIFwicGFyZW50RWxlbWVudFwiLCBcInNlbGVjdFwiLFxuICAgICAgICBcInNldEVuZFBvaW50XCIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCJdO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIFRyaW8gb2YgZnVuY3Rpb25zIHRha2VuIGZyb20gUGV0ZXIgTWljaGF1eCdzIGFydGljbGU6XG4gICAgLy8gaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvZmVhdHVyZS1kZXRlY3Rpb24tc3RhdGUtb2YtdGhlLWFydC1icm93c2VyLXNjcmlwdGluZ1xuICAgIGZ1bmN0aW9uIGlzSG9zdE1ldGhvZChvLCBwKSB7XG4gICAgICAgIHZhciB0ID0gdHlwZW9mIG9bcF07XG4gICAgICAgIHJldHVybiB0ID09IEZVTkNUSU9OIHx8ICghISh0ID09IE9CSkVDVCAmJiBvW3BdKSkgfHwgdCA9PSBcInVua25vd25cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hvc3RPYmplY3QobywgcCkge1xuICAgICAgICByZXR1cm4gISEodHlwZW9mIG9bcF0gPT0gT0JKRUNUICYmIG9bcF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSG9zdFByb3BlcnR5KG8sIHApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvW3BdICE9IFVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2F2ZSB2ZXJib3NlIHJlcGVhdGVkIGNhbGxzIHRvIHRlc3RzIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KHRlc3RGdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvLCBwcm9wcykge1xuICAgICAgICAgICAgdmFyIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0RnVuYyhvLCBwcm9wc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE5leHQgdHJpbyBvZiBmdW5jdGlvbnMgYXJlIGEgY29udmVuaWVuY2UgdG8gc2F2ZSB2ZXJib3NlIHJlcGVhdGVkIGNhbGxzIHRvIHByZXZpb3VzIHR3byBmdW5jdGlvbnNcbiAgICB2YXIgYXJlSG9zdE1ldGhvZHMgPSBjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdChpc0hvc3RNZXRob2QpO1xuICAgIHZhciBhcmVIb3N0T2JqZWN0cyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdE9iamVjdCk7XG4gICAgdmFyIGFyZUhvc3RQcm9wZXJ0aWVzID0gY3JlYXRlTXVsdGlwbGVQcm9wZXJ0eVRlc3QoaXNIb3N0UHJvcGVydHkpO1xuXG4gICAgZnVuY3Rpb24gaXNUZXh0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICYmIGFyZUhvc3RNZXRob2RzKHJhbmdlLCB0ZXh0UmFuZ2VNZXRob2RzKSAmJiBhcmVIb3N0UHJvcGVydGllcyhyYW5nZSwgdGV4dFJhbmdlUHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keShkb2MpIHtcbiAgICAgICAgcmV0dXJuIGlzSG9zdE9iamVjdChkb2MsIFwiYm9keVwiKSA/IGRvYy5ib2R5IDogZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcbiAgICB9XG5cbiAgICB2YXIgbW9kdWxlcyA9IHt9O1xuXG4gICAgdmFyIGFwaSA9IHtcbiAgICAgICAgdmVyc2lvbjogXCIxLjNhbHBoYS4yMDE0MDgwNFwiLFxuICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgIHN1cHBvcnRlZDogdHJ1ZSxcblxuICAgICAgICB1dGlsOiB7XG4gICAgICAgICAgICBpc0hvc3RNZXRob2Q6IGlzSG9zdE1ldGhvZCxcbiAgICAgICAgICAgIGlzSG9zdE9iamVjdDogaXNIb3N0T2JqZWN0LFxuICAgICAgICAgICAgaXNIb3N0UHJvcGVydHk6IGlzSG9zdFByb3BlcnR5LFxuICAgICAgICAgICAgYXJlSG9zdE1ldGhvZHM6IGFyZUhvc3RNZXRob2RzLFxuICAgICAgICAgICAgYXJlSG9zdE9iamVjdHM6IGFyZUhvc3RPYmplY3RzLFxuICAgICAgICAgICAgYXJlSG9zdFByb3BlcnRpZXM6IGFyZUhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgaXNUZXh0UmFuZ2U6IGlzVGV4dFJhbmdlLFxuICAgICAgICAgICAgZ2V0Qm9keTogZ2V0Qm9keVxuICAgICAgICB9LFxuXG4gICAgICAgIGZlYXR1cmVzOiB7fSxcblxuICAgICAgICBtb2R1bGVzOiBtb2R1bGVzLFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIGFsZXJ0T25GYWlsOiB0cnVlLFxuICAgICAgICAgICAgYWxlcnRPbldhcm46IGZhbHNlLFxuICAgICAgICAgICAgcHJlZmVyVGV4dFJhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9Jbml0aWFsaXplOiAodHlwZW9mIHJhbmd5QXV0b0luaXRpYWxpemUgPT0gVU5ERUZJTkVEKSA/IHRydWUgOiByYW5neUF1dG9Jbml0aWFsaXplXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29uc29sZUxvZyhtc2cpIHtcbiAgICAgICAgaWYgKGlzSG9zdE9iamVjdCh3aW5kb3csIFwiY29uc29sZVwiKSAmJiBpc0hvc3RNZXRob2Qod2luZG93LmNvbnNvbGUsIFwibG9nXCIpKSB7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsZXJ0T3JMb2cobXNnLCBzaG91bGRBbGVydCkge1xuICAgICAgICBpZiAoc2hvdWxkQWxlcnQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hbGVydChtc2cpO1xuICAgICAgICB9IGVsc2UgIHtcbiAgICAgICAgICAgIGNvbnNvbGVMb2cobXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgICAgIGFwaS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGFwaS5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgYWxlcnRPckxvZyhcIlJhbmd5IGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwYWdlIGluIHlvdXIgYnJvd3Nlci4gUmVhc29uOiBcIiArIHJlYXNvbiwgYXBpLmNvbmZpZy5hbGVydE9uRmFpbCk7XG4gICAgfVxuXG4gICAgYXBpLmZhaWwgPSBmYWlsO1xuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgYWxlcnRPckxvZyhcIlJhbmd5IHdhcm5pbmc6IFwiICsgbXNnLCBhcGkuY29uZmlnLmFsZXJ0T25XYXJuKTtcbiAgICB9XG5cbiAgICBhcGkud2FybiA9IHdhcm47XG5cbiAgICAvLyBBZGQgdXRpbGl0eSBleHRlbmQoKSBtZXRob2RcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkpIHtcbiAgICAgICAgYXBpLnV0aWwuZXh0ZW5kID0gZnVuY3Rpb24ob2JqLCBwcm9wcywgZGVlcCkge1xuICAgICAgICAgICAgdmFyIG8sIHA7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvYmpbaV07XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXAgJiYgbyAhPT0gbnVsbCAmJiB0eXBlb2YgbyA9PSBcIm9iamVjdFwiICYmIHAgIT09IG51bGwgJiYgdHlwZW9mIHAgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnV0aWwuZXh0ZW5kKG8sIHAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9ialtpXSA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0b1N0cmluZywgd2hpY2ggZG9lcyBub3Qgc2hvdyB1cCBpbiBmb3IuLi5pbiBsb29wcyBpbiBJRSA8PSA4XG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIG9iai50b1N0cmluZyA9IHByb3BzLnRvU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWlsKFwiaGFzT3duUHJvcGVydHkgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBUZXN0IHdoZXRoZXIgQXJyYXkucHJvdG90eXBlLnNsaWNlIGNhbiBiZSByZWxpZWQgb24gZm9yIE5vZGVMaXN0cyBhbmQgdXNlIGFuIGFsdGVybmF0aXZlIHRvQXJyYXkoKSBpZiBub3RcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgdmFyIHNsaWNlID0gW10uc2xpY2U7XG4gICAgICAgIHZhciB0b0FycmF5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNsaWNlLmNhbGwoZWwuY2hpbGROb2RlcywgMClbMF0ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIHRvQXJyYXkgPSBmdW5jdGlvbihhcnJheUxpa2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXlMaWtlLCAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIGlmICghdG9BcnJheSkge1xuICAgICAgICAgICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXlMaWtlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBhcGkudXRpbC50b0FycmF5ID0gdG9BcnJheTtcbiAgICB9KSgpO1xuXG5cbiAgICAvLyBWZXJ5IHNpbXBsZSBldmVudCBoYW5kbGVyIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBkb2Vzbid0IGF0dGVtcHQgdG8gc29sdmUgaXNzdWVzIHN1Y2ggYXMgXCJ0aGlzXCIgaGFuZGxpbmcgb3JcbiAgICAvLyBub3JtYWxpemF0aW9uIG9mIGV2ZW50IHByb3BlcnRpZXNcbiAgICB2YXIgYWRkTGlzdGVuZXI7XG4gICAgaWYgKGlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJhZGRFdmVudExpc3RlbmVyXCIpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyID0gZnVuY3Rpb24ob2JqLCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2QoZG9jdW1lbnQsIFwiYXR0YWNoRXZlbnRcIikpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihvYmosIGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9iai5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWlsKFwiRG9jdW1lbnQgZG9lcyBub3QgaGF2ZSByZXF1aXJlZCBhZGRFdmVudExpc3RlbmVyIG9yIGF0dGFjaEV2ZW50IG1ldGhvZFwiKTtcbiAgICB9XG5cbiAgICBhcGkudXRpbC5hZGRMaXN0ZW5lciA9IGFkZExpc3RlbmVyO1xuXG4gICAgdmFyIGluaXRMaXN0ZW5lcnMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGdldEVycm9yRGVzYyhleCkge1xuICAgICAgICByZXR1cm4gZXgubWVzc2FnZSB8fCBleC5kZXNjcmlwdGlvbiB8fCBTdHJpbmcoZXgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemF0aW9uXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgaWYgKGFwaS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXN0UmFuZ2U7XG4gICAgICAgIHZhciBpbXBsZW1lbnRzRG9tUmFuZ2UgPSBmYWxzZSwgaW1wbGVtZW50c1RleHRSYW5nZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEZpcnN0LCBwZXJmb3JtIGJhc2ljIGZlYXR1cmUgdGVzdHNcblxuICAgICAgICBpZiAoaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImNyZWF0ZVJhbmdlXCIpKSB7XG4gICAgICAgICAgICB0ZXN0UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGFyZUhvc3RNZXRob2RzKHRlc3RSYW5nZSwgZG9tUmFuZ2VNZXRob2RzKSAmJiBhcmVIb3N0UHJvcGVydGllcyh0ZXN0UmFuZ2UsIGRvbVJhbmdlUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRzRG9tUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KGRvY3VtZW50KTtcbiAgICAgICAgaWYgKCFib2R5IHx8IGJvZHkubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSBcImJvZHlcIikge1xuICAgICAgICAgICAgZmFpbChcIk5vIGJvZHkgZWxlbWVudCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5ICYmIGlzSG9zdE1ldGhvZChib2R5LCBcImNyZWF0ZVRleHRSYW5nZVwiKSkge1xuICAgICAgICAgICAgdGVzdFJhbmdlID0gYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChpc1RleHRSYW5nZSh0ZXN0UmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgaW1wbGVtZW50c1RleHRSYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWltcGxlbWVudHNEb21SYW5nZSAmJiAhaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgICAgICAgICAgZmFpbChcIk5laXRoZXIgUmFuZ2Ugbm9yIFRleHRSYW5nZSBhcmUgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBpLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgYXBpLmZlYXR1cmVzID0ge1xuICAgICAgICAgICAgaW1wbGVtZW50c0RvbVJhbmdlOiBpbXBsZW1lbnRzRG9tUmFuZ2UsXG4gICAgICAgICAgICBpbXBsZW1lbnRzVGV4dFJhbmdlOiBpbXBsZW1lbnRzVGV4dFJhbmdlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtb2R1bGVzXG4gICAgICAgIHZhciBtb2R1bGUsIGVycm9yTWVzc2FnZTtcbiAgICAgICAgZm9yICh2YXIgbW9kdWxlTmFtZSBpbiBtb2R1bGVzKSB7XG4gICAgICAgICAgICBpZiAoIChtb2R1bGUgPSBtb2R1bGVzW21vZHVsZU5hbWVdKSBpbnN0YW5jZW9mIE1vZHVsZSApIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaW5pdChtb2R1bGUsIGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIGluaXQgbGlzdGVuZXJzXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbml0TGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGluaXRMaXN0ZW5lcnNbaV0oYXBpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJSYW5neSBpbml0IGxpc3RlbmVyIHRocmV3IGFuIGV4Y2VwdGlvbi4gQ29udGludWluZy4gRGV0YWlsOiBcIiArIGdldEVycm9yRGVzYyhleCk7XG4gICAgICAgICAgICAgICAgY29uc29sZUxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgc2NyaXB0cyB0byBpbml0aWFsaXplIHRoaXMgbGlicmFyeSBpbiBjYXNlIGl0J3MgbG9hZGVkIGFmdGVyIHRoZSBkb2N1bWVudCBoYXMgbG9hZGVkXG4gICAgYXBpLmluaXQgPSBpbml0O1xuXG4gICAgLy8gRXhlY3V0ZSBsaXN0ZW5lciBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgYXBpLmFkZEluaXRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcGkuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGFwaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzaGltTGlzdGVuZXJzID0gW107XG5cbiAgICBhcGkuYWRkU2hpbUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgc2hpbUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2hpbSh3aW4pIHtcbiAgICAgICAgd2luID0gd2luIHx8IHdpbmRvdztcbiAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNoaW1MaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHNoaW1MaXN0ZW5lcnNbaV0od2luKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwaS5zaGltID0gYXBpLmNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkgPSBzaGltO1xuXG4gICAgZnVuY3Rpb24gTW9kdWxlKG5hbWUsIGRlcGVuZGVuY2llcywgaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplciA9IGluaXRpYWxpemVyO1xuICAgIH1cblxuICAgIE1vZHVsZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVkTW9kdWxlTmFtZXMgPSB0aGlzLmRlcGVuZGVuY2llcyB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXF1aXJlZE1vZHVsZU5hbWVzLmxlbmd0aCwgcmVxdWlyZWRNb2R1bGUsIG1vZHVsZU5hbWU7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWUgPSByZXF1aXJlZE1vZHVsZU5hbWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRNb2R1bGUgPSBtb2R1bGVzW21vZHVsZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWlyZWRNb2R1bGUgfHwgIShyZXF1aXJlZE1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVxdWlyZWQgbW9kdWxlICdcIiArIG1vZHVsZU5hbWUgKyBcIicgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcXVpcmVkTW9kdWxlLmluaXQoKTtcblxuICAgICAgICAgICAgICAgIGlmICghcmVxdWlyZWRNb2R1bGUuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcXVpcmVkIG1vZHVsZSAnXCIgKyBtb2R1bGVOYW1lICsgXCInIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBOb3cgcnVuIGluaXRpYWxpemVyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZmFpbDogZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUgJ1wiICsgdGhpcy5uYW1lICsgXCInIGZhaWxlZCB0byBsb2FkOiBcIiArIHJlYXNvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2FybjogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICBhcGkud2FybihcIk1vZHVsZSBcIiArIHRoaXMubmFtZSArIFwiOiBcIiArIG1zZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVwcmVjYXRpb25Ob3RpY2U6IGZ1bmN0aW9uKGRlcHJlY2F0ZWQsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBhcGkud2FybihcIkRFUFJFQ0FURUQ6IFwiICsgZGVwcmVjYXRlZCArIFwiIGluIG1vZHVsZSBcIiArIHRoaXMubmFtZSArIFwiaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIiArXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgKyBcIiBpbnN0ZWFkXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFcnJvciBpbiBSYW5neSBcIiArIHRoaXMubmFtZSArIFwiIG1vZHVsZTogXCIgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBjcmVhdGVNb2R1bGUoaXNDb3JlLCBuYW1lLCBkZXBlbmRlbmNpZXMsIGluaXRGdW5jKSB7XG4gICAgICAgIHZhciBuZXdNb2R1bGUgPSBuZXcgTW9kdWxlKG5hbWUsIGRlcGVuZGVuY2llcywgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAoIW1vZHVsZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdEZ1bmMoYXBpLCBtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJNb2R1bGUgJ1wiICsgbmFtZSArIFwiJyBmYWlsZWQgdG8gbG9hZDogXCIgKyBnZXRFcnJvckRlc2MoZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlTG9nKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbW9kdWxlc1tuYW1lXSA9IG5ld01vZHVsZTtcbiAgICB9XG5cbiAgICBhcGkuY3JlYXRlTW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAvLyBBbGxvdyAyIG9yIDMgYXJndW1lbnRzIChzZWNvbmQgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgZGVwZW5kZW5jaWVzKVxuICAgICAgICB2YXIgaW5pdEZ1bmMsIGRlcGVuZGVuY2llcztcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgaW5pdEZ1bmMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRGdW5jID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vZHVsZSA9IGNyZWF0ZU1vZHVsZShmYWxzZSwgbmFtZSwgZGVwZW5kZW5jaWVzLCBpbml0RnVuYyk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGltbWVkaWF0ZWx5IGlmIHRoZSBjb3JlIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgaWYgKGFwaS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgbW9kdWxlLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhcGkuY3JlYXRlQ29yZU1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUsIGRlcGVuZGVuY2llcywgaW5pdEZ1bmMpIHtcbiAgICAgICAgY3JlYXRlTW9kdWxlKHRydWUsIG5hbWUsIGRlcGVuZGVuY2llcywgaW5pdEZ1bmMpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gRW5zdXJlIHJhbmd5LnJhbmdlUHJvdG90eXBlIGFuZCByYW5neS5zZWxlY3Rpb25Qcm90b3R5cGUgYXJlIGF2YWlsYWJsZSBpbW1lZGlhdGVseVxuXG4gICAgZnVuY3Rpb24gUmFuZ2VQcm90b3R5cGUoKSB7fVxuICAgIGFwaS5SYW5nZVByb3RvdHlwZSA9IFJhbmdlUHJvdG90eXBlO1xuICAgIGFwaS5yYW5nZVByb3RvdHlwZSA9IG5ldyBSYW5nZVByb3RvdHlwZSgpO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uUHJvdG90eXBlKCkge31cbiAgICBhcGkuc2VsZWN0aW9uUHJvdG90eXBlID0gbmV3IFNlbGVjdGlvblByb3RvdHlwZSgpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGxvYWQgYmVmb3JlIHJ1bm5pbmcgdGVzdHNcblxuICAgIHZhciBkb2NSZWFkeSA9IGZhbHNlO1xuXG4gICAgdmFyIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWRvY1JlYWR5KSB7XG4gICAgICAgICAgICBkb2NSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWFwaS5pbml0aWFsaXplZCAmJiBhcGkuY29uZmlnLmF1dG9Jbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRlc3Qgd2hldGhlciB3ZSBoYXZlIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyB0aGF0IHdlIHdpbGwgbmVlZFxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09IFVOREVGSU5FRCkge1xuICAgICAgICBmYWlsKFwiTm8gd2luZG93IGZvdW5kXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT0gVU5ERUZJTkVEKSB7XG4gICAgICAgIGZhaWwoXCJObyBkb2N1bWVudCBmb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0hvc3RNZXRob2QoZG9jdW1lbnQsIFwiYWRkRXZlbnRMaXN0ZW5lclwiKSkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBsb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhIGZhbGxiYWNrIGluIGNhc2UgdGhlIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgaXNuJ3Qgc3VwcG9ydGVkXG4gICAgYWRkTGlzdGVuZXIod2luZG93LCBcImxvYWRcIiwgbG9hZEhhbmRsZXIpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBcbiAgICAvLyBET00gdXRpbGl0eSBtZXRob2RzIHVzZWQgYnkgUmFuZ3lcbiAgICBhcGkuY3JlYXRlQ29yZU1vZHVsZShcIkRvbVV0aWxcIiwgW10sIGZ1bmN0aW9uKGFwaSwgbW9kdWxlKSB7XG4gICAgICAgIHZhciBVTkRFRiA9IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIHZhciB1dGlsID0gYXBpLnV0aWw7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBmZWF0dXJlIHRlc3RzXG4gICAgICAgIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyhkb2N1bWVudCwgW1wiY3JlYXRlRG9jdW1lbnRGcmFnbWVudFwiLCBcImNyZWF0ZUVsZW1lbnRcIiwgXCJjcmVhdGVUZXh0Tm9kZVwiXSkpIHtcbiAgICAgICAgICAgIG1vZHVsZS5mYWlsKFwiZG9jdW1lbnQgbWlzc2luZyBhIE5vZGUgY3JlYXRpb24gbWV0aG9kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiKSkge1xuICAgICAgICAgICAgbW9kdWxlLmZhaWwoXCJkb2N1bWVudCBtaXNzaW5nIGdldEVsZW1lbnRzQnlUYWdOYW1lIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyhlbCwgW1wiaW5zZXJ0QmVmb3JlXCIsIFwiYXBwZW5kQ2hpbGRcIiwgXCJjbG9uZU5vZGVcIl0gfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5hcmVIb3N0T2JqZWN0cyhlbCwgW1wicHJldmlvdXNTaWJsaW5nXCIsIFwibmV4dFNpYmxpbmdcIiwgXCJjaGlsZE5vZGVzXCIsIFwicGFyZW50Tm9kZVwiXSkpKSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIkluY29tcGxldGUgRWxlbWVudCBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlubmVySFRNTCBpcyByZXF1aXJlZCBmb3IgUmFuZ2UncyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgbWV0aG9kXG4gICAgICAgIGlmICghdXRpbC5pc0hvc3RQcm9wZXJ0eShlbCwgXCJpbm5lckhUTUxcIikpIHtcbiAgICAgICAgICAgIG1vZHVsZS5mYWlsKFwiRWxlbWVudCBpcyBtaXNzaW5nIGlubmVySFRNTCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGVzdFwiKTtcbiAgICAgICAgaWYgKCF1dGlsLmFyZUhvc3RNZXRob2RzKHRleHROb2RlLCBbXCJzcGxpdFRleHRcIiwgXCJkZWxldGVEYXRhXCIsIFwiaW5zZXJ0RGF0YVwiLCBcImFwcGVuZERhdGFcIiwgXCJjbG9uZU5vZGVcIl0gfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5hcmVIb3N0T2JqZWN0cyhlbCwgW1wicHJldmlvdXNTaWJsaW5nXCIsIFwibmV4dFNpYmxpbmdcIiwgXCJjaGlsZE5vZGVzXCIsIFwicGFyZW50Tm9kZVwiXSkgfHxcbiAgICAgICAgICAgICAgICAhdXRpbC5hcmVIb3N0UHJvcGVydGllcyh0ZXh0Tm9kZSwgW1wiZGF0YVwiXSkpKSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIkluY29tcGxldGUgVGV4dCBOb2RlIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBSZW1vdmVkIHVzZSBvZiBpbmRleE9mIGJlY2F1c2Ugb2YgYSBiaXphcnJlIGJ1ZyBpbiBPcGVyYSB0aGF0IGlzIHRocm93biBpbiBvbmUgb2YgdGhlIEFjaWQzIHRlc3RzLiBJIGhhdmVuJ3QgYmVlblxuICAgICAgICAvLyBhYmxlIHRvIHJlcGxpY2F0ZSBpdCBvdXRzaWRlIG9mIHRoZSB0ZXN0LiBUaGUgYnVnIGlzIHRoYXQgaW5kZXhPZiByZXR1cm5zIC0xIHdoZW4gY2FsbGVkIG9uIGFuIEFycmF5IHRoYXRcbiAgICAgICAgLy8gY29udGFpbnMganVzdCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgZWxlbWVudCBhbmQgdGhlIHZhbHVlIHNlYXJjaGVkIGZvciBpcyB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHZhciBhcnJheUNvbnRhaW5zID0gLypBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA/XG4gICAgICAgICAgICBmdW5jdGlvbihhcnIsIHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnIuaW5kZXhPZih2YWwpID4gLTE7XG4gICAgICAgICAgICB9OiovXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uKGFyciwgdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIE9wZXJhIDExIHB1dHMgSFRNTCBlbGVtZW50cyBpbiB0aGUgbnVsbCBuYW1lc3BhY2UsIGl0IHNlZW1zLCBhbmQgSUUgNyBoYXMgdW5kZWZpbmVkIG5hbWVzcGFjZVVSSVxuICAgICAgICBmdW5jdGlvbiBpc0h0bWxOYW1lc3BhY2Uobm9kZSkge1xuICAgICAgICAgICAgdmFyIG5zO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBub2RlLm5hbWVzcGFjZVVSSSA9PSBVTkRFRiB8fCAoKG5zID0gbm9kZS5uYW1lc3BhY2VVUkkpID09PSBudWxsIHx8IG5zID09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudEVsZW1lbnQobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiAocGFyZW50Lm5vZGVUeXBlID09IDEpID8gcGFyZW50IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5vZGVJbmRleChub2RlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSggKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykgKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXROb2RlTGVuZ3RoKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvcihub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvcnMgPSBbXSwgbjtcbiAgICAgICAgICAgIGZvciAobiA9IG5vZGUxOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gobik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobiA9IG5vZGUyOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5Q29udGFpbnMoYW5jZXN0b3JzLCBuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3Rvck9mKGFuY2VzdG9yLCBkZXNjZW5kYW50LCBzZWxmSXNBbmNlc3Rvcikge1xuICAgICAgICAgICAgdmFyIG4gPSBzZWxmSXNBbmNlc3RvciA/IGRlc2NlbmRhbnQgOiBkZXNjZW5kYW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzT3JJc0FuY2VzdG9yT2YoYW5jZXN0b3IsIGRlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FuY2VzdG9yT2YoYW5jZXN0b3IsIGRlc2NlbmRhbnQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZSwgYW5jZXN0b3IsIHNlbGZJc0FuY2VzdG9yKSB7XG4gICAgICAgICAgICB2YXIgcCwgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgcCA9IG4ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4gPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0ID09IDMgfHwgdCA9PSA0IHx8IHQgPT0gOCA7IC8vIFRleHQsIENEYXRhU2VjdGlvbiBvciBDb21tZW50XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1RleHRPckNvbW1lbnROb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0ID09IDMgfHwgdCA9PSA4IDsgLy8gVGV4dCBvciBDb21tZW50XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZnRlcihub2RlLCBwcmVjZWRpbmdOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBwcmVjZWRpbmdOb2RlLm5leHRTaWJsaW5nLCBwYXJlbnQgPSBwcmVjZWRpbmdOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHROb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgY2Fubm90IHVzZSBzcGxpdFRleHQoKSBiZWNhdXNlIGl0IGlzIGJ1Z3JpZGRlbiBpbiBJRSA5LlxuICAgICAgICBmdW5jdGlvbiBzcGxpdERhdGFOb2RlKG5vZGUsIGluZGV4LCBwb3NpdGlvbnNUb1ByZXNlcnZlKSB7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgIG5ld05vZGUuZGVsZXRlRGF0YSgwLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlLmRlbGV0ZURhdGEoaW5kZXgsIG5vZGUubGVuZ3RoIC0gaW5kZXgpO1xuICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIobmV3Tm9kZSwgbm9kZSk7XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHBvc2l0aW9uc1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1RvUHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcG9zaXRpb247IHBvc2l0aW9uID0gcG9zaXRpb25zVG9QcmVzZXJ2ZVtpKytdOyApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcG9zaXRpb24gd2FzIGluc2lkZSB0aGUgcG9ydGlvbiBvZiBub2RlIGFmdGVyIHRoZSBzcGxpdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ubm9kZSA9PSBub2RlICYmIHBvc2l0aW9uLm9mZnNldCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5ub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLm9mZnNldCAtPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHBvc2l0aW9uIGlzIGEgbm9kZSBvZmZzZXQgd2l0aGluIG5vZGUncyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubm9kZSA9PSBub2RlLnBhcmVudE5vZGUgJiYgcG9zaXRpb24ub2Zmc2V0ID4gZ2V0Tm9kZUluZGV4KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3Bvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5vd25lckRvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuZG9jdW1lbnQgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldERvY3VtZW50KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcImdldERvY3VtZW50OiBubyBkb2N1bWVudCBmb3VuZCBmb3Igbm9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvYy5kZWZhdWx0VmlldyAhPSBVTkRFRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MucGFyZW50V2luZG93ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcIkNhbm5vdCBnZXQgYSB3aW5kb3cgb2JqZWN0IGZvciBub2RlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWZyYW1lRWwuY29udGVudERvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiZ2V0SWZyYW1lRG9jdW1lbnQ6IE5vIERvY3VtZW50IG9iamVjdCBmb3VuZCBmb3IgaWZyYW1lIGVsZW1lbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRJZnJhbWVXaW5kb3coaWZyYW1lRWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWZyYW1lRWwuY29udGVudFdpbmRvdyAhPSBVTkRFRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWZyYW1lRWwuY29udGVudERvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiZ2V0SWZyYW1lV2luZG93OiBObyBXaW5kb3cgb2JqZWN0IGZvdW5kIGZvciBpZnJhbWUgZWxlbWVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgbG9va3MgYmFkLiBJcyBpdCB3b3J0aCBpdD9cbiAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHV0aWwuaXNIb3N0TWV0aG9kKG9iaiwgXCJzZXRUaW1lb3V0XCIpICYmIHV0aWwuaXNIb3N0T2JqZWN0KG9iaiwgXCJkb2N1bWVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbnRlbnREb2N1bWVudChvYmosIG1vZHVsZSwgbWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgdmFyIGRvYztcblxuICAgICAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgICAgICBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGVzdCBpZiBhIERPTSBub2RlIGhhcyBiZWVuIHBhc3NlZCBhbmQgb2J0YWluIGEgZG9jdW1lbnQgb2JqZWN0IGZvciBpdCBpZiBzb1xuICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc0hvc3RQcm9wZXJ0eShvYmosIFwibm9kZVR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBkb2MgPSAob2JqLm5vZGVUeXBlID09IDEgJiYgb2JqLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImlmcmFtZVwiKSA/XG4gICAgICAgICAgICAgICAgICAgIGdldElmcmFtZURvY3VtZW50KG9iaikgOiBnZXREb2N1bWVudChvYmopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSBkb2MgcGFyYW1ldGVyIGFwcGVhcnMgdG8gYmUgYSBXaW5kb3cgb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmIChpc1dpbmRvdyhvYmopKSB7XG4gICAgICAgICAgICAgICAgZG9jID0gb2JqLmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihtZXRob2ROYW1lICsgXCIoKTogUGFyYW1ldGVyIG11c3QgYmUgYSBXaW5kb3cgb2JqZWN0IG9yIERPTSBub2RlXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Um9vdENvbnRhaW5lcihub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCAocGFyZW50ID0gbm9kZS5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKG5vZGVBLCBvZmZzZXRBLCBub2RlQiwgb2Zmc2V0Qikge1xuICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLVRyYXZlcnNhbC1SYW5nZS9yYW5nZXMuaHRtbCNMZXZlbC0yLVJhbmdlLUNvbXBhcmluZ1xuICAgICAgICAgICAgdmFyIG5vZGVDLCByb290LCBjaGlsZEEsIGNoaWxkQiwgbjtcbiAgICAgICAgICAgIGlmIChub2RlQSA9PSBub2RlQikge1xuICAgICAgICAgICAgICAgIC8vIENhc2UgMTogbm9kZXMgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldEEgPT09IG9mZnNldEIgPyAwIDogKG9mZnNldEEgPCBvZmZzZXRCKSA/IC0xIDogMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIChub2RlQyA9IGdldENsb3Nlc3RBbmNlc3RvckluKG5vZGVCLCBub2RlQSwgdHJ1ZSkpICkge1xuICAgICAgICAgICAgICAgIC8vIENhc2UgMjogbm9kZSBDIChjb250YWluZXIgQiBvciBhbiBhbmNlc3RvcikgaXMgYSBjaGlsZCBub2RlIG9mIEFcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0QSA8PSBnZXROb2RlSW5kZXgobm9kZUMpID8gLTEgOiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggKG5vZGVDID0gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUEsIG5vZGVCLCB0cnVlKSkgKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAzOiBub2RlIEMgKGNvbnRhaW5lciBBIG9yIGFuIGFuY2VzdG9yKSBpcyBhIGNoaWxkIG5vZGUgb2YgQlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2RlSW5kZXgobm9kZUMpIDwgb2Zmc2V0QiAgPyAtMSA6IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QgPSBnZXRDb21tb25BbmNlc3Rvcihub2RlQSwgbm9kZUIpO1xuICAgICAgICAgICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wYXJlUG9pbnRzIGVycm9yOiBub2RlcyBoYXZlIG5vIGNvbW1vbiBhbmNlc3RvclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYXNlIDQ6IGNvbnRhaW5lcnMgYXJlIHNpYmxpbmdzIG9yIGRlc2NlbmRhbnRzIG9mIHNpYmxpbmdzXG4gICAgICAgICAgICAgICAgY2hpbGRBID0gKG5vZGVBID09PSByb290KSA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQSwgcm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2hpbGRCID0gKG5vZGVCID09PSByb290KSA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQiwgcm9vdCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRBID09PSBjaGlsZEIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiY29tcGFyZVBvaW50cyBnb3QgdG8gY2FzZSA0IGFuZCBjaGlsZEEgYW5kIGNoaWxkQiBhcmUgdGhlIHNhbWUhXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA9PT0gY2hpbGRBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSBjaGlsZEIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBUZXN0IGZvciBJRSdzIGNyYXNoIChJRSA2LzcpIG9yIGV4Y2VwdGlvbiAoSUUgPj0gOCkgd2hlbiBhIHJlZmVyZW5jZSB0byBnYXJiYWdlLWNvbGxlY3RlZCB0ZXh0IG5vZGUgaXMgcXVlcmllZFxuICAgICAgICB2YXIgY3Jhc2h5VGV4dE5vZGVzID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNCcm9rZW5Ob2RlKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiXCIpO1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCIxXCI7XG4gICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8YnI+XCI7XG4gICAgICAgICAgICBjcmFzaHlUZXh0Tm9kZXMgPSBpc0Jyb2tlbk5vZGUodGV4dE5vZGUpO1xuXG4gICAgICAgICAgICBhcGkuZmVhdHVyZXMuY3Jhc2h5VGV4dE5vZGVzID0gY3Jhc2h5VGV4dE5vZGVzO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgZnVuY3Rpb24gaW5zcGVjdE5vZGUobm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW05vIG5vZGVdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Jhc2h5VGV4dE5vZGVzICYmIGlzQnJva2VuTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltCcm9rZW4gbm9kZV1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcIicgKyBub2RlLmRhdGEgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBpZEF0dHIgPSBub2RlLmlkID8gJyBpZD1cIicgKyBub2RlLmlkICsgJ1wiJyA6IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgbm9kZS5ub2RlTmFtZSArIGlkQXR0ciArIFwiPltpbmRleDpcIiArIGdldE5vZGVJbmRleChub2RlKSArIFwiLGxlbmd0aDpcIiArIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggKyBcIl1bXCIgKyAobm9kZS5pbm5lckhUTUwgfHwgXCJbaW5uZXJIVE1MIG5vdCBzdXBwb3J0ZWRdXCIpLnNsaWNlKDAsIDI1KSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4obm9kZSkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZ2V0RG9jdW1lbnQobm9kZSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBjaGlsZDtcbiAgICAgICAgICAgIHdoaWxlICggKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSApIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICE9IFVOREVGKSB7XG4gICAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlUHJvcGVydHkgPSBmdW5jdGlvbihlbCwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93KGVsKS5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKVtwcm9wTmFtZV07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICE9IFVOREVGKSB7XG4gICAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlUHJvcGVydHkgPSBmdW5jdGlvbihlbCwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY3VycmVudFN0eWxlW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIk5vIG1lYW5zIG9mIG9idGFpbmluZyBjb21wdXRlZCBzdHlsZSBwcm9wZXJ0aWVzIGZvdW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gTm9kZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLl9uZXh0ID0gcm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGVJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBfY3VycmVudDogbnVsbCxcblxuICAgICAgICAgICAgaGFzTmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQ7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkLCBuZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gbi5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChuICE9PSB0aGlzLnJvb3QpICYmICEobmV4dCA9IG4ubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGV0YWNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dCA9IHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlSXRlcmF0b3Iocm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBEb21Qb3NpdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIERvbVBvc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcG9zICYmIHRoaXMubm9kZSA9PT0gcG9zLm5vZGUgJiYgdGhpcy5vZmZzZXQgPT0gcG9zLm9mZnNldDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluc3BlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltEb21Qb3NpdGlvbihcIiArIGluc3BlY3ROb2RlKHRoaXMubm9kZSkgKyBcIjpcIiArIHRoaXMub2Zmc2V0ICsgXCIpXVwiO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBET01FeGNlcHRpb24oY29kZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IHRoaXNbY29kZU5hbWVdO1xuICAgICAgICAgICAgdGhpcy5jb2RlTmFtZSA9IGNvZGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJET01FeGNlcHRpb246IFwiICsgdGhpcy5jb2RlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBJTkRFWF9TSVpFX0VSUjogMSxcbiAgICAgICAgICAgIEhJRVJBUkNIWV9SRVFVRVNUX0VSUjogMyxcbiAgICAgICAgICAgIFdST05HX0RPQ1VNRU5UX0VSUjogNCxcbiAgICAgICAgICAgIE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUjogNyxcbiAgICAgICAgICAgIE5PVF9GT1VORF9FUlI6IDgsXG4gICAgICAgICAgICBOT1RfU1VQUE9SVEVEX0VSUjogOSxcbiAgICAgICAgICAgIElOVkFMSURfU1RBVEVfRVJSOiAxMSxcbiAgICAgICAgICAgIElOVkFMSURfTk9ERV9UWVBFX0VSUjogMjRcbiAgICAgICAgfTtcblxuICAgICAgICBET01FeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFwaS5kb20gPSB7XG4gICAgICAgICAgICBhcnJheUNvbnRhaW5zOiBhcnJheUNvbnRhaW5zLFxuICAgICAgICAgICAgaXNIdG1sTmFtZXNwYWNlOiBpc0h0bWxOYW1lc3BhY2UsXG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50OiBwYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgZ2V0Tm9kZUluZGV4OiBnZXROb2RlSW5kZXgsXG4gICAgICAgICAgICBnZXROb2RlTGVuZ3RoOiBnZXROb2RlTGVuZ3RoLFxuICAgICAgICAgICAgZ2V0Q29tbW9uQW5jZXN0b3I6IGdldENvbW1vbkFuY2VzdG9yLFxuICAgICAgICAgICAgaXNBbmNlc3Rvck9mOiBpc0FuY2VzdG9yT2YsXG4gICAgICAgICAgICBpc09ySXNBbmNlc3Rvck9mOiBpc09ySXNBbmNlc3Rvck9mLFxuICAgICAgICAgICAgZ2V0Q2xvc2VzdEFuY2VzdG9ySW46IGdldENsb3Nlc3RBbmNlc3RvckluLFxuICAgICAgICAgICAgaXNDaGFyYWN0ZXJEYXRhTm9kZTogaXNDaGFyYWN0ZXJEYXRhTm9kZSxcbiAgICAgICAgICAgIGlzVGV4dE9yQ29tbWVudE5vZGU6IGlzVGV4dE9yQ29tbWVudE5vZGUsXG4gICAgICAgICAgICBpbnNlcnRBZnRlcjogaW5zZXJ0QWZ0ZXIsXG4gICAgICAgICAgICBzcGxpdERhdGFOb2RlOiBzcGxpdERhdGFOb2RlLFxuICAgICAgICAgICAgZ2V0RG9jdW1lbnQ6IGdldERvY3VtZW50LFxuICAgICAgICAgICAgZ2V0V2luZG93OiBnZXRXaW5kb3csXG4gICAgICAgICAgICBnZXRJZnJhbWVXaW5kb3c6IGdldElmcmFtZVdpbmRvdyxcbiAgICAgICAgICAgIGdldElmcmFtZURvY3VtZW50OiBnZXRJZnJhbWVEb2N1bWVudCxcbiAgICAgICAgICAgIGdldEJvZHk6IHV0aWwuZ2V0Qm9keSxcbiAgICAgICAgICAgIGlzV2luZG93OiBpc1dpbmRvdyxcbiAgICAgICAgICAgIGdldENvbnRlbnREb2N1bWVudDogZ2V0Q29udGVudERvY3VtZW50LFxuICAgICAgICAgICAgZ2V0Um9vdENvbnRhaW5lcjogZ2V0Um9vdENvbnRhaW5lcixcbiAgICAgICAgICAgIGNvbXBhcmVQb2ludHM6IGNvbXBhcmVQb2ludHMsXG4gICAgICAgICAgICBpc0Jyb2tlbk5vZGU6IGlzQnJva2VuTm9kZSxcbiAgICAgICAgICAgIGluc3BlY3ROb2RlOiBpbnNwZWN0Tm9kZSxcbiAgICAgICAgICAgIGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eTogZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5LFxuICAgICAgICAgICAgZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuOiBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4sXG4gICAgICAgICAgICBjcmVhdGVJdGVyYXRvcjogY3JlYXRlSXRlcmF0b3IsXG4gICAgICAgICAgICBEb21Qb3NpdGlvbjogRG9tUG9zaXRpb25cbiAgICAgICAgfTtcblxuICAgICAgICBhcGkuRE9NRXhjZXB0aW9uID0gRE9NRXhjZXB0aW9uO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIFB1cmUgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBET00gUmFuZ2VcbiAgICBhcGkuY3JlYXRlQ29yZU1vZHVsZShcIkRvbVJhbmdlXCIsIFtcIkRvbVV0aWxcIl0sIGZ1bmN0aW9uKGFwaSwgbW9kdWxlKSB7XG4gICAgICAgIHZhciBkb20gPSBhcGkuZG9tO1xuICAgICAgICB2YXIgdXRpbCA9IGFwaS51dGlsO1xuICAgICAgICB2YXIgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb247XG4gICAgICAgIHZhciBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uO1xuXG4gICAgICAgIHZhciBpc0NoYXJhY3RlckRhdGFOb2RlID0gZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGU7XG4gICAgICAgIHZhciBnZXROb2RlSW5kZXggPSBkb20uZ2V0Tm9kZUluZGV4O1xuICAgICAgICB2YXIgaXNPcklzQW5jZXN0b3JPZiA9IGRvbS5pc09ySXNBbmNlc3Rvck9mO1xuICAgICAgICB2YXIgZ2V0RG9jdW1lbnQgPSBkb20uZ2V0RG9jdW1lbnQ7XG4gICAgICAgIHZhciBjb21wYXJlUG9pbnRzID0gZG9tLmNvbXBhcmVQb2ludHM7XG4gICAgICAgIHZhciBzcGxpdERhdGFOb2RlID0gZG9tLnNwbGl0RGF0YU5vZGU7XG4gICAgICAgIHZhciBnZXRDbG9zZXN0QW5jZXN0b3JJbiA9IGRvbS5nZXRDbG9zZXN0QW5jZXN0b3JJbjtcbiAgICAgICAgdmFyIGdldE5vZGVMZW5ndGggPSBkb20uZ2V0Tm9kZUxlbmd0aDtcbiAgICAgICAgdmFyIGFycmF5Q29udGFpbnMgPSBkb20uYXJyYXlDb250YWlucztcbiAgICAgICAgdmFyIGdldFJvb3RDb250YWluZXIgPSBkb20uZ2V0Um9vdENvbnRhaW5lcjtcbiAgICAgICAgdmFyIGNyYXNoeVRleHROb2RlcyA9IGFwaS5mZWF0dXJlcy5jcmFzaHlUZXh0Tm9kZXM7XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uc1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKG5vZGUsIHJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5vZGUubm9kZVR5cGUgIT0gMykgJiZcbiAgICAgICAgICAgICAgICAgICAoaXNPcklzQW5jZXN0b3JPZihub2RlLCByYW5nZS5zdGFydENvbnRhaW5lcikgfHwgaXNPcklzQW5jZXN0b3JPZihub2RlLCByYW5nZS5lbmRDb250YWluZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJhbmdlRG9jdW1lbnQocmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5kb2N1bWVudCB8fCBnZXREb2N1bWVudChyYW5nZS5zdGFydENvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRCb3VuZGFyeUJlZm9yZU5vZGUobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihub2RlLnBhcmVudE5vZGUsIGdldE5vZGVJbmRleChub2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRCb3VuZGFyeUFmdGVyTm9kZShub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbVBvc2l0aW9uKG5vZGUucGFyZW50Tm9kZSwgZ2V0Tm9kZUluZGV4KG5vZGUpICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCBuLCBvKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlSW5zZXJ0ZWQgPSBub2RlLm5vZGVUeXBlID09IDExID8gbm9kZS5maXJzdENoaWxkIDogbm9kZTtcbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKG4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gPT0gbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmluc2VydEFmdGVyKG5vZGUsIG4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbyA9PSAwID8gbiA6IHNwbGl0RGF0YU5vZGUobiwgbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobyA+PSBuLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbi5pbnNlcnRCZWZvcmUobm9kZSwgbi5jaGlsZE5vZGVzW29dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaXJzdE5vZGVJbnNlcnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmdlc0ludGVyc2VjdChyYW5nZUEsIHJhbmdlQiwgdG91Y2hpbmdJc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZChyYW5nZUEpO1xuICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZChyYW5nZUIpO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UmFuZ2VEb2N1bWVudChyYW5nZUIpICE9IGdldFJhbmdlRG9jdW1lbnQocmFuZ2VBKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJXUk9OR19ET0NVTUVOVF9FUlJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSBjb21wYXJlUG9pbnRzKHJhbmdlQS5zdGFydENvbnRhaW5lciwgcmFuZ2VBLnN0YXJ0T2Zmc2V0LCByYW5nZUIuZW5kQ29udGFpbmVyLCByYW5nZUIuZW5kT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBlbmRDb21wYXJpc29uID0gY29tcGFyZVBvaW50cyhyYW5nZUEuZW5kQ29udGFpbmVyLCByYW5nZUEuZW5kT2Zmc2V0LCByYW5nZUIuc3RhcnRDb250YWluZXIsIHJhbmdlQi5zdGFydE9mZnNldCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nID8gc3RhcnRDb21wYXJpc29uIDw9IDAgJiYgZW5kQ29tcGFyaXNvbiA+PSAwIDogc3RhcnRDb21wYXJpc29uIDwgMCAmJiBlbmRDb21wYXJpc29uID4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsb25lU3VidHJlZShpdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxseVNlbGVjdGVkO1xuICAgICAgICAgICAgZm9yICh2YXIgbm9kZSwgZnJhZyA9IGdldFJhbmdlRG9jdW1lbnQoaXRlcmF0b3IucmFuZ2UpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3ViSXRlcmF0b3I7IG5vZGUgPSBpdGVyYXRvci5uZXh0KCk7ICkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxseVNlbGVjdGVkID0gaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jbG9uZU5vZGUoIXBhcnRpYWxseVNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydGlhbGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjbG9uZVN1YnRyZWUoc3ViSXRlcmF0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViSXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMTApIHsgLy8gRG9jdW1lbnRUeXBlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVTdWJ0cmVlKHJhbmdlSXRlcmF0b3IsIGZ1bmMsIGl0ZXJhdG9yU3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBpdCwgbjtcbiAgICAgICAgICAgIGl0ZXJhdG9yU3RhdGUgPSBpdGVyYXRvclN0YXRlIHx8IHsgc3RvcDogZmFsc2UgfTtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGUsIHN1YlJhbmdlSXRlcmF0b3I7IG5vZGUgPSByYW5nZUl0ZXJhdG9yLm5leHQoKTsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlSXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuYyhub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yU3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQgYnkgdGhlIFJhbmdlLCBzbyB3ZSBjYW4gdXNlIGEgbmV3IFJhbmdlSXRlcmF0b3Igb24gdGhlIHBvcnRpb24gb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBub2RlIHNlbGVjdGVkIGJ5IHRoZSBSYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlJhbmdlSXRlcmF0b3IgPSByYW5nZUl0ZXJhdG9yLmdldFN1YnRyZWVJdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZVN1YnRyZWUoc3ViUmFuZ2VJdGVyYXRvciwgZnVuYywgaXRlcmF0b3JTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZUl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yU3RhdGUuc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBub2RlIGlzIHNlbGVjdGVkLCBzbyB3ZSBjYW4gdXNlIGVmZmljaWVudCBET00gaXRlcmF0aW9uIHRvIGl0ZXJhdGUgb3ZlciB0aGUgbm9kZSBhbmQgaXRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc2NlbmRhbnRzXG4gICAgICAgICAgICAgICAgICAgIGl0ID0gZG9tLmNyZWF0ZUl0ZXJhdG9yKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChuID0gaXQubmV4dCgpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jKG4pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yU3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlU3VidHJlZShpdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIHN1Ykl0ZXJhdG9yO1xuICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5pc1BhcnRpYWxseVNlbGVjdGVkU3VidHJlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Ykl0ZXJhdG9yID0gaXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVN1YnRyZWUoc3ViSXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzdWJJdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0U3VidHJlZShpdGVyYXRvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgbm9kZSwgZnJhZyA9IGdldFJhbmdlRG9jdW1lbnQoaXRlcmF0b3IucmFuZ2UpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3ViSXRlcmF0b3I7IG5vZGUgPSBpdGVyYXRvci5uZXh0KCk7ICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChleHRyYWN0U3VidHJlZShzdWJJdGVyYXRvcikpO1xuICAgICAgICAgICAgICAgICAgICBzdWJJdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMTApIHsgLy8gRG9jdW1lbnRUeXBlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5vZGVzSW5SYW5nZShyYW5nZSwgbm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJOb2RlVHlwZXMgPSAhIShub2RlVHlwZXMgJiYgbm9kZVR5cGVzLmxlbmd0aCksIHJlZ2V4O1xuICAgICAgICAgICAgdmFyIGZpbHRlckV4aXN0cyA9ICEhZmlsdGVyO1xuICAgICAgICAgICAgaWYgKGZpbHRlck5vZGVUeXBlcykge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBub2RlVHlwZXMuam9pbihcInxcIikgKyBcIikkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGl0ZXJhdGVTdWJ0cmVlKG5ldyBSYW5nZUl0ZXJhdG9yKHJhbmdlLCBmYWxzZSksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyTm9kZVR5cGVzICYmICFyZWdleC50ZXN0KG5vZGUubm9kZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckV4aXN0cyAmJiAhZmlsdGVyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBhIGJvdW5kYXJ5IGNvbnRhaW5lciBpZiBpdCBpcyBhIGNoYXJhY3RlciBkYXRhIG5vZGUgYW5kIHRoZSByYW5nZSBkb2VzIG5vdCBjb250YWluIGFueVxuICAgICAgICAgICAgICAgIC8vIG9mIGl0cyBjaGFyYWN0ZXIgZGF0YS4gU2VlIGlzc3VlIDE5MC5cbiAgICAgICAgICAgICAgICB2YXIgc2MgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBzYyAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKHNjKSAmJiByYW5nZS5zdGFydE9mZnNldCA9PSBzYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlYyA9IHJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBlYyAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKGVjKSAmJiByYW5nZS5lbmRPZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zcGVjdChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSAodHlwZW9mIHJhbmdlLmdldE5hbWUgPT0gXCJ1bmRlZmluZWRcIikgPyBcIlJhbmdlXCIgOiByYW5nZS5nZXROYW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBuYW1lICsgXCIoXCIgKyBkb20uaW5zcGVjdE5vZGUocmFuZ2Uuc3RhcnRDb250YWluZXIpICsgXCI6XCIgKyByYW5nZS5zdGFydE9mZnNldCArIFwiLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIGRvbS5pbnNwZWN0Tm9kZShyYW5nZS5lbmRDb250YWluZXIpICsgXCI6XCIgKyByYW5nZS5lbmRPZmZzZXQgKyBcIildXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIC8vIFJhbmdlSXRlcmF0b3IgY29kZSBwYXJ0aWFsbHkgYm9ycm93cyBmcm9tIElFUmFuZ2UgYnkgVGltIFJ5YW4gKGh0dHA6Ly9naXRodWIuY29tL3RpbWNhbWVyb25yeWFuL0lFUmFuZ2UpXG5cbiAgICAgICAgZnVuY3Rpb24gUmFuZ2VJdGVyYXRvcihyYW5nZSwgY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2Rlcykge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgdGhpcy5jbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzID0gY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2RlcztcblxuXG4gICAgICAgICAgICBpZiAoIXJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2MgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB0aGlzLnNvID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lYyA9IHJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB0aGlzLmVvID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zYyA9PT0gdGhpcy5lYyAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTaW5nbGVDaGFyYWN0ZXJEYXRhTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fbGFzdCA9IHRoaXMuX25leHQgPSB0aGlzLnNjO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fbmV4dCA9ICh0aGlzLnNjID09PSByb290ICYmICFpc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc2MpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjLmNoaWxkTm9kZXNbdGhpcy5zb10gOiBnZXRDbG9zZXN0QW5jZXN0b3JJbih0aGlzLnNjLCByb290LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdCA9ICh0aGlzLmVjID09PSByb290ICYmICFpc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuZWMpKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVjLmNoaWxkTm9kZXNbdGhpcy5lbyAtIDFdIDogZ2V0Q2xvc2VzdEFuY2VzdG9ySW4odGhpcy5lYywgcm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmFuZ2VJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBfY3VycmVudDogbnVsbCxcbiAgICAgICAgICAgIF9uZXh0OiBudWxsLFxuICAgICAgICAgICAgX2ZpcnN0OiBudWxsLFxuICAgICAgICAgICAgX2xhc3Q6IG51bGwsXG4gICAgICAgICAgICBpc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlOiBmYWxzZSxcblxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHQgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhhc05leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX25leHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgbm9kZVxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dCA9IChjdXJyZW50ICE9PSB0aGlzLl9sYXN0KSA/IGN1cnJlbnQubmV4dFNpYmxpbmcgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBwYXJ0aWFsbHkgc2VsZWN0ZWQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShjdXJyZW50KSAmJiB0aGlzLmNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmNsb25lTm9kZSh0cnVlKSkuZGVsZXRlRGF0YSh0aGlzLmVvLCBjdXJyZW50Lmxlbmd0aCAtIHRoaXMuZW8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgPT09IHRoaXMuc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuY2xvbmVOb2RlKHRydWUpKS5kZWxldGVEYXRhKDAsIHRoaXMuc28pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudCwgc3RhcnQsIGVuZDtcblxuICAgICAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckRhdGFOb2RlKGN1cnJlbnQpICYmIChjdXJyZW50ID09PSB0aGlzLnNjIHx8IGN1cnJlbnQgPT09IHRoaXMuZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gKGN1cnJlbnQgPT09IHRoaXMuc2MpID8gdGhpcy5zbyA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IChjdXJyZW50ID09PSB0aGlzLmVjKSA/IHRoaXMuZW8gOiBjdXJyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICE9IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kZWxldGVEYXRhKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWRcbiAgICAgICAgICAgIGlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGN1cnJlbnQsIHRoaXMucmFuZ2UpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0U3VidHJlZUl0ZXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViUmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVDaGFyYWN0ZXJEYXRhTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZSA9IHRoaXMucmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViUmFuZ2UgPSBuZXcgUmFuZ2UoZ2V0UmFuZ2VEb2N1bWVudCh0aGlzLnJhbmdlKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gY3VycmVudCwgc3RhcnRPZmZzZXQgPSAwLCBlbmRDb250YWluZXIgPSBjdXJyZW50LCBlbmRPZmZzZXQgPSBnZXROb2RlTGVuZ3RoKGN1cnJlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09ySXNBbmNlc3Rvck9mKGN1cnJlbnQsIHRoaXMuc2MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHRoaXMuc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IHRoaXMuc287XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT3JJc0FuY2VzdG9yT2YoY3VycmVudCwgdGhpcy5lYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IHRoaXMuZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSB0aGlzLmVvO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQm91bmRhcmllcyhzdWJSYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VJdGVyYXRvcihzdWJSYW5nZSwgdGhpcy5jbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0ID0gdGhpcy5fZmlyc3QgPSB0aGlzLl9sYXN0ID0gdGhpcy5zYyA9IHRoaXMuc28gPSB0aGlzLmVjID0gdGhpcy5lbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICB2YXIgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOCwgMTBdO1xuICAgICAgICB2YXIgcm9vdENvbnRhaW5lck5vZGVUeXBlcyA9IFsyLCA5LCAxMV07XG4gICAgICAgIHZhciByZWFkb25seU5vZGVUeXBlcyA9IFs1LCA2LCAxMCwgMTJdO1xuICAgICAgICB2YXIgaW5zZXJ0YWJsZU5vZGVUeXBlcyA9IFsxLCAzLCA0LCA1LCA3LCA4LCAxMCwgMTFdO1xuICAgICAgICB2YXIgc3Vycm91bmROb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOF07XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQW5jZXN0b3JGaW5kZXIobm9kZVR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgc2VsZklzQW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCwgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbi5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Q29udGFpbnMobm9kZVR5cGVzLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKCBbOSwgMTFdICk7XG4gICAgICAgIHZhciBnZXRSZWFkb25seUFuY2VzdG9yID0gY3JlYXRlQW5jZXN0b3JGaW5kZXIocmVhZG9ubHlOb2RlVHlwZXMpO1xuICAgICAgICB2YXIgZ2V0RG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3IgPSBjcmVhdGVBbmNlc3RvckZpbmRlciggWzYsIDEwLCAxMl0gKTtcblxuICAgICAgICBmdW5jdGlvbiBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGFsbG93U2VsZikge1xuICAgICAgICAgICAgaWYgKGdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGFsbG93U2VsZikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBpbnZhbGlkVHlwZXMpIHtcbiAgICAgICAgICAgIGlmICghYXJyYXlDb250YWlucyhpbnZhbGlkVHlwZXMsIG5vZGUubm9kZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfTk9ERV9UWVBFX0VSUlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gKGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkgPyBub2RlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOREVYX1NJWkVfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudChub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIGlmIChnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTEsIHRydWUpICE9PSBnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTIsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIldST05HX0RPQ1VNRU5UX0VSUlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydE5vZGVOb3RSZWFkT25seShub2RlKSB7XG4gICAgICAgICAgICBpZiAoZ2V0UmVhZG9ubHlBbmNlc3Rvcihub2RlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhc3NlcnROb2RlKG5vZGUsIGNvZGVOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGNvZGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzT3JwaGFuKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoY3Jhc2h5VGV4dE5vZGVzICYmIGRvbS5pc0Jyb2tlbk5vZGUobm9kZSkpIHx8XG4gICAgICAgICAgICAgICAgIWFycmF5Q29udGFpbnMocm9vdENvbnRhaW5lck5vZGVUeXBlcywgbm9kZS5ub2RlVHlwZSkgJiYgIWdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lcihub2RlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0IDw9IChpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpID8gbm9kZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzUmFuZ2VWYWxpZChyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuICghIXJhbmdlLnN0YXJ0Q29udGFpbmVyICYmICEhcmFuZ2UuZW5kQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc09ycGhhbihyYW5nZS5zdGFydENvbnRhaW5lcikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzT3JwaGFuKHJhbmdlLmVuZENvbnRhaW5lcikgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZE9mZnNldChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWRPZmZzZXQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydFJhbmdlVmFsaWQocmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICghaXNSYW5nZVZhbGlkKHJhbmdlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIGVycm9yOiBSYW5nZSBpcyBubyBsb25nZXIgdmFsaWQgYWZ0ZXIgRE9NIG11dGF0aW9uIChcIiArIHJhbmdlLmluc3BlY3QoKSArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgLy8gVGVzdCB0aGUgYnJvd3NlcidzIGlubmVySFRNTCBzdXBwb3J0IHRvIGRlY2lkZSBob3cgdG8gaW1wbGVtZW50IGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudFxuICAgICAgICB2YXIgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgdmFyIGh0bWxQYXJzaW5nQ29uZm9ybXMgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0eWxlRWwuaW5uZXJIVE1MID0gXCI8Yj54PC9iPlwiO1xuICAgICAgICAgICAgaHRtbFBhcnNpbmdDb25mb3JtcyA9IChzdHlsZUVsLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMyk7IC8vIE9wZXJhIGluY29ycmVjdGx5IGNyZWF0ZXMgYW4gZWxlbWVudCBub2RlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElFIDYgYW5kIDcgdGhyb3dcbiAgICAgICAgfVxuXG4gICAgICAgIGFwaS5mZWF0dXJlcy5odG1sUGFyc2luZ0NvbmZvcm1zID0gaHRtbFBhcnNpbmdDb25mb3JtcztcblxuICAgICAgICB2YXIgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50ID0gaHRtbFBhcnNpbmdDb25mb3JtcyA/XG5cbiAgICAgICAgICAgIC8vIEltcGxlbWVudGF0aW9uIGFzIHBlciBIVE1MIHBhcnNpbmcgc3BlYywgdHJ1c3RpbmcgaW4gdGhlIGJyb3dzZXIncyBpbXBsZW1lbnRhdGlvbiBvZiBpbm5lckhUTUwuIFNlZVxuICAgICAgICAgICAgLy8gZGlzY3Vzc2lvbiBhbmQgYmFzZSBjb2RlIGZvciB0aGlzIGltcGxlbWVudGF0aW9uIGF0IGlzc3VlIDY3LlxuICAgICAgICAgICAgLy8gU3BlYzogaHR0cDovL2h0bWw1Lm9yZy9zcGVjcy9kb20tcGFyc2luZy5odG1sI2V4dGVuc2lvbnMtdG8tdGhlLXJhbmdlLWludGVyZmFjZVxuICAgICAgICAgICAgLy8gVGhhbmtzIHRvIEFsZWtzIFdpbGxpYW1zLlxuICAgICAgICAgICAgZnVuY3Rpb24oZnJhZ21lbnRTdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBcIkxldCBub2RlIHRoZSBjb250ZXh0IG9iamVjdCdzIHN0YXJ0J3Mgbm9kZS5cIlxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQobm9kZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBcIklmIHRoZSBjb250ZXh0IG9iamVjdCdzIHN0YXJ0J3Mgbm9kZSBpcyBudWxsLCByYWlzZSBhbiBJTlZBTElEX1NUQVRFX0VSUlxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXCJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFwiTGV0IGVsZW1lbnQgYmUgYXMgZm9sbG93cywgZGVwZW5kaW5nIG9uIG5vZGUncyBpbnRlcmZhY2U6XCJcbiAgICAgICAgICAgICAgICAvLyBEb2N1bWVudCwgRG9jdW1lbnQgRnJhZ21lbnQ6IG51bGxcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gXCJFbGVtZW50OiBub2RlXCJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gbm9kZTtcblxuICAgICAgICAgICAgICAgIC8vIFwiVGV4dCwgQ29tbWVudDogbm9kZSdzIHBhcmVudEVsZW1lbnRcIlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGRvbS5wYXJlbnRFbGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFwiSWYgZWl0aGVyIGVsZW1lbnQgaXMgbnVsbCBvciBlbGVtZW50J3Mgb3duZXJEb2N1bWVudCBpcyBhbiBIVE1MIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLy8gYW5kIGVsZW1lbnQncyBsb2NhbCBuYW1lIGlzIFwiaHRtbFwiIGFuZCBlbGVtZW50J3MgbmFtZXNwYWNlIGlzIHRoZSBIVE1MXG4gICAgICAgICAgICAgICAgLy8gbmFtZXNwYWNlXCJcbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IG51bGwgfHwgKFxuICAgICAgICAgICAgICAgICAgICBlbC5ub2RlTmFtZSA9PSBcIkhUTUxcIiAmJlxuICAgICAgICAgICAgICAgICAgICBkb20uaXNIdG1sTmFtZXNwYWNlKGdldERvY3VtZW50KGVsKS5kb2N1bWVudEVsZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5pc0h0bWxOYW1lc3BhY2UoZWwpXG4gICAgICAgICAgICAgICAgKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gXCJsZXQgZWxlbWVudCBiZSBhIG5ldyBFbGVtZW50IHdpdGggXCJib2R5XCIgYXMgaXRzIGxvY2FsIG5hbWUgYW5kIHRoZSBIVE1MXG4gICAgICAgICAgICAgICAgLy8gbmFtZXNwYWNlIGFzIGl0cyBuYW1lc3BhY2UuXCJcIlxuICAgICAgICAgICAgICAgICAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gXCJJZiB0aGUgbm9kZSdzIGRvY3VtZW50IGlzIGFuIEhUTUwgZG9jdW1lbnQ6IEludm9rZSB0aGUgSFRNTCBmcmFnbWVudCBwYXJzaW5nIGFsZ29yaXRobS5cIlxuICAgICAgICAgICAgICAgIC8vIFwiSWYgdGhlIG5vZGUncyBkb2N1bWVudCBpcyBhbiBYTUwgZG9jdW1lbnQ6IEludm9rZSB0aGUgWE1MIGZyYWdtZW50IHBhcnNpbmcgYWxnb3JpdGhtLlwiXG4gICAgICAgICAgICAgICAgLy8gXCJJbiBlaXRoZXIgY2FzZSwgdGhlIGFsZ29yaXRobSBtdXN0IGJlIGludm9rZWQgd2l0aCBmcmFnbWVudCBhcyB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAvLyBhbmQgZWxlbWVudCBhcyB0aGUgY29udGV4dCBlbGVtZW50LlwiXG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gZnJhZ21lbnRTdHI7XG5cbiAgICAgICAgICAgICAgICAvLyBcIklmIHRoaXMgcmFpc2VzIGFuIGV4Y2VwdGlvbiwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy4gT3RoZXJ3aXNlLCBsZXQgbmV3XG4gICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4gYmUgdGhlIG5vZGVzIHJldHVybmVkLlwiXG5cbiAgICAgICAgICAgICAgICAvLyBcIkxldCBmcmFnbWVudCBiZSBhIG5ldyBEb2N1bWVudEZyYWdtZW50LlwiXG4gICAgICAgICAgICAgICAgLy8gXCJBcHBlbmQgYWxsIG5ldyBjaGlsZHJlbiB0byBmcmFnbWVudC5cIlxuICAgICAgICAgICAgICAgIC8vIFwiUmV0dXJuIGZyYWdtZW50LlwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbS5mcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4oZWwpO1xuICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgaW5uZXJIVE1MIGNhbm5vdCBiZSB0cnVzdGVkLCBzbyBmYWxsIGJhY2sgdG8gYSBzaW1wbGVyLCBub24tY29uZm9ybWFudCBpbXBsZW1lbnRhdGlvbiB0aGF0XG4gICAgICAgICAgICAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiBSYW5neSB1c2VkICh3aXRoIHRoZSBleGNlcHRpb24gb2YgdXNpbmcgYSBib2R5IGVsZW1lbnQgcmF0aGVyIHRoYW4gYSBkaXYpXG4gICAgICAgICAgICBmdW5jdGlvbihmcmFnbWVudFN0cikge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBmcmFnbWVudFN0cjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkb20uZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuKGVsKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gc3BsaXRSYW5nZUJvdW5kYXJpZXMocmFuZ2UsIHBvc2l0aW9uc1RvUHJlc2VydmUpIHtcbiAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQocmFuZ2UpO1xuXG4gICAgICAgICAgICB2YXIgc2MgPSByYW5nZS5zdGFydENvbnRhaW5lciwgc28gPSByYW5nZS5zdGFydE9mZnNldCwgZWMgPSByYW5nZS5lbmRDb250YWluZXIsIGVvID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHN0YXJ0RW5kU2FtZSA9IChzYyA9PT0gZWMpO1xuXG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShlYykgJiYgZW8gPiAwICYmIGVvIDwgZWMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3BsaXREYXRhTm9kZShlYywgZW8sIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShzYykgJiYgc28gPiAwICYmIHNvIDwgc2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2MgPSBzcGxpdERhdGFOb2RlKHNjLCBzbywgcG9zaXRpb25zVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RW5kU2FtZSkge1xuICAgICAgICAgICAgICAgICAgICBlbyAtPSBzbztcbiAgICAgICAgICAgICAgICAgICAgZWMgPSBzYztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVjID09IHNjLnBhcmVudE5vZGUgJiYgZW8gPj0gZ2V0Tm9kZUluZGV4KHNjKSkge1xuICAgICAgICAgICAgICAgICAgICBlbysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEFuZEVuZChzYywgc28sIGVjLCBlbyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHJhbmdlVG9IdG1sKHJhbmdlKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHJhbmdlKTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5wYXJlbnROb2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoIHJhbmdlLmNsb25lQ29udGVudHMoKSApO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgIH1cblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIHZhciByYW5nZVByb3BlcnRpZXMgPSBbXCJzdGFydENvbnRhaW5lclwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwiZW5kQ29udGFpbmVyXCIsIFwiZW5kT2Zmc2V0XCIsIFwiY29sbGFwc2VkXCIsXG4gICAgICAgICAgICBcImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyXCJdO1xuXG4gICAgICAgIHZhciBzMnMgPSAwLCBzMmUgPSAxLCBlMmUgPSAyLCBlMnMgPSAzO1xuICAgICAgICB2YXIgbl9iID0gMCwgbl9hID0gMSwgbl9iX2EgPSAyLCBuX2kgPSAzO1xuXG4gICAgICAgIHV0aWwuZXh0ZW5kKGFwaS5yYW5nZVByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29tcGFyZUJvdW5kYXJ5UG9pbnRzOiBmdW5jdGlvbihob3csIHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KHRoaXMuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgIHZhciBub2RlQSwgb2Zmc2V0QSwgbm9kZUIsIG9mZnNldEI7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeEEgPSAoaG93ID09IGUycyB8fCBob3cgPT0gczJzKSA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeEIgPSAoaG93ID09IHMyZSB8fCBob3cgPT0gczJzKSA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgbm9kZUEgPSB0aGlzW3ByZWZpeEEgKyBcIkNvbnRhaW5lclwiXTtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gdGhpc1twcmVmaXhBICsgXCJPZmZzZXRcIl07XG4gICAgICAgICAgICAgICAgbm9kZUIgPSByYW5nZVtwcmVmaXhCICsgXCJDb250YWluZXJcIl07XG4gICAgICAgICAgICAgICAgb2Zmc2V0QiA9IHJhbmdlW3ByZWZpeEIgKyBcIk9mZnNldFwiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhub2RlQSwgb2Zmc2V0QSwgbm9kZUIsIG9mZnNldEIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBpbnNlcnRhYmxlTm9kZVR5cGVzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnROb2RlTm90UmVhZE9ubHkodGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPcklzQW5jZXN0b3JPZihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE5vIGNoZWNrIGZvciB3aGV0aGVyIHRoZSBjb250YWluZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSBSYW5nZSBpcyBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhbGxvd1xuICAgICAgICAgICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSB0eXBlIG9mIG5vZGU6IHRoZSBicm93c2VyJ3MgRE9NIGltcGxlbWVudGF0aW9uIHNob3VsZCBkbyB0aGlzIGZvciB1cyB3aGVuIHdlIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAvLyB0byBhZGQgdGhlIG5vZGVcblxuICAgICAgICAgICAgICAgIHZhciBmaXJzdE5vZGVJbnNlcnRlZCA9IGluc2VydE5vZGVBdFBvc2l0aW9uKG5vZGUsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnRCZWZvcmUoZmlyc3ROb2RlSW5zZXJ0ZWQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xvbmVDb250ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBjbG9uZSwgZnJhZztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhbmdlRG9jdW1lbnQodGhpcykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVuZENvbnRhaW5lciAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHRoaXMuc3RhcnRDb250YWluZXIuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuZGF0YSA9IGNsb25lLmRhdGEuc2xpY2UodGhpcy5zdGFydE9mZnNldCwgdGhpcy5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGdldFJhbmdlRG9jdW1lbnQodGhpcykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBjbG9uZVN1YnRyZWUoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhblN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLmVuZENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudHMgY2FuIGJlIHN1cnJvdW5kZWQuIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB3aGV0aGVyIHRoZSByYW5nZSBwYXJ0aWFsbHkgc2VsZWN0c1xuICAgICAgICAgICAgICAgIC8vIG5vIG5vbi10ZXh0IG5vZGVzLlxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyaWVzSW52YWxpZCA9IChpdGVyYXRvci5fZmlyc3QgJiYgKGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpKSk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFib3VuZGFyaWVzSW52YWxpZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIHN1cnJvdW5kTm9kZVR5cGVzKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYW5TdXJyb3VuZENvbnRlbnRzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmV4dHJhY3RDb250ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNoaWxkcmVuIG9mIHRoZSBub2RlXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBub2RlIGFuZCBhZGQgdGhlIGV4dHJhY3RlZCBjb250ZW50c1xuICAgICAgICAgICAgICAgIGluc2VydE5vZGVBdFBvc2l0aW9uKG5vZGUsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbG9uZVJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShnZXRSYW5nZURvY3VtZW50KHRoaXMpKTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsIHByb3A7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wID0gcmFuZ2VQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByYW5nZVtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAgICAgaWYgKHNjID09PSB0aGlzLmVuZENvbnRhaW5lciAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKHNjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNjLm5vZGVUeXBlID09IDMgfHwgc2Mubm9kZVR5cGUgPT0gNCkgPyBzYy5kYXRhLnNsaWNlKHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuZW5kT2Zmc2V0KSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRQYXJ0cyA9IFtdLCBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU3VidHJlZShpdGVyYXRvciwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXB0IG9ubHkgdGV4dCBvciBDREFUQSBub2Rlcywgbm90IGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzIHx8IG5vZGUubm9kZVR5cGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQYXJ0cy5wdXNoKG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRQYXJ0cy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRoZSBtZXRob2RzIGJlbG93IGFyZSBhbGwgbm9uLXN0YW5kYXJkLiBUaGUgZm9sbG93aW5nIGJhdGNoIHdlcmUgaW50cm9kdWNlZCBieSBNb3ppbGxhIGJ1dCBoYXZlIHNpbmNlXG4gICAgICAgICAgICAvLyBiZWVuIHJlbW92ZWQgZnJvbSBNb3ppbGxhLlxuXG4gICAgICAgICAgICBjb21wYXJlTm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBnZXROb2RlSW5kZXgobm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiTk9UX0ZPVU5EX0VSUlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gdGhpcy5jb21wYXJlUG9pbnQocGFyZW50LCBub2RlSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb21wYXJpc29uID0gdGhpcy5jb21wYXJlUG9pbnQocGFyZW50LCBub2RlSW5kZXggKyAxKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGFydENvbXBhcmlzb24gPCAwKSB7IC8vIE5vZGUgc3RhcnRzIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVuZENvbXBhcmlzb24gPiAwKSA/IG5fYl9hIDogbl9iO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZW5kQ29tcGFyaXNvbiA+IDApID8gbl9hIDogbl9pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbXBhcmVQb2ludDogZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnROb2RlKG5vZGUsIFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50OiBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQsXG5cbiAgICAgICAgICAgIHRvSHRtbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9IdG1sKHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gdG91Y2hpbmdJc0ludGVyc2VjdGluZyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBtZXRob2QgY29uc2lkZXJzIGEgbm9kZSB0aGF0IGJvcmRlcnMgYSByYW5nZSBpbnRlcnNlY3RzXG4gICAgICAgICAgICAvLyB3aXRoIGl0IChhcyBpbiBXZWJLaXQpIG9yIG5vdCAoYXMgaW4gR2Vja28gcHJlLTEuOSwgYW5kIHRoZSBkZWZhdWx0KVxuICAgICAgICAgICAgaW50ZXJzZWN0c05vZGU6IGZ1bmN0aW9uKG5vZGUsIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vZGUobm9kZSwgXCJOT1RfRk9VTkRfRVJSXCIpO1xuICAgICAgICAgICAgICAgIGlmIChnZXREb2N1bWVudChub2RlKSAhPT0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSwgb2Zmc2V0ID0gZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vZGUocGFyZW50LCBcIk5PVF9GT1VORF9FUlJcIik7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gY29tcGFyZVBvaW50cyhwYXJlbnQsIG9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IGNvbXBhcmVQb2ludHMocGFyZW50LCBvZmZzZXQgKyAxLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nID8gc3RhcnRDb21wYXJpc29uIDw9IDAgJiYgZW5kQ29tcGFyaXNvbiA+PSAwIDogc3RhcnRDb21wYXJpc29uIDwgMCAmJiBlbmRDb21wYXJpc29uID4gMDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzUG9pbnRJblJhbmdlOiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vZGUobm9kZSwgXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudChub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpID49IDApICYmXG4gICAgICAgICAgICAgICAgICAgICAgIChjb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA8PSAwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRoZSBtZXRob2RzIGJlbG93IGFyZSBub24tc3RhbmRhcmQgYW5kIGludmVudGVkIGJ5IG1lLlxuXG4gICAgICAgICAgICAvLyBTaGFyaW5nIGEgYm91bmRhcnkgc3RhcnQtdG8tZW5kIG9yIGVuZC10by1zdGFydCBkb2VzIG5vdCBjb3VudCBhcyBpbnRlcnNlY3Rpb24uXG4gICAgICAgICAgICBpbnRlcnNlY3RzUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlc0ludGVyc2VjdCh0aGlzLCByYW5nZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gU2hhcmluZyBhIGJvdW5kYXJ5IHN0YXJ0LXRvLWVuZCBvciBlbmQtdG8tc3RhcnQgZG9lcyBjb3VudCBhcyBpbnRlcnNlY3Rpb24uXG4gICAgICAgICAgICBpbnRlcnNlY3RzT3JUb3VjaGVzUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlc0ludGVyc2VjdCh0aGlzLCByYW5nZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1JhbmdlKHJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gY29tcGFyZVBvaW50cyh0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0LCByYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IGNvbXBhcmVQb2ludHModGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvblJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydENvbXBhcmlzb24gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZENvbXBhcmlzb24gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uUmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdW5pb246IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c09yVG91Y2hlc1JhbmdlKHJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pb25SYW5nZSA9IHRoaXMuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlvblJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pb25SYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmlvblJhbmdlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJSYW5nZXMgZG8gbm90IGludGVyc2VjdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb250YWluc05vZGU6IGZ1bmN0aW9uKG5vZGUsIGFsbG93UGFydGlhbCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd1BhcnRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c05vZGUobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVOb2RlKG5vZGUpID09IG5faTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb250YWluc05vZGVDb250ZW50czogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQb2ludChub2RlLCAwKSA+PSAwICYmIHRoaXMuY29tcGFyZVBvaW50KG5vZGUsIGdldE5vZGVMZW5ndGgobm9kZSkpIDw9IDA7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb250YWluc1JhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLmludGVyc2VjdGlvbihyYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbiAhPT0gbnVsbCAmJiByYW5nZS5lcXVhbHMoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbnRhaW5zTm9kZVRleHQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgbm9kZVJhbmdlLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHROb2RlcyA9IG5vZGVSYW5nZS5nZXROb2RlcyhbM10pO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlUmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGVzWzBdLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RUZXh0Tm9kZSA9IHRleHROb2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJhbmdlLnNldEVuZChsYXN0VGV4dE5vZGUsIGxhc3RUZXh0Tm9kZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc1JhbmdlKG5vZGVSYW5nZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnNOb2RlQ29udGVudHMobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Tm9kZXM6IGZ1bmN0aW9uKG5vZGVUeXBlcywgZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Tm9kZXNJblJhbmdlKHRoaXMsIG5vZGVUeXBlcywgZmlsdGVyKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldERvY3VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbGxhcHNlQmVmb3JlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb2xsYXBzZUFmdGVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBnZXRCb29rbWFyazogZnVuY3Rpb24oY29udGFpbmVyTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBwcmVTZWxlY3Rpb25SYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lck5vZGUgPSBjb250YWluZXJOb2RlIHx8IGRvbS5nZXRCb2R5KGRvYyk7XG4gICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGNvbnRhaW5lck5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuaW50ZXJzZWN0aW9uKHByZVNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAwLCBlbmQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb25SYW5nZS5zZXRFbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBwcmVTZWxlY3Rpb25SYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyByYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJOb2RlOiBjb250YWluZXJOb2RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vdmVUb0Jvb2ttYXJrOiBmdW5jdGlvbihib29rbWFyaykge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJOb2RlID0gYm9va21hcmsuY29udGFpbmVyTm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXJ0KGNvbnRhaW5lck5vZGUsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVTdGFjayA9IFtjb250YWluZXJOb2RlXSwgbm9kZSwgZm91bmRTdGFydCA9IGZhbHNlLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRDaGFySW5kZXgsIGksIGNoaWxkTm9kZXM7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIXN0b3AgJiYgKG5vZGUgPSBub2RlU3RhY2sucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGFySW5kZXggPSBjaGFySW5kZXggKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFydCAmJiBib29rbWFyay5zdGFydCA+PSBjaGFySW5kZXggJiYgYm9va21hcmsuc3RhcnQgPD0gbmV4dENoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnQobm9kZSwgYm9va21hcmsuc3RhcnQgLSBjaGFySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RhcnQgJiYgYm9va21hcmsuZW5kID49IGNoYXJJbmRleCAmJiBib29rbWFyay5lbmQgPD0gbmV4dENoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kKG5vZGUsIGJvb2ttYXJrLmVuZCAtIGNoYXJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFySW5kZXggPSBuZXh0Q2hhckluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlU3RhY2sucHVzaChjaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkRvbVJhbmdlXCI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJhbmdlLnJhbmdlc0VxdWFsKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1JhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpbnNwZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zcGVjdCh0aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gRE9NNCwgZGV0YWNoKCkgaXMgbm93IGEgbm8tb3AuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzVG9PYmplY3Qob2JqKSB7XG4gICAgICAgICAgICBvYmouU1RBUlRfVE9fU1RBUlQgPSBzMnM7XG4gICAgICAgICAgICBvYmouU1RBUlRfVE9fRU5EID0gczJlO1xuICAgICAgICAgICAgb2JqLkVORF9UT19FTkQgPSBlMmU7XG4gICAgICAgICAgICBvYmouRU5EX1RPX1NUQVJUID0gZTJzO1xuXG4gICAgICAgICAgICBvYmouTk9ERV9CRUZPUkUgPSBuX2I7XG4gICAgICAgICAgICBvYmouTk9ERV9BRlRFUiA9IG5fYTtcbiAgICAgICAgICAgIG9iai5OT0RFX0JFRk9SRV9BTkRfQUZURVIgPSBuX2JfYTtcbiAgICAgICAgICAgIG9iai5OT0RFX0lOU0lERSA9IG5faTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0KGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzVG9PYmplY3QoY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIocmVtb3ZlciwgYm91bmRhcnlVcGRhdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXIsIHNvID0gdGhpcy5zdGFydE9mZnNldCwgcm9vdCA9IHRoaXMuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIFdvcmsgb3V0IHdoZXJlIHRvIHBvc2l0aW9uIHRoZSByYW5nZSBhZnRlciBjb250ZW50IHJlbW92YWxcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSwgYm91bmRhcnk7XG4gICAgICAgICAgICAgICAgaWYgKHNjICE9PSByb290KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBnZXRDbG9zZXN0QW5jZXN0b3JJbihzYywgcm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gYm91bmRhcnkubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgc28gPSBib3VuZGFyeS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgbm9uZSBvZiB0aGUgcmFuZ2UgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICAgICAgaXRlcmF0ZVN1YnRyZWUoaXRlcmF0b3IsIGFzc2VydE5vZGVOb3RSZWFkT25seSk7XG5cbiAgICAgICAgICAgICAgICBpdGVyYXRvci5yZXNldCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjb250ZW50XG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVtb3ZlcihpdGVyYXRvcik7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBzYywgc28pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3RvdHlwZVJhbmdlKGNvbnN0cnVjdG9yLCBib3VuZGFyeVVwZGF0ZXIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihpc0JlZm9yZSwgaXNTdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKGdldFJvb3RDb250YWluZXIobm9kZSksIHJvb3RDb250YWluZXJOb2RlVHlwZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeSA9IChpc0JlZm9yZSA/IGdldEJvdW5kYXJ5QmVmb3JlTm9kZSA6IGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgKGlzU3RhcnQgPyBzZXRSYW5nZVN0YXJ0IDogc2V0UmFuZ2VFbmQpKHRoaXMsIGJvdW5kYXJ5Lm5vZGUsIGJvdW5kYXJ5Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0UmFuZ2VTdGFydChyYW5nZSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVjID0gcmFuZ2UuZW5kQ29udGFpbmVyLCBlbyA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5zdGFydE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcm9vdCBjb250YWluZXJzIG9mIHRoZSByYW5nZSBhbmQgdGhlIG5ldyBib3VuZGFyeSwgYW5kIGFsc28gY2hlY2sgd2hldGhlciB0aGUgbmV3IGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFmdGVyIHRoZSBjdXJyZW50IGVuZC4gSW4gZWl0aGVyIGNhc2UsIGNvbGxhcHNlIHRoZSByYW5nZSB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRSb290Q29udGFpbmVyKG5vZGUpICE9IGdldFJvb3RDb250YWluZXIoZWMpIHx8IGNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCBlYywgZW8pID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVjID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVvID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcihyYW5nZSwgbm9kZSwgb2Zmc2V0LCBlYywgZW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0UmFuZ2VFbmQocmFuZ2UsIG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBzYyA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBzbyA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSByYW5nZS5lbmRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5lbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJvb3QgY29udGFpbmVycyBvZiB0aGUgcmFuZ2UgYW5kIHRoZSBuZXcgYm91bmRhcnksIGFuZCBhbHNvIGNoZWNrIHdoZXRoZXIgdGhlIG5ldyBib3VuZGFyeVxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBhZnRlciB0aGUgY3VycmVudCBlbmQuIEluIGVpdGhlciBjYXNlLCBjb2xsYXBzZSB0aGUgcmFuZ2UgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0Um9vdENvbnRhaW5lcihub2RlKSAhPSBnZXRSb290Q29udGFpbmVyKHNjKSB8fCBjb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgc2MsIHNvKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc28gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHJhbmdlLCBzYywgc28sIG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdXAgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gYXBpLnJhbmdlUHJvdG90eXBlO1xuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICAgICAgICAgICAgdXRpbC5leHRlbmQoY29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgc2V0U3RhcnQ6IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFJhbmdlU3RhcnQodGhpcywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0RW5kOiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRSYW5nZUVuZCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gc2V0IGEgcmFuZ2UncyBzdGFydCBhbmQgZW5kIGJvdW5kYXJpZXMuIE92ZXJsb2FkZWQgYXMgZm9sbG93czpcbiAgICAgICAgICAgICAgICAgKiAtIFR3byBwYXJhbWV0ZXJzIChub2RlLCBvZmZzZXQpIGNyZWF0ZXMgYSBjb2xsYXBzZWQgcmFuZ2UgYXQgdGhhdCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAqIC0gVGhyZWUgcGFyYW1ldGVycyAobm9kZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkgY3JlYXRlcyBhIHJhbmdlIGNvbnRhaW5lZCB3aXRoIG5vZGUgc3RhcnRpbmcgYXRcbiAgICAgICAgICAgICAgICAgKiAgIHN0YXJ0T2Zmc2V0IGFuZCBlbmRpbmcgYXQgZW5kT2Zmc2V0XG4gICAgICAgICAgICAgICAgICogLSBGb3VyIHBhcmFtZXRlcnMgKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCkgY3JlYXRlcyBhIHJhbmdlIHN0YXJ0aW5nIGF0IHN0YXJ0T2Zmc2V0IGluXG4gICAgICAgICAgICAgICAgICogICBzdGFydE5vZGUgYW5kIGVuZGluZyBhdCBlbmRPZmZzZXQgaW4gZW5kTm9kZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNldFN0YXJ0QW5kRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYyA9IGFyZ3NbMF0sIHNvID0gYXJnc1sxXSwgZWMgPSBzYywgZW8gPSBzbztcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW8gPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjID0gYXJnc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbyA9IGFyZ3NbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBlYywgZW8pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2V0Qm91bmRhcnk6IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCwgaXNTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wic2V0XCIgKyAoaXNTdGFydCA/IFwiU3RhcnRcIiA6IFwiRW5kXCIpXShub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXRTdGFydEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIHRydWUpLFxuICAgICAgICAgICAgICAgIHNldFN0YXJ0QWZ0ZXI6IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihmYWxzZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgc2V0RW5kQmVmb3JlOiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIodHJ1ZSwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIHNldEVuZEFmdGVyOiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoZmFsc2UsIGZhbHNlKSxcblxuICAgICAgICAgICAgICAgIGNvbGxhcHNlOiBmdW5jdGlvbihpc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNlbGVjdE5vZGVDb250ZW50czogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBub2RlLCAwLCBub2RlLCBnZXROb2RlTGVuZ3RoKG5vZGUpKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBiZWZvcmVBZnRlck5vZGVUeXBlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0Qm91bmRhcnlCZWZvcmVOb2RlKG5vZGUpLCBlbmQgPSBnZXRCb3VuZGFyeUFmdGVyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm5vZGUsIGVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBleHRyYWN0Q29udGVudHM6IGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIoZXh0cmFjdFN1YnRyZWUsIGJvdW5kYXJ5VXBkYXRlciksXG5cbiAgICAgICAgICAgICAgICBkZWxldGVDb250ZW50czogY3JlYXRlUmFuZ2VDb250ZW50UmVtb3ZlcihkZWxldGVTdWJ0cmVlLCBib3VuZGFyeVVwZGF0ZXIpLFxuXG4gICAgICAgICAgICAgICAgY2FuU3Vycm91bmRDb250ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuZW5kQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudHMgY2FuIGJlIHN1cnJvdW5kZWQuIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB3aGV0aGVyIHRoZSByYW5nZSBwYXJ0aWFsbHkgc2VsZWN0c1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBub24tdGV4dCBub2Rlcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFJhbmdlSXRlcmF0b3IodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGFyaWVzSW52YWxpZCA9IChpdGVyYXRvci5fZmlyc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2ZpcnN0LCB0aGlzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpdGVyYXRvci5fbGFzdCAmJiBpc05vblRleHRQYXJ0aWFsbHlTZWxlY3RlZChpdGVyYXRvci5fbGFzdCwgdGhpcykpKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYm91bmRhcmllc0ludmFsaWQ7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNwbGl0Qm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0UmFuZ2VCb3VuZGFyaWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzcGxpdEJvdW5kYXJpZXNQcmVzZXJ2aW5nUG9zaXRpb25zOiBmdW5jdGlvbihwb3NpdGlvbnNUb1ByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0UmFuZ2VCb3VuZGFyaWVzKHRoaXMsIHBvc2l0aW9uc1RvUHJlc2VydmUpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBub3JtYWxpemVCb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2MgPSB0aGlzLnN0YXJ0Q29udGFpbmVyLCBzbyA9IHRoaXMuc3RhcnRPZmZzZXQsIGVjID0gdGhpcy5lbmRDb250YWluZXIsIGVvID0gdGhpcy5lbmRPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lcmdlRm9yd2FyZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgPT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbyA9IG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kRGF0YShzaWJsaW5nLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2VCYWNrd2FyZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLm5vZGVUeXBlID09IG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVMZW5ndGggPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbyA9IHNpYmxpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5zZXJ0RGF0YSgwLCBzaWJsaW5nLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MgPT0gZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW8gKz0gc287XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjID0gc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlYyA9PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGdldE5vZGVJbmRleChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVvID09IG5vZGVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWMgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW8gPSBub2RlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVvID4gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlby0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVTdGFydCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyRGF0YU5vZGUoZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWMubGVuZ3RoID09IGVvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VGb3J3YXJkKGVjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGVjLmNoaWxkTm9kZXNbZW8gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kTm9kZSAmJiBpc0NoYXJhY3RlckRhdGFOb2RlKGVuZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlRm9yd2FyZChlbmROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVTdGFydCA9ICF0aGlzLmNvbGxhcHNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyRGF0YU5vZGUoc2MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VCYWNrd2FyZChzYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc28gPCBzYy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gc2MuY2hpbGROb2Rlc1tzb107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydE5vZGUgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUJhY2t3YXJkKHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYyA9IGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgc28gPSBlbztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzYywgc28sIGVjLCBlbyk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGNvbGxhcHNlVG9Qb2ludDogZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnRBbmRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29weUNvbXBhcmlzb25Db25zdGFudHMoY29uc3RydWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBVcGRhdGVzIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIGFuZCBjb2xsYXBzZWQgYWZ0ZXIgYm91bmRhcnkgY2hhbmdlXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yKHJhbmdlKSB7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZWQgPSAocmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IHJhbmdlLmVuZENvbnRhaW5lciAmJiByYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29sbGFwc2VkID9cbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydENvbnRhaW5lciA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUJvdW5kYXJpZXMocmFuZ2UsIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpIHtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICByYW5nZS5zdGFydE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgcmFuZ2UuZW5kT2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgICAgICAgICAgcmFuZ2UuZG9jdW1lbnQgPSBkb20uZ2V0RG9jdW1lbnQoc3RhcnRDb250YWluZXIpO1xuXG4gICAgICAgICAgICB1cGRhdGVDb2xsYXBzZWRBbmRDb21tb25BbmNlc3RvcihyYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBSYW5nZShkb2MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBkb2M7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29udGFpbmVyID0gZG9jO1xuICAgICAgICAgICAgdGhpcy5lbmRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvYztcbiAgICAgICAgICAgIHVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3JlYXRlUHJvdG90eXBlUmFuZ2UoUmFuZ2UsIHVwZGF0ZUJvdW5kYXJpZXMpO1xuXG4gICAgICAgIHV0aWwuZXh0ZW5kKFJhbmdlLCB7XG4gICAgICAgICAgICByYW5nZVByb3BlcnRpZXM6IHJhbmdlUHJvcGVydGllcyxcbiAgICAgICAgICAgIFJhbmdlSXRlcmF0b3I6IFJhbmdlSXRlcmF0b3IsXG4gICAgICAgICAgICBjb3B5Q29tcGFyaXNvbkNvbnN0YW50czogY29weUNvbXBhcmlzb25Db25zdGFudHMsXG4gICAgICAgICAgICBjcmVhdGVQcm90b3R5cGVSYW5nZTogY3JlYXRlUHJvdG90eXBlUmFuZ2UsXG4gICAgICAgICAgICBpbnNwZWN0OiBpbnNwZWN0LFxuICAgICAgICAgICAgdG9IdG1sOiByYW5nZVRvSHRtbCxcbiAgICAgICAgICAgIGdldFJhbmdlRG9jdW1lbnQ6IGdldFJhbmdlRG9jdW1lbnQsXG4gICAgICAgICAgICByYW5nZXNFcXVhbDogZnVuY3Rpb24ocjEsIHIyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIxLnN0YXJ0Q29udGFpbmVyID09PSByMi5zdGFydENvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgICAgICByMS5zdGFydE9mZnNldCA9PT0gcjIuc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgcjEuZW5kQ29udGFpbmVyID09PSByMi5lbmRDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgcjEuZW5kT2Zmc2V0ID09PSByMi5lbmRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwaS5Eb21SYW5nZSA9IFJhbmdlO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIFdyYXBwZXJzIGZvciB0aGUgYnJvd3NlcidzIG5hdGl2ZSBET00gUmFuZ2UgYW5kL29yIFRleHRSYW5nZSBpbXBsZW1lbnRhdGlvbiBcbiAgICBhcGkuY3JlYXRlQ29yZU1vZHVsZShcIldyYXBwZWRSYW5nZVwiLCBbXCJEb21SYW5nZVwiXSwgZnVuY3Rpb24oYXBpLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIFdyYXBwZWRSYW5nZSwgV3JhcHBlZFRleHRSYW5nZTtcbiAgICAgICAgdmFyIGRvbSA9IGFwaS5kb207XG4gICAgICAgIHZhciB1dGlsID0gYXBpLnV0aWw7XG4gICAgICAgIHZhciBEb21Qb3NpdGlvbiA9IGRvbS5Eb21Qb3NpdGlvbjtcbiAgICAgICAgdmFyIERvbVJhbmdlID0gYXBpLkRvbVJhbmdlO1xuICAgICAgICB2YXIgZ2V0Qm9keSA9IGRvbS5nZXRCb2R5O1xuICAgICAgICB2YXIgZ2V0Q29udGVudERvY3VtZW50ID0gZG9tLmdldENvbnRlbnREb2N1bWVudDtcbiAgICAgICAgdmFyIGlzQ2hhcmFjdGVyRGF0YU5vZGUgPSBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZTtcblxuXG4gICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgaWYgKGFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgYnJvd3NlcidzIG5hdGl2ZSBET00gUmFuZ2UuIEl0IGhhcyB0d28gYWltczpcbiAgICAgICAgICAgIC8vIC0gUHJvdmlkZSB3b3JrYXJvdW5kcyBmb3Igc3BlY2lmaWMgYnJvd3NlciBidWdzXG4gICAgICAgICAgICAvLyAtIHByb3ZpZGUgY29udmVuaWVudCBleHRlbnNpb25zLCB3aGljaCBhcmUgaW5oZXJpdGVkIGZyb20gUmFuZ3kncyBEb21SYW5nZVxuXG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlUHJvdG87XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlUHJvcGVydGllcyA9IERvbVJhbmdlLnJhbmdlUHJvcGVydGllcztcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlUHJvcGVydGllcyhyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsIHByb3A7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSByYW5nZVByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZVtwcm9wXSA9IHJhbmdlLm5hdGl2ZVJhbmdlW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBmb3IgYnJva2VuIGNvbGxhcHNlZCBwcm9wZXJ0eSBpbiBJRSA5LlxuICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZWQgPSAocmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IHJhbmdlLmVuZENvbnRhaW5lciAmJiByYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVOYXRpdmVSYW5nZShyYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNb3ZlZCA9IChyYW5nZS5zdGFydENvbnRhaW5lciAhPT0gc3RhcnRDb250YWluZXIgfHwgcmFuZ2Uuc3RhcnRPZmZzZXQgIT0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTW92ZWQgPSAocmFuZ2UuZW5kQ29udGFpbmVyICE9PSBlbmRDb250YWluZXIgfHwgcmFuZ2UuZW5kT2Zmc2V0ICE9IGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVSYW5nZURpZmZlcmVudCA9ICFyYW5nZS5lcXVhbHMocmFuZ2UubmF0aXZlUmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgYm90aCBib3VuZGFyaWVzIGZvciB0aGUgYmVuZWZpdCBvZiBJRTkgKHNlZSBpc3N1ZSAzNSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0TW92ZWQgfHwgZW5kTW92ZWQgfHwgbmF0aXZlUmFuZ2VEaWZmZXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChlbmRDb250YWluZXIsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcjtcblxuICAgICAgICAgICAgICAgIFdyYXBwZWRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcIldyYXBwZWRSYW5nZTogUmFuZ2UgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIERvbVJhbmdlLmNyZWF0ZVByb3RvdHlwZVJhbmdlKFdyYXBwZWRSYW5nZSwgdXBkYXRlTmF0aXZlUmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90byA9IFdyYXBwZWRSYW5nZS5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNlbGVjdE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLmNsb25lQ29udGVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYSBsb25nLXN0YW5kaW5nIEZpcmVmb3ggYnVnIHRoYXQgSSBoYXZlIG5vdCBiZWVuIGFibGUgdG8gZmluZCBhIHJlbGlhYmxlIHdheSB0byBkZXRlY3QsXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0Tm9kZSgpIGlzIG5ldmVyIGRlbGVnYXRlZCB0byB0aGUgbmF0aXZlIHJhbmdlLlxuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zdXJyb3VuZENvbnRlbnRzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnN1cnJvdW5kQ29udGVudHMobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5jb2xsYXBzZSA9IGZ1bmN0aW9uKGlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5jb2xsYXBzZShpc1N0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLmNsb25lUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkUmFuZ2UodGhpcy5uYXRpdmVSYW5nZS5jbG9uZVJhbmdlKCkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0ZXN0IHJhbmdlIGFuZCBub2RlIGZvciBmZWF0dXJlIGRldGVjdGlvblxuXG4gICAgICAgICAgICAgICAgdmFyIHRlc3RUZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGVzdFwiKTtcbiAgICAgICAgICAgICAgICBnZXRCb2R5KGRvY3VtZW50KS5hcHBlbmRDaGlsZCh0ZXN0VGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIEZpcmVmb3ggMiBidWcgdGhhdCBwcmV2ZW50cyBtb3ZpbmcgdGhlIHN0YXJ0IG9mIGEgUmFuZ2UgdG8gYSBwb2ludCBhZnRlciBpdHMgY3VycmVudCBlbmQgYW5kXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBmb3IgaXRcblxuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRlc3RUZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRlc3RUZXh0Tm9kZSwgMCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnQgPSBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldEVuZCA9IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0ID0gZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZXRFbmQgPSBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyID0gZnVuY3Rpb24obmFtZSwgb3Bwb3NpdGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZVtvcHBvc2l0ZU5hbWVdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW25hbWVdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRTdGFydEJlZm9yZVwiLCBcInNldEVuZEJlZm9yZVwiKTtcbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0QWZ0ZXIgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRTdGFydEFmdGVyXCIsIFwic2V0RW5kQWZ0ZXJcIik7XG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZXRFbmRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRFbmRCZWZvcmVcIiwgXCJzZXRTdGFydEJlZm9yZVwiKTtcbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldEVuZEFmdGVyID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0RW5kQWZ0ZXJcIiwgXCJzZXRTdGFydEFmdGVyXCIpO1xuXG4gICAgICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNlIERPTTQtY29tcGxpYW50IHNlbGVjdE5vZGVDb250ZW50cyBpbXBsZW1lbnRhdGlvbjogaXQncyBzaW1wbGVyIGFuZCBsZXNzIGNvZGUgdGhhbiB0ZXN0aW5nXG4gICAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGNhbiBiZSB0cnVzdGVkXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZWxlY3ROb2RlQ29udGVudHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnRBbmRFbmQobm9kZSwgMCwgZG9tLmdldE5vZGVMZW5ndGgobm9kZSkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIGFuZCBjb3JyZWN0IFdlYktpdCBidWcgdGhhdCBoYXMgdGhlIGJlaGF2aW91ciBvZiBjb21wYXJlQm91bmRhcnlQb2ludHMgcm91bmQgdGhlIHdyb25nIHdheSBmb3JcbiAgICAgICAgICAgICAgICAvLyBjb25zdGFudHMgU1RBUlRfVE9fRU5EIGFuZCBFTkRfVE9fU1RBUlQ6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDczOFxuXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRlc3RUZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRlc3RUZXh0Tm9kZSwgMyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UyID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZTIuc2VsZWN0Tm9kZUNvbnRlbnRzKHRlc3RUZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2UyLnNldEVuZCh0ZXN0VGV4dE5vZGUsIDQpO1xuICAgICAgICAgICAgICAgIHJhbmdlMi5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyYW5nZS5TVEFSVF9UT19FTkQsIHJhbmdlMikgPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyYW5nZS5FTkRfVE9fU1RBUlQsIHJhbmdlMikgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSB3cm9uZyB3YXkgcm91bmQsIHNvIGNvcnJlY3QgZm9yIGl0XG5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5jb21wYXJlQm91bmRhcnlQb2ludHMgPSBmdW5jdGlvbih0eXBlLCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZS5uYXRpdmVSYW5nZSB8fCByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IHJhbmdlLlNUQVJUX1RPX0VORCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSByYW5nZS5FTkRfVE9fU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gcmFuZ2UuRU5EX1RPX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJhbmdlLlNUQVJUX1RPX0VORDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyh0eXBlLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQcm90by5jb21wYXJlQm91bmRhcnlQb2ludHMgPSBmdW5jdGlvbih0eXBlLCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKHR5cGUsIHJhbmdlLm5hdGl2ZVJhbmdlIHx8IHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDkgZGVsZXRlQ29udGVudHMoKSBhbmQgZXh0cmFjdENvbnRlbnRzKCkgYnVnIGFuZCBjb3JyZWN0IGl0LiBTZWUgaXNzdWUgMTA3LlxuXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjEyM1wiO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKGVsKTtcblxuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAxKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIDIpO1xuICAgICAgICAgICAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUuZGF0YSA9PSBcIjEzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVoYXZpb3VyIGlzIGNvcnJlY3QgcGVyIERPTTQgUmFuZ2Ugc28gd3JhcCB0aGUgYnJvd3NlcidzIGltcGxlbWVudGF0aW9uIG9mIGRlbGV0ZUNvbnRlbnRzKCkgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhY3RDb250ZW50cygpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uZGVsZXRlQ29udGVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByYW5nZVByb3RvLmV4dHJhY3RDb250ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLm5hdGl2ZVJhbmdlLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICBib2R5ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBmb3IgZXhpc3RlbmNlIG9mIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBhbmQgZGVsZWdhdGUgdG8gaXQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNIb3N0TWV0aG9kKHJhbmdlLCBcImNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZVByb3RvLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCA9IGZ1bmN0aW9uKGZyYWdtZW50U3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoZnJhZ21lbnRTdHIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgICAgICBnZXRCb2R5KGRvY3VtZW50KS5yZW1vdmVDaGlsZCh0ZXN0VGV4dE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5nZXROYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIldyYXBwZWRSYW5nZVwiO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBhcGkuV3JhcHBlZFJhbmdlID0gV3JhcHBlZFJhbmdlO1xuXG4gICAgICAgICAgICAgICAgYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IGdldENvbnRlbnREb2N1bWVudChkb2MsIG1vZHVsZSwgXCJjcmVhdGVOYXRpdmVSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoYXBpLmZlYXR1cmVzLmltcGxlbWVudHNUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBidWcgd2hlcmUgSUUgcmV0dXJucyB0aGUgd3JvbmcgY29udGFpbmVyIGVsZW1lbnQgZnJvbSB0aGUgVGV4dFJhbmdlJ3MgcGFyZW50RWxlbWVudCgpXG4gICAgICAgICAgICBtZXRob2QuIEZvciBleGFtcGxlLCBpbiB0aGUgZm9sbG93aW5nICh3aGVyZSBwaXBlcyBkZW5vdGUgdGhlIHNlbGVjdGlvbiBib3VuZGFyaWVzKTpcblxuICAgICAgICAgICAgPHVsIGlkPVwidWxcIj48bGkgaWQ9XCJhXCI+fCBhIDwvbGk+PGxpIGlkPVwiYlwiPiBiIHw8L2xpPjwvdWw+XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgYWxlcnQocmFuZ2UucGFyZW50RWxlbWVudCgpLmlkKTsgLy8gU2hvdWxkIGFsZXJ0IFwidWxcIiBidXQgYWxlcnRzIFwiYlwiXG5cbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGNvbW1vbiBhbmNlc3RvciBub2RlIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZVxuICAgICAgICAgICAgLSB0aGUgcGFyZW50RWxlbWVudCgpIG9mIHRoZSB0ZXh0UmFuZ2UgYWZ0ZXIgY2FsbGluZyBjb2xsYXBzZSh0cnVlKVxuICAgICAgICAgICAgLSB0aGUgcGFyZW50RWxlbWVudCgpIG9mIHRoZSB0ZXh0UmFuZ2UgYWZ0ZXIgY2FsbGluZyBjb2xsYXBzZShmYWxzZSlcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCA9IGZ1bmN0aW9uKHRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbCA9IHRleHRSYW5nZS5wYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEVsID0gcmFuZ2UucGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kRWwgPSByYW5nZS5wYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RW5kQ29udGFpbmVyID0gKHN0YXJ0RWwgPT0gZW5kRWwpID8gc3RhcnRFbCA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihzdGFydEVsLCBlbmRFbCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRFbmRDb250YWluZXIgPT0gcGFyZW50RWwgPyBzdGFydEVuZENvbnRhaW5lciA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihwYXJlbnRFbCwgc3RhcnRFbmRDb250YWluZXIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRleHRSYW5nZUlzQ29sbGFwc2VkID0gZnVuY3Rpb24odGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRSYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLCB0ZXh0UmFuZ2UpID09IDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBHZXRzIHRoZSBib3VuZGFyeSBvZiBhIFRleHRSYW5nZSBleHByZXNzZWQgYXMgYSBub2RlIGFuZCBhbiBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS4gVGhpcyBmdW5jdGlvbiBzdGFydGVkXG4gICAgICAgICAgICAvLyBvdXQgYXMgYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiBjb2RlIGZvdW5kIGluIFRpbSBDYW1lcm9uIFJ5YW4ncyBJRVJhbmdlIChodHRwOi8vY29kZS5nb29nbGUuY29tL3AvaWVyYW5nZS8pXG4gICAgICAgICAgICAvLyBidXQgaGFzIGdyb3duLCBmaXhpbmcgcHJvYmxlbXMgd2l0aCBsaW5lIGJyZWFrcyBpbiBwcmVmb3JtYXR0ZWQgdGV4dCwgYWRkaW5nIHdvcmthcm91bmQgZm9yIElFIFRleHRSYW5nZVxuICAgICAgICAgICAgLy8gYnVncywgaGFuZGxpbmcgZm9yIGlucHV0cyBhbmQgaW1hZ2VzLCBwbHVzIG9wdGltaXphdGlvbnMuXG4gICAgICAgICAgICB2YXIgZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbiA9IGZ1bmN0aW9uKHRleHRSYW5nZSwgd2hvbGVSYW5nZUNvbnRhaW5lckVsZW1lbnQsIGlzU3RhcnQsIGlzQ29sbGFwc2VkLCBzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgd29ya2luZ1JhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZShpc1N0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IHdvcmtpbmdSYW5nZS5wYXJlbnRFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgY29sbGFwc2luZyBhIFRleHRSYW5nZSB0aGF0J3MgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlIGNhbiBtb3ZlIGl0IGludG8gdGhlIHByZXZpb3VzIG5vZGUsIHNvXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRoYXRcbiAgICAgICAgICAgICAgICBpZiAoIWRvbS5pc09ySXNBbmNlc3Rvck9mKHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50LCBjb250YWluZXJFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJFbGVtZW50ID0gd2hvbGVSYW5nZUNvbnRhaW5lckVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggbm9kZXMgdGhhdCBjYW5ub3QgXCJjb250YWluIHJpY2ggSFRNTCBtYXJrdXBcIi4gSW4gcHJhY3RpY2UsIHRoaXMgbWVhbnMgZm9ybSBpbnB1dHMsIGltYWdlcyBhbmRcbiAgICAgICAgICAgICAgICAvLyBzaW1pbGFyLiBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2FhNzAzOTUwJTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyRWxlbWVudC5jYW5IYXZlSFRNTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gbmV3IERvbVBvc2l0aW9uKGNvbnRhaW5lckVsZW1lbnQucGFyZW50Tm9kZSwgZG9tLmdldE5vZGVJbmRleChjb250YWluZXJFbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogcG9zLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJFbGVtZW50OiBwb3Mubm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB3b3JraW5nTm9kZSA9IGRvbS5nZXREb2N1bWVudChjb250YWluZXJFbGVtZW50KS5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIEhUTUw1IFNoaXYncyBpbnNhbmUgdmlvbGF0aW9uIG9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoKS4gU2VlIFJhbmd5IGlzc3VlIDEwNCBhbmQgSFRNTDVcbiAgICAgICAgICAgICAgICAvLyBTaGl2IGlzc3VlIDY0OiBodHRwczovL2dpdGh1Yi5jb20vYUZhcmthcy9odG1sNXNoaXYvaXNzdWVzLzY0XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmdOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZ05vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3b3JraW5nTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhcmlzb24sIHdvcmtpbmdDb21wYXJpc29uVHlwZSA9IGlzU3RhcnQgPyBcIlN0YXJ0VG9TdGFydFwiIDogXCJTdGFydFRvRW5kXCI7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzTm9kZSwgbmV4dE5vZGUsIGJvdW5kYXJ5UG9zaXRpb24sIGJvdW5kYXJ5Tm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAoc3RhcnRJbmZvICYmIHN0YXJ0SW5mby5jb250YWluZXJFbGVtZW50ID09IGNvbnRhaW5lckVsZW1lbnQpID8gc3RhcnRJbmZvLm5vZGVJbmRleCA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUNvdW50ID0gY29udGFpbmVyRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gY2hpbGROb2RlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlbmQgZmlyc3QuIENvZGUgd2l0aGluIHRoZSBsb29wIGFzc3VtZXMgdGhhdCB0aGUgZW5kdGggY2hpbGQgbm9kZSBvZiB0aGUgY29udGFpbmVyIGlzIGRlZmluaXRlbHlcbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgcmFuZ2UgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGVuZDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlSW5kZXggPT0gY2hpbGROb2RlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQod29ya2luZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5pbnNlcnRCZWZvcmUod29ya2luZ05vZGUsIGNvbnRhaW5lckVsZW1lbnQuY2hpbGROb2Rlc1tub2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JraW5nUmFuZ2UubW92ZVRvRWxlbWVudFRleHQod29ya2luZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uID0gd29ya2luZ1JhbmdlLmNvbXBhcmVFbmRQb2ludHMod29ya2luZ0NvbXBhcmlzb25UeXBlLCB0ZXh0UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvbiA9PSAwIHx8IHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvbiA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA9PSBzdGFydCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBlbmR0aCBjaGlsZCBub2RlIGlzIGFmdGVyIHRoZSByYW5nZSBib3VuZGFyeSwgc28gd2UgbXVzdCBiZSBkb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChlbmQgPT0gc3RhcnQgKyAxKSA/IHN0YXJ0IDogbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJFbGVtZW50LnJlbW92ZUNoaWxkKHdvcmtpbmdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIG5vdyByZWFjaGVkIG9yIGdvbmUgcGFzdCB0aGUgYm91bmRhcnkgb2YgdGhlIHRleHQgcmFuZ2Ugd2UncmUgaW50ZXJlc3RlZCBpblxuICAgICAgICAgICAgICAgIC8vIHNvIGhhdmUgaWRlbnRpZmllZCB0aGUgbm9kZSB3ZSB3YW50XG4gICAgICAgICAgICAgICAgYm91bmRhcnlOb2RlID0gd29ya2luZ05vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvbiA9PSAtMSAmJiBib3VuZGFyeU5vZGUgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShib3VuZGFyeU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjaGFyYWN0ZXIgZGF0YSBub2RlICh0ZXh0LCBjb21tZW50LCBjZGF0YSkuIFRoZSB3b3JraW5nIHJhbmdlIGlzIGNvbGxhcHNlZCBhdCB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgdGV4dCByYW5nZSdzIGJvdW5kYXJ5LCBzbyB3ZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHdvcmtpbmcgcmFuZ2UgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdW5kYXJ5IHBvaW50IGFuZCBtZWFzdXJlIHRoZSBsZW5ndGggb2YgaXRzIHRleHQgdG8gZ2V0IHRoZSBib3VuZGFyeSdzIG9mZnNldCB3aXRoaW4gdGhlIG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmdSYW5nZS5zZXRFbmRQb2ludChpc1N0YXJ0ID8gXCJFbmRUb1N0YXJ0XCIgOiBcIkVuZFRvRW5kXCIsIHRleHRSYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoL1tcXHJcXG5dLy50ZXN0KGJvdW5kYXJ5Tm9kZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvciB0aGUgcGFydGljdWxhciBjYXNlIG9mIGEgYm91bmRhcnkgd2l0aGluIGEgdGV4dCBub2RlIGNvbnRhaW5pbmcgcmVuZGVyZWQgbGluZSBicmVha3MgKHdpdGhpbiBhXG4gICAgICAgICAgICAgICAgICAgICAgICA8cHJlPiBlbGVtZW50LCBmb3IgZXhhbXBsZSksIHdlIG5lZWQgYSBzbGlnaHRseSBjb21wbGljYXRlZCBhcHByb2FjaCB0byBnZXQgdGhlIGJvdW5kYXJ5J3Mgb2Zmc2V0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBJRS4gVGhlIGZhY3RzOlxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAtIEVhY2ggbGluZSBicmVhayBpcyByZXByZXNlbnRlZCBhcyBcXHIgaW4gdGhlIHRleHQgbm9kZSdzIGRhdGEvbm9kZVZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gRWFjaCBsaW5lIGJyZWFrIGlzIHJlcHJlc2VudGVkIGFzIFxcclxcbiBpbiB0aGUgVGV4dFJhbmdlJ3MgJ3RleHQnIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSAndGV4dCcgcHJvcGVydHkgb2YgdGhlIFRleHRSYW5nZSBkb2VzIG5vdCBjb250YWluIHRyYWlsaW5nIGxpbmUgYnJlYWtzXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFRvIGdldCByb3VuZCB0aGUgcHJvYmxlbSBwcmVzZW50ZWQgYnkgdGhlIGZpbmFsIGZhY3QgYWJvdmUsIHdlIGNhbiB1c2UgdGhlIGZhY3QgdGhhdCBUZXh0UmFuZ2Unc1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVN0YXJ0KCkgYW5kIG1vdmVFbmQoKSBtZXRob2RzIHJldHVybiB0aGUgYWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1vdmVkLCB3aGljaCBpcyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lY2Vzc2FyaWx5IHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpdCB3YXMgaW5zdHJ1Y3RlZCB0byBtb3ZlLiBUaGUgc2ltcGxlc3QgYXBwcm9hY2ggaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvIHVzZSB0aGlzIHRvIHN0b3JlIHRoZSBjaGFyYWN0ZXJzIG1vdmVkIHdoZW4gbW92aW5nIGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgb2YgdGhlIGRvY3VtZW50IGJvZHkgYW5kIHN1YnRyYWN0aW5nIHRoZSBzdGFydCBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mZnNldCAodGhlXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1vdmUtbmVnYXRpdmUtZ2F6aWxsaW9uXCIgbWV0aG9kKS4gSG93ZXZlciwgdGhpcyBpcyBleHRyZW1lbHkgc2xvdyB3aGVuIHRoZSBkb2N1bWVudCBpcyBsYXJnZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByYW5nZSBpcyBuZWFyIHRoZSBlbmQgb2YgaXQuIENsZWFybHkgZG9pbmcgdGhlIG1pcnJvciBpbWFnZSAoaS5lLiBtb3ZpbmcgdGhlIHJhbmdlIGJvdW5kYXJpZXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50KSBoYXMgdGhlIHNhbWUgcHJvYmxlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgQW5vdGhlciBhcHByb2FjaCB0aGF0IHdvcmtzIGlzIHRvIHVzZSBtb3ZlU3RhcnQoKSB0byBtb3ZlIHRoZSBzdGFydCBib3VuZGFyeSBvZiB0aGUgcmFuZ2UgdXAgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgYm91bmRhcnkgb25lIGNoYXJhY3RlciBhdCBhIHRpbWUgYW5kIGluY3JlbWVudGluZyBhIGNvdW50ZXIgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlU3RhcnQoKSBjYWxsLiBIb3dldmVyLCB0aGUgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHN0YXJ0IGJvdW5kYXJ5IGhhcyByZWFjaGVkIHRoZSBlbmQgYm91bmRhcnkgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVuc2l2ZSwgc28gdGhpcyBtZXRob2QgaXMgc2xvdyAoYWx0aG91Z2ggdW5saWtlIFwibW92ZS1uZWdhdGl2ZS1nYXppbGxpb25cIiBpcyBsYXJnZWx5IHVuYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgcmFuZ2Ugd2l0aGluIHRoZSBkb2N1bWVudCkuXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBhcHByb2FjaCB1c2VkIGJlbG93IGlzIGEgaHlicmlkIG9mIHRoZSB0d28gbWV0aG9kcyBhYm92ZS4gSXQgdXNlcyB0aGUgZmFjdCB0aGF0IGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nIHRoZSBUZXh0UmFuZ2UncyAndGV4dCcgcHJvcGVydHkgd2l0aCBlYWNoIFxcclxcbiBjb252ZXJ0ZWQgdG8gYSBzaW5nbGUgXFxyIGNoYXJhY3RlciBjYW5ub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlIGxvbmdlciB0aGFuIHRoZSB0ZXh0IG9mIHRoZSBUZXh0UmFuZ2UsIHNvIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgaXMgbW92ZWQgdGhhdCBsZW5ndGggaW5pdGlhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlbiBhIGNoYXJhY3RlciBhdCBhIHRpbWUgdG8gbWFrZSB1cCBmb3IgYW55IHRyYWlsaW5nIGxpbmUgYnJlYWtzIG5vdCBjb250YWluZWQgaW4gdGhlICd0ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuIFRoaXMgaGFzIGdvb2QgcGVyZm9ybWFuY2UgaW4gbW9zdCBzaXR1YXRpb25zIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyB0d28gbWV0aG9kcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcFJhbmdlID0gd29ya2luZ1JhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlTGVuZ3RoID0gdGVtcFJhbmdlLnRleHQucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxyXCIpLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGVtcFJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCByYW5nZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChjb21wYXJpc29uID0gdGVtcFJhbmdlLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHRlbXBSYW5nZSkpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHdvcmtpbmdSYW5nZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKGJvdW5kYXJ5Tm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBib3VuZGFyeSBpbW1lZGlhdGVseSBmb2xsb3dzIGEgY2hhcmFjdGVyIGRhdGEgbm9kZSBhbmQgdGhpcyBpcyB0aGUgZW5kIGJvdW5kYXJ5LCB3ZSBzaG91bGQgZmF2b3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcG9zaXRpb24gd2l0aGluIHRoYXQsIGFuZCBsaWtld2lzZSBmb3IgYSBzdGFydCBib3VuZGFyeSBwcmVjZWRpbmcgYSBjaGFyYWN0ZXIgZGF0YSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IChpc0NvbGxhcHNlZCB8fCAhaXNTdGFydCkgJiYgd29ya2luZ05vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IChpc0NvbGxhcHNlZCB8fCBpc1N0YXJ0KSAmJiB3b3JraW5nTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROb2RlICYmIGlzQ2hhcmFjdGVyRGF0YU5vZGUobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKG5leHROb2RlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c05vZGUgJiYgaXNDaGFyYWN0ZXJEYXRhTm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKHByZXZpb3VzTm9kZSwgcHJldmlvdXNOb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UG9zaXRpb24gPSBuZXcgRG9tUG9zaXRpb24oY29udGFpbmVyRWxlbWVudCwgZG9tLmdldE5vZGVJbmRleCh3b3JraW5nTm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgICAgICB3b3JraW5nTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdvcmtpbmdOb2RlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UG9zaXRpb246IGJvdW5kYXJ5UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXg6IG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQ6IGNvbnRhaW5lckVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBSZXR1cm5zIGEgVGV4dFJhbmdlIHJlcHJlc2VudGluZyB0aGUgYm91bmRhcnkgb2YgYSBUZXh0UmFuZ2UgZXhwcmVzc2VkIGFzIGEgbm9kZSBhbmQgYW4gb2Zmc2V0IHdpdGhpbiB0aGF0XG4gICAgICAgICAgICAvLyBub2RlLiBUaGlzIGZ1bmN0aW9uIHN0YXJ0ZWQgb3V0IGFzIGFuIG9wdGltaXplZCB2ZXJzaW9uIG9mIGNvZGUgZm91bmQgaW4gVGltIENhbWVyb24gUnlhbidzIElFUmFuZ2VcbiAgICAgICAgICAgIC8vIChodHRwOi8vY29kZS5nb29nbGUuY29tL3AvaWVyYW5nZS8pXG4gICAgICAgICAgICB2YXIgY3JlYXRlQm91bmRhcnlUZXh0UmFuZ2UgPSBmdW5jdGlvbihib3VuZGFyeVBvc2l0aW9uLCBpc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5Tm9kZSwgYm91bmRhcnlQYXJlbnQsIGJvdW5kYXJ5T2Zmc2V0ID0gYm91bmRhcnlQb3NpdGlvbi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChib3VuZGFyeVBvc2l0aW9uLm5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciB3b3JraW5nTm9kZSwgY2hpbGROb2Rlcywgd29ya2luZ1JhbmdlID0gZ2V0Qm9keShkb2MpLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlSXNEYXRhTm9kZSA9IGlzQ2hhcmFjdGVyRGF0YU5vZGUoYm91bmRhcnlQb3NpdGlvbi5ub2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlSXNEYXRhTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeU5vZGUgPSBib3VuZGFyeVBvc2l0aW9uLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50ID0gYm91bmRhcnlOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGJvdW5kYXJ5UG9zaXRpb24ubm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeU5vZGUgPSAoYm91bmRhcnlPZmZzZXQgPCBjaGlsZE5vZGVzLmxlbmd0aCkgPyBjaGlsZE5vZGVzW2JvdW5kYXJ5T2Zmc2V0XSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50ID0gYm91bmRhcnlQb3NpdGlvbi5ub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIHRoZSByYW5nZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgYm91bmRhcnlcbiAgICAgICAgICAgICAgICB3b3JraW5nTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2luZyB0aGUgd29ya2luZyBlbGVtZW50IG5vbi1lbXB0eSBlbGVtZW50IHBlcnN1YWRlcyBJRSB0byBjb25zaWRlciB0aGUgVGV4dFJhbmdlIGJvdW5kYXJ5IHRvIGJlIHdpdGhpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IGJlZm9yZSBvciBhZnRlciBpdFxuICAgICAgICAgICAgICAgIHdvcmtpbmdOb2RlLmlubmVySFRNTCA9IFwiJiNmZWZmO1wiO1xuXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0QmVmb3JlIGlzIHN1cHBvc2VkIHRvIHdvcmsgbGlrZSBhcHBlbmRDaGlsZCBpZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBudWxsLiBIb3dldmVyLCBhIGJ1ZyByZXBvcnRcbiAgICAgICAgICAgICAgICAvLyBmb3IgSUVSYW5nZSBzdWdnZXN0cyB0aGF0IGl0IGNhbiBjcmFzaCB0aGUgYnJvd3NlcjogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2llcmFuZ2UvaXNzdWVzL2RldGFpbD9pZD0xMlxuICAgICAgICAgICAgICAgIGlmIChib3VuZGFyeU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlQYXJlbnQuaW5zZXJ0QmVmb3JlKHdvcmtpbmdOb2RlLCBib3VuZGFyeU5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50LmFwcGVuZENoaWxkKHdvcmtpbmdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3b3JraW5nUmFuZ2UubW92ZVRvRWxlbWVudFRleHQod29ya2luZ05vZGUpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZSghaXNTdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50LnJlbW92ZUNoaWxkKHdvcmtpbmdOb2RlKTtcblxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHdvcmtpbmcgcmFuZ2UgdG8gdGhlIHRleHQgb2Zmc2V0LCBpZiByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGlmIChub2RlSXNEYXRhTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nUmFuZ2VbaXNTdGFydCA/IFwibW92ZVN0YXJ0XCIgOiBcIm1vdmVFbmRcIl0oXCJjaGFyYWN0ZXJcIiwgYm91bmRhcnlPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nUmFuZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIFRleHRSYW5nZSwgcHJvdmlkaW5nIGZ1bGwgRE9NIFJhbmdlIGZ1bmN0aW9uYWxpdHkgdXNpbmcgcmFuZ3kncyBEb21SYW5nZSBhcyBhXG4gICAgICAgICAgICAvLyBwcm90b3R5cGVcblxuICAgICAgICAgICAgV3JhcHBlZFRleHRSYW5nZSA9IGZ1bmN0aW9uKHRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dFJhbmdlID0gdGV4dFJhbmdlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgV3JhcHBlZFRleHRSYW5nZS5wcm90b3R5cGUgPSBuZXcgRG9tUmFuZ2UoZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICBXcmFwcGVkVGV4dFJhbmdlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0LCBlbmQsIHN0YXJ0Qm91bmRhcnk7XG5cbiAgICAgICAgICAgICAgICAvLyBUZXh0UmFuZ2UncyBwYXJlbnRFbGVtZW50KCkgbWV0aG9kIGNhbm5vdCBiZSB0cnVzdGVkLiBnZXRUZXh0UmFuZ2VDb250YWluZXJFbGVtZW50KCkgd29ya3MgYXJvdW5kIHRoYXQuXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlQ29udGFpbmVyRWxlbWVudCA9IGdldFRleHRSYW5nZUNvbnRhaW5lckVsZW1lbnQodGhpcy50ZXh0UmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRleHRSYW5nZUlzQ29sbGFwc2VkKHRoaXMudGV4dFJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCA9IGdldFRleHRSYW5nZUJvdW5kYXJ5UG9zaXRpb24odGhpcy50ZXh0UmFuZ2UsIHJhbmdlQ29udGFpbmVyRWxlbWVudCwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUpLmJvdW5kYXJ5UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRCb3VuZGFyeSA9IGdldFRleHRSYW5nZUJvdW5kYXJ5UG9zaXRpb24odGhpcy50ZXh0UmFuZ2UsIHJhbmdlQ29udGFpbmVyRWxlbWVudCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0Qm91bmRhcnkuYm91bmRhcnlQb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBbiBvcHRpbWl6YXRpb24gdXNlZCBoZXJlIGlzIHRoYXQgaWYgdGhlIHN0YXJ0IGFuZCBlbmQgYm91bmRhcmllcyBoYXZlIHRoZSBzYW1lIHBhcmVudCBlbGVtZW50LCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIHNjb3BlIGZvciB0aGUgZW5kIGJvdW5kYXJ5IGNhbiBiZSBsaW1pdGVkIHRvIGV4Y2x1ZGUgdGhlIHBvcnRpb24gb2YgdGhlIGVsZW1lbnQgdGhhdCBwcmVjZWRlc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3RhcnQgYm91bmRhcnlcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbih0aGlzLnRleHRSYW5nZSwgcmFuZ2VDb250YWluZXJFbGVtZW50LCBmYWxzZSwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEJvdW5kYXJ5Lm5vZGVJbmZvKS5ib3VuZGFyeVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnQoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVuZChlbmQubm9kZSwgZW5kLm9mZnNldCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBXcmFwcGVkVGV4dFJhbmdlLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiV3JhcHBlZFRleHRSYW5nZVwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgRG9tUmFuZ2UuY29weUNvbXBhcmlzb25Db25zdGFudHMoV3JhcHBlZFRleHRSYW5nZSk7XG5cbiAgICAgICAgICAgIHZhciByYW5nZVRvVGV4dFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmFuZ2UgPSBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRSYW5nZSA9IGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRSYW5nZSA9IGdldEJvZHkoIERvbVJhbmdlLmdldFJhbmdlRG9jdW1lbnQocmFuZ2UpICkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRSYW5nZS5zZXRFbmRQb2ludChcIlN0YXJ0VG9TdGFydFwiLCBzdGFydFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFJhbmdlLnNldEVuZFBvaW50KFwiRW5kVG9FbmRcIiwgZW5kUmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFJhbmdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFdyYXBwZWRUZXh0UmFuZ2UucmFuZ2VUb1RleHRSYW5nZSA9IHJhbmdlVG9UZXh0UmFuZ2U7XG5cbiAgICAgICAgICAgIFdyYXBwZWRUZXh0UmFuZ2UucHJvdG90eXBlLnRvVGV4dFJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9UZXh0UmFuZ2UodGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhcGkuV3JhcHBlZFRleHRSYW5nZSA9IFdyYXBwZWRUZXh0UmFuZ2U7XG5cbiAgICAgICAgICAgIC8vIElFIDkgYW5kIGFib3ZlIGhhdmUgYm90aCBpbXBsZW1lbnRhdGlvbnMgYW5kIFJhbmd5IG1ha2VzIGJvdGggYXZhaWxhYmxlLiBUaGUgbmV4dCBmZXcgbGluZXMgc2V0cyB3aGljaFxuICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gdG8gdXNlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICBpZiAoIWFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UgfHwgYXBpLmNvbmZpZy5wcmVmZXJUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgV3JhcHBlZFRleHRSYW5nZSBhcyB0aGUgUmFuZ2UgcHJvcGVydHkgb2YgdGhlIGdsb2JhbCBvYmplY3QgdG8gYWxsb3cgZXhwcmVzc2lvbiBsaWtlIFJhbmdlLkVORF9UT19FTkQgdG8gd29ya1xuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxPYmogPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsT2JqLlJhbmdlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsT2JqLlJhbmdlID0gV3JhcHBlZFRleHRSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gZ2V0Q29udGVudERvY3VtZW50KGRvYywgbW9kdWxlLCBcImNyZWF0ZU5hdGl2ZVJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Qm9keShkb2MpLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBhcGkuV3JhcHBlZFJhbmdlID0gV3JhcHBlZFRleHRSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFwaS5jcmVhdGVSYW5nZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgZG9jID0gZ2V0Q29udGVudERvY3VtZW50KGRvYywgbW9kdWxlLCBcImNyZWF0ZVJhbmdlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhcGkuV3JhcHBlZFJhbmdlKGFwaS5jcmVhdGVOYXRpdmVSYW5nZShkb2MpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBhcGkuY3JlYXRlUmFuZ3lSYW5nZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgZG9jID0gZ2V0Q29udGVudERvY3VtZW50KGRvYywgbW9kdWxlLCBcImNyZWF0ZVJhbmd5UmFuZ2VcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbVJhbmdlKGRvYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYXBpLmNyZWF0ZUlmcmFtZVJhbmdlID0gZnVuY3Rpb24oaWZyYW1lRWwpIHtcbiAgICAgICAgICAgIG1vZHVsZS5kZXByZWNhdGlvbk5vdGljZShcImNyZWF0ZUlmcmFtZVJhbmdlKClcIiwgXCJjcmVhdGVSYW5nZShpZnJhbWVFbClcIik7XG4gICAgICAgICAgICByZXR1cm4gYXBpLmNyZWF0ZVJhbmdlKGlmcmFtZUVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBhcGkuY3JlYXRlSWZyYW1lUmFuZ3lSYW5nZSA9IGZ1bmN0aW9uKGlmcmFtZUVsKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGVwcmVjYXRpb25Ob3RpY2UoXCJjcmVhdGVJZnJhbWVSYW5neVJhbmdlKClcIiwgXCJjcmVhdGVSYW5neVJhbmdlKGlmcmFtZUVsKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBhcGkuY3JlYXRlUmFuZ3lSYW5nZShpZnJhbWVFbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYXBpLmFkZFNoaW1MaXN0ZW5lcihmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvYy5jcmVhdGVSYW5nZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNyZWF0ZVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGkuY3JlYXRlUmFuZ2UoZG9jKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jID0gd2luID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gVGhpcyBtb2R1bGUgY3JlYXRlcyBhIHNlbGVjdGlvbiBvYmplY3Qgd3JhcHBlciB0aGF0IGNvbmZvcm1zIGFzIGNsb3NlbHkgYXMgcG9zc2libGUgdG8gdGhlIFNlbGVjdGlvbiBzcGVjaWZpY2F0aW9uXG4gICAgLy8gaW4gdGhlIEhUTUwgRWRpdGluZyBzcGVjIChodHRwOi8vZHZjcy53My5vcmcvaGcvZWRpdGluZy9yYXctZmlsZS90aXAvZWRpdGluZy5odG1sI3NlbGVjdGlvbnMpXG4gICAgYXBpLmNyZWF0ZUNvcmVNb2R1bGUoXCJXcmFwcGVkU2VsZWN0aW9uXCIsIFtcIkRvbVJhbmdlXCIsIFwiV3JhcHBlZFJhbmdlXCJdLCBmdW5jdGlvbihhcGksIG1vZHVsZSkge1xuICAgICAgICBhcGkuY29uZmlnLmNoZWNrU2VsZWN0aW9uUmFuZ2VzID0gdHJ1ZTtcblxuICAgICAgICB2YXIgQk9PTEVBTiA9IFwiYm9vbGVhblwiO1xuICAgICAgICB2YXIgTlVNQkVSID0gXCJudW1iZXJcIjtcbiAgICAgICAgdmFyIGRvbSA9IGFwaS5kb207XG4gICAgICAgIHZhciB1dGlsID0gYXBpLnV0aWw7XG4gICAgICAgIHZhciBpc0hvc3RNZXRob2QgPSB1dGlsLmlzSG9zdE1ldGhvZDtcbiAgICAgICAgdmFyIERvbVJhbmdlID0gYXBpLkRvbVJhbmdlO1xuICAgICAgICB2YXIgV3JhcHBlZFJhbmdlID0gYXBpLldyYXBwZWRSYW5nZTtcbiAgICAgICAgdmFyIERPTUV4Y2VwdGlvbiA9IGFwaS5ET01FeGNlcHRpb247XG4gICAgICAgIHZhciBEb21Qb3NpdGlvbiA9IGRvbS5Eb21Qb3NpdGlvbjtcbiAgICAgICAgdmFyIGdldE5hdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgdmFyIHNlbGVjdGlvbklzQ29sbGFwc2VkO1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBhcGkuZmVhdHVyZXM7XG4gICAgICAgIHZhciBDT05UUk9MID0gXCJDb250cm9sXCI7XG4gICAgICAgIHZhciBnZXREb2N1bWVudCA9IGRvbS5nZXREb2N1bWVudDtcbiAgICAgICAgdmFyIGdldEJvZHkgPSBkb20uZ2V0Qm9keTtcbiAgICAgICAgdmFyIHJhbmdlc0VxdWFsID0gRG9tUmFuZ2UucmFuZ2VzRXF1YWw7XG5cblxuICAgICAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHN1cHBvcnQgZGlyZWN0aW9uIHBhcmFtZXRlcnMgaW4gdGhlIEFQSSB0aGF0IG1heSBiZSBhIHN0cmluZyAoXCJiYWNrd2FyZFwiIG9yIFwiZm9yd2FyZFwiKSBvciBhXG4gICAgICAgIC8vIEJvb2xlYW4gKHRydWUgZm9yIGJhY2t3YXJkcykuXG4gICAgICAgIGZ1bmN0aW9uIGlzRGlyZWN0aW9uQmFja3dhcmQoZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBkaXIgPT0gXCJzdHJpbmdcIikgPyAvXmJhY2t3YXJkKHMpPyQvaS50ZXN0KGRpcikgOiAhIWRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvdyh3aW4sIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICghd2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLmlzV2luZG93KHdpbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW4gaW5zdGFuY2VvZiBXcmFwcGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbi53aW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBkb20uZ2V0Q29udGVudERvY3VtZW50KHdpbiwgbW9kdWxlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmdldFdpbmRvdyhkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0V2luU2VsZWN0aW9uKHdpblBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93KHdpblBhcmFtLCBcImdldFdpblNlbGVjdGlvblwiKS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERvY1NlbGVjdGlvbih3aW5QYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvdyh3aW5QYXJhbSwgXCJnZXREb2NTZWxlY3Rpb25cIikuZG9jdW1lbnQuc2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiB3aW5TZWxlY3Rpb25Jc0JhY2t3YXJkKHNlbCkge1xuICAgICAgICAgICAgdmFyIGJhY2t3YXJkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsLmFuY2hvck5vZGUpIHtcbiAgICAgICAgICAgICAgICBiYWNrd2FyZCA9IChkb20uY29tcGFyZVBvaW50cyhzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KSA9PSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYWNrd2FyZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3QgZm9yIHRoZSBSYW5nZS9UZXh0UmFuZ2UgYW5kIFNlbGVjdGlvbiBmZWF0dXJlcyByZXF1aXJlZFxuICAgICAgICAvLyBUZXN0IGZvciBhYmlsaXR5IHRvIHJldHJpZXZlIHNlbGVjdGlvblxuICAgICAgICB2YXIgaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbiA9IGlzSG9zdE1ldGhvZCh3aW5kb3csIFwiZ2V0U2VsZWN0aW9uXCIpLFxuICAgICAgICAgICAgaW1wbGVtZW50c0RvY1NlbGVjdGlvbiA9IHV0aWwuaXNIb3N0T2JqZWN0KGRvY3VtZW50LCBcInNlbGVjdGlvblwiKTtcblxuICAgICAgICBmZWF0dXJlcy5pbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uID0gaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbjtcbiAgICAgICAgZmVhdHVyZXMuaW1wbGVtZW50c0RvY1NlbGVjdGlvbiA9IGltcGxlbWVudHNEb2NTZWxlY3Rpb247XG5cbiAgICAgICAgdmFyIHVzZURvY3VtZW50U2VsZWN0aW9uID0gaW1wbGVtZW50c0RvY1NlbGVjdGlvbiAmJiAoIWltcGxlbWVudHNXaW5HZXRTZWxlY3Rpb24gfHwgYXBpLmNvbmZpZy5wcmVmZXJUZXh0UmFuZ2UpO1xuXG4gICAgICAgIGlmICh1c2VEb2N1bWVudFNlbGVjdGlvbikge1xuICAgICAgICAgICAgZ2V0TmF0aXZlU2VsZWN0aW9uID0gZ2V0RG9jU2VsZWN0aW9uO1xuICAgICAgICAgICAgYXBpLmlzU2VsZWN0aW9uVmFsaWQgPSBmdW5jdGlvbih3aW5QYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXRXaW5kb3cod2luUGFyYW0sIFwiaXNTZWxlY3Rpb25WYWxpZFwiKS5kb2N1bWVudCwgbmF0aXZlU2VsID0gZG9jLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBUZXh0UmFuZ2UgaXMgYWN0dWFsbHkgY29udGFpbmVkIHdpdGhpbiB0aGUgY29ycmVjdCBkb2N1bWVudFxuICAgICAgICAgICAgICAgIHJldHVybiAobmF0aXZlU2VsLnR5cGUgIT0gXCJOb25lXCIgfHwgZ2V0RG9jdW1lbnQobmF0aXZlU2VsLmNyZWF0ZVJhbmdlKCkucGFyZW50RWxlbWVudCgpKSA9PSBkb2MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBnZXROYXRpdmVTZWxlY3Rpb24gPSBnZXRXaW5TZWxlY3Rpb247XG4gICAgICAgICAgICBhcGkuaXNTZWxlY3Rpb25WYWxpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5mYWlsKFwiTmVpdGhlciBkb2N1bWVudC5zZWxlY3Rpb24gb3Igd2luZG93LmdldFNlbGVjdGlvbigpIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwaS5nZXROYXRpdmVTZWxlY3Rpb24gPSBnZXROYXRpdmVTZWxlY3Rpb247XG5cbiAgICAgICAgdmFyIHRlc3RTZWxlY3Rpb24gPSBnZXROYXRpdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHRlc3RSYW5nZSA9IGFwaS5jcmVhdGVOYXRpdmVSYW5nZShkb2N1bWVudCk7XG4gICAgICAgIHZhciBib2R5ID0gZ2V0Qm9keShkb2N1bWVudCk7XG5cbiAgICAgICAgLy8gT2J0YWluaW5nIGEgcmFuZ2UgZnJvbSBhIHNlbGVjdGlvblxuICAgICAgICB2YXIgc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgPSB1dGlsLmFyZUhvc3RQcm9wZXJ0aWVzKHRlc3RTZWxlY3Rpb24sXG4gICAgICAgICAgICBbXCJhbmNob3JOb2RlXCIsIFwiZm9jdXNOb2RlXCIsIFwiYW5jaG9yT2Zmc2V0XCIsIFwiZm9jdXNPZmZzZXRcIl0pO1xuXG4gICAgICAgIGZlYXR1cmVzLnNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXM7XG5cbiAgICAgICAgLy8gVGVzdCBmb3IgZXhpc3RlbmNlIG9mIG5hdGl2ZSBzZWxlY3Rpb24gZXh0ZW5kKCkgbWV0aG9kXG4gICAgICAgIHZhciBzZWxlY3Rpb25IYXNFeHRlbmQgPSBpc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJleHRlbmRcIik7XG4gICAgICAgIGZlYXR1cmVzLnNlbGVjdGlvbkhhc0V4dGVuZCA9IHNlbGVjdGlvbkhhc0V4dGVuZDtcbiAgICAgICAgXG4gICAgICAgIC8vIFRlc3QgaWYgcmFuZ2VDb3VudCBleGlzdHNcbiAgICAgICAgdmFyIHNlbGVjdGlvbkhhc1JhbmdlQ291bnQgPSAodHlwZW9mIHRlc3RTZWxlY3Rpb24ucmFuZ2VDb3VudCA9PSBOVU1CRVIpO1xuICAgICAgICBmZWF0dXJlcy5zZWxlY3Rpb25IYXNSYW5nZUNvdW50ID0gc2VsZWN0aW9uSGFzUmFuZ2VDb3VudDtcblxuICAgICAgICB2YXIgc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkUmFuZ2VCYWNrd2FyZFRvTmF0aXZlID0gc2VsZWN0aW9uSGFzRXh0ZW5kID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKG5hdGl2ZVNlbGVjdGlvbiwgcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gRG9tUmFuZ2UuZ2V0UmFuZ2VEb2N1bWVudChyYW5nZSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgICAgICAgZW5kUmFuZ2UuY29sbGFwc2VUb1BvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBuYXRpdmVTZWxlY3Rpb24uYWRkUmFuZ2UoZ2V0TmF0aXZlUmFuZ2UoZW5kUmFuZ2UpKTtcbiAgICAgICAgICAgICAgICBuYXRpdmVTZWxlY3Rpb24uZXh0ZW5kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICB9IDogbnVsbDtcblxuICAgICAgICBpZiAodXRpbC5hcmVIb3N0TWV0aG9kcyh0ZXN0U2VsZWN0aW9uLCBbXCJhZGRSYW5nZVwiLCBcImdldFJhbmdlQXRcIiwgXCJyZW1vdmVBbGxSYW5nZXNcIl0pICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRlc3RTZWxlY3Rpb24ucmFuZ2VDb3VudCA9PSBOVU1CRVIgJiYgZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2aW91c2x5IGFuIGlmcmFtZSB3YXMgdXNlZCBidXQgdGhpcyBjYXVzZWQgcHJvYmxlbXMgaW4gc29tZSBjaXJjdW1zdGFuY2VzIGluIElFLCBzbyB0ZXN0cyBhcmVcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnQncyBzZWxlY3Rpb24uIFNlZSBpc3N1ZSAxMDkuXG5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIGFsc28gdGhhdCBpZiBhIHNlbGVjdGlvbiBwcmV2aW91c2x5IGV4aXN0ZWQsIGl0IGlzIHdpcGVkIGJ5IHRoZXNlIHRlc3RzLiBUaGlzIHNob3VsZCB1c3VhbGx5IGJlIGZpbmVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGluaXRpYWxpemF0aW9uIHVzdWFsbHkgaGFwcGVucyB3aGVuIHRoZSBkb2N1bWVudCBsb2FkcywgYnV0IGNvdWxkIGJlIGEgcHJvYmxlbSBmb3IgYSBzY3JpcHQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGxvYWRzIGFuZCBpbml0aWFsaXplcyBSYW5neSBsYXRlci4gSWYgYW55b25lIGNvbXBsYWlucywgY29kZSBjb3VsZCBiZSBhZGRlZCB0byBzYXZlIGFuZCByZXN0b3JlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbFNlbGVjdGlvblJhbmdlQ291bnQgPSBzZWwucmFuZ2VDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkhhc011bHRpcGxlUmFuZ2VzID0gKG9yaWdpbmFsU2VsZWN0aW9uUmFuZ2VDb3VudCA+IDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxTZWxlY3Rpb25SYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2VsZWN0aW9uQmFja3dhcmQgPSB3aW5TZWxlY3Rpb25Jc0JhY2t3YXJkKHNlbCk7IFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWdpbmFsU2VsZWN0aW9uUmFuZ2VDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNlbGVjdGlvblJhbmdlc1tpXSA9IHNlbC5nZXRSYW5nZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc29tZSB0ZXN0IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gZ2V0Qm9keShkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0RWwgPSBib2R5LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RFbC5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IHRlc3RFbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXHUwMGEwXFx1MDBhMFxcdTAwYTBcIikgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIG5hdGl2ZSBzZWxlY3Rpb24gd2lsbCBhbGxvdyBhIGNvbGxhcHNlZCBzZWxlY3Rpb24gd2l0aGluIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIxID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICAgICAgICAgICAgICAgICAgICByMS5zZXRTdGFydCh0ZXh0Tm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHIxLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocjEpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQgPSAoc2VsLnJhbmdlQ291bnQgPT0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIG5hdGl2ZSBzZWxlY3Rpb24gaXMgY2FwYWJsZSBvZiBzdXBwb3J0aW5nIG11bHRpcGxlIHJhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25IYXNNdWx0aXBsZVJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9pbmcgdGhlIG9yaWdpbmFsIGZlYXR1cmUgdGVzdCBoZXJlIGluIENocm9tZSAzNiAoYW5kIHByZXN1bWFibHkgbGF0ZXIgdmVyc2lvbnMpIHByaW50cyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlIGVycm9yIG9mIFwiRGlzY29udGlndW91cyBzZWxlY3Rpb24gaXMgbm90IHN1cHBvcnRlZC5cIiB0aGF0IGNhbm5vdCBiZSBzdXBwcmVzc2VkLiBUaGVyZSdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHdlIGNhbiBkbyBhYm91dCB0aGlzIHdoaWxlIHJldGFpbmluZyB0aGUgZmVhdHVyZSB0ZXN0IHNvIHdlIGhhdmUgdG8gcmVzb3J0IHRvIGEgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc25pZmYuIEknbSBub3QgaGFwcHkgYWJvdXQgaXQuIFNlZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM5OTc5MVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNocm9tZU1hdGNoID0gd2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9DaHJvbWVcXC8oLio/KSAvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHJvbWVNYXRjaCAmJiBwYXJzZUludChjaHJvbWVNYXRjaFsxXSkgPj0gMzYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByMiA9IHIxLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByMS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjIuc2V0RW5kKHRleHROb2RlLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByMi5zZXRTdGFydCh0ZXh0Tm9kZSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHIxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMgPSAoc2VsLnJhbmdlQ291bnQgPT0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKHRlc3RFbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3JpZ2luYWxTZWxlY3Rpb25SYW5nZUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDAgJiYgb3JpZ2luYWxTZWxlY3Rpb25CYWNrd2FyZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRSYW5nZUJhY2t3YXJkVG9OYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2VCYWNrd2FyZFRvTmF0aXZlKHNlbCwgb3JpZ2luYWxTZWxlY3Rpb25SYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS53YXJuKFwiUmFuZ3kgaW5pdGlhbGl6YXRpb246IG9yaWdpbmFsIHNlbGVjdGlvbiB3YXMgYmFja3dhcmRzIGJ1dCBzZWxlY3Rpb24gaGFzIGJlZW4gcmVzdG9yZWQgZm9yd2FyZHMgYmVjYXVzZSB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFNlbGVjdGlvbi5leHRlbmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5hZGRSYW5nZShvcmlnaW5hbFNlbGVjdGlvblJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2Uob3JpZ2luYWxTZWxlY3Rpb25SYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZlYXR1cmVzLnNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMgPSBzZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzO1xuICAgICAgICBmZWF0dXJlcy5jb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQgPSBjb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQ7XG5cbiAgICAgICAgLy8gQ29udHJvbFJhbmdlc1xuICAgICAgICB2YXIgaW1wbGVtZW50c0NvbnRyb2xSYW5nZSA9IGZhbHNlLCB0ZXN0Q29udHJvbFJhbmdlO1xuXG4gICAgICAgIGlmIChib2R5ICYmIGlzSG9zdE1ldGhvZChib2R5LCBcImNyZWF0ZUNvbnRyb2xSYW5nZVwiKSkge1xuICAgICAgICAgICAgdGVzdENvbnRyb2xSYW5nZSA9IGJvZHkuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgICAgICAgICBpZiAodXRpbC5hcmVIb3N0UHJvcGVydGllcyh0ZXN0Q29udHJvbFJhbmdlLCBbXCJpdGVtXCIsIFwiYWRkXCJdKSkge1xuICAgICAgICAgICAgICAgIGltcGxlbWVudHNDb250cm9sUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLmltcGxlbWVudHNDb250cm9sUmFuZ2UgPSBpbXBsZW1lbnRzQ29udHJvbFJhbmdlO1xuXG4gICAgICAgIC8vIFNlbGVjdGlvbiBjb2xsYXBzZWRuZXNzXG4gICAgICAgIGlmIChzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT09IHNlbC5mb2N1c05vZGUgJiYgc2VsLmFuY2hvck9mZnNldCA9PT0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklzQ29sbGFwc2VkID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbC5yYW5nZUNvdW50ID8gc2VsLmdldFJhbmdlQXQoc2VsLnJhbmdlQ291bnQgLSAxKS5jb2xsYXBzZWQgOiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHJhbmdlLCBiYWNrd2FyZCkge1xuICAgICAgICAgICAgdmFyIGFuY2hvclByZWZpeCA9IGJhY2t3YXJkID8gXCJlbmRcIiA6IFwic3RhcnRcIiwgZm9jdXNQcmVmaXggPSBiYWNrd2FyZCA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgICAgICBzZWwuYW5jaG9yTm9kZSA9IHJhbmdlW2FuY2hvclByZWZpeCArIFwiQ29udGFpbmVyXCJdO1xuICAgICAgICAgICAgc2VsLmFuY2hvck9mZnNldCA9IHJhbmdlW2FuY2hvclByZWZpeCArIFwiT2Zmc2V0XCJdO1xuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSA9IHJhbmdlW2ZvY3VzUHJlZml4ICsgXCJDb250YWluZXJcIl07XG4gICAgICAgICAgICBzZWwuZm9jdXNPZmZzZXQgPSByYW5nZVtmb2N1c1ByZWZpeCArIFwiT2Zmc2V0XCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uKHNlbCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVNlbCA9IHNlbC5uYXRpdmVTZWxlY3Rpb247XG4gICAgICAgICAgICBzZWwuYW5jaG9yTm9kZSA9IG5hdGl2ZVNlbC5hbmNob3JOb2RlO1xuICAgICAgICAgICAgc2VsLmFuY2hvck9mZnNldCA9IG5hdGl2ZVNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID0gbmF0aXZlU2VsLmZvY3VzTm9kZTtcbiAgICAgICAgICAgIHNlbC5mb2N1c09mZnNldCA9IG5hdGl2ZVNlbC5mb2N1c09mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCkge1xuICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUgPSBzZWwuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbC5hbmNob3JPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgc2VsLnJhbmdlQ291bnQgPSAwO1xuICAgICAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbC5fcmFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXROYXRpdmVSYW5nZShyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVJhbmdlO1xuICAgICAgICAgICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRG9tUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVSYW5nZSA9IGFwaS5jcmVhdGVOYXRpdmVSYW5nZShyYW5nZS5nZXREb2N1bWVudCgpKTtcbiAgICAgICAgICAgICAgICBuYXRpdmVSYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIG5hdGl2ZVJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlIGluc3RhbmNlb2YgV3JhcHBlZFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZS5uYXRpdmVSYW5nZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlICYmIChyYW5nZSBpbnN0YW5jZW9mIGRvbS5nZXRXaW5kb3cocmFuZ2Uuc3RhcnRDb250YWluZXIpLlJhbmdlKSkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZVJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByYW5nZUNvbnRhaW5zU2luZ2xlRWxlbWVudChyYW5nZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlTm9kZXMubGVuZ3RoIHx8IHJhbmdlTm9kZXNbMF0ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSByYW5nZU5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb20uaXNBbmNlc3Rvck9mKHJhbmdlTm9kZXNbMF0sIHJhbmdlTm9kZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNpbmdsZUVsZW1lbnRGcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHJhbmdlLmdldE5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNTaW5nbGVFbGVtZW50KG5vZGVzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcImdldFNpbmdsZUVsZW1lbnRGcm9tUmFuZ2U6IHJhbmdlIFwiICsgcmFuZ2UuaW5zcGVjdCgpICsgXCIgZGlkIG5vdCBjb25zaXN0IG9mIGEgc2luZ2xlIGVsZW1lbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW1wbGUsIHF1aWNrIHRlc3Qgd2hpY2ggb25seSBuZWVkcyB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGEgVGV4dFJhbmdlIGFuZCBhIENvbnRyb2xSYW5nZVxuICAgICAgICBmdW5jdGlvbiBpc1RleHRSYW5nZShyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhcmFuZ2UgJiYgdHlwZW9mIHJhbmdlLnRleHQgIT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUZyb21UZXh0UmFuZ2Uoc2VsLCByYW5nZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgUmFuZ2UgZnJvbSB0aGUgc2VsZWN0ZWQgVGV4dFJhbmdlXG4gICAgICAgICAgICB2YXIgd3JhcHBlZFJhbmdlID0gbmV3IFdyYXBwZWRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBzZWwuX3JhbmdlcyA9IFt3cmFwcGVkUmFuZ2VdO1xuXG4gICAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHdyYXBwZWRSYW5nZSwgZmFsc2UpO1xuICAgICAgICAgICAgc2VsLnJhbmdlQ291bnQgPSAxO1xuICAgICAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gd3JhcHBlZFJhbmdlLmNvbGxhcHNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGJhc2VkIG9uIHdoYXQncyBub3cgaW4gdGhlIG5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIHNlbC5fcmFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoc2VsLmRvY1NlbGVjdGlvbi50eXBlID09IFwiTm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHNlbC5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0UmFuZ2UoY29udHJvbFJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhc2UgKHdoZXJlIHRoZSBzZWxlY3Rpb24gdHlwZSBpcyBcIkNvbnRyb2xcIiBhbmQgY2FsbGluZyBjcmVhdGVSYW5nZSgpIG9uIHRoZSBzZWxlY3Rpb24gcmV0dXJuc1xuICAgICAgICAgICAgICAgICAgICAvLyBhIFRleHRSYW5nZSkgY2FuIGhhcHBlbiBpbiBJRSA5LiBJdCBoYXBwZW5zLCBmb3IgZXhhbXBsZSwgd2hlbiBhbGwgZWxlbWVudHMgaW4gdGhlIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2xSYW5nZSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBDb250cm9sUmFuZ2UgYW5kIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUZyb21UZXh0UmFuZ2Uoc2VsLCBjb250cm9sUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5yYW5nZUNvdW50ID0gY29udHJvbFJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlLCBkb2MgPSBnZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoY29udHJvbFJhbmdlLml0ZW0oaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLl9yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsLnJhbmdlQ291bnQgPT0gMSAmJiBzZWwuX3Jhbmdlc1swXS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgc2VsLl9yYW5nZXNbc2VsLnJhbmdlQ291bnQgLSAxXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFJhbmdlVG9Db250cm9sU2VsZWN0aW9uKHNlbCwgcmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSBzZWwuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgcmFuZ2VFbGVtZW50ID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBDb250cm9sUmFuZ2UgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RlZCBDb250cm9sUmFuZ2UgcGx1cyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgLy8gY29udGFpbmVkIGJ5IHRoZSBzdXBwbGllZCByYW5nZVxuICAgICAgICAgICAgdmFyIGRvYyA9IGdldERvY3VtZW50KGNvbnRyb2xSYW5nZS5pdGVtKDApKTtcbiAgICAgICAgICAgIHZhciBuZXdDb250cm9sUmFuZ2UgPSBnZXRCb2R5KGRvYykuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29udHJvbFJhbmdlLmFkZChjb250cm9sUmFuZ2UuaXRlbShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xSYW5nZS5hZGQocmFuZ2VFbGVtZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiYWRkUmFuZ2UoKTogRWxlbWVudCB3aXRoaW4gdGhlIHNwZWNpZmllZCBSYW5nZSBjb3VsZCBub3QgYmUgYWRkZWQgdG8gY29udHJvbCBzZWxlY3Rpb24gKGRvZXMgaXQgaGF2ZSBsYXlvdXQ/KVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0NvbnRyb2xSYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgICAgICB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0U2VsZWN0aW9uUmFuZ2VBdDtcblxuICAgICAgICBpZiAoaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZ2V0UmFuZ2VBdFwiKSkge1xuICAgICAgICAgICAgLy8gdHJ5L2NhdGNoIGlzIHByZXNlbnQgYmVjYXVzZSBnZXRSYW5nZUF0KCkgbXVzdCBoYXZlIHRocm93biBhbiBlcnJvciBpbiBzb21lIGJyb3dzZXIgYW5kIHNvbWUgc2l0dWF0aW9uLlxuICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSSBkaWRuJ3Qgd3JpdGUgYSBjb21tZW50IGFib3V0IHRoZSBzcGVjaWZpY3MgYW5kIGFtIG5vdyBzY2FyZWQgdG8gdGFrZSBpdCBvdXQuIExldCB0aGF0IGJlIGFcbiAgICAgICAgICAgIC8vIGxlc3NvbiB0byB1cyBhbGwsIGVzcGVjaWFsbHkgbWUuXG4gICAgICAgICAgICBnZXRTZWxlY3Rpb25SYW5nZUF0ID0gZnVuY3Rpb24oc2VsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWwuZ2V0UmFuZ2VBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cykge1xuICAgICAgICAgICAgZ2V0U2VsZWN0aW9uUmFuZ2VBdCA9IGZ1bmN0aW9uKHNlbCkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBbmRFbmQoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQsIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiB0aGUgc2VsZWN0aW9uIHdhcyBzZWxlY3RlZCBiYWNrd2FyZHMgKGZyb20gdGhlIGVuZCB0byB0aGUgc3RhcnQgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCAhPT0gdGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFuZEVuZChzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlZFNlbGVjdGlvbihzZWxlY3Rpb24sIGRvY1NlbGVjdGlvbiwgd2luKSB7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZG9jU2VsZWN0aW9uID0gZG9jU2VsZWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLndpbiA9IHdpbjtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgV3JhcHBlZFNlbGVjdGlvbi5wcm90b3R5cGUgPSBhcGkuc2VsZWN0aW9uUHJvdG90eXBlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnRpZXMoc2VsKSB7XG4gICAgICAgICAgICBzZWwud2luID0gc2VsLmFuY2hvck5vZGUgPSBzZWwuZm9jdXNOb2RlID0gc2VsLl9yYW5nZXMgPSBudWxsO1xuICAgICAgICAgICAgc2VsLnJhbmdlQ291bnQgPSBzZWwuYW5jaG9yT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHNlbC5kZXRhY2hlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FjaGVkUmFuZ3lTZWxlY3Rpb25zID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gYWN0T25DYWNoZWRTZWxlY3Rpb24od2luLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBpID0gY2FjaGVkUmFuZ3lTZWxlY3Rpb25zLmxlbmd0aCwgY2FjaGVkLCBzZWw7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkID0gY2FjaGVkUmFuZ3lTZWxlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIHNlbCA9IGNhY2hlZC5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBcImRlbGV0ZUFsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnRpZXMoc2VsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhY2hlZC53aW4gPT0gd2luKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmFuZ3lTZWxlY3Rpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXCJkZWxldGVBbGxcIikge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJhbmd5U2VsZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgUmFuZ3kgU2VsZWN0aW9uIG9iamVjdFxuICAgICAgICAgICAgaWYgKHdpbiAmJiB3aW4gaW5zdGFuY2VvZiBXcmFwcGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2luLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW4gPSBnZXRXaW5kb3cod2luLCBcImdldE5hdGl2ZVNlbGVjdGlvblwiKTtcblxuICAgICAgICAgICAgdmFyIHNlbCA9IGFjdE9uQ2FjaGVkU2VsZWN0aW9uKHdpbik7XG4gICAgICAgICAgICB2YXIgbmF0aXZlU2VsID0gZ2V0TmF0aXZlU2VsZWN0aW9uKHdpbiksIGRvY1NlbCA9IGltcGxlbWVudHNEb2NTZWxlY3Rpb24gPyBnZXREb2NTZWxlY3Rpb24od2luKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc2VsKSB7XG4gICAgICAgICAgICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbiA9IG5hdGl2ZVNlbDtcbiAgICAgICAgICAgICAgICBzZWwuZG9jU2VsZWN0aW9uID0gZG9jU2VsO1xuICAgICAgICAgICAgICAgIHNlbC5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbCA9IG5ldyBXcmFwcGVkU2VsZWN0aW9uKG5hdGl2ZVNlbCwgZG9jU2VsLCB3aW4pO1xuICAgICAgICAgICAgICAgIGNhY2hlZFJhbmd5U2VsZWN0aW9ucy5wdXNoKCB7IHdpbjogd2luLCBzZWxlY3Rpb246IHNlbCB9ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFwaS5nZXRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb247XG5cbiAgICAgICAgYXBpLmdldElmcmFtZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGlmcmFtZUVsKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGVwcmVjYXRpb25Ob3RpY2UoXCJnZXRJZnJhbWVTZWxlY3Rpb24oKVwiLCBcImdldFNlbGVjdGlvbihpZnJhbWVFbClcIik7XG4gICAgICAgICAgICByZXR1cm4gYXBpLmdldFNlbGVjdGlvbihkb20uZ2V0SWZyYW1lV2luZG93KGlmcmFtZUVsKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNlbFByb3RvID0gV3JhcHBlZFNlbGVjdGlvbi5wcm90b3R5cGU7XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ29udHJvbFNlbGVjdGlvbihzZWwsIHJhbmdlcykge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbGVjdGlvbiBiZWNvbWVzIG9mIHR5cGUgXCJDb250cm9sXCJcbiAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChyYW5nZXNbMF0uc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IGdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbCwgbGVuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbFJhbmdlLmFkZChlbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwic2V0UmFuZ2VzKCk6IEVsZW1lbnQgd2l0aGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIFJhbmdlcyBjb3VsZCBub3QgYmUgYWRkZWQgdG8gY29udHJvbCBzZWxlY3Rpb24gKGRvZXMgaXQgaGF2ZSBsYXlvdXQ/KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCdzIG5vdyBpbiB0aGUgbmF0aXZlIHNlbGVjdGlvblxuICAgICAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0aW5nIGEgcmFuZ2VcbiAgICAgICAgaWYgKCF1c2VEb2N1bWVudFNlbGVjdGlvbiAmJiBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyAmJiB1dGlsLmFyZUhvc3RNZXRob2RzKHRlc3RTZWxlY3Rpb24sIFtcInJlbW92ZUFsbFJhbmdlc1wiLCBcImFkZFJhbmdlXCJdKSkge1xuICAgICAgICAgICAgc2VsUHJvdG8ucmVtb3ZlQWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYWRkUmFuZ2VCYWNrd2FyZCA9IGZ1bmN0aW9uKHNlbCwgcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBhZGRSYW5nZUJhY2t3YXJkVG9OYXRpdmUoc2VsLm5hdGl2ZVNlbGVjdGlvbiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIHNlbC5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uSGFzUmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHNlbFByb3RvLmFkZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmIHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlyZWN0aW9uQmFja3dhcmQoZGlyZWN0aW9uKSAmJiBzZWxlY3Rpb25IYXNFeHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZUJhY2t3YXJkKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUmFuZ2VDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1JhbmdlQ291bnQgPSB0aGlzLnJhbmdlQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSYW5nZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIG5hdGl2ZSByYW5nZSBzbyB0aGF0IGNoYW5naW5nIHRoZSBzZWxlY3RlZCByYW5nZSBkb2VzIG5vdCBhZmZlY3QgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGNvbnRyYXJ5IHRvIHRoZSBzcGVjIGJ1dCBpcyB0aGUgb25seSB3YXkgdG8gYWNoaWV2ZSBjb25zaXN0ZW5jeSBiZXR3ZWVuIGJyb3dzZXJzLiBTZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpc3N1ZSA4MC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVNlbGVjdGlvbi5hZGRSYW5nZShnZXROYXRpdmVSYW5nZShyYW5nZSkuY2xvbmVSYW5nZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYWRkaW5nIHRoZSByYW5nZSB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMubmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09IHByZXZpb3VzUmFuZ2VDb3VudCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHdhcyBhZGRlZCBzdWNjZXNzZnVsbHlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByYW5nZSB0aGF0IHdlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gaXMgcmVmbGVjdGVkIGluIHRoZSBsYXN0IHJhbmdlIGV4dHJhY3RlZCBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwaS5jb25maWcuY2hlY2tTZWxlY3Rpb25SYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVSYW5nZSA9IGdldFNlbGVjdGlvblJhbmdlQXQodGhpcy5uYXRpdmVTZWxlY3Rpb24sIHRoaXMucmFuZ2VDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVJhbmdlICYmICFyYW5nZXNFcXVhbChuYXRpdmVSYW5nZSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFwcGVucyBpbiBXZWJLaXQgd2l0aCwgZm9yIGV4YW1wbGUsIGEgc2VsZWN0aW9uIHBsYWNlZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBXcmFwcGVkUmFuZ2UobmF0aXZlUmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jhbmdlc1t0aGlzLnJhbmdlQ291bnQgLSAxXSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZSh0aGlzLCByYW5nZSwgc2VsZWN0aW9uSXNCYWNrd2FyZCh0aGlzLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHdhcyBub3QgYWRkZWQgc3VjY2Vzc2Z1bGx5LiBUaGUgc2ltcGxlc3QgdGhpbmcgaXMgdG8gcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxQcm90by5hZGRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlyZWN0aW9uQmFja3dhcmQoZGlyZWN0aW9uKSAmJiBzZWxlY3Rpb25IYXNFeHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlQmFja3dhcmQodGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24uYWRkUmFuZ2UoZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgaW1wbGVtZW50c0RvY1NlbGVjdGlvbiAmJiByYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDb250cm9sU2VsZWN0aW9uKHRoaXMsIHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJlbXB0eVwiKSAmJiBpc0hvc3RNZXRob2QodGVzdFJhbmdlLCBcInNlbGVjdFwiKSAmJlxuICAgICAgICAgICAgICAgICAgIGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgdXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcblxuICAgICAgICAgICAgc2VsUHJvdG8ucmVtb3ZlQWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkZWQgdHJ5L2NhdGNoIGFzIGZpeCBmb3IgaXNzdWUgIzIxXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NTZWxlY3Rpb24uZW1wdHkoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZW1wdHkoKSBub3Qgd29ya2luZyAoaXNzdWUgIzI0KVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSAhPSBcIk5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZmFpbHVyZSB0byBlbXB0eSBhIGNvbnRyb2wgc2VsZWN0aW9uIGJ5IGluc3RlYWQgc2VsZWN0aW5nIGEgVGV4dFJhbmdlIGFuZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIGVtcHR5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmNob3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZ2V0RG9jdW1lbnQodGhpcy5hbmNob3JOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHRoaXMuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZ2V0RG9jdW1lbnQoIGNvbnRyb2xSYW5nZS5pdGVtKDApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UmFuZ2UgPSBnZXRCb2R5KGRvYykuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jU2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoKGV4KSB7fVxuICAgICAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2VsUHJvdG8uYWRkUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5XcmFwcGVkVGV4dFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UocmFuZ2UpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZXNbMF0gPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IHRoaXMuX3Jhbmdlc1swXS5jb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHRoaXMsIHJhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VDb3VudCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZmFpbChcIk5vIG1lYW5zIG9mIHNlbGVjdGluZyBhIFJhbmdlIG9yIFRleHRSYW5nZSB3YXMgZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxQcm90by5nZXRSYW5nZUF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOREVYX1NJWkVfRVJSXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgcmFuZ2UgdG8gcHJlc2VydmUgc2VsZWN0aW9uLXJhbmdlIGluZGVwZW5kZW5jZS4gU2VlIGlzc3VlIDgwLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5nZXNbaW5kZXhdLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVmcmVzaFNlbGVjdGlvbjtcblxuICAgICAgICBpZiAodXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKGFwaS5pc1NlbGVjdGlvblZhbGlkKHNlbC53aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZ2V0Qm9keShzZWwud2luLmRvY3VtZW50KS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dFJhbmdlKHJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJnZXRSYW5nZUF0XCIpICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLnJhbmdlQ291bnQgPT0gTlVNQkVSKSB7XG4gICAgICAgICAgICByZWZyZXNoU2VsZWN0aW9uID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgaW1wbGVtZW50c0RvY1NlbGVjdGlvbiAmJiBzZWwuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsLl9yYW5nZXMubGVuZ3RoID0gc2VsLnJhbmdlQ291bnQgPSBzZWwubmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbC5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuX3Jhbmdlc1tpXSA9IG5ldyBhcGkuV3JhcHBlZFJhbmdlKHNlbC5uYXRpdmVTZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHNlbC5fcmFuZ2VzW3NlbC5yYW5nZUNvdW50IC0gMV0sIHNlbGVjdGlvbklzQmFja3dhcmQoc2VsLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLmlzQ29sbGFwc2VkID09IEJPT0xFQU4gJiYgdHlwZW9mIHRlc3RSYW5nZS5jb2xsYXBzZWQgPT0gQk9PTEVBTiAmJiBmZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UpIHtcbiAgICAgICAgICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UsIG5hdGl2ZVNlbCA9IHNlbC5uYXRpdmVTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVNlbC5hbmNob3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZ2V0U2VsZWN0aW9uUmFuZ2VBdChuYXRpdmVTZWwsIDApO1xuICAgICAgICAgICAgICAgICAgICBzZWwuX3JhbmdlcyA9IFtyYW5nZV07XG4gICAgICAgICAgICAgICAgICAgIHNlbC5yYW5nZUNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKHNlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmZhaWwoXCJObyBtZWFucyBvZiBvYnRhaW5pbmcgYSBSYW5nZSBvciBUZXh0UmFuZ2UgZnJvbSB0aGUgdXNlcidzIHNlbGVjdGlvbiB3YXMgZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxQcm90by5yZWZyZXNoID0gZnVuY3Rpb24oY2hlY2tGb3JDaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgb2xkUmFuZ2VzID0gY2hlY2tGb3JDaGFuZ2VzID8gdGhpcy5fcmFuZ2VzLnNsaWNlKDApIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBvbGRBbmNob3JOb2RlID0gdGhpcy5hbmNob3JOb2RlLCBvbGRBbmNob3JPZmZzZXQgPSB0aGlzLmFuY2hvck9mZnNldDtcblxuICAgICAgICAgICAgcmVmcmVzaFNlbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIGlmIChjaGVja0ZvckNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgY291bnQgZmlyc3RcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG9sZFJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gdGhpcy5fcmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgdGhlIGRpcmVjdGlvbi4gQ2hlY2tpbmcgdGhlIGFuY2hvciBwb3NpdGlvbiBpcyB0aGUgc2FtZSBpcyBlbm91Z2ggc2luY2Ugd2UncmUgY2hlY2tpbmcgYWxsIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJhbmdlcyBhZnRlciB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5jaG9yTm9kZSAhPSBvbGRBbmNob3JOb2RlIHx8IHRoaXMuYW5jaG9yT2Zmc2V0ICE9IG9sZEFuY2hvck9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBjb21wYXJlIGVhY2ggcmFuZ2UgaW4gdHVyblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYW5nZXNFcXVhbChvbGRSYW5nZXNbaV0sIHRoaXMuX3Jhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZW1vdmFsIG9mIGEgc2luZ2xlIHJhbmdlXG4gICAgICAgIHZhciByZW1vdmVSYW5nZU1hbnVhbGx5ID0gZnVuY3Rpb24oc2VsLCByYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHNlbC5nZXRBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlc0VxdWFsKHJhbmdlLCByYW5nZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2VFbGVtZW50ID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IENvbnRyb2xSYW5nZSBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBtaW51cyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBjb250YWluZWQgYnkgdGhlIHN1cHBsaWVkIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb250cm9sUmFuZ2UgPSBnZXRCb2R5KGRvYykuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCwgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGNvbnRyb2xSYW5nZS5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsICE9PSByYW5nZUVsZW1lbnQgfHwgcmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xSYW5nZS5hZGQoY29udHJvbFJhbmdlLml0ZW0oaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmFuZ2VNYW51YWxseSh0aGlzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVSYW5nZU1hbnVhbGx5KHRoaXMsIHJhbmdlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3RpbmcgaWYgYSBzZWxlY3Rpb24gaXMgYmFja3dhcmRcbiAgICAgICAgdmFyIHNlbGVjdGlvbklzQmFja3dhcmQ7XG4gICAgICAgIGlmICghdXNlRG9jdW1lbnRTZWxlY3Rpb24gJiYgc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgJiYgZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Jc0JhY2t3YXJkID0gd2luU2VsZWN0aW9uSXNCYWNrd2FyZDtcblxuICAgICAgICAgICAgc2VsUHJvdG8uaXNCYWNrd2FyZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Jc0JhY2t3YXJkKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklzQmFja3dhcmQgPSBzZWxQcm90by5pc0JhY2t3YXJkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEZyb20gMS4zLCBldmVyeXRoaW5nIGlzIFwiYmFja3dhcmRcIiByYXRoZXIgdGhhbiBcImJhY2t3YXJkc1wiXG4gICAgICAgIHNlbFByb3RvLmlzQmFja3dhcmRzID0gc2VsUHJvdG8uaXNCYWNrd2FyZDtcblxuICAgICAgICAvLyBTZWxlY3Rpb24gc3RyaW5naWZpZXJcbiAgICAgICAgLy8gVGhpcyBpcyBjb25mb3JtYW50IHRvIHRoZSBvbGQgSFRNTDUgc2VsZWN0aW9ucyBkcmFmdCBzcGVjIGJ1dCBkaWZmZXJzIGZyb20gV2ViS2l0IGFuZCBNb3ppbGxhJ3MgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHNwZWMgZG9lcyBub3QgeWV0IGRlZmluZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgc2VsUHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVRleHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICByYW5nZVRleHRzW2ldID0gXCJcIiArIHRoaXMuX3Jhbmdlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZVRleHRzLmpvaW4oXCJcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50KHNlbCwgbm9kZSkge1xuICAgICAgICAgICAgaWYgKHNlbC53aW4uZG9jdW1lbnQgIT0gZ2V0RG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gY3VycmVudCBicm93c2VyIGNvbmZvcm1zIGZ1bGx5IHRvIHRoZSBzcGVjIGZvciB0aGlzIG1ldGhvZCwgc28gUmFuZ3kncyBvd24gbWV0aG9kIGlzIGFsd2F5cyB1c2VkXG4gICAgICAgIHNlbFByb3RvLmNvbGxhcHNlID0gZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBhc3NlcnROb2RlSW5TYW1lRG9jdW1lbnQodGhpcywgbm9kZSk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2Uobm9kZSk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZVRvUG9pbnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2luZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uY29sbGFwc2VUb1N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLmNvbGxhcHNlVG9FbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZXNbdGhpcy5yYW5nZUNvdW50IC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGUgc3BlYyBpcyB2ZXJ5IHNwZWNpZmljIG9uIGhvdyBzZWxlY3RBbGxDaGlsZHJlbiBzaG91bGQgYmUgaW1wbGVtZW50ZWQgc28gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpc1xuICAgICAgICAvLyBuZXZlciB1c2VkIGJ5IFJhbmd5LlxuICAgICAgICBzZWxQcm90by5zZWxlY3RBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGFzc2VydE5vZGVJblNhbWVEb2N1bWVudCh0aGlzLCBub2RlKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShub2RlKTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2luZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLmRlbGV0ZUZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2VwY2lhbCBiZWhhdmlvdXIgcmVxdWlyZWQgZm9yIElFJ3MgY29udHJvbCBzZWxlY3Rpb25zXG4gICAgICAgICAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmIHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb250cm9sUmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjb250cm9sUmFuZ2UuaXRlbSgwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbFJhbmdlLnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZ2V0QWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzW2ldLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNwZWMgc2F5cyBub3RoaW5nIGFib3V0IHdoYXQgdGhlIHNlbGVjdGlvbiBzaG91bGQgY29udGFpbiBhZnRlciBjYWxsaW5nIGRlbGV0ZUNvbnRlbnRzIG9uIGVhY2hcbiAgICAgICAgICAgICAgICAgICAgLy8gcmFuZ2UuIEZpcmVmb3ggbW92ZXMgdGhlIHNlbGVjdGlvbiB0byB3aGVyZSB0aGUgZmluYWwgc2VsZWN0ZWQgcmFuZ2Ugd2FzLCBzbyB3ZSBlbXVsYXRlIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbbGVuIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSBub24tc3RhbmRhcmQgZXh0ZW5zaW9uc1xuICAgICAgICBzZWxQcm90by5lYWNoUmFuZ2UgPSBmdW5jdGlvbihmdW5jLCByZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3Jhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICggZnVuYyggdGhpcy5nZXRSYW5nZUF0KGkpICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uZ2V0QWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLmVhY2hSYW5nZShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5zZXRTaW5nbGVSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLmFkZFJhbmdlKHJhbmdlLCBkaXJlY3Rpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLmNhbGxNZXRob2RPbkVhY2hSYW5nZSA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZWFjaFJhbmdlKCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggcmFuZ2VbbWV0aG9kTmFtZV0uYXBwbHkocmFuZ2UsIHBhcmFtcykgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU3RhcnRPckVuZFNldHRlcihpc1N0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlW1wic2V0XCIgKyAoaXNTdGFydCA/IFwiU3RhcnRcIiA6IFwiRW5kXCIpXShub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKHRoaXMud2luLmRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBbmRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaW5nbGVSYW5nZShyYW5nZSwgdGhpcy5pc0JhY2t3YXJkKCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbFByb3RvLnNldFN0YXJ0ID0gY3JlYXRlU3RhcnRPckVuZFNldHRlcih0cnVlKTtcbiAgICAgICAgc2VsUHJvdG8uc2V0RW5kID0gY3JlYXRlU3RhcnRPckVuZFNldHRlcihmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgc2VsZWN0KCkgbWV0aG9kIHRvIFJhbmdlIHByb3RvdHlwZS4gQW55IGV4aXN0aW5nIHNlbGVjdGlvbiB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgIGFwaS5yYW5nZVByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGdldFNlbGVjdGlvbiggdGhpcy5nZXREb2N1bWVudCgpICkuc2V0U2luZ2xlUmFuZ2UodGhpcywgZGlyZWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5jaGFuZ2VFYWNoUmFuZ2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICAgICAgICB2YXIgYmFja3dhcmQgPSB0aGlzLmlzQmFja3dhcmQoKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoUmFuZ2UoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmdW5jKHJhbmdlKTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIGlmIChiYWNrd2FyZCAmJiByYW5nZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJhbmdlKHJhbmdlc1swXSwgXCJiYWNrd2FyZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5jb250YWluc05vZGUgPSBmdW5jdGlvbihub2RlLCBhbGxvd1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2hSYW5nZSggZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UuY29udGFpbnNOb2RlKG5vZGUsIGFsbG93UGFydGlhbCk7XG4gICAgICAgICAgICB9LCB0cnVlICkgfHwgZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uZ2V0Qm9va21hcmsgPSBmdW5jdGlvbihjb250YWluZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJhY2t3YXJkOiB0aGlzLmlzQmFja3dhcmQoKSxcbiAgICAgICAgICAgICAgICByYW5nZUJvb2ttYXJrczogdGhpcy5jYWxsTWV0aG9kT25FYWNoUmFuZ2UoXCJnZXRCb29rbWFya1wiLCBbY29udGFpbmVyTm9kZV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLm1vdmVUb0Jvb2ttYXJrID0gZnVuY3Rpb24oYm9va21hcmspIHtcbiAgICAgICAgICAgIHZhciBzZWxSYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByYW5nZUJvb2ttYXJrLCByYW5nZTsgcmFuZ2VCb29rbWFyayA9IGJvb2ttYXJrLnJhbmdlQm9va21hcmtzW2krK107ICkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKHRoaXMud2luKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlVG9Cb29rbWFyayhyYW5nZUJvb2ttYXJrKTtcbiAgICAgICAgICAgICAgICBzZWxSYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm9va21hcmsuYmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNpbmdsZVJhbmdlKHNlbFJhbmdlc1swXSwgXCJiYWNrd2FyZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZXMoc2VsUmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by50b0h0bWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByYW5nZUh0bWxzID0gW107XG4gICAgICAgICAgICB0aGlzLmVhY2hSYW5nZShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlSHRtbHMucHVzaCggRG9tUmFuZ2UudG9IdG1sKHJhbmdlKSApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VIdG1scy5qb2luKFwiXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChmZWF0dXJlcy5pbXBsZW1lbnRzVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICBzZWxQcm90by5nZXROYXRpdmVUZXh0UmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsLCB0ZXh0UmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKCAoc2VsID0gdGhpcy5kb2NTZWxlY3Rpb24pICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWwuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGV4dFJhbmdlKHJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbW9kdWxlLmNyZWF0ZUVycm9yKFwiZ2V0TmF0aXZlVGV4dFJhbmdlOiBzZWxlY3Rpb24gaXMgYSBjb250cm9sIHNlbGVjdGlvblwiKTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5XcmFwcGVkVGV4dFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UoIHRoaXMuZ2V0UmFuZ2VBdCgwKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1vZHVsZS5jcmVhdGVFcnJvcihcImdldE5hdGl2ZVRleHRSYW5nZTogc2VsZWN0aW9uIGNvbnRhaW5zIG5vIHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNwZWN0KHNlbCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlSW5zcGVjdHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBuZXcgRG9tUG9zaXRpb24oc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gbmV3IERvbVBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICh0eXBlb2Ygc2VsLmdldE5hbWUgPT0gXCJmdW5jdGlvblwiKSA/IHNlbC5nZXROYW1lKCkgOiBcIlNlbGVjdGlvblwiO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbC5yYW5nZUNvdW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsLnJhbmdlQ291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZUluc3BlY3RzW2ldID0gRG9tUmFuZ2UuaW5zcGVjdChzZWwuZ2V0UmFuZ2VBdChpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgbmFtZSArIFwiKFJhbmdlczogXCIgKyByYW5nZUluc3BlY3RzLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiKShhbmNob3I6IFwiICsgYW5jaG9yLmluc3BlY3QoKSArIFwiLCBmb2N1czogXCIgKyBmb2N1cy5pbnNwZWN0KCkgKyBcIl1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBcIldyYXBwZWRTZWxlY3Rpb25cIjtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdCh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxQcm90by5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFjdE9uQ2FjaGVkU2VsZWN0aW9uKHRoaXMud2luLCBcImRlbGV0ZVwiKTtcbiAgICAgICAgICAgIGRlbGV0ZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgV3JhcHBlZFNlbGVjdGlvbi5kZXRhY2hBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFjdE9uQ2FjaGVkU2VsZWN0aW9uKG51bGwsIFwiZGVsZXRlQWxsXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFdyYXBwZWRTZWxlY3Rpb24uaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgICAgIFdyYXBwZWRTZWxlY3Rpb24uaXNEaXJlY3Rpb25CYWNrd2FyZCA9IGlzRGlyZWN0aW9uQmFja3dhcmQ7XG5cbiAgICAgICAgYXBpLlNlbGVjdGlvbiA9IFdyYXBwZWRTZWxlY3Rpb247XG5cbiAgICAgICAgYXBpLnNlbGVjdGlvblByb3RvdHlwZSA9IHNlbFByb3RvO1xuXG4gICAgICAgIGFwaS5hZGRTaGltTGlzdGVuZXIoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbi5nZXRTZWxlY3Rpb24gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHdpbi5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFNlbGVjdGlvbih3aW4pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW4gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICByZXR1cm4gYXBpO1xufSwgdGhpcyk7Oy8qKlxuICogU2VsZWN0aW9uIHNhdmUgYW5kIHJlc3RvcmUgbW9kdWxlIGZvciBSYW5neS5cbiAqIFNhdmVzIGFuZCByZXN0b3JlcyB1c2VyIHNlbGVjdGlvbnMgdXNpbmcgbWFya2VyIGludmlzaWJsZSBlbGVtZW50cyBpbiB0aGUgRE9NLlxuICpcbiAqIFBhcnQgb2YgUmFuZ3ksIGEgY3Jvc3MtYnJvd3NlciBKYXZhU2NyaXB0IHJhbmdlIGFuZCBzZWxlY3Rpb24gbGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Jhbmd5L1xuICpcbiAqIERlcGVuZHMgb24gUmFuZ3kgY29yZS5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCwgVGltIERvd25cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIFZlcnNpb246IDEuM2FscGhhLjIwMTQwODA0XG4gKiBCdWlsZCBkYXRlOiA0IEF1Z3VzdCAyMDE0XG4gKi9cbihmdW5jdGlvbihmYWN0b3J5LCBnbG9iYWwpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUgd2l0aCBhIGRlcGVuZGVuY3kgb24gUmFuZ3kuXG4gICAgICAgIGRlZmluZShbXCJyYW5neVwiXSwgZmFjdG9yeSk7XG4gICAgICAgIC8qXG4gICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgIC8vIE5vZGUvQ29tbW9uSlMgc3R5bGUgZm9yIEJyb3dzZXJpZnlcbiAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiAgICAgICAgICovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gQU1EIG9yIENvbW1vbkpTIHN1cHBvcnQgc28gd2UgdXNlIHRoZSByYW5neSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgZmFjdG9yeShnbG9iYWwucmFuZ3kpO1xuICAgIH1cbn0pKGZ1bmN0aW9uKHJhbmd5KSB7XG4gICAgcmFuZ3kuY3JlYXRlTW9kdWxlKFwiU2F2ZVJlc3RvcmVcIiwgW1wiV3JhcHBlZFJhbmdlXCJdLCBmdW5jdGlvbihhcGksIG1vZHVsZSkge1xuICAgICAgICB2YXIgZG9tID0gYXBpLmRvbTtcblxuICAgICAgICB2YXIgbWFya2VyVGV4dENoYXIgPSBcIlxcdWZlZmZcIjtcblxuICAgICAgICBmdW5jdGlvbiBnRUJJKGlkLCBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiAoZG9jIHx8IGRvY3VtZW50KS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRSYW5nZUJvdW5kYXJ5TWFya2VyKHJhbmdlLCBhdFN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgbWFya2VySWQgPSBcInNlbGVjdGlvbkJvdW5kYXJ5X1wiICsgKCtuZXcgRGF0ZSgpKSArIFwiX1wiICsgKFwiXCIgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcbiAgICAgICAgICAgIHZhciBtYXJrZXJFbDtcbiAgICAgICAgICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQocmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgUmFuZ2UgYW5kIGNvbGxhcHNlIHRvIHRoZSBhcHByb3ByaWF0ZSBib3VuZGFyeSBwb2ludFxuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5UmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICBib3VuZGFyeVJhbmdlLmNvbGxhcHNlKGF0U3RhcnQpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG1hcmtlciBlbGVtZW50IGNvbnRhaW5pbmcgYSBzaW5nbGUgaW52aXNpYmxlIGNoYXJhY3RlciB1c2luZyBET00gbWV0aG9kcyBhbmQgaW5zZXJ0IGl0XG4gICAgICAgICAgICBtYXJrZXJFbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIG1hcmtlckVsLmlkID0gbWFya2VySWQ7XG4gICAgICAgICAgICBtYXJrZXJFbC5zdHlsZS5saW5lSGVpZ2h0ID0gXCIwXCI7XG4gICAgICAgICAgICBtYXJrZXJFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBtYXJrZXJFbC5jbGFzc05hbWUgPSBcInJhbmd5U2VsZWN0aW9uQm91bmRhcnlcIjtcbiAgICAgICAgICAgIG1hcmtlckVsLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShtYXJrZXJUZXh0Q2hhcikpO1xuXG4gICAgICAgICAgICBib3VuZGFyeVJhbmdlLmluc2VydE5vZGUobWFya2VyRWwpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckVsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0UmFuZ2VCb3VuZGFyeShkb2MsIHJhbmdlLCBtYXJrZXJJZCwgYXRTdGFydCkge1xuICAgICAgICAgICAgdmFyIG1hcmtlckVsID0gZ0VCSShtYXJrZXJJZCwgZG9jKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXJFbCkge1xuICAgICAgICAgICAgICAgIHJhbmdlW2F0U3RhcnQgPyBcInNldFN0YXJ0QmVmb3JlXCIgOiBcInNldEVuZEJlZm9yZVwiXShtYXJrZXJFbCk7XG4gICAgICAgICAgICAgICAgbWFya2VyRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtYXJrZXJFbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZHVsZS53YXJuKFwiTWFya2VyIGVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZC4gQ2Fubm90IHJlc3RvcmUgc2VsZWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocjEsIHIyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjIuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKHIxLlNUQVJUX1RPX1NUQVJULCByMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzYXZlUmFuZ2UocmFuZ2UsIGJhY2t3YXJkKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbCwgZW5kRWwsIGRvYyA9IGFwaS5Eb21SYW5nZS5nZXRSYW5nZURvY3VtZW50KHJhbmdlKSwgdGV4dCA9IHJhbmdlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICBlbmRFbCA9IGluc2VydFJhbmdlQm91bmRhcnlNYXJrZXIocmFuZ2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogZG9jLFxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJJZDogZW5kRWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZEVsID0gaW5zZXJ0UmFuZ2VCb3VuZGFyeU1hcmtlcihyYW5nZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YXJ0RWwgPSBpbnNlcnRSYW5nZUJvdW5kYXJ5TWFya2VyKHJhbmdlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBkb2MsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWFya2VySWQ6IHN0YXJ0RWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGVuZE1hcmtlcklkOiBlbmRFbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYmFja3dhcmQ6IGJhY2t3YXJkLFxuICAgICAgICAgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcmlnaW5hbCB0ZXh0OiAnXCIgKyB0ZXh0ICsgXCInLCBuZXcgdGV4dDogJ1wiICsgcmFuZ2UudG9TdHJpbmcoKSArIFwiJ1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlc3RvcmVSYW5nZShyYW5nZUluZm8sIG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHJhbmdlSW5mby5kb2N1bWVudDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9ybWFsaXplID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgICBpZiAocmFuZ2VJbmZvLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJFbCA9IGdFQkkocmFuZ2VJbmZvLm1hcmtlcklkLCBkb2MpO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJFbCkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJFbC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzTm9kZSA9IG1hcmtlckVsLnByZXZpb3VzU2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBpc3N1ZSAxN1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNOb2RlICYmIHByZXZpb3VzTm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1hcmtlckVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlVG9Qb2ludChwcmV2aW91c05vZGUsIHByZXZpb3VzTm9kZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2VCZWZvcmUobWFya2VyRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtYXJrZXJFbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUud2FybihcIk1hcmtlciBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQuIENhbm5vdCByZXN0b3JlIHNlbGVjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRSYW5nZUJvdW5kYXJ5KGRvYywgcmFuZ2UsIHJhbmdlSW5mby5zdGFydE1hcmtlcklkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZXRSYW5nZUJvdW5kYXJ5KGRvYywgcmFuZ2UsIHJhbmdlSW5mby5lbmRNYXJrZXJJZCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uubm9ybWFsaXplQm91bmRhcmllcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzYXZlUmFuZ2VzKHJhbmdlcywgYmFja3dhcmQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZUluZm9zID0gW10sIHJhbmdlLCBkb2M7XG5cbiAgICAgICAgICAgIC8vIE9yZGVyIHRoZSByYW5nZXMgYnkgcG9zaXRpb24gd2l0aGluIHRoZSBET00sIGxhdGVzdCBmaXJzdCwgY2xvbmluZyB0aGUgYXJyYXkgdG8gbGVhdmUgdGhlIG9yaWdpbmFsIHVudG91Y2hlZFxuICAgICAgICAgICAgcmFuZ2VzID0gcmFuZ2VzLnNsaWNlKDApO1xuICAgICAgICAgICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICByYW5nZUluZm9zW2ldID0gc2F2ZVJhbmdlKHJhbmdlc1tpXSwgYmFja3dhcmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3cgdGhhdCBhbGwgdGhlIG1hcmtlcnMgYXJlIGluIHBsYWNlIGFuZCBET00gbWFuaXB1bGF0aW9uIG92ZXIsIGFkanVzdCBlYWNoIHJhbmdlJ3MgYm91bmRhcmllcyB0byBsaWVcbiAgICAgICAgICAgIC8vIGJldHdlZW4gaXRzIG1hcmtlcnNcbiAgICAgICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgZG9jID0gYXBpLkRvbVJhbmdlLmdldFJhbmdlRG9jdW1lbnQocmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2VBZnRlcihnRUJJKHJhbmdlSW5mb3NbaV0ubWFya2VySWQsIGRvYykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShnRUJJKHJhbmdlSW5mb3NbaV0uZW5kTWFya2VySWQsIGRvYykpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKGdFQkkocmFuZ2VJbmZvc1tpXS5zdGFydE1hcmtlcklkLCBkb2MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByYW5nZUluZm9zO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2F2ZVNlbGVjdGlvbih3aW4pIHtcbiAgICAgICAgICAgIGlmICghYXBpLmlzU2VsZWN0aW9uVmFsaWQod2luKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS53YXJuKFwiQ2Fubm90IHNhdmUgc2VsZWN0aW9uLiBUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkIGFuZCB0aGUgc2VsZWN0aW9uIGRvY3VtZW50IGhhcyBsb3N0IGZvY3VzLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWwgPSBhcGkuZ2V0U2VsZWN0aW9uKHdpbik7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2VsLmdldEFsbFJhbmdlcygpO1xuICAgICAgICAgICAgdmFyIGJhY2t3YXJkID0gKHJhbmdlcy5sZW5ndGggPT0gMSAmJiBzZWwuaXNCYWNrd2FyZCgpKTtcblxuICAgICAgICAgICAgdmFyIHJhbmdlSW5mb3MgPSBzYXZlUmFuZ2VzKHJhbmdlcywgYmFja3dhcmQpO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgY3VycmVudCBzZWxlY3Rpb24gaXMgdW5hZmZlY3RlZFxuICAgICAgICAgICAgaWYgKGJhY2t3YXJkKSB7XG4gICAgICAgICAgICAgICAgc2VsLnNldFNpbmdsZVJhbmdlKHJhbmdlc1swXSwgXCJiYWNrd2FyZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsLnNldFJhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpbjogd2luLFxuICAgICAgICAgICAgICAgIHJhbmdlSW5mb3M6IHJhbmdlSW5mb3MsXG4gICAgICAgICAgICAgICAgcmVzdG9yZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzdG9yZVJhbmdlcyhyYW5nZUluZm9zKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gW107XG5cbiAgICAgICAgICAgIC8vIFJhbmdlcyBhcmUgaW4gcmV2ZXJzZSBvcmRlciBvZiBhcHBlYXJhbmNlIGluIHRoZSBET00uIFdlIHdhbnQgdG8gcmVzdG9yZSBlYXJsaWVzdCBmaXJzdCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiBhZmZlY3RpbmcgcHJldmlvdXNseSByZXN0b3JlZCByYW5nZXMuXG4gICAgICAgICAgICB2YXIgcmFuZ2VDb3VudCA9IHJhbmdlSW5mb3MubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcmFuZ2VDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzW2ldID0gcmVzdG9yZVJhbmdlKHJhbmdlSW5mb3NbaV0sIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihzYXZlZFNlbGVjdGlvbiwgcHJlc2VydmVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghc2F2ZWRTZWxlY3Rpb24ucmVzdG9yZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VJbmZvcyA9IHNhdmVkU2VsZWN0aW9uLnJhbmdlSW5mb3M7XG4gICAgICAgICAgICAgICAgdmFyIHNlbCA9IGFwaS5nZXRTZWxlY3Rpb24oc2F2ZWRTZWxlY3Rpb24ud2luKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gcmVzdG9yZVJhbmdlcyhyYW5nZUluZm9zKSwgcmFuZ2VDb3VudCA9IHJhbmdlSW5mb3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlQ291bnQgPT0gMSAmJiBwcmVzZXJ2ZURpcmVjdGlvbiAmJiBhcGkuZmVhdHVyZXMuc2VsZWN0aW9uSGFzRXh0ZW5kICYmIHJhbmdlSW5mb3NbMF0uYmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2VzWzBdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWwuc2V0UmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2F2ZWRTZWxlY3Rpb24ucmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTWFya2VyRWxlbWVudChkb2MsIG1hcmtlcklkKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyRWwgPSBnRUJJKG1hcmtlcklkLCBkb2MpO1xuICAgICAgICAgICAgaWYgKG1hcmtlckVsKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtYXJrZXJFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVNYXJrZXJzKHNhdmVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VJbmZvcyA9IHNhdmVkU2VsZWN0aW9uLnJhbmdlSW5mb3M7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFuZ2VJbmZvcy5sZW5ndGgsIHJhbmdlSW5mbzsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VJbmZvID0gcmFuZ2VJbmZvc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VJbmZvLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVNYXJrZXJFbGVtZW50KHNhdmVkU2VsZWN0aW9uLmRvYywgcmFuZ2VJbmZvLm1hcmtlcklkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVNYXJrZXJFbGVtZW50KHNhdmVkU2VsZWN0aW9uLmRvYywgcmFuZ2VJbmZvLnN0YXJ0TWFya2VySWQpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVNYXJrZXJFbGVtZW50KHNhdmVkU2VsZWN0aW9uLmRvYywgcmFuZ2VJbmZvLmVuZE1hcmtlcklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcGkudXRpbC5leHRlbmQoYXBpLCB7XG4gICAgICAgICAgICBzYXZlUmFuZ2U6IHNhdmVSYW5nZSxcbiAgICAgICAgICAgIHJlc3RvcmVSYW5nZTogcmVzdG9yZVJhbmdlLFxuICAgICAgICAgICAgc2F2ZVJhbmdlczogc2F2ZVJhbmdlcyxcbiAgICAgICAgICAgIHJlc3RvcmVSYW5nZXM6IHJlc3RvcmVSYW5nZXMsXG4gICAgICAgICAgICBzYXZlU2VsZWN0aW9uOiBzYXZlU2VsZWN0aW9uLFxuICAgICAgICAgICAgcmVzdG9yZVNlbGVjdGlvbjogcmVzdG9yZVNlbGVjdGlvbixcbiAgICAgICAgICAgIHJlbW92ZU1hcmtlckVsZW1lbnQ6IHJlbW92ZU1hcmtlckVsZW1lbnQsXG4gICAgICAgICAgICByZW1vdmVNYXJrZXJzOiByZW1vdmVNYXJrZXJzXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxufSwgdGhpcyk7Oy8qXG5cdEJhc2UuanMsIHZlcnNpb24gMS4xYVxuXHRDb3B5cmlnaHQgMjAwNi0yMDEwLCBEZWFuIEVkd2FyZHNcblx0TGljZW5zZTogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiovXG5cbnZhciBCYXNlID0gZnVuY3Rpb24oKSB7XG5cdC8vIGR1bW15XG59O1xuXG5CYXNlLmV4dGVuZCA9IGZ1bmN0aW9uKF9pbnN0YW5jZSwgX3N0YXRpYykgeyAvLyBzdWJjbGFzc1xuXHR2YXIgZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kO1xuXHRcblx0Ly8gYnVpbGQgdGhlIHByb3RvdHlwZVxuXHRCYXNlLl9wcm90b3R5cGluZyA9IHRydWU7XG5cdHZhciBwcm90byA9IG5ldyB0aGlzO1xuXHRleHRlbmQuY2FsbChwcm90bywgX2luc3RhbmNlKTtcbiAgcHJvdG8uYmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNhbGwgdGhpcyBtZXRob2QgZnJvbSBhbnkgb3RoZXIgbWV0aG9kIHRvIGludm9rZSB0aGF0IG1ldGhvZCdzIGFuY2VzdG9yXG4gIH07XG5cdGRlbGV0ZSBCYXNlLl9wcm90b3R5cGluZztcblx0XG5cdC8vIGNyZWF0ZSB0aGUgd3JhcHBlciBmb3IgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG5cdC8vdmFyIGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IudmFsdWVPZigpOyAvLy1kZWFuXG5cdHZhciBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yO1xuXHR2YXIga2xhc3MgPSBwcm90by5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghQmFzZS5fcHJvdG90eXBpbmcpIHtcblx0XHRcdGlmICh0aGlzLl9jb25zdHJ1Y3RpbmcgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBrbGFzcykgeyAvLyBpbnN0YW50aWF0aW9uXG5cdFx0XHRcdHRoaXMuX2NvbnN0cnVjdGluZyA9IHRydWU7XG5cdFx0XHRcdGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jb25zdHJ1Y3Rpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSAhPSBudWxsKSB7IC8vIGNhc3Rpbmdcblx0XHRcdFx0cmV0dXJuIChhcmd1bWVudHNbMF0uZXh0ZW5kIHx8IGV4dGVuZCkuY2FsbChhcmd1bWVudHNbMF0sIHByb3RvKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHQvLyBidWlsZCB0aGUgY2xhc3MgaW50ZXJmYWNlXG5cdGtsYXNzLmFuY2VzdG9yID0gdGhpcztcblx0a2xhc3MuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XG5cdGtsYXNzLmZvckVhY2ggPSB0aGlzLmZvckVhY2g7XG5cdGtsYXNzLmltcGxlbWVudCA9IHRoaXMuaW1wbGVtZW50O1xuXHRrbGFzcy5wcm90b3R5cGUgPSBwcm90bztcblx0a2xhc3MudG9TdHJpbmcgPSB0aGlzLnRvU3RyaW5nO1xuXHRrbGFzcy52YWx1ZU9mID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdC8vcmV0dXJuICh0eXBlID09IFwib2JqZWN0XCIpID8ga2xhc3MgOiBjb25zdHJ1Y3RvcjsgLy8tZGVhblxuXHRcdHJldHVybiAodHlwZSA9PSBcIm9iamVjdFwiKSA/IGtsYXNzIDogY29uc3RydWN0b3IudmFsdWVPZigpO1xuXHR9O1xuXHRleHRlbmQuY2FsbChrbGFzcywgX3N0YXRpYyk7XG5cdC8vIGNsYXNzIGluaXRpYWxpc2F0aW9uXG5cdGlmICh0eXBlb2Yga2xhc3MuaW5pdCA9PSBcImZ1bmN0aW9uXCIpIGtsYXNzLmluaXQoKTtcblx0cmV0dXJuIGtsYXNzO1xufTtcblxuQmFzZS5wcm90b3R5cGUgPSB7XHRcblx0ZXh0ZW5kOiBmdW5jdGlvbihzb3VyY2UsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IC8vIGV4dGVuZGluZyB3aXRoIGEgbmFtZS92YWx1ZSBwYWlyXG5cdFx0XHR2YXIgYW5jZXN0b3IgPSB0aGlzW3NvdXJjZV07XG5cdFx0XHRpZiAoYW5jZXN0b3IgJiYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpICYmIC8vIG92ZXJyaWRpbmcgYSBtZXRob2Q/XG5cdFx0XHRcdC8vIHRoZSB2YWx1ZU9mKCkgY29tcGFyaXNvbiBpcyB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG5cdFx0XHRcdCghYW5jZXN0b3IudmFsdWVPZiB8fCBhbmNlc3Rvci52YWx1ZU9mKCkgIT0gdmFsdWUudmFsdWVPZigpKSAmJlxuXHRcdFx0XHQvXFxiYmFzZVxcYi8udGVzdCh2YWx1ZSkpIHtcblx0XHRcdFx0Ly8gZ2V0IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuXHRcdFx0XHR2YXIgbWV0aG9kID0gdmFsdWUudmFsdWVPZigpO1xuXHRcdFx0XHQvLyBvdmVycmlkZVxuXHRcdFx0XHR2YWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwcmV2aW91cyA9IHRoaXMuYmFzZSB8fCBCYXNlLnByb3RvdHlwZS5iYXNlO1xuXHRcdFx0XHRcdHRoaXMuYmFzZSA9IGFuY2VzdG9yO1xuXHRcdFx0XHRcdHZhciByZXR1cm5WYWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdHRoaXMuYmFzZSA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gcG9pbnQgdG8gdGhlIHVuZGVybHlpbmcgbWV0aG9kXG5cdFx0XHRcdHZhbHVlLnZhbHVlT2YgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuICh0eXBlID09IFwib2JqZWN0XCIpID8gdmFsdWUgOiBtZXRob2Q7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhbHVlLnRvU3RyaW5nID0gQmFzZS50b1N0cmluZztcblx0XHRcdH1cblx0XHRcdHRoaXNbc291cmNlXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAoc291cmNlKSB7IC8vIGV4dGVuZGluZyB3aXRoIGFuIG9iamVjdCBsaXRlcmFsXG5cdFx0XHR2YXIgZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kO1xuXHRcdFx0Ly8gaWYgdGhpcyBvYmplY3QgaGFzIGEgY3VzdG9taXNlZCBleHRlbmQgbWV0aG9kIHRoZW4gdXNlIGl0XG5cdFx0XHRpZiAoIUJhc2UuX3Byb3RvdHlwaW5nICYmIHR5cGVvZiB0aGlzICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHRlbmQgPSB0aGlzLmV4dGVuZCB8fCBleHRlbmQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcHJvdG8gPSB7dG9Tb3VyY2U6IG51bGx9O1xuXHRcdFx0Ly8gZG8gdGhlIFwidG9TdHJpbmdcIiBhbmQgb3RoZXIgbWV0aG9kcyBtYW51YWxseVxuXHRcdFx0dmFyIGhpZGRlbiA9IFtcImNvbnN0cnVjdG9yXCIsIFwidG9TdHJpbmdcIiwgXCJ2YWx1ZU9mXCJdO1xuXHRcdFx0Ly8gaWYgd2UgYXJlIHByb3RvdHlwaW5nIHRoZW4gaW5jbHVkZSB0aGUgY29uc3RydWN0b3Jcblx0XHRcdHZhciBpID0gQmFzZS5fcHJvdG90eXBpbmcgPyAwIDogMTtcblx0XHRcdHdoaWxlIChrZXkgPSBoaWRkZW5baSsrXSkge1xuXHRcdFx0XHRpZiAoc291cmNlW2tleV0gIT0gcHJvdG9ba2V5XSkge1xuXHRcdFx0XHRcdGV4dGVuZC5jYWxsKHRoaXMsIGtleSwgc291cmNlW2tleV0pO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGNvcHkgZWFjaCBvZiB0aGUgc291cmNlIG9iamVjdCdzIHByb3BlcnRpZXMgdG8gdGhpcyBvYmplY3Rcblx0XHRcdGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0aWYgKCFwcm90b1trZXldKSBleHRlbmQuY2FsbCh0aGlzLCBrZXksIHNvdXJjZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vIGluaXRpYWxpc2VcbkJhc2UgPSBCYXNlLmV4dGVuZCh7XG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmV4dGVuZChhcmd1bWVudHNbMF0pO1xuXHR9XG59LCB7XG5cdGFuY2VzdG9yOiBPYmplY3QsXG5cdHZlcnNpb246IFwiMS4xXCIsXG5cdFxuXHRmb3JFYWNoOiBmdW5jdGlvbihvYmplY3QsIGJsb2NrLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHRcdFx0aWYgKHRoaXMucHJvdG90eXBlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRibG9jay5jYWxsKGNvbnRleHQsIG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcdFxuXHRpbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0Ly8gaWYgaXQncyBhIGZ1bmN0aW9uLCBjYWxsIGl0XG5cdFx0XHRcdGFyZ3VtZW50c1tpXSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBhZGQgdGhlIGludGVyZmFjZSB1c2luZyB0aGUgZXh0ZW5kIG1ldGhvZFxuXHRcdFx0XHR0aGlzLnByb3RvdHlwZS5leHRlbmQoYXJndW1lbnRzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG5cdH1cbn0pOzsvKipcbiAqIERldGVjdCBicm93c2VyIHN1cHBvcnQgZm9yIHNwZWNpZmljIGZlYXR1cmVzXG4gKi9cbnd5c2lodG1sNS5icm93c2VyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdXNlckFnZW50ICAgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgLy8gQnJvd3NlciBzbmlmZmluZyBpcyB1bmZvcnR1bmF0ZWx5IG5lZWRlZCBzaW5jZSBzb21lIGJlaGF2aW9ycyBhcmUgaW1wb3NzaWJsZSB0byBmZWF0dXJlIGRldGVjdFxuICAgICAgaXNHZWNrbyAgICAgPSB1c2VyQWdlbnQuaW5kZXhPZihcIkdlY2tvXCIpICAgICAgICAhPT0gLTEgJiYgdXNlckFnZW50LmluZGV4T2YoXCJLSFRNTFwiKSA9PT0gLTEsXG4gICAgICBpc1dlYktpdCAgICA9IHVzZXJBZ2VudC5pbmRleE9mKFwiQXBwbGVXZWJLaXQvXCIpICE9PSAtMSxcbiAgICAgIGlzQ2hyb21lICAgID0gdXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWUvXCIpICAgICAgIT09IC0xLFxuICAgICAgaXNPcGVyYSAgICAgPSB1c2VyQWdlbnQuaW5kZXhPZihcIk9wZXJhL1wiKSAgICAgICAhPT0gLTE7XG5cbiAgZnVuY3Rpb24gaW9zVmVyc2lvbih1c2VyQWdlbnQpIHtcbiAgICByZXR1cm4gKygoL2lwYWR8aXBob25lfGlwb2QvLnRlc3QodXNlckFnZW50KSAmJiB1c2VyQWdlbnQubWF0Y2goLyBvcyAoXFxkKykuKz8gbGlrZSBtYWMgb3MgeC8pKSB8fCBbdW5kZWZpbmVkLCAwXSlbMV07XG4gIH1cblxuICBmdW5jdGlvbiBhbmRyb2lkVmVyc2lvbih1c2VyQWdlbnQpIHtcbiAgICByZXR1cm4gKyh1c2VyQWdlbnQubWF0Y2goL2FuZHJvaWQgKFxcZCspLykgfHwgW3VuZGVmaW5lZCwgMF0pWzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJRSh2ZXJzaW9uLCBlcXVhdGlvbikge1xuICAgIHZhciBydiA9IC0xLFxuICAgICAgICByZTtcblxuICAgIGlmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSAnTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyJykge1xuICAgICAgcmUgPSBuZXcgUmVnRXhwKFwiTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KVwiKTtcbiAgICB9IGVsc2UgaWYgKG5hdmlnYXRvci5hcHBOYW1lID09ICdOZXRzY2FwZScpIHtcbiAgICAgIHJlID0gbmV3IFJlZ0V4cChcIlRyaWRlbnQvLipydjooWzAtOV17MSx9W1xcLjAtOV17MCx9KVwiKTtcbiAgICB9XG5cbiAgICBpZiAocmUgJiYgcmUuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSAhPSBudWxsKSB7XG4gICAgICBydiA9IHBhcnNlRmxvYXQoUmVnRXhwLiQxKTtcbiAgICB9XG5cbiAgICBpZiAocnYgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICghdmVyc2lvbikgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlmICghZXF1YXRpb24pIHsgcmV0dXJuIHZlcnNpb24gPT09IHJ2OyB9XG4gICAgaWYgKGVxdWF0aW9uID09PSBcIjxcIikgeyByZXR1cm4gdmVyc2lvbiA8IHJ2OyB9XG4gICAgaWYgKGVxdWF0aW9uID09PSBcIj5cIikgeyByZXR1cm4gdmVyc2lvbiA+IHJ2OyB9XG4gICAgaWYgKGVxdWF0aW9uID09PSBcIjw9XCIpIHsgcmV0dXJuIHZlcnNpb24gPD0gcnY7IH1cbiAgICBpZiAoZXF1YXRpb24gPT09IFwiPj1cIikgeyByZXR1cm4gdmVyc2lvbiA+PSBydjsgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTdGF0aWMgdmFyaWFibGUgbmVlZGVkLCBwdWJsaWNseSBhY2Nlc3NpYmxlLCB0byBiZSBhYmxlIG92ZXJyaWRlIGl0IGluIHVuaXQgdGVzdHNcbiAgICBVU0VSX0FHRU5UOiB1c2VyQWdlbnQsXG5cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlIGJyb3dzZXJzIHRoYXQgYXJlIG5vdCBjYXBhYmxlIG9mIGRpc3BsYXlpbmcgYW5kIGhhbmRsaW5nXG4gICAgICogY29udGVudEVkaXRhYmxlIGFzIGRlc2lyZWQ6XG4gICAgICogICAgLSBpUGhvbmUsIGlQYWQgKHRlc3RlZCBpT1MgNC4yLjIpIGFuZCBBbmRyb2lkICh0ZXN0ZWQgMi4yKSByZWZ1c2UgdG8gbWFrZSBjb250ZW50RWRpdGFibGVzIGZvY3VzYWJsZVxuICAgICAqICAgIC0gSUUgPCA4IGNyZWF0ZSBpbnZhbGlkIG1hcmt1cCBhbmQgY3Jhc2ggcmFuZG9tbHkgZnJvbSB0aW1lIHRvIHRpbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgICAgICAgICAgICAgICAgICAgPSB0aGlzLlVTRVJfQUdFTlQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAvLyBFc3NlbnRpYWwgZm9yIG1ha2luZyBodG1sIGVsZW1lbnRzIGVkaXRhYmxlXG4gICAgICAgICAgaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydCAgID0gXCJjb250ZW50RWRpdGFibGVcIiBpbiB0ZXN0RWxlbWVudCxcbiAgICAgICAgICAvLyBGb2xsb3dpbmcgbWV0aG9kcyBhcmUgbmVlZGVkIGluIG9yZGVyIHRvIGludGVyYWN0IHdpdGggdGhlIGNvbnRlbnRFZGl0YWJsZSBhcmVhXG4gICAgICAgICAgaGFzRWRpdGluZ0FwaVN1cHBvcnQgICAgICAgID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQgJiYgZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkICYmIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlLFxuICAgICAgICAgIC8vIGRvY3VtZW50IHNlbGVjdG9yIGFwaXMgYXJlIG9ubHkgc3VwcG9ydGVkIGJ5IElFIDgrLCBTYWZhcmkgNCssIENocm9tZSBhbmQgRmlyZWZveCAzLjUrXG4gICAgICAgICAgaGFzUXVlcnlTZWxlY3RvclN1cHBvcnQgICAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsLFxuICAgICAgICAgIC8vIGNvbnRlbnRFZGl0YWJsZSBpcyB1bnVzYWJsZSBpbiBtb2JpbGUgYnJvd3NlcnMgKHRlc3RlZCBpT1MgNC4yLjIsIEFuZHJvaWQgMi4yLCBPcGVyYSBNb2JpbGUsIFdlYk9TIDMuMDUpXG4gICAgICAgICAgaXNJbmNvbXBhdGlibGVNb2JpbGVCcm93c2VyID0gKHRoaXMuaXNJb3MoKSAmJiBpb3NWZXJzaW9uKHVzZXJBZ2VudCkgPCA1KSB8fCAodGhpcy5pc0FuZHJvaWQoKSAmJiBhbmRyb2lkVmVyc2lvbih1c2VyQWdlbnQpIDwgNCkgfHwgdXNlckFnZW50LmluZGV4T2YoXCJvcGVyYSBtb2JpXCIpICE9PSAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZihcImhwd29zL1wiKSAhPT0gLTE7XG4gICAgICByZXR1cm4gaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydFxuICAgICAgICAmJiBoYXNFZGl0aW5nQXBpU3VwcG9ydFxuICAgICAgICAmJiBoYXNRdWVyeVNlbGVjdG9yU3VwcG9ydFxuICAgICAgICAmJiAhaXNJbmNvbXBhdGlibGVNb2JpbGVCcm93c2VyO1xuICAgIH0sXG5cbiAgICBpc1RvdWNoRGV2aWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRzRXZlbnQoXCJ0b3VjaG1vdmVcIik7XG4gICAgfSxcblxuICAgIGlzSW9zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoL2lwYWR8aXBob25lfGlwb2QvaSkudGVzdCh0aGlzLlVTRVJfQUdFTlQpO1xuICAgIH0sXG5cbiAgICBpc0FuZHJvaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuVVNFUl9BR0VOVC5pbmRleE9mKFwiQW5kcm9pZFwiKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgc2FuZGJveGVkIGlmcmFtZXNcbiAgICAgKiBDdXJyZW50bHkgb25seSBJRSA2KyBvZmZlcnMgc3VjaCBmZWF0dXJlIDxpZnJhbWUgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCI+XG4gICAgICpcbiAgICAgKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzQ2MjIodj12cy44NSkuYXNweFxuICAgICAqIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llL2FyY2hpdmUvMjAwOC8wMS8xOC91c2luZy1mcmFtZXMtbW9yZS1zZWN1cmVseS5hc3B4XG4gICAgICpcbiAgICAgKiBIVE1MNSBzYW5kYm94ZWQgaWZyYW1lcyBhcmUgc3RpbGwgYnVnZ3kgYW5kIHRoZWlyIERPTSBpcyBub3QgcmVhY2hhYmxlIGZyb20gdGhlIG91dHNpZGUgKGV4Y2VwdCB3aGVuIHVzaW5nIHBvc3RNZXNzYWdlKVxuICAgICAqL1xuICAgIHN1cHBvcnRzU2FuZGJveGVkSWZyYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNJRSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJRTYrNyB0aHJvdyBhIG1peGVkIGNvbnRlbnQgd2FybmluZyB3aGVuIHRoZSBzcmMgb2YgYW4gaWZyYW1lXG4gICAgICogaXMgZW1wdHkvdW5zZXQgb3IgYWJvdXQ6YmxhbmtcbiAgICAgKiB3aW5kb3cucXVlcnlTZWxlY3RvciBpcyBpbXBsZW1lbnRlZCBhcyBvZiBJRThcbiAgICAgKi9cbiAgICB0aHJvd3NNaXhlZENvbnRlbnRXYXJuaW5nV2hlbklmcmFtZVNyY0lzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEoXCJxdWVyeVNlbGVjdG9yXCIgaW4gZG9jdW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjYXJldCBpcyBjb3JyZWN0bHkgZGlzcGxheWVkIGluIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50c1xuICAgICAqIEZpcmVmb3ggc29tZXRpbWVzIHNob3dzIGEgaHVnZSBjYXJldCBpbiB0aGUgYmVnaW5uaW5nIGFmdGVyIGZvY3VzaW5nXG4gICAgICovXG4gICAgZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzSUUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmEgYW5kIElFIGFyZSB0aGUgb25seSBicm93c2VycyB3aG8gb2ZmZXIgdGhlIGNzcyB2YWx1ZVxuICAgICAqIGluIHRoZSBvcmlnaW5hbCB1bml0LCB0aHggdG8gdGhlIGN1cnJlbnRTdHlsZSBvYmplY3RcbiAgICAgKiBBbGwgb3RoZXIgYnJvd3NlcnMgcHJvdmlkZSB0aGUgY29tcHV0ZWQgc3R5bGUgaW4gcHggdmlhIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlXG4gICAgICovXG4gICAgaGFzQ3VycmVudFN0eWxlUHJvcGVydHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiY3VycmVudFN0eWxlXCIgaW4gdGVzdEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVmb3ggb24gT1NYIG5hdmlnYXRlcyB0aHJvdWdoIGhpc3Rvcnkgd2hlbiBoaXR0aW5nIENNRCArIEFycm93IHJpZ2h0L2xlZnRcbiAgICAgKi9cbiAgICBoYXNIaXN0b3J5SXNzdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gJiYgbmF2aWdhdG9yLnBsYXRmb3JtLnN1YnN0cigwLCAzKSA9PT0gXCJNYWNcIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBpbnNlcnRzIGEgPGJyPiB3aGVuIHByZXNzaW5nIGVudGVyIGluIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBpbnNlcnRzTGluZUJyZWFrc09uUmV0dXJuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc0dlY2tvO1xuICAgIH0sXG5cbiAgICBzdXBwb3J0c1BsYWNlaG9sZGVyQXR0cmlidXRlT246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBcInBsYWNlaG9sZGVyXCIgaW4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgc3VwcG9ydHNFdmVudDogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICByZXR1cm4gXCJvblwiICsgZXZlbnROYW1lIGluIHRlc3RFbGVtZW50IHx8IChmdW5jdGlvbigpIHtcbiAgICAgICAgdGVzdEVsZW1lbnQuc2V0QXR0cmlidXRlKFwib25cIiArIGV2ZW50TmFtZSwgXCJyZXR1cm47XCIpO1xuICAgICAgICByZXR1cm4gdHlwZW9mKHRlc3RFbGVtZW50W1wib25cIiArIGV2ZW50TmFtZV0pID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9KSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcGVyYSBkb2Vzbid0IGNvcnJlY3RseSBmaXJlIGZvY3VzL2JsdXIgZXZlbnRzIHdoZW4gY2xpY2tpbmcgaW4tIGFuZCBvdXRzaWRlIG9mIGlmcmFtZVxuICAgICAqL1xuICAgIHN1cHBvcnRzRXZlbnRzSW5JZnJhbWVDb3JyZWN0bHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFpc09wZXJhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFdmVyeXRoaW5nIGJlbG93IElFOSBkb2Vzbid0IGtub3cgaG93IHRvIHRyZWF0IEhUTUw1IHRhZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBkb2N1bWVudCBvYmplY3Qgb24gd2hpY2ggdG8gY2hlY2sgSFRNTDUgc3VwcG9ydFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0hUTUw1VGFncyhkb2N1bWVudCk7XG4gICAgICovXG4gICAgc3VwcG9ydHNIVE1MNVRhZ3M6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgIGh0bWw1ICAgPSBcIjxhcnRpY2xlPmZvbzwvYXJ0aWNsZT5cIjtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDU7XG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKSA9PT0gaHRtbDU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgZG9jdW1lbnQgc3VwcG9ydHMgYSBjZXJ0YWluIHF1ZXJ5Q29tbWFuZFxuICAgICAqIEluIHBhcnRpY3VsYXIsIE9wZXJhIG5lZWRzIGEgcmVmZXJlbmNlIHRvIGEgZG9jdW1lbnQgdGhhdCBoYXMgYSBjb250ZW50RWRpdGFibGUgaW4gaXQncyBkb20gdHJlZVxuICAgICAqIGluIG9kZXIgdG8gcmVwb3J0IGNvcnJlY3QgcmVzdWx0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3Qgb24gd2hpY2ggdG8gY2hlY2sgZm9yIGEgcXVlcnkgY29tbWFuZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBxdWVyeSBjb21tYW5kIHRvIGNoZWNrIGZvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzQ29tbWFuZChkb2N1bWVudCwgXCJib2xkXCIpO1xuICAgICAqL1xuICAgIHN1cHBvcnRzQ29tbWFuZDogKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRm9sbG93aW5nIGNvbW1hbmRzIGFyZSBzdXBwb3J0ZWQgYnV0IGNvbnRhaW4gYnVncyBpbiBzb21lIGJyb3dzZXJzXG4gICAgICB2YXIgYnVnZ3lDb21tYW5kcyA9IHtcbiAgICAgICAgLy8gZm9ybWF0QmxvY2sgZmFpbHMgd2l0aCBzb21lIHRhZ3MgKGVnLiA8YmxvY2txdW90ZT4pXG4gICAgICAgIFwiZm9ybWF0QmxvY2tcIjogICAgICAgICAgaXNJRSgxMCwgXCI8PVwiKSxcbiAgICAgICAgIC8vIFdoZW4gaW5zZXJ0aW5nIHVub3JkZXJlZCBvciBvcmRlcmVkIGxpc3RzIGluIEZpcmVmb3gsIENocm9tZSBvciBTYWZhcmksIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBvciBsaW5lIGdldHNcbiAgICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIGEgbGlzdCAoPHVsPjxsaT4uLi48L2xpPjwvdWw+LCA8b2w+PGxpPi4uLjwvbGk+PC9vbD4pXG4gICAgICAgICAvLyBJRSBhbmQgT3BlcmEgYWN0IGEgYml0IGRpZmZlcmVudCBoZXJlIGFzIHRoZXkgY29udmVydCB0aGUgZW50aXJlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgYmxvY2sgZWxlbWVudCBpbnRvIGEgbGlzdFxuICAgICAgICBcImluc2VydFVub3JkZXJlZExpc3RcIjogIGlzSUUoKSxcbiAgICAgICAgXCJpbnNlcnRPcmRlcmVkTGlzdFwiOiAgICBpc0lFKClcbiAgICAgIH07XG5cbiAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGVycm9ycyBmb3IgcXVlcnlDb21tYW5kU3VwcG9ydGVkLCBzbyB3ZSBoYXZlIHRvIGJ1aWxkIHVwIG91ciBvd24gb2JqZWN0IG9mIHN1cHBvcnRlZCBjb21tYW5kc1xuICAgICAgdmFyIHN1cHBvcnRlZCA9IHtcbiAgICAgICAgXCJpbnNlcnRIVE1MXCI6IGlzR2Vja29cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihkb2MsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGlzQnVnZ3kgPSBidWdneUNvbW1hbmRzW2NvbW1hbmRdO1xuICAgICAgICBpZiAoIWlzQnVnZ3kpIHtcbiAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBlcnJvcnMgd2hlbiBpbnZva2luZyBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQgb3IgcXVlcnlDb21tYW5kRW5hYmxlZFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjb21tYW5kKTtcbiAgICAgICAgICB9IGNhdGNoKGUxKSB7fVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkb2MucXVlcnlDb21tYW5kRW5hYmxlZChjb21tYW5kKTtcbiAgICAgICAgICB9IGNhdGNoKGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gISFzdXBwb3J0ZWRbY29tbWFuZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIC8qKlxuICAgICAqIElFOiBVUkxzIHN0YXJ0aW5nIHdpdGg6XG4gICAgICogICAgd3d3LiwgaHR0cDovLywgaHR0cHM6Ly8sIGZ0cDovLywgZ29waGVyOi8vLCBtYWlsdG86LCBuZXc6LCBzbmV3czosIHRlbG5ldDosIHdhc2lzOiwgZmlsZTovLyxcbiAgICAgKiAgICBubnRwOi8vLCBuZXdzcmM6LCBsZGFwOi8vLCBsZGFwczovLywgb3V0bG9vazosIG1pYzovLyBhbmQgdXJsOlxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBiZSBhdXRvLWxpbmtlZCB3aGVuIGVpdGhlciB0aGUgdXNlciBpbnNlcnRzIHRoZW0gdmlhIGNvcHkmcGFzdGUgb3IgcHJlc3NlcyB0aGVcbiAgICAgKiBzcGFjZSBiYXIgd2hlbiB0aGUgY2FyZXQgaXMgZGlyZWN0bHkgYWZ0ZXIgc3VjaCBhbiB1cmwuXG4gICAgICogVGhpcyBiZWhhdmlvciBjYW5ub3QgZWFzaWx5IGJlIGF2b2lkZWQgaW4gSUUgPCA5IHNpbmNlIHRoZSBsb2dpYyBpcyBoYXJkY29kZWQgaW4gdGhlIG1zaHRtbC5kbGxcbiAgICAgKiAocmVsYXRlZCBibG9nIHBvc3Qgb24gbXNkblxuICAgICAqIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAwOS8wOS8xNy9wcmV2ZW50LWF1dG9tYXRpYy1oeXBlcmxpbmtpbmctaW4tY29udGVudGVkaXRhYmxlLWh0bWwuYXNweCkuXG4gICAgICovXG4gICAgZG9lc0F1dG9MaW5raW5nSW5Db250ZW50RWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzSUUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXMgc3RhdGVkIGFib3ZlLCBJRSBhdXRvIGxpbmtzIHVybHMgdHlwZWQgaW50byBjb250ZW50RWRpdGFibGUgZWxlbWVudHNcbiAgICAgKiBTaW5jZSBJRTkgaXQncyBwb3NzaWJsZSB0byBwcmV2ZW50IHRoaXMgYmVoYXZpb3JcbiAgICAgKi9cbiAgICBjYW5EaXNhYmxlQXV0b0xpbmtpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydHNDb21tYW5kKGRvY3VtZW50LCBcIkF1dG9VcmxEZXRlY3RcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElFIGxlYXZlcyBhbiBlbXB0eSBwYXJhZ3JhcGggaW4gdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IGFmdGVyIGNsZWFyaW5nIGl0XG4gICAgICogQ2hyb21lL1NhZmFyaSBzb21ldGltZXMgYW4gZW1wdHkgPGRpdj5cbiAgICAgKi9cbiAgICBjbGVhcnNDb250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNPcGVyYSB8fCBpc1dlYktpdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZ2V0QXR0cmlidXRlXG4gICAgICovXG4gICAgc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgcmV0dXJuIHRkLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIikgIT0gXCIxXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2xpY2tpbmcgb24gaW1hZ2VzIGluIElFLCBPcGVyYSBhbmQgRmlyZWZveCwgdGhleSBhcmUgc2VsZWN0ZWQsIHdoaWNoIG1ha2VzIGl0IGVhc3kgdG8gaW50ZXJhY3Qgd2l0aCB0aGVtLlxuICAgICAqIENocm9tZSBhbmQgU2FmYXJpIGJvdGggZG9uJ3Qgc3VwcG9ydCB0aGlzXG4gICAgICovXG4gICAgY2FuU2VsZWN0SW1hZ2VzSW5Db250ZW50RWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNJRSgpIHx8IGlzT3BlcmE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFsbCBicm93c2VycyBleGNlcHQgU2FmYXJpIGFuZCBDaHJvbWUgYXV0b21hdGljYWxseSBzY3JvbGwgdGhlIHJhbmdlL2NhcmV0IHBvc2l0aW9uIGludG8gdmlld1xuICAgICAqL1xuICAgIGF1dG9TY3JvbGxzVG9DYXJldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIWlzV2ViS2l0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIGF1dG9tYXRpY2FsbHkgY2xvc2VzIHRhZ3MgdGhhdCBkb24ndCBuZWVkIHRvIGJlIG9wZW5lZFxuICAgICAqL1xuICAgIGF1dG9DbG9zZXNVbmNsb3NlZFRhZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNsb25lZFRlc3RFbGVtZW50ID0gdGVzdEVsZW1lbnQuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICByZXR1cm5WYWx1ZSxcbiAgICAgICAgICBpbm5lckhUTUw7XG5cbiAgICAgIGNsb25lZFRlc3RFbGVtZW50LmlubmVySFRNTCA9IFwiPHA+PGRpdj48L2Rpdj5cIjtcbiAgICAgIGlubmVySFRNTCAgICAgICAgICAgICAgICAgICA9IGNsb25lZFRlc3RFbGVtZW50LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuVmFsdWUgICAgICAgICAgICAgICAgID0gaW5uZXJIVE1MID09PSBcIjxwPjwvcD48ZGl2PjwvZGl2PlwiIHx8IGlubmVySFRNTCA9PT0gXCI8cD48ZGl2PjwvZGl2PjwvcD5cIjtcblxuICAgICAgLy8gQ2FjaGUgcmVzdWx0IGJ5IG92ZXJ3cml0aW5nIGN1cnJlbnQgZnVuY3Rpb25cbiAgICAgIHRoaXMuYXV0b0Nsb3Nlc1VuY2xvc2VkVGFncyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmV0dXJuVmFsdWU7IH07XG5cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgbmF0aXZlIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgd2hpY2ggcmV0dXJucyBsaXZlIE5vZGVMaXN0c1xuICAgICAqL1xuICAgIHN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXMgb2Ygbm93ICgxOS4wNC4yMDExKSBvbmx5IHN1cHBvcnRlZCBieSBGaXJlZm94IDQgYW5kIENocm9tZVxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU2VsZWN0aW9uL21vZGlmeVxuICAgICAqL1xuICAgIHN1cHBvcnRzU2VsZWN0aW9uTW9kaWZ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImdldFNlbGVjdGlvblwiIGluIHdpbmRvdyAmJiBcIm1vZGlmeVwiIGluIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmEgbmVlZHMgYSB3aGl0ZSBzcGFjZSBhZnRlciBhIDxicj4gaW4gb3JkZXIgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGNvcnJlY3RseVxuICAgICAqL1xuICAgIG5lZWRzU3BhY2VBZnRlckxpbmVCcmVhazogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgc3BlZWNoIGFwaSBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqIFNlZSBodHRwOi8vbWlrZXB1bHR6LmNvbS8yMDExLzAzL2FjY2Vzc2luZy1nb29nbGUtc3BlZWNoLWFwaS1jaHJvbWUtMTEvXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgKiAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNTcGVlY2hBcGlPbihpbnB1dCkpIHtcbiAgICAgKiAgICAgIC8vIC4uLlxuICAgICAqICAgIH1cbiAgICAgKi9cbiAgICBzdXBwb3J0c1NwZWVjaEFwaU9uOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgdmFyIGNocm9tZVZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pIHx8IFt1bmRlZmluZWQsIDBdO1xuICAgICAgcmV0dXJuIGNocm9tZVZlcnNpb25bMV0gPj0gMTEgJiYgKFwib253ZWJraXRzcGVlY2hjaGFuZ2VcIiBpbiBpbnB1dCB8fCBcInNwZWVjaFwiIGluIGlucHV0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUU5IGNyYXNoZXMgd2hlbiBzZXR0aW5nIGEgZ2V0dGVyIHZpYSBPYmplY3QuZGVmaW5lUHJvcGVydHkgb24gWE1MSHR0cFJlcXVlc3Qgb3IgWERvbWFpblJlcXVlc3RcbiAgICAgKiBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vaWUvZmVlZGJhY2svZGV0YWlscy82NTAxMTJcbiAgICAgKiBvciB0cnkgdGhlIFBPQyBodHRwOi8vdGlmZnRpZmYuZGUvaWU5X2NyYXNoL1xuICAgICAqL1xuICAgIGNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gaXNJRSg5KSAmJiAocHJvcGVydHkgPT09IFwiWE1MSHR0cFJlcXVlc3RcIiB8fCBwcm9wZXJ0eSA9PT0gXCJYRG9tYWluUmVxdWVzdFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgaXMgdGhlIG9ubHkgYnJvd3NlciB3aG8gZmlyZXMgdGhlIFwiZm9jdXNcIiBldmVudCBub3QgaW1tZWRpYXRlbHkgd2hlbiAuZm9jdXMoKSBpcyBjYWxsZWQgb24gYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGRvZXNBc3luY0ZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc0lFKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluIElFIGl0J3MgaW1wc3NpYmxlIGZvciB0aGUgdXNlciBhbmQgZm9yIHRoZSBzZWxlY3Rpb24gbGlicmFyeSB0byBzZXQgdGhlIGNhcmV0IGFmdGVyIGFuIDxpbWc+IHdoZW4gaXQncyB0aGUgbGFzdENoaWxkIGluIHRoZSBkb2N1bWVudFxuICAgICAqL1xuICAgIGhhc1Byb2JsZW1zU2V0dGluZ0NhcmV0QWZ0ZXJJbWc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzSUUoKTtcbiAgICB9LFxuXG4gICAgaGFzVW5kb0luQ29udGV4dE1lbnU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNDaHJvbWUgfHwgaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmEgc29tZXRpbWVzIGRvZXNuJ3QgaW5zZXJ0IHRoZSBub2RlIGF0IHRoZSByaWdodCBwb3NpdGlvbiB3aGVuIHJhbmdlLmluc2VydE5vZGUoc29tZU5vZGUpXG4gICAgICogaXMgdXNlZCAocmVnYXJkbGVzcyBpZiByYW5neSBvciBuYXRpdmUpXG4gICAgICogVGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgd2hlbiB0aGUgY2FyZXQgaXMgcG9zaXRpb25lZCByaWdodCBhZnRlciBhIDxicj4gYmVjYXVzZSB0aGVuXG4gICAgICogaW5zZXJ0Tm9kZSgpIHdpbGwgaW5zZXJ0IHRoZSBub2RlIHJpZ2h0IGJlZm9yZSB0aGUgPGJyPlxuICAgICAqL1xuICAgIGhhc0luc2VydE5vZGVJc3N1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgOCs5IGRvbid0IGZpcmUgdGhlIGZvY3VzIGV2ZW50IG9mIHRoZSA8Ym9keT4gd2hlbiB0aGUgaWZyYW1lIGdldHMgZm9jdXNlZCAoZXZlbiB0aG91Z2ggdGhlIGNhcmV0IGdldHMgc2V0IGludG8gdGhlIDxib2R5PilcbiAgICAgKi9cbiAgICBoYXNJZnJhbWVGb2N1c0lzc3VlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc0lFKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENocm9tZSArIFNhZmFyaSBjcmVhdGUgaW52YWxpZCBuZXN0ZWQgbWFya3VwIGFmdGVyIHBhc3RlXG4gICAgICpcbiAgICAgKiAgPHA+XG4gICAgICogICAgZm9vXG4gICAgICogICAgPHA+YmFyPC9wPiA8IS0tIEJPTyEgLS0+XG4gICAgICogIDwvcD5cbiAgICAgKi9cbiAgICBjcmVhdGVzTmVzdGVkSW52YWxpZE1hcmt1cEFmdGVyUGFzdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzV2ViS2l0O1xuICAgIH0sXG5cbiAgICBzdXBwb3J0c011dGF0aW9uRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcIk11dGF0aW9uRXZlbnRcIiBpbiB3aW5kb3cpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgIElFIChhdCBsZWFzdCB1cCB0byAxMSkgZG9lcyBub3Qgc3VwcG9ydCBjbGlwYm9hcmREYXRhIG9uIGV2ZW50LlxuICAgICAgSXQgaXMgb24gd2luZG93IGJ1dCBjYW5ub3QgcmV0dXJuIHRleHQvaHRtbFxuICAgICAgU2hvdWxkIGFjdHVhbGx5IGNoZWNrIGZvciBjbGlwYm9hcmREYXRhIG9uIHBhc3RlIGV2ZW50LCBidXQgY2Fubm90IGluIGZpcmVmb3hcbiAgICAqL1xuICAgIHN1cHBvcnRzTW9kZW5QYXN0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEoXCJjbGlwYm9hcmREYXRhXCIgaW4gd2luZG93KTtcbiAgICB9XG4gIH07XG59KSgpO1xuO3d5c2lodG1sNS5sYW5nLmFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIG9iamVjdCBleGlzdHMgaW4gYW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmxhbmcuYXJyYXkoWzEsIDJdKS5jb250YWlucygxKTtcbiAgICAgKiAgICAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBtYXRjaCBhcnJheSB3aXRoIGFycmF5LiBJZiBpbnRlcnNlY3Rpb24gaXMgZm91bmQgdHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqL1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihuZWVkbGUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5lZWRsZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5lZWRsZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAod3lzaWh0bWw1LmxhbmcuYXJyYXkoYXJyKS5pbmRleE9mKG5lZWRsZVtpXSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHd5c2lodG1sNS5sYW5nLmFycmF5KGFycikuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIG9iamVjdCBleGlzdHMgaW4gYW4gYXJyYXkgYW5kIHJldHVybiBpbmRleFxuICAgICAqIElmIG5vIGVsZWxlbXQgZm91bmQgcmV0dXJucyAtMVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5hcnJheShbMSwgMl0pLmluZGV4T2YoMik7XG4gICAgICogICAgLy8gPT4gMVxuICAgICAqL1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKG5lZWRsZSkge1xuICAgICAgICBpZiAoYXJyLmluZGV4T2YpIHtcbiAgICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YobmVlZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbmd0aD1hcnIubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID09PSBuZWVkbGUpIHsgcmV0dXJuIGk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnN0cmFjdCBvbmUgYXJyYXkgZnJvbSBhbm90aGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5sYW5nLmFycmF5KFsxLCAyLCAzLCA0XSkud2l0aG91dChbMywgNF0pO1xuICAgICAqICAgIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIHdpdGhvdXQ6IGZ1bmN0aW9uKGFycmF5VG9TdWJzdHJhY3QpIHtcbiAgICAgIGFycmF5VG9TdWJzdHJhY3QgPSB3eXNpaHRtbDUubGFuZy5hcnJheShhcnJheVRvU3Vic3RyYWN0KTtcbiAgICAgIHZhciBuZXdBcnIgID0gW10sXG4gICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgbGVuZ3RoICA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWFycmF5VG9TdWJzdHJhY3QuY29udGFpbnMoYXJyW2ldKSkge1xuICAgICAgICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBcnI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNsZWFuIG5hdGl2ZSBhcnJheVxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHdpbGwgY29udmVydCBhIExpdmUgTm9kZUxpc3QgdG8gYSBwcm9wZXIgQXJyYXlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBjaGlsZE5vZGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZE5vZGVzKS5nZXQoKTtcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgICAgICAgID0gMCxcbiAgICAgICAgICBsZW5ndGggICA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgbmV3QXJyYXkgPSBbXTtcbiAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0FycmF5LnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSB3aXRoIHRoZSByZXN1bHRzIG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeSBlbGVtZW50IGluIHRoaXMgYXJyYXkuXG4gICAgICogb3B0aW9uYWxseSB0aGlzIGNhbiBiZSBwcm92aWRlZCBhcyBzZWNvbmQgYXJndW1lbnRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgdmFyIGNoaWxkTm9kZXMgPSB3eXNpaHRtbDUubGFuZy5hcnJheShbMSwyLDMsNF0pLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICogMjtcbiAgICAgKiAgICB9KTtcbiAgICAgKiAgICAvLyA9PiBbMiw0LDYsOF1cbiAgICAgKi9cbiAgICBtYXA6IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoQXJyYXkucHJvdG90eXBlLm1hcCkge1xuICAgICAgICByZXR1cm4gYXJyLm1hcChjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgIEEgPSBuZXcgQXJyYXkobGVuKSxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgIEFbaV0gPSBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogUmV0dXJuUyBuZXcgYXJyYXkgd2l0aG91dCBkdXBsaWNhdGUgZW50cmllc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgdW5pcSA9IHd5c2lodG1sNS5sYW5nLmFycmF5KFsxLDIsMywyLDEsNF0pLnVuaXF1ZSgpO1xuICAgICAqICAgIC8vID0+IFsxLDIsMyw0XVxuICAgICAqL1xuICAgIHVuaXF1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFscyA9IFtdLFxuICAgICAgICAgIG1heCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgaWR4ID0gMDtcblxuICAgICAgd2hpbGUgKGlkeCA8IG1heCkge1xuICAgICAgICBpZiAoIXd5c2lodG1sNS5sYW5nLmFycmF5KHZhbHMpLmNvbnRhaW5zKGFycltpZHhdKSkge1xuICAgICAgICAgIHZhbHMucHVzaChhcnJbaWR4XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWR4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFscztcbiAgICB9XG5cbiAgfTtcbn07XG47d3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlciA9IEJhc2UuZXh0ZW5kKFxuICAvKiogQHNjb3BlIHd5c2lodG1sNS5sYW5nLkRpYWxvZy5wcm90b3R5cGUgKi8ge1xuICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCB7fTtcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb2ZmOiBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9O1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgaGFuZGxlcnMsXG4gICAgICAgIG5ld0hhbmRsZXJzO1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIGhhbmRsZXJzICAgID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSB8fCBbXSxcbiAgICAgIG5ld0hhbmRsZXJzID0gW107XG4gICAgICBmb3IgKDsgaTxoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGFuZGxlcnNbaV0gIT09IGhhbmRsZXIgJiYgaGFuZGxlcikge1xuICAgICAgICAgIG5ld0hhbmRsZXJzLnB1c2goaGFuZGxlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gbmV3SGFuZGxlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFuIHVwIGFsbCBldmVudHNcbiAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGZpcmU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSB8fCBbXSxcbiAgICAgICAgaSAgICAgICAgPSAwO1xuICAgIGZvciAoOyBpPGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBkZXByZWNhdGVkLCB1c2UgLm9uKClcbiAgb2JzZXJ2ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvLyBkZXByZWNhdGVkLCB1c2UgLm9mZigpXG4gIHN0b3BPYnNlcnZpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9mZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59KTtcbjt3eXNpaHRtbDUubGFuZy5vYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5sYW5nLm9iamVjdCh7IGZvbzogMSwgYmFyOiAxIH0pLm1lcmdlKHsgYmFyOiAyLCBiYXo6IDMgfSkuZ2V0KCk7XG4gICAgICogICAgLy8gPT4geyBmb286IDEsIGJhcjogMiwgYmF6OiAzIH1cbiAgICAgKi9cbiAgICBtZXJnZTogZnVuY3Rpb24ob3RoZXJPYmopIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb3RoZXJPYmopIHtcbiAgICAgICAgb2JqW2ldID0gb3RoZXJPYmpbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHsgZm9vOiAxIH0pLmNsb25lKCk7XG4gICAgICogICAgLy8gPT4geyBmb286IDEgfVxuICAgICAqXG4gICAgICogICAgdjAuNC4xNCBhZGRzIG9wdGlvbnMgZm9yIGRlZXAgY2xvbmUgOiB3eXNpaHRtbDUubGFuZy5vYmplY3QoeyBmb286IDEgfSkuY2xvbmUodHJ1ZSk7XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgIHZhciBuZXdPYmogPSB7fSxcbiAgICAgICAgICBpO1xuXG4gICAgICBpZiAob2JqID09PSBudWxsIHx8ICF3eXNpaHRtbDUubGFuZy5vYmplY3Qob2JqKS5pc1BsYWluT2JqZWN0KCkpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cblxuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgbmV3T2JqW2ldID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KG9ialtpXSkuY2xvbmUoZGVlcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld09ialtpXSA9IG9ialtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KFtdKS5pc0FycmF5KCk7XG4gICAgICogICAgLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGlzQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KGZ1bmN0aW9uKCkge30pLmlzRnVuY3Rpb24oKTtcbiAgICAgKiAgICAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfSxcblxuICAgIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuICB9O1xufTtcbjsoZnVuY3Rpb24oKSB7XG4gIHZhciBXSElURV9TUEFDRV9TVEFSVCA9IC9eXFxzKy8sXG4gICAgICBXSElURV9TUEFDRV9FTkQgICA9IC9cXHMrJC8sXG4gICAgICBFTlRJVFlfUkVHX0VYUCAgICA9IC9bJjw+XFx0XCJdL2csXG4gICAgICBFTlRJVFlfTUFQID0ge1xuICAgICAgICAnJic6ICcmYW1wOycsXG4gICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgICAgJ1xcdCc6XCImbmJzcDsgXCJcbiAgICAgIH07XG4gIHd5c2lodG1sNS5sYW5nLnN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5zdHJpbmcoXCIgICBmb28gICBcIikudHJpbSgpO1xuICAgICAgICogICAgLy8gPT4gXCJmb29cIlxuICAgICAgICovXG4gICAgICB0cmltOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKFdISVRFX1NQQUNFX1NUQVJULCBcIlwiKS5yZXBsYWNlKFdISVRFX1NQQUNFX0VORCwgXCJcIik7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5zdHJpbmcoXCJIZWxsbyAje25hbWV9XCIpLmludGVycG9sYXRlKHsgbmFtZTogXCJDaHJpc3RvcGhlclwiIH0pO1xuICAgICAgICogICAgLy8gPT4gXCJIZWxsbyBDaHJpc3RvcGhlclwiXG4gICAgICAgKi9cbiAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbih2YXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdmFycykge1xuICAgICAgICAgIHN0ciA9IHRoaXMucmVwbGFjZShcIiN7XCIgKyBpICsgXCJ9XCIpLmJ5KHZhcnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5zdHJpbmcoXCJIZWxsbyBUb21cIikucmVwbGFjZShcIlRvbVwiKS53aXRoKFwiSGFuc1wiKTtcbiAgICAgICAqICAgIC8vID0+IFwiSGVsbG8gSGFuc1wiXG4gICAgICAgKi9cbiAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uKHNlYXJjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5OiBmdW5jdGlvbihyZXBsYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnNwbGl0KHNlYXJjaCkuam9pbihyZXBsYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5zdHJpbmcoXCJoZWxsbzxicj5cIikuZXNjYXBlSFRNTCgpO1xuICAgICAgICogICAgLy8gPT4gXCJoZWxsbyZsdDticiZndDtcIlxuICAgICAgICovXG4gICAgICBlc2NhcGVIVE1MOiBmdW5jdGlvbihsaW5lYnJlYWtzLCBjb252ZXJ0U3BhY2VzKSB7XG4gICAgICAgIHZhciBodG1sID0gc3RyLnJlcGxhY2UoRU5USVRZX1JFR19FWFAsIGZ1bmN0aW9uKGMpIHsgcmV0dXJuIEVOVElUWV9NQVBbY107IH0pO1xuICAgICAgICBpZiAobGluZWJyZWFrcykge1xuICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCAnPGJyIC8+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnZlcnRTcGFjZXMpIHtcbiAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC8gIC9naSwgXCImbmJzcDsgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59KSgpO1xuOy8qKlxuICogRmluZCB1cmxzIGluIGRlc2NlbmRhbnQgdGV4dCBub2RlcyBvZiBhbiBlbGVtZW50IGFuZCBhdXRvLWxpbmtzIHRoZW1cbiAqIEluc3BpcmVkIGJ5IGh0dHA6Ly9qYW1lcy5wYWRvbHNleS5jb20vamF2YXNjcmlwdC9maW5kLWFuZC1yZXBsYWNlLXRleHQtd2l0aC1qYXZhc2NyaXB0L1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBDb250YWluZXIgZWxlbWVudCBpbiB3aGljaCB0byBzZWFyY2ggZm9yIHVybHNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgPGRpdiBpZD1cInRleHQtY29udGFpbmVyXCI+UGxlYXNlIGNsaWNrIGhlcmU6IHd3dy5nb29nbGUuY29tPC9kaXY+XG4gKiAgICA8c2NyaXB0Pnd5c2lodG1sNS5kb20uYXV0b0xpbmsoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXh0LWNvbnRhaW5lclwiKSk7PC9zY3JpcHQ+XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIC8qKlxuICAgICAgICogRG9uJ3QgYXV0by1saW5rIHVybHMgdGhhdCBhcmUgY29udGFpbmVkIGluIHRoZSBmb2xsb3dpbmcgZWxlbWVudHM6XG4gICAgICAgKi9cbiAgICAgIElHTk9SRV9VUkxTX0lOICAgICAgICA9IHd5c2lodG1sNS5sYW5nLmFycmF5KFtcIkNPREVcIiwgXCJQUkVcIiwgXCJBXCIsIFwiU0NSSVBUXCIsIFwiSEVBRFwiLCBcIlRJVExFXCIsIFwiU1RZTEVcIl0pLFxuICAgICAgLyoqXG4gICAgICAgKiByZXZpc2lvbiAxOlxuICAgICAgICogICAgLyhcXFMrXFwuezF9W15cXHNcXCxcXC5cXCFdKykvZ1xuICAgICAgICpcbiAgICAgICAqIHJldmlzaW9uIDI6XG4gICAgICAgKiAgICAvKFxcYigoKGh0dHBzP3xmdHApOlxcL1xcLyl8KHd3d1xcLikpWy1BLVowLTkrJkAjXFwvJT89fl98ITosLjtcXFtcXF1dKlstQS1aMC05KyZAI1xcLyU9fl98XSkvZ2ltXG4gICAgICAgKlxuICAgICAgICogcHV0IHRoaXMgaW4gdGhlIGJlZ2lubmluZyBpZiB5b3UgZG9uJ3Qgd2FuJ3QgdG8gbWF0Y2ggd2l0aGluIGEgd29yZFxuICAgICAgICogICAgKF58W1xcPlxcKFxce1xcW1xcc1xcPl0pXG4gICAgICAgKi9cbiAgICAgIFVSTF9SRUdfRVhQICAgICAgICAgICA9IC8oKGh0dHBzPzpcXC9cXC98d3d3XFwuKVteXFxzPF17Myx9KS9naSxcbiAgICAgIFRSQUlMSU5HX0NIQVJfUkVHX0VYUCA9IC8oW15cXHdcXC9cXC1dKCw/KSkkL2ksXG4gICAgICBNQVhfRElTUExBWV9MRU5HVEggICAgPSAxMDAsXG4gICAgICBCUkFDS0VUUyAgICAgICAgICAgICAgPSB7IFwiKVwiOiBcIihcIiwgXCJdXCI6IFwiW1wiLCBcIn1cIjogXCJ7XCIgfTtcblxuICBmdW5jdGlvbiBhdXRvTGluayhlbGVtZW50LCBpZ25vcmVJbkNsYXNzZXMpIHtcbiAgICBpZiAoX2hhc1BhcmVudFRoYXRTaG91bGRCZUlnbm9yZWQoZWxlbWVudCwgaWdub3JlSW5DbGFzc2VzKSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgPT09IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3BhcnNlTm9kZShlbGVtZW50LCBpZ25vcmVJbkNsYXNzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYmFzaWNhbGx5IGEgcmVidWlsZCBvZlxuICAgKiB0aGUgcmFpbHMgYXV0b19saW5rX3VybHMgdGV4dCBoZWxwZXJcbiAgICovXG4gIGZ1bmN0aW9uIF9jb252ZXJ0VXJsc1RvTGlua3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFVSTF9SRUdfRVhQLCBmdW5jdGlvbihtYXRjaCwgdXJsKSB7XG4gICAgICB2YXIgcHVuY3R1YXRpb24gPSAodXJsLm1hdGNoKFRSQUlMSU5HX0NIQVJfUkVHX0VYUCkgfHwgW10pWzFdIHx8IFwiXCIsXG4gICAgICAgICAgb3BlbmluZyAgICAgPSBCUkFDS0VUU1twdW5jdHVhdGlvbl07XG4gICAgICB1cmwgPSB1cmwucmVwbGFjZShUUkFJTElOR19DSEFSX1JFR19FWFAsIFwiXCIpO1xuXG4gICAgICBpZiAodXJsLnNwbGl0KG9wZW5pbmcpLmxlbmd0aCA+IHVybC5zcGxpdChwdW5jdHVhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHVybCA9IHVybCArIHB1bmN0dWF0aW9uO1xuICAgICAgICBwdW5jdHVhdGlvbiA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgcmVhbFVybCAgICA9IHVybCxcbiAgICAgICAgICBkaXNwbGF5VXJsID0gdXJsO1xuICAgICAgaWYgKHVybC5sZW5ndGggPiBNQVhfRElTUExBWV9MRU5HVEgpIHtcbiAgICAgICAgZGlzcGxheVVybCA9IGRpc3BsYXlVcmwuc3Vic3RyKDAsIE1BWF9ESVNQTEFZX0xFTkdUSCkgKyBcIi4uLlwiO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGh0dHAgcHJlZml4IGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHJlYWxVcmwuc3Vic3RyKDAsIDQpID09PSBcInd3dy5cIikge1xuICAgICAgICByZWFsVXJsID0gXCJodHRwOi8vXCIgKyByZWFsVXJsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxhIGhyZWY9XCInICsgcmVhbFVybCArICdcIj4nICsgZGlzcGxheVVybCArICc8L2E+JyArIHB1bmN0dWF0aW9uO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgKGlmIGFscmVhZHkgY2FjaGVkKSByZXR1cm5zIGEgdGVtcCBlbGVtZW50XG4gICAqIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0VGVtcEVsZW1lbnQoY29udGV4dCkge1xuICAgIHZhciB0ZW1wRWxlbWVudCA9IGNvbnRleHQuX3d5c2lodG1sNV90ZW1wRWxlbWVudDtcbiAgICBpZiAoIXRlbXBFbGVtZW50KSB7XG4gICAgICB0ZW1wRWxlbWVudCA9IGNvbnRleHQuX3d5c2lodG1sNV90ZW1wRWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBvcmlnaW5hbCB0ZXh0IG5vZGVzIHdpdGggdGhlIG5ld2x5IGF1dG8tbGlua2VkIGRvbSB0cmVlXG4gICAqL1xuICBmdW5jdGlvbiBfd3JhcE1hdGNoZXNJbk5vZGUodGV4dE5vZGUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSAgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICBub2RlVmFsdWUgICA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyh0ZXh0Tm9kZS5kYXRhKS5lc2NhcGVIVE1MKCksXG4gICAgICAgIHRlbXBFbGVtZW50ID0gX2dldFRlbXBFbGVtZW50KHBhcmVudE5vZGUub3duZXJEb2N1bWVudCk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGluc2VydCBhbiBlbXB0eS90ZW1wb3JhcnkgPHNwYW4gLz4gdG8gZml4IElFIHF1aXJrc1xuICAgIC8vIEVsc2V3aXNlIElFIHdvdWxkIHN0cmlwIHdoaXRlIHNwYWNlIGluIHRoZSBiZWdpbm5pbmdcbiAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBcIjxzcGFuPjwvc3Bhbj5cIiArIF9jb252ZXJ0VXJsc1RvTGlua3Mobm9kZVZhbHVlKTtcbiAgICB0ZW1wRWxlbWVudC5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudC5maXJzdENoaWxkKTtcblxuICAgIHdoaWxlICh0ZW1wRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAvLyBpbnNlcnRzIHRlbXBFbGVtZW50LmZpcnN0Q2hpbGQgYmVmb3JlIHRleHROb2RlXG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZW1wRWxlbWVudC5maXJzdENoaWxkLCB0ZXh0Tm9kZSk7XG4gICAgfVxuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhc1BhcmVudFRoYXRTaG91bGRCZUlnbm9yZWQobm9kZSwgaWdub3JlSW5DbGFzc2VzKSB7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICBpZiAobm9kZS5jbGFzc05hbWUgJiYgd3lzaWh0bWw1LmxhbmcuYXJyYXkobm9kZS5jbGFzc05hbWUuc3BsaXQoJyAnKSkuY29udGFpbnMoaWdub3JlSW5DbGFzc2VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChJR05PUkVfVVJMU19JTi5jb250YWlucyhub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImJvZHlcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wYXJzZU5vZGUoZWxlbWVudCwgaWdub3JlSW5DbGFzc2VzKSB7XG4gICAgaWYgKElHTk9SRV9VUkxTX0lOLmNvbnRhaW5zKGVsZW1lbnQubm9kZU5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lICYmIHd5c2lodG1sNS5sYW5nLmFycmF5KGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJykpLmNvbnRhaW5zKGlnbm9yZUluQ2xhc3NlcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiBlbGVtZW50LmRhdGEubWF0Y2goVVJMX1JFR19FWFApKSB7XG4gICAgICBfd3JhcE1hdGNoZXNJbk5vZGUoZWxlbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkTm9kZXMgICAgICAgID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZWxlbWVudC5jaGlsZE5vZGVzKS5nZXQoKSxcbiAgICAgICAgY2hpbGROb2Rlc0xlbmd0aCAgPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgaSAgICAgICAgICAgICAgICAgPSAwO1xuXG4gICAgZm9yICg7IGk8Y2hpbGROb2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBfcGFyc2VOb2RlKGNoaWxkTm9kZXNbaV0sIGlnbm9yZUluQ2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB3eXNpaHRtbDUuZG9tLmF1dG9MaW5rID0gYXV0b0xpbms7XG5cbiAgLy8gUmV2ZWFsIHVybCByZWcgZXhwIHRvIHRoZSBvdXRzaWRlXG4gIHd5c2lodG1sNS5kb20uYXV0b0xpbmsuVVJMX1JFR19FWFAgPSBVUkxfUkVHX0VYUDtcbn0pKHd5c2lodG1sNSk7XG47KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgYXBpID0gd3lzaWh0bWw1LmRvbTtcblxuICBhcGkuYWRkQ2xhc3MgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICB2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgaWYgKGFwaS5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICB9O1xuXG4gIGFwaS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXHMrKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHMrfCQpXCIpLCBcIiBcIik7XG4gIH07XG5cbiAgYXBpLmhhc0NsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICAgIGlmIChjbGFzc0xpc3QpIHtcbiAgICAgIHJldHVybiBjbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgIHJldHVybiAoZWxlbWVudENsYXNzTmFtZS5sZW5ndGggPiAwICYmIChlbGVtZW50Q2xhc3NOYW1lID09IGNsYXNzTmFtZSB8fCBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc05hbWUgKyBcIihcXFxcc3wkKVwiKS50ZXN0KGVsZW1lbnRDbGFzc05hbWUpKSk7XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuO3d5c2lodG1sNS5kb20uY29udGFpbnMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmIChkb2N1bWVudEVsZW1lbnQuY29udGFpbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lciAhPT0gZWxlbWVudCAmJiBjb250YWluZXIuY29udGFpbnMoZWxlbWVudCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgcmV0dXJuICEhKGNvbnRhaW5lci5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIDE2KTtcbiAgICB9O1xuICB9XG59KSgpO1xuOy8qKlxuICogQ29udmVydHMgYW4gSFRNTCBmcmFnbWVudC9lbGVtZW50IGludG8gYSB1bm9yZGVyZWQvb3JkZXJlZCBsaXN0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdoaWNoIHNob3VsZCBiZSB0dXJuZWQgaW50byBhIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0VHlwZSBUaGUgbGlzdCB0eXBlIGluIHdoaWNoIHRvIGNvbnZlcnQgdGhlIHRyZWUgKGVpdGhlciBcInVsXCIgb3IgXCJvbFwiKVxuICogQHJldHVybiB7RWxlbWVudH0gVGhlIGNyZWF0ZWQgbGlzdFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICA8IS0tIEFzc3VtZSB0aGUgZm9sbG93aW5nIGRvbTogLS0+XG4gKiAgICA8c3BhbiBpZD1cInBzZXVkby1saXN0XCI+XG4gKiAgICAgIGVtaW5lbTxicj5cbiAqICAgICAgZHIuIGRyZVxuICogICAgICA8ZGl2PjUwIENlbnQ8L2Rpdj5cbiAqICAgIDwvc3Bhbj5cbiAqXG4gKiAgICA8c2NyaXB0PlxuICogICAgICB3eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwc2V1ZG8tbGlzdFwiKSwgXCJ1bFwiKTtcbiAqICAgIDwvc2NyaXB0PlxuICpcbiAqICAgIDwhLS0gV2lsbCByZXN1bHQgaW46IC0tPlxuICogICAgPHVsPlxuICogICAgICA8bGk+ZW1pbmVtPC9saT5cbiAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICogICAgICA8bGk+NTAgQ2VudDwvbGk+XG4gKiAgICA8L3VsPlxuICovXG53eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIF9jcmVhdGVMaXN0SXRlbShkb2MsIGxpc3QpIHtcbiAgICB2YXIgbGlzdEl0ZW0gPSBkb2MuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgIGxpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgIHJldHVybiBsaXN0SXRlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVMaXN0KGRvYywgdHlwZSkge1xuICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRUb0xpc3QoZWxlbWVudCwgbGlzdFR5cGUsIHVuZWRpdGFibGVDbGFzcykge1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSBcIlVMXCIgfHwgZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJPTFwiIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09IFwiTUVOVVwiKSB7XG4gICAgICAvLyBBbHJlYWR5IGEgbGlzdFxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyAgICAgICAgICAgICAgID0gZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgICBsaXN0ICAgICAgICAgICAgICA9IF9jcmVhdGVMaXN0KGRvYywgbGlzdFR5cGUpLFxuICAgICAgICBsaW5lQnJlYWtzICAgICAgICA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJyXCIpLFxuICAgICAgICBsaW5lQnJlYWtzTGVuZ3RoICA9IGxpbmVCcmVha3MubGVuZ3RoLFxuICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICBjaGlsZE5vZGVzTGVuZ3RoLFxuICAgICAgICBjaGlsZE5vZGUsXG4gICAgICAgIGxpbmVCcmVhayxcbiAgICAgICAgcGFyZW50Tm9kZSxcbiAgICAgICAgaXNCbG9ja0VsZW1lbnQsXG4gICAgICAgIGlzTGluZUJyZWFrLFxuICAgICAgICBjdXJyZW50TGlzdEl0ZW0sXG4gICAgICAgIGk7XG5cbiAgICAvLyBGaXJzdCBmaW5kIDxicj4gYXQgdGhlIGVuZCBvZiBpbmxpbmUgZWxlbWVudHMgYW5kIG1vdmUgdGhlbSBiZWhpbmQgdGhlbVxuICAgIGZvciAoaT0wOyBpPGxpbmVCcmVha3NMZW5ndGg7IGkrKykge1xuICAgICAgbGluZUJyZWFrID0gbGluZUJyZWFrc1tpXTtcbiAgICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IGxpbmVCcmVhay5wYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlICE9PSBlbGVtZW50ICYmIHBhcmVudE5vZGUubGFzdENoaWxkID09PSBsaW5lQnJlYWspIHtcbiAgICAgICAgaWYgKHd5c2lodG1sNS5kb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20ocGFyZW50Tm9kZSkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZUJyZWFrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB3eXNpaHRtbDUuZG9tLmluc2VydChsaW5lQnJlYWspLmFmdGVyKGxpbmVCcmVhay5wYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZE5vZGVzICAgICAgICA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGVsZW1lbnQuY2hpbGROb2RlcykuZ2V0KCk7XG4gICAgY2hpbGROb2Rlc0xlbmd0aCAgPSBjaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgIGZvciAoaT0wOyBpPGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudExpc3RJdGVtICAgPSBjdXJyZW50TGlzdEl0ZW0gfHwgX2NyZWF0ZUxpc3RJdGVtKGRvYywgbGlzdCk7XG4gICAgICBjaGlsZE5vZGUgICAgICAgICA9IGNoaWxkTm9kZXNbaV07XG4gICAgICBpc0Jsb2NrRWxlbWVudCAgICA9IHd5c2lodG1sNS5kb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20oY2hpbGROb2RlKSA9PT0gXCJibG9ja1wiO1xuICAgICAgaXNMaW5lQnJlYWsgICAgICAgPSBjaGlsZE5vZGUubm9kZU5hbWUgPT09IFwiQlJcIjtcblxuICAgICAgLy8gY29uc2lkZXIgdW5lZGl0YWJsZSBhcyBhbiBpbmxpbmUgZWxlbWVudFxuICAgICAgaWYgKGlzQmxvY2tFbGVtZW50ICYmICghdW5lZGl0YWJsZUNsYXNzIHx8ICF3eXNpaHRtbDUuZG9tLmhhc0NsYXNzKGNoaWxkTm9kZSwgdW5lZGl0YWJsZUNsYXNzKSkpIHtcbiAgICAgICAgLy8gQXBwZW5kIGJsb2NrRWxlbWVudCB0byBjdXJyZW50IDxsaT4gaWYgZW1wdHksIG90aGVyd2lzZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IGN1cnJlbnRMaXN0SXRlbS5maXJzdENoaWxkID8gX2NyZWF0ZUxpc3RJdGVtKGRvYywgbGlzdCkgOiBjdXJyZW50TGlzdEl0ZW07XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICBjdXJyZW50TGlzdEl0ZW0gPSBudWxsO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGluZUJyZWFrKSB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGEgbmV3IGxpc3QgaXRlbSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gd2hlbiB0aGUgY3VycmVudCBvbmUgaGFzIGFscmVhZHkgY29udGVudFxuICAgICAgICBjdXJyZW50TGlzdEl0ZW0gPSBjdXJyZW50TGlzdEl0ZW0uZmlyc3RDaGlsZCA/IG51bGwgOiBjdXJyZW50TGlzdEl0ZW07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50TGlzdEl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIF9jcmVhdGVMaXN0SXRlbShkb2MsIGxpc3QpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobGlzdCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gY29udmVydFRvTGlzdDtcbn0pKCk7XG47LyoqXG4gKiBDb3B5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlc1RvQ29weSBMaXN0IG9mIGF0dHJpYnV0ZXMgd2hpY2ggc2hvdWxkIGJlIGNvcGllZFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aGljaCBvZmZlcnMgdGhlIFwiZnJvbVwiIG1ldGhvZCB3aGljaCBjYW4gYmUgaW52b2tlZCB3aXRoIHRoZSBlbGVtZW50IHdoZXJlIHRvXG4gKiAgICBjb3B5IHRoZSBhdHRyaWJ1dGVzIGZyb20uLCB0aGlzIGFnYWluIHJldHVybnMgYW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGEgbWV0aG9kIG5hbWVkIFwidG9cIiB3aGljaCBjYW4gYmUgaW52b2tlZFxuICogICAgd2l0aCB0aGUgZWxlbWVudCB3aGVyZSB0byBjb3B5IHRoZSBhdHRyaWJ1dGVzIHRvIChzZWUgZXhhbXBsZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgdmFyIHRleHRhcmVhICAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpLFxuICogICAgICAgIGRpdiAgICAgICAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIiksXG4gKiAgICAgICAgYW5vdGhlckRpdiAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2LnByZXZpZXdcIik7XG4gKiAgICB3eXNpaHRtbDUuZG9tLmNvcHlBdHRyaWJ1dGVzKFtcInNwZWxsY2hlY2tcIiwgXCJ2YWx1ZVwiLCBcInBsYWNlaG9sZGVyXCJdKS5mcm9tKHRleHRhcmVhKS50byhkaXYpLmFuZFRvKGFub3RoZXJEaXYpO1xuICpcbiAqL1xud3lzaWh0bWw1LmRvbS5jb3B5QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXNUb0NvcHkpIHtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBmdW5jdGlvbihlbGVtZW50VG9Db3B5RnJvbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG86IGZ1bmN0aW9uKGVsZW1lbnRUb0NvcHlUbykge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIGkgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgIGxlbmd0aCAgICA9IGF0dHJpYnV0ZXNUb0NvcHkubGVuZ3RoO1xuICAgICAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzVG9Db3B5W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihlbGVtZW50VG9Db3B5RnJvbVthdHRyaWJ1dGVdKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtZW50VG9Db3B5RnJvbVthdHRyaWJ1dGVdICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRUb0NvcHlUb1thdHRyaWJ1dGVdID0gZWxlbWVudFRvQ29weUZyb21bYXR0cmlidXRlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgYW5kVG86IGFyZ3VtZW50cy5jYWxsZWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuOy8qKlxuICogQ29weSBhIHNldCBvZiBzdHlsZXMgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgb25seSB3b3JrcyBwcm9wZXJseSBhY3Jvc3MgYnJvd3NlcnMgd2hlbiB0aGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGNvcHkgdGhlIHN0eWxlc1xuICogaXMgaW4gdGhlIGRvbVxuICpcbiAqIEludGVyZXN0aW5nIGFydGljbGUgb24gaG93IHRvIGNvcHkgc3R5bGVzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc3R5bGVzVG9Db3B5IExpc3Qgb2Ygc3R5bGVzIHdoaWNoIHNob3VsZCBiZSBjb3BpZWRcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggb2ZmZXJzIHRoZSBcImZyb21cIiBtZXRob2Qgd2hpY2ggY2FuIGJlIGludm9rZWQgd2l0aCB0aGUgZWxlbWVudCB3aGVyZSB0b1xuICogICAgY29weSB0aGUgc3R5bGVzIGZyb20uLCB0aGlzIGFnYWluIHJldHVybnMgYW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGEgbWV0aG9kIG5hbWVkIFwidG9cIiB3aGljaCBjYW4gYmUgaW52b2tlZFxuICogICAgd2l0aCB0aGUgZWxlbWVudCB3aGVyZSB0byBjb3B5IHRoZSBzdHlsZXMgdG8gKHNlZSBleGFtcGxlKVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICB2YXIgdGV4dGFyZWEgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGV4dGFyZWFcIiksXG4gKiAgICAgICAgZGl2ICAgICAgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2W2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiKSxcbiAqICAgICAgICBhbm90aGVyRGl2ICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJkaXYucHJldmlld1wiKTtcbiAqICAgIHd5c2lodG1sNS5kb20uY29weVN0eWxlcyhbXCJvdmVyZmxvdy15XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0pLmZyb20odGV4dGFyZWEpLnRvKGRpdikuYW5kVG8oYW5vdGhlckRpdik7XG4gKlxuICovXG4oZnVuY3Rpb24oZG9tKSB7XG5cbiAgLyoqXG4gICAqIE1vemlsbGEsIFdlYktpdCBhbmQgT3BlcmEgcmVjYWxjdWxhdGUgdGhlIGNvbXB1dGVkIHdpZHRoIHdoZW4gYm94LXNpemluZzogYm9kZXItYm94OyBpcyBzZXRcbiAgICogU28gaWYgYW4gZWxlbWVudCBoYXMgXCJ3aWR0aDogMjAwcHg7IC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDsgYm9yZGVyOiAxcHg7XCIgdGhlblxuICAgKiBpdHMgY29tcHV0ZWQgY3NzIHdpZHRoIHdpbGwgYmUgMTk4cHhcbiAgICpcbiAgICogU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUyMDk5MlxuICAgKi9cbiAgdmFyIEJPWF9TSVpJTkdfUFJPUEVSVElFUyA9IFtcIi13ZWJraXQtYm94LXNpemluZ1wiLCBcIi1tb3otYm94LXNpemluZ1wiLCBcIi1tcy1ib3gtc2l6aW5nXCIsIFwiYm94LXNpemluZ1wiXTtcblxuICB2YXIgc2hvdWxkSWdub3JlQm94U2l6aW5nQm9yZGVyQm94ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmIChoYXNCb3hTaXppbmdCb3JkZXJCb3goZWxlbWVudCkpIHtcbiAgICAgICByZXR1cm4gcGFyc2VJbnQoZG9tLmdldFN0eWxlKFwid2lkdGhcIikuZnJvbShlbGVtZW50KSwgMTApIDwgZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBoYXNCb3hTaXppbmdCb3JkZXJCb3ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGkgICAgICAgPSAwLFxuICAgICAgICBsZW5ndGggID0gQk9YX1NJWklOR19QUk9QRVJUSUVTLmxlbmd0aDtcbiAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRvbS5nZXRTdHlsZShCT1hfU0laSU5HX1BST1BFUlRJRVNbaV0pLmZyb20oZWxlbWVudCkgPT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICAgIHJldHVybiBCT1hfU0laSU5HX1BST1BFUlRJRVNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGRvbS5jb3B5U3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzVG9Db3B5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveChlbGVtZW50KSkge1xuICAgICAgICAgIHN0eWxlc1RvQ29weSA9IHd5c2lodG1sNS5sYW5nLmFycmF5KHN0eWxlc1RvQ29weSkud2l0aG91dChCT1hfU0laSU5HX1BST1BFUlRJRVMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzc1RleHQgPSBcIlwiLFxuICAgICAgICAgICAgbGVuZ3RoICA9IHN0eWxlc1RvQ29weS5sZW5ndGgsXG4gICAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICAgIHByb3BlcnR5O1xuICAgICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHByb3BlcnR5ID0gc3R5bGVzVG9Db3B5W2ldO1xuICAgICAgICAgIGNzc1RleHQgKz0gcHJvcGVydHkgKyBcIjpcIiArIGRvbS5nZXRTdHlsZShwcm9wZXJ0eSkuZnJvbShlbGVtZW50KSArIFwiO1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0bzogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZG9tLnNldFN0eWxlcyhjc3NUZXh0KS5vbihlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7IGFuZFRvOiBhcmd1bWVudHMuY2FsbGVlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59KSh3eXNpaHRtbDUuZG9tKTtcbjsvKipcbiAqIEV2ZW50IERlbGVnYXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5kZWxlZ2F0ZShkb2N1bWVudC5ib2R5LCBcImFcIiwgXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAqICAgICAgLy8gZm9vXG4gKiAgICB9KTtcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuXG4gIHd5c2lodG1sNS5kb20uZGVsZWdhdGUgPSBmdW5jdGlvbihjb250YWluZXIsIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGNvbnRhaW5lciwgZXZlbnROYW1lLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRhcmdldCAgICA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBtYXRjaCAgICAgPSB3eXNpaHRtbDUubGFuZy5hcnJheShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChtYXRjaC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG59KSh3eXNpaHRtbDUpO1xuOy8vIFRPRE86IFJlZmFjdG9yIGRvbSB0cmVlIHRyYXZlcnNpbmcgaGVyZVxuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB3eXNpaHRtbDUuZG9tLmRvbU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGRlZmF1bHROb2RlVHlwZXMgPSBbd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSwgd3lzaWh0bWw1LlRFWFRfTk9ERV07XG5cbiAgICB2YXIgX2lzQmxhbmtUZXh0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUgJiYgKC9eXFxzKiQvZykudGVzdChub2RlLmRhdGEpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAvLyB2YXIgbm9kZSA9IHd5c2lodG1sNS5kb20uZG9tTm9kZShlbGVtZW50KS5wcmV2KHtub2RlVHlwZXM6IFsxLDNdLCBpZ25vcmVCbGFua1RleHRzOiB0cnVlfSk7XG4gICAgICBwcmV2OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBwcmV2Tm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICAgICAgdHlwZXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLm5vZGVUeXBlcykgPyBvcHRpb25zLm5vZGVUeXBlcyA6IGRlZmF1bHROb2RlVHlwZXM7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXByZXZOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgKCF3eXNpaHRtbDUubGFuZy5hcnJheSh0eXBlcykuY29udGFpbnMocHJldk5vZGUubm9kZVR5cGUpKSB8fCAvLyBub2RlVHlwZXMgY2hlY2suXG4gICAgICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZ25vcmVCbGFua1RleHRzICYmIF9pc0JsYW5rVGV4dChwcmV2Tm9kZSkpIC8vIEJsYW5rIHRleHQgbm9kZXMgYnlwYXNzZWQgaWYgc2V0XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB3eXNpaHRtbDUuZG9tLmRvbU5vZGUocHJldk5vZGUpLnByZXYob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwcmV2Tm9kZTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIHZhciBub2RlID0gd3lzaWh0bWw1LmRvbS5kb21Ob2RlKGVsZW1lbnQpLm5leHQoe25vZGVUeXBlczogWzEsM10sIGlnbm9yZUJsYW5rVGV4dHM6IHRydWV9KTtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZyxcbiAgICAgICAgICAgIHR5cGVzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2RlVHlwZXMpID8gb3B0aW9ucy5ub2RlVHlwZXMgOiBkZWZhdWx0Tm9kZVR5cGVzO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFuZXh0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICghd3lzaWh0bWw1LmxhbmcuYXJyYXkodHlwZXMpLmNvbnRhaW5zKG5leHROb2RlLm5vZGVUeXBlKSkgfHwgLy8gbm9kZVR5cGVzIGNoZWNrLlxuICAgICAgICAgIChvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlQmxhbmtUZXh0cyAmJiBfaXNCbGFua1RleHQobmV4dE5vZGUpKSAvLyBibGFuayB0ZXh0IG5vZGVzIGJ5cGFzc2VkIGlmIHNldFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5kb21Ob2RlKG5leHROb2RlKS5uZXh0KG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgICB9XG5cblxuXG4gICAgfTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7Oy8qKlxuICogUmV0dXJucyB0aGUgZ2l2ZW4gaHRtbCB3cmFwcGVkIGluIGEgZGl2IGVsZW1lbnRcbiAqXG4gKiBGaXhpbmcgSUUncyBpbmFiaWxpdHkgdG8gdHJlYXQgdW5rbm93biBlbGVtZW50cyAoSFRNTDUgc2VjdGlvbiwgYXJ0aWNsZSwgLi4uKSBjb3JyZWN0bHlcbiAqIHdoZW4gaW5zZXJ0ZWQgdmlhIGlubmVySFRNTFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBodG1sIHdoaWNoIHNob3VsZCBiZSB3cmFwcGVkIGluIGEgZG9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JlamN0fSBbY29udGV4dF0gRG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjb250ZXh0IHRoZSBodG1sIGJlbG9uZ3MgdG9cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5nZXRBc0RvbShcIjxhcnRpY2xlPmZvbzwvYXJ0aWNsZT5cIik7XG4gKi9cbnd5c2lodG1sNS5kb20uZ2V0QXNEb20gPSAoZnVuY3Rpb24oKSB7XG5cbiAgdmFyIF9pbm5lckhUTUxTaGl2ID0gZnVuY3Rpb24oaHRtbCwgY29udGV4dCkge1xuICAgIHZhciB0ZW1wRWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0ZW1wRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgY29udGV4dC5ib2R5LmFwcGVuZENoaWxkKHRlbXBFbGVtZW50KTtcbiAgICAvLyBJRSB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gdHJ5aW5nIHRvIGluc2VydCA8ZnJhbWVzZXQ+PC9mcmFtZXNldD4gdmlhIGlubmVySFRNTFxuICAgIHRyeSB7IHRlbXBFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7IH0gY2F0Y2goZSkge31cbiAgICBjb250ZXh0LmJvZHkucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQpO1xuICAgIHJldHVybiB0ZW1wRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBzdXJlIElFIHN1cHBvcnRzIEhUTUw1IHRhZ3MsIHdoaWNoIGlzIGFjY29tcGxpc2hlZCBieSBzaW1wbHkgY3JlYXRpbmcgb25lIGluc3RhbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgKi9cbiAgdmFyIF9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuX3d5c2lodG1sNV9zdXBwb3J0c0hUTUw1VGFncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpPTAsIGxlbmd0aD1IVE1MNV9FTEVNRU5UUy5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnRleHQuY3JlYXRlRWxlbWVudChIVE1MNV9FTEVNRU5UU1tpXSk7XG4gICAgfVxuICAgIGNvbnRleHQuX3d5c2lodG1sNV9zdXBwb3J0c0hUTUw1VGFncyA9IHRydWU7XG4gIH07XG5cblxuICAvKipcbiAgICogTGlzdCBvZiBodG1sNSB0YWdzXG4gICAqIHRha2VuIGZyb20gaHR0cDovL3NpbW9uLmh0bWw1Lm9yZy9odG1sNS1lbGVtZW50c1xuICAgKi9cbiAgdmFyIEhUTUw1X0VMRU1FTlRTID0gW1xuICAgIFwiYWJiclwiLCBcImFydGljbGVcIiwgXCJhc2lkZVwiLCBcImF1ZGlvXCIsIFwiYmRpXCIsIFwiY2FudmFzXCIsIFwiY29tbWFuZFwiLCBcImRhdGFsaXN0XCIsIFwiZGV0YWlsc1wiLCBcImZpZ2NhcHRpb25cIixcbiAgICBcImZpZ3VyZVwiLCBcImZvb3RlclwiLCBcImhlYWRlclwiLCBcImhncm91cFwiLCBcImtleWdlblwiLCBcIm1hcmtcIiwgXCJtZXRlclwiLCBcIm5hdlwiLCBcIm91dHB1dFwiLCBcInByb2dyZXNzXCIsXG4gICAgXCJycFwiLCBcInJ0XCIsIFwicnVieVwiLCBcInN2Z1wiLCBcInNlY3Rpb25cIiwgXCJzb3VyY2VcIiwgXCJzdW1tYXJ5XCIsIFwidGltZVwiLCBcInRyYWNrXCIsIFwidmlkZW9cIiwgXCJ3YnJcIlxuICBdO1xuXG4gIHJldHVybiBmdW5jdGlvbihodG1sLCBjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG4gICAgdmFyIHRlbXBFbGVtZW50O1xuICAgIGlmICh0eXBlb2YoaHRtbCkgPT09IFwib2JqZWN0XCIgJiYgaHRtbC5ub2RlVHlwZSkge1xuICAgICAgdGVtcEVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0ZW1wRWxlbWVudC5hcHBlbmRDaGlsZChodG1sKTtcbiAgICB9IGVsc2UgaWYgKHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzSFRNTDVUYWdzKGNvbnRleHQpKSB7XG4gICAgICB0ZW1wRWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRlbXBFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkoY29udGV4dCk7XG4gICAgICB0ZW1wRWxlbWVudCA9IF9pbm5lckhUTUxTaGl2KGh0bWwsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcEVsZW1lbnQ7XG4gIH07XG59KSgpO1xuOy8qKlxuICogV2Fsa3MgdGhlIGRvbSB0cmVlIGZyb20gdGhlIGdpdmVuIG5vZGUgdXAgdW50aWwgaXQgZmluZHMgYSBtYXRjaFxuICogRGVzaWduZWQgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBmcm9tIHdoaWNoIHRvIGNoZWNrIHRoZSBwYXJlbnQgbm9kZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGluZ1NldCBPYmplY3QgdG8gbWF0Y2ggYWdhaW5zdCAocG9zc2libGUgcHJvcGVydGllczogbm9kZU5hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApXG4gKiBAcGFyYW0ge051bWJlcn0gW2xldmVsc10gSG93IG1hbnkgcGFyZW50cyBzaG91bGQgdGhlIGZ1bmN0aW9uIGNoZWNrIHVwIGZyb20gdGhlIGN1cnJlbnQgbm9kZSAoZGVmYXVsdHMgdG8gNTApXG4gKiBAcmV0dXJuIHtudWxsfEVsZW1lbnR9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVkIHRoZSBkZXNpcmVkTm9kZU5hbWUocylcbiAqIEBleGFtcGxlXG4gKiAgICB2YXIgbGlzdEVsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpXCIpLCB7IG5vZGVOYW1lOiBbXCJNRU5VXCIsIFwiVUxcIiwgXCJPTFwiXSB9KTtcbiAqICAgIC8vIC4uLiBvciAuLi5cbiAqICAgIHZhciB1bm9yZGVyZWRMaXN0RWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlcIiksIHsgbm9kZU5hbWU6IFwiVUxcIiB9KTtcbiAqICAgIC8vIC4uLiBvciAuLi5cbiAqICAgIHZhciBjb2xvcmVkRWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChteVRleHROb2RlLCB7IG5vZGVOYW1lOiBcIlNQQU5cIiwgY2xhc3NOYW1lOiBcInd5c2l3eWctY29sb3ItcmVkXCIsIGNsYXNzUmVnRXhwOiAvd3lzaXd5Zy1jb2xvci1bYS16XS9nIH0pO1xuICovXG53eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gX2lzU2FtZU5vZGVOYW1lKG5vZGVOYW1lLCBkZXNpcmVkTm9kZU5hbWVzKSB7XG4gICAgaWYgKCFkZXNpcmVkTm9kZU5hbWVzIHx8ICFkZXNpcmVkTm9kZU5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihkZXNpcmVkTm9kZU5hbWVzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG5vZGVOYW1lID09PSBkZXNpcmVkTm9kZU5hbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZGVzaXJlZE5vZGVOYW1lcykuY29udGFpbnMobm9kZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhc0NsYXNzTmFtZShlbGVtZW50LCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSAoZWxlbWVudC5jbGFzc05hbWUgfHwgXCJcIikubWF0Y2goY2xhc3NSZWdFeHApIHx8IFtdO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gISFjbGFzc05hbWVzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXNbY2xhc3NOYW1lcy5sZW5ndGggLSAxXSA9PT0gY2xhc3NOYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhc1N0eWxlKGVsZW1lbnQsIGNzc1N0eWxlLCBzdHlsZVJlZ0V4cCkge1xuICAgIHZhciBzdHlsZXMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgXCJcIikubWF0Y2goc3R5bGVSZWdFeHApIHx8IFtdO1xuICAgIGlmICghY3NzU3R5bGUpIHtcbiAgICAgIHJldHVybiAhIXN0eWxlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXNbc3R5bGVzLmxlbmd0aCAtIDFdID09PSBjc3NTdHlsZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihub2RlLCBtYXRjaGluZ1NldCwgbGV2ZWxzLCBjb250YWluZXIpIHtcbiAgICB2YXIgZmluZEJ5U3R5bGUgPSAobWF0Y2hpbmdTZXQuY3NzU3R5bGUgfHwgbWF0Y2hpbmdTZXQuc3R5bGVSZWdFeHApLFxuICAgICAgICBmaW5kQnlDbGFzcyA9IChtYXRjaGluZ1NldC5jbGFzc05hbWUgfHwgbWF0Y2hpbmdTZXQuY2xhc3NSZWdFeHApO1xuXG4gICAgbGV2ZWxzID0gbGV2ZWxzIHx8IDUwOyAvLyBHbyBtYXggNTAgbm9kZXMgdXB3YXJkcyBmcm9tIGN1cnJlbnQgbm9kZVxuXG4gICAgd2hpbGUgKGxldmVscy0tICYmIG5vZGUgJiYgbm9kZS5ub2RlTmFtZSAhPT0gXCJCT0RZXCIgJiYgKCFjb250YWluZXIgfHwgbm9kZSAhPT0gY29udGFpbmVyKSkge1xuICAgICAgaWYgKF9pc0VsZW1lbnQobm9kZSkgJiYgX2lzU2FtZU5vZGVOYW1lKG5vZGUubm9kZU5hbWUsIG1hdGNoaW5nU2V0Lm5vZGVOYW1lKSAmJlxuICAgICAgICAgICghZmluZEJ5U3R5bGUgfHwgX2hhc1N0eWxlKG5vZGUsIG1hdGNoaW5nU2V0LmNzc1N0eWxlLCBtYXRjaGluZ1NldC5zdHlsZVJlZ0V4cCkpICYmXG4gICAgICAgICAgKCFmaW5kQnlDbGFzcyB8fCBfaGFzQ2xhc3NOYW1lKG5vZGUsIG1hdGNoaW5nU2V0LmNsYXNzTmFtZSwgbWF0Y2hpbmdTZXQuY2xhc3NSZWdFeHApKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59KSgpO1xuOy8qKlxuICogR2V0IGVsZW1lbnQncyBzdHlsZSBmb3IgYSBzcGVjaWZpYyBjc3MgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdG8gcmV0cmlldmUgdGhlIHN0eWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIENTUyBwcm9wZXJ0eSB0byByZXRyaWV2ZSAoXCJmbG9hdFwiLCBcImRpc3BsYXlcIiwgXCJ0ZXh0LWFsaWduXCIsIC4uLilcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShkb2N1bWVudC5ib2R5KTtcbiAqICAgIC8vID0+IFwiYmxvY2tcIlxuICovXG53eXNpaHRtbDUuZG9tLmdldFN0eWxlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGVQcm9wZXJ0eU1hcHBpbmcgPSB7XG4gICAgICAgIFwiZmxvYXRcIjogKFwic3R5bGVGbG9hdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUpID8gXCJzdHlsZUZsb2F0XCIgOiBcImNzc0Zsb2F0XCJcbiAgICAgIH0sXG4gICAgICBSRUdfRVhQX0NBTUVMSVpFID0gL1xcLVthLXpdL2c7XG5cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR19FWFBfQ0FNRUxJWkUsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2guY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2MgICAgICAgICAgICAgICA9IGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIGNhbWVsaXplZFByb3BlcnR5ID0gc3R5bGVQcm9wZXJ0eU1hcHBpbmdbcHJvcGVydHldIHx8IGNhbWVsaXplKHByb3BlcnR5KSxcbiAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgID0gZWxlbWVudC5zdHlsZSxcbiAgICAgICAgICAgIGN1cnJlbnRTdHlsZSAgICAgID0gZWxlbWVudC5jdXJyZW50U3R5bGUsXG4gICAgICAgICAgICBzdHlsZVZhbHVlICAgICAgICA9IHN0eWxlW2NhbWVsaXplZFByb3BlcnR5XTtcbiAgICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1cnJlbnRTdHlsZSBpcyBubyBzdGFuZGFyZCBhbmQgb25seSBzdXBwb3J0ZWQgYnkgT3BlcmEgYW5kIElFIGJ1dCBpdCBoYXMgb25lIGltcG9ydGFudCBhZHZhbnRhZ2Ugb3ZlciB0aGUgc3RhbmRhcmQtY29tcGxpYW50XG4gICAgICAgIC8vIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlLCBzaW5jZSBpdCByZXR1cm5zIGNzcyBwcm9wZXJ0eSB2YWx1ZXMgaW4gdGhlaXIgb3JpZ2luYWwgdW5pdDpcbiAgICAgICAgLy8gSWYgeW91IHNldCBhbiBlbGVtZW50cyB3aWR0aCB0byBcIjUwJVwiLCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB3aWxsIGdpdmUgeW91IGl0J3MgY3VycmVudCB3aWR0aCBpbiBweCB3aGlsZSBjdXJyZW50U3R5bGVcbiAgICAgICAgLy8gZ2l2ZXMgeW91IHRoZSBvcmlnaW5hbCBcIjUwJVwiLlxuICAgICAgICAvLyBPcGVyYSBzdXBwb3J0cyBib3RoLCBjdXJyZW50U3R5bGUgYW5kIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlLCB0aGF0J3Mgd2h5IGNoZWNraW5nIGZvciBjdXJyZW50U3R5bGUgc2hvdWxkIGhhdmUgaGlnaGVyIHByaW9cbiAgICAgICAgaWYgKGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFN0eWxlW2NhbWVsaXplZFByb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vaWUgd2lsbCBvY2Nhc2lvbmFsbHkgZmFpbCBmb3IgdW5rbm93biByZWFzb25zLiBzd2FsbG93aW5nIGV4Y2VwdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aW4gICAgICAgICAgICAgICAgID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3csXG4gICAgICAgICAgICBuZWVkc092ZXJmbG93UmVzZXQgID0gKHByb3BlcnR5ID09PSBcImhlaWdodFwiIHx8IHByb3BlcnR5ID09PSBcIndpZHRoXCIpICYmIGVsZW1lbnQubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIixcbiAgICAgICAgICAgIG9yaWdpbmFsT3ZlcmZsb3csXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICBpZiAod2luLmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGNhbGN1bGF0ZSBhIHdyb25nIHdpZHRoIGFuZCBoZWlnaHQgZm9yIHRleHRhcmVhcyB3aGVuIHRoZXkgaGF2ZSBzY3JvbGwgYmFyc1xuICAgICAgICAgIC8vIHRoZXJmb3JlIHdlIHJlbW92ZSBhbmQgcmVzdG9yZSB0aGUgc2Nyb2xsYmFyIGFuZCBjYWxjdWxhdGUgdGhlIHZhbHVlIGluIGJldHdlZW5cbiAgICAgICAgICBpZiAobmVlZHNPdmVyZmxvd1Jlc2V0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbE92ZXJmbG93ID0gc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblZhbHVlID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgICAgICAgaWYgKG5lZWRzT3ZlcmZsb3dSZXNldCkge1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcmlnaW5hbE92ZXJmbG93IHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG59KSgpO1xuO3d5c2lodG1sNS5kb20uZ2V0VGV4dE5vZGVzID0gZnVuY3Rpb24obm9kZSwgaW5nb3JlRW1wdHkpe1xuICB2YXIgYWxsID0gW107XG4gIGZvciAobm9kZT1ub2RlLmZpcnN0Q2hpbGQ7bm9kZTtub2RlPW5vZGUubmV4dFNpYmxpbmcpe1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgIGlmICghaW5nb3JlRW1wdHkgfHwgISgvXlxccyokLykudGVzdChub2RlLmlubmVyVGV4dCB8fCBub2RlLnRleHRDb250ZW50KSkge1xuICAgICAgICBhbGwucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsID0gYWxsLmNvbmNhdCh3eXNpaHRtbDUuZG9tLmdldFRleHROb2Rlcyhub2RlLCBpbmdvcmVFbXB0eSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsO1xufTs7LyoqXG4gKiBIaWdoIHBlcmZvcm1hbnQgd2F5IHRvIGNoZWNrIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgdGFnIG5hbWUgaXMgaW4gdGhlIGdpdmVuIGRvY3VtZW50XG4gKiBPcHRpbWl6ZWQgZm9yIGJlaW5nIGhlYXZpbHkgZXhlY3V0ZWRcbiAqIFVubGVhc2hlcyB0aGUgcG93ZXIgb2YgbGl2ZSBub2RlIGxpc3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBUaGUgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjb250ZXh0IHdoZXJlIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBVcHBlciBjYXNlZCB0YWcgbmFtZVxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvY3VtZW50LCBcIklNR1wiKTtcbiAqL1xud3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aFRhZ05hbWUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBMSVZFX0NBQ0hFICAgICAgICAgID0ge30sXG4gICAgICBET0NVTUVOVF9JREVOVElGSUVSID0gMTtcblxuICBmdW5jdGlvbiBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykge1xuICAgIHJldHVybiBkb2MuX3d5c2lodG1sNV9pZGVudGlmaWVyIHx8IChkb2MuX3d5c2lodG1sNV9pZGVudGlmaWVyID0gRE9DVU1FTlRfSURFTlRJRklFUisrKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihkb2MsIHRhZ05hbWUpIHtcbiAgICB2YXIga2V5ICAgICAgICAgPSBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykgKyBcIjpcIiArIHRhZ05hbWUsXG4gICAgICAgIGNhY2hlRW50cnkgID0gTElWRV9DQUNIRVtrZXldO1xuICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgY2FjaGVFbnRyeSA9IExJVkVfQ0FDSEVba2V5XSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVFbnRyeS5sZW5ndGggPiAwO1xuICB9O1xufSkoKTtcbjsvKipcbiAqIEhpZ2ggcGVyZm9ybWFudCB3YXkgdG8gY2hlY2sgd2hldGhlciBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpYyBjbGFzcyBuYW1lIGlzIGluIHRoZSBnaXZlbiBkb2N1bWVudFxuICogT3B0aW1pemVkIGZvciBiZWluZyBoZWF2aWx5IGV4ZWN1dGVkXG4gKiBVbmxlYXNoZXMgdGhlIHBvd2VyIG9mIGxpdmUgbm9kZSBsaXN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgVGhlIGRvY3VtZW50IG9iamVjdCBvZiB0aGUgY29udGV4dCB3aGVyZSB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVXBwZXIgY2FzZWQgdGFnIG5hbWVcbiAqIEBleGFtcGxlXG4gKiAgICB3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoQ2xhc3NOYW1lKGRvY3VtZW50LCBcImZvb2JhclwiKTtcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgTElWRV9DQUNIRSAgICAgICAgICA9IHt9LFxuICAgICAgRE9DVU1FTlRfSURFTlRJRklFUiA9IDE7XG5cbiAgZnVuY3Rpb24gX2dldERvY3VtZW50SWRlbnRpZmllcihkb2MpIHtcbiAgICByZXR1cm4gZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciB8fCAoZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciA9IERPQ1VNRU5UX0lERU5USUZJRVIrKyk7XG4gIH1cblxuICB3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoQ2xhc3NOYW1lID0gZnVuY3Rpb24oZG9jLCBjbGFzc05hbWUpIHtcbiAgICAvLyBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUU8OVxuICAgIC8vIGJ1dCBpcyBzb21ldGltZXMgbW9ja2VkIHZpYSBsaWJyYXJ5IGNvZGUgKHdoaWNoIHRoZW4gZG9lc24ndCByZXR1cm4gbGl2ZSBub2RlIGxpc3RzKVxuICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNOYXRpdmVHZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCkpIHtcbiAgICAgIHJldHVybiAhIWRvYy5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ICAgICAgICAgPSBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykgKyBcIjpcIiArIGNsYXNzTmFtZSxcbiAgICAgICAgY2FjaGVFbnRyeSAgPSBMSVZFX0NBQ0hFW2tleV07XG4gICAgaWYgKCFjYWNoZUVudHJ5KSB7XG4gICAgICBjYWNoZUVudHJ5ID0gTElWRV9DQUNIRVtrZXldID0gZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVFbnRyeS5sZW5ndGggPiAwO1xuICB9O1xufSkod3lzaWh0bWw1KTtcbjt3eXNpaHRtbDUuZG9tLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnRUb0luc2VydCkge1xuICByZXR1cm4ge1xuICAgIGFmdGVyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnRUb0luc2VydCwgZWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgfSxcblxuICAgIGJlZm9yZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50VG9JbnNlcnQsIGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBpbnRvOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnRUb0luc2VydCk7XG4gICAgfVxuICB9O1xufTtcbjt3eXNpaHRtbDUuZG9tLmluc2VydENTUyA9IGZ1bmN0aW9uKHJ1bGVzKSB7XG4gIHJ1bGVzID0gcnVsZXMuam9pbihcIlxcblwiKTtcblxuICByZXR1cm4ge1xuICAgIGludG86IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuICAgICAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBydWxlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUocnVsZXMpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmsgPSBkb2MucXVlcnlTZWxlY3RvcihcImhlYWQgbGlua1wiKTtcbiAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgIGxpbmsucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsaW5rKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhlYWQgPSBkb2MucXVlcnlTZWxlY3RvcihcImhlYWRcIik7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbjsvLyBUT0RPOiBSZWZhY3RvciBkb20gdHJlZSB0cmF2ZXJzaW5nIGhlcmVcbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgd3lzaWh0bWw1LmRvbS5saW5lQnJlYWtzID0gZnVuY3Rpb24obm9kZSkge1xuXG4gICAgZnVuY3Rpb24gX2lzTGluZUJyZWFrKG4pIHtcbiAgICAgIHJldHVybiBuLm5vZGVOYW1lID09PSBcIkJSXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGVsbWVudCBjYXVzZXMgYSB2aXN1YWwgbGluZSBicmVha1xuICAgICAqICg8YnI+IG9yIGJsb2NrIGVsZW1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGlmIChfaXNMaW5lQnJlYWsoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh3eXNpaHRtbDUuZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKGVsZW1lbnQpID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKiB3eXNpaHRtbDUuZG9tLmxpbmVCcmVha3MoZWxlbWVudCkuYWRkKCk7XG4gICAgICAgKlxuICAgICAgICogQWRkcyBsaW5lIGJyZWFrcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBnaXZlbiBub2RlIGlmIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBzaWJsaW5nc1xuICAgICAgICogYXJlbid0IGFscmVhZHkgY2F1c2luZyBhIHZpc3VhbCBsaW5lIGJyZWFrIChibG9jayBlbGVtZW50IG9yIDxicj4pXG4gICAgICAgKi9cbiAgICAgIGFkZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZG9jICAgICAgICAgICAgID0gbm9kZS5vd25lckRvY3VtZW50LFxuICAgICAgICAgIG5leHRTaWJsaW5nICAgICA9IHd5c2lodG1sNS5kb20uZG9tTm9kZShub2RlKS5uZXh0KHtpZ25vcmVCbGFua1RleHRzOiB0cnVlfSksXG4gICAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gd3lzaWh0bWw1LmRvbS5kb21Ob2RlKG5vZGUpLnByZXYoe2lnbm9yZUJsYW5rVGV4dHM6IHRydWV9KTtcblxuICAgICAgICBpZiAobmV4dFNpYmxpbmcgJiYgIV9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20uaW5zZXJ0KGRvYy5jcmVhdGVFbGVtZW50KFwiYnJcIikpLmFmdGVyKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgIV9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KHByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICB3eXNpaHRtbDUuZG9tLmluc2VydChkb2MuY3JlYXRlRWxlbWVudChcImJyXCIpKS5iZWZvcmUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qIHd5c2lodG1sNS5kb20ubGluZUJyZWFrcyhlbGVtZW50KS5yZW1vdmUoKTtcbiAgICAgICAqXG4gICAgICAgKiBSZW1vdmVzIGxpbmUgYnJlYWtzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGdpdmVuIG5vZGVcbiAgICAgICAqL1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZyAgICAgPSB3eXNpaHRtbDUuZG9tLmRvbU5vZGUobm9kZSkubmV4dCh7aWdub3JlQmxhbmtUZXh0czogdHJ1ZX0pLFxuICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gd3lzaWh0bWw1LmRvbS5kb21Ob2RlKG5vZGUpLnByZXYoe2lnbm9yZUJsYW5rVGV4dHM6IHRydWV9KTtcblxuICAgICAgICBpZiAobmV4dFNpYmxpbmcgJiYgX2lzTGluZUJyZWFrKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIG5leHRTaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgX2lzTGluZUJyZWFrKHByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICBwcmV2aW91c1NpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7Oy8qKlxuICogTWV0aG9kIHRvIHNldCBkb20gZXZlbnRzXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LCBbXCJmb2N1c1wiLCBcImJsdXJcIl0sIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gKi9cbnd5c2lodG1sNS5kb20ub2JzZXJ2ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGhhbmRsZXIpIHtcbiAgZXZlbnROYW1lcyA9IHR5cGVvZihldmVudE5hbWVzKSA9PT0gXCJzdHJpbmdcIiA/IFtldmVudE5hbWVzXSA6IGV2ZW50TmFtZXM7XG5cbiAgdmFyIGhhbmRsZXJXcmFwcGVyLFxuICAgICAgZXZlbnROYW1lLFxuICAgICAgaSAgICAgICA9IDAsXG4gICAgICBsZW5ndGggID0gZXZlbnROYW1lcy5sZW5ndGg7XG5cbiAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICBldmVudE5hbWUgPSBldmVudE5hbWVzW2ldO1xuICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcldyYXBwZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIShcInRhcmdldFwiIGluIGV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBldmVudC5wcmV2ZW50RGVmYXVsdCB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGhhbmRsZXIuY2FsbChlbGVtZW50LCBldmVudCk7XG4gICAgICB9O1xuICAgICAgZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50TmFtZSxcbiAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICBsZW5ndGggID0gZXZlbnROYW1lcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWVzW2ldO1xuICAgICAgICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuOy8qKlxuICogSFRNTCBTYW5pdGl6ZXJcbiAqIFJld3JpdGVzIHRoZSBIVE1MIGJhc2VkIG9uIGdpdmVuIHJ1bGVzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudE9ySHRtbCBIVE1MIFN0cmluZyB0byBiZSBzYW5pdGl6ZWQgT1IgZWxlbWVudCB3aG9zZSBjb250ZW50IHNob3VsZCBiZSBzYW5pdGl6ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcnVsZXNdIExpc3Qgb2YgcnVsZXMgZm9yIHJld3JpdGluZyB0aGUgSFRNTCwgaWYgdGhlcmUncyBubyBydWxlIGZvciBhbiBlbGVtZW50IGl0IHdpbGxcbiAqICAgIGJlIGNvbnZlcnRlZCB0byBhIFwic3BhblwiLiBFYWNoIHJ1bGUgaXMgYSBrZXkvdmFsdWUgcGFpciB3aGVyZSBrZXkgaXMgdGhlIHRhZyB0byBjb252ZXJ0LCBhbmQgdmFsdWUgdGhlXG4gKiAgICBkZXNpcmVkIHN1YnN0aXR1dGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IERvY3VtZW50IG9iamVjdCBpbiB3aGljaCB0byBwYXJzZSB0aGUgaHRtbCwgbmVlZGVkIHRvIHNhbmRib3ggdGhlIHBhcnNpbmdcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fFN0cmluZ30gRGVwZW5kcyBvbiB0aGUgZWxlbWVudE9ySHRtbCBwYXJhbWV0ZXIuIFdoZW4gaHRtbCB0aGVuIHRoZSBzYW5pdGl6ZWQgaHRtbCBhcyBzdHJpbmcgZWxzZXdpc2UgdGhlIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8ZGl2IGlkPVwiZm9vXCIgb25jbGljaz1cImFsZXJ0KDEpO1wiPjxwPjxmb250IGNvbG9yPVwicmVkXCI+Zm9vPC9mb250PjxzY3JpcHQ+YWxlcnQoMSk7PC9zY3JpcHQ+PC9wPjwvZGl2Pic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MLCB7XG4gKiAgICAgIHRhZ3Mge1xuICogICAgICAgIHA6ICAgICAgXCJkaXZcIiwgICAgICAvLyBSZW5hbWUgcCB0YWdzIHRvIGRpdiB0YWdzXG4gKiAgICAgICAgZm9udDogICBcInNwYW5cIiAgICAgIC8vIFJlbmFtZSBmb250IHRhZ3MgdG8gc3BhbiB0YWdzXG4gKiAgICAgICAgZGl2OiAgICB0cnVlLCAgICAgICAvLyBLZWVwIHRoZW0sIGFsc28gcG9zc2libGUgKHNhbWUgcmVzdWx0IHdoZW4gcGFzc2luZzogXCJkaXZcIiBvciB0cnVlKVxuICogICAgICAgIHNjcmlwdDogdW5kZWZpbmVkICAgLy8gUmVtb3ZlIHNjcmlwdCBlbGVtZW50c1xuICogICAgICB9XG4gKiAgICB9KTtcbiAqICAgIC8vID0+IDxkaXY+PGRpdj48c3Bhbj5mb28gYmFyPC9zcGFuPjwvZGl2PjwvZGl2PlxuICpcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8dGFibGU+PHRib2R5Pjx0cj48dGQ+SSdtIGEgdGFibGUhPC90ZD48L3RyPjwvdGJvZHk+PC90YWJsZT4nO1xuICogICAgd3lzaWh0bWw1LmRvbS5wYXJzZSh1c2VySFRNTCk7XG4gKiAgICAvLyA9PiAnPHNwYW4+PHNwYW4+PHNwYW4+PHNwYW4+SSdtIGEgdGFibGUhPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPidcbiAqXG4gKiAgICB2YXIgdXNlckhUTUwgPSAnPGRpdj5mb29iYXI8YnI+Zm9vYmFyPC9kaXY+JztcbiAqICAgIHd5c2lodG1sNS5kb20ucGFyc2UodXNlckhUTUwsIHtcbiAqICAgICAgdGFnczoge1xuICogICAgICAgIGRpdjogdW5kZWZpbmVkLFxuICogICAgICAgIGJyOiAgdHJ1ZVxuICogICAgICB9XG4gKiAgICB9KTtcbiAqICAgIC8vID0+ICcnXG4gKlxuICogICAgdmFyIHVzZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJyZWRcIj5mb288L2Rpdj48ZGl2IGNsYXNzPVwicGlua1wiPmJhcjwvZGl2Pic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MLCB7XG4gKiAgICAgIGNsYXNzZXM6IHtcbiAqICAgICAgICByZWQ6ICAgIDEsXG4gKiAgICAgICAgZ3JlZW46ICAxXG4gKiAgICAgIH0sXG4gKiAgICAgIHRhZ3M6IHtcbiAqICAgICAgICBkaXY6IHtcbiAqICAgICAgICAgIHJlbmFtZV90YWc6ICAgICBcInBcIlxuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSk7XG4gKiAgICAvLyA9PiAnPHAgY2xhc3M9XCJyZWRcIj5mb288L3A+PHA+YmFyPC9wPidcbiAqL1xuXG53eXNpaHRtbDUuZG9tLnBhcnNlID0gZnVuY3Rpb24oZWxlbWVudE9ySHRtbF9jdXJyZW50LCBjb25maWdfY3VycmVudCkge1xuICAvKiBUT0RPOiBDdXJyZW50bHkgZXNjYXBlZCBtb2R1bGUgcGF0dGVybiBhcyBvdGhlcndpc2UgZm9sbG9vd2luZyBkZWZhdWx0IHN3aWxsIGJlIHNoYXJlZCBhbW9uZyBtdWx0aXBsZSBlZGl0b3JzLlxuICAgKiBSZWZhY3RvciB3aG9sZSBjb2RlIGFzIHRoaXMgbWV0aG9kIHdoaWxlIHdvcmtpbmQgaXMga2luZCBvZiBhd2t3YXJkIHRvbyAqL1xuXG4gIC8qKlxuICAgKiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYSBYTUxQYXJzZXIvRE9NUGFyc2VyIGFzIEhUTUw1IGlzIG5vdCBhbHdheXMgd2VsbC1mb3JtZWQgWE1MXG4gICAqIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoJzxpbWcgc3JjPVwiZm9vLmdpZlwiPicpIHdpbGwgY2F1c2UgYSBwYXJzZUVycm9yIHNpbmNlIHRoZVxuICAgKiBub2RlIGlzbid0IGNsb3NlZFxuICAgKlxuICAgKiBUaGVyZWZvcmUgd2UndmUgdG8gdXNlIHRoZSBicm93c2VyJ3Mgb3JkaW5hcnkgSFRNTCBwYXJzZXIgaW52b2tlZCBieSBzZXR0aW5nIGlubmVySFRNTC5cbiAgICovXG4gIHZhciBOT0RFX1RZUEVfTUFQUElORyA9IHtcbiAgICAgICAgXCIxXCI6IF9oYW5kbGVFbGVtZW50LFxuICAgICAgICBcIjNcIjogX2hhbmRsZVRleHQsXG4gICAgICAgIFwiOFwiOiBfaGFuZGxlQ29tbWVudFxuICAgICAgfSxcbiAgICAgIC8vIFJlbmFtZSB1bmtub3duIHRhZ3MgdG8gdGhpc1xuICAgICAgREVGQVVMVF9OT0RFX05BTUUgICA9IFwic3BhblwiLFxuICAgICAgV0hJVEVfU1BBQ0VfUkVHX0VYUCA9IC9cXHMrLyxcbiAgICAgIGRlZmF1bHRSdWxlcyAgICAgICAgPSB7IHRhZ3M6IHt9LCBjbGFzc2VzOiB7fSB9LFxuICAgICAgY3VycmVudFJ1bGVzICAgICAgICA9IHt9O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjaGlsZHMgb2YgdGhlIGVsZW1lbnQsIHJlY3JlYXRlcyB0aGVtLCBhcHBlbmRzIHRoZW0gaW50byBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAqIHdoaWNoIGxhdGVyIHJlcGxhY2VzIHRoZSBlbnRpcmUgYm9keSBjb250ZW50XG4gICAqL1xuICAgZnVuY3Rpb24gcGFyc2UoZWxlbWVudE9ySHRtbCwgY29uZmlnKSB7XG4gICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KGN1cnJlbnRSdWxlcykubWVyZ2UoZGVmYXVsdFJ1bGVzKS5tZXJnZShjb25maWcucnVsZXMpLmdldCgpO1xuXG4gICAgdmFyIGNvbnRleHQgICAgICAgPSBjb25maWcuY29udGV4dCB8fCBlbGVtZW50T3JIdG1sLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQsXG4gICAgICAgIGZyYWdtZW50ICAgICAgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgaXNTdHJpbmcgICAgICA9IHR5cGVvZihlbGVtZW50T3JIdG1sKSA9PT0gXCJzdHJpbmdcIixcbiAgICAgICAgY2xlYXJJbnRlcm5hbHMgPSBmYWxzZSxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgZmlyc3RDaGlsZDtcblxuICAgIGlmIChjb25maWcuY2xlYXJJbnRlcm5hbHMgPT09IHRydWUpIHtcbiAgICAgIGNsZWFySW50ZXJuYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIGVsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldEFzRG9tKGVsZW1lbnRPckh0bWwsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudE9ySHRtbDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFJ1bGVzLnNlbGVjdG9ycykge1xuICAgICAgX2FwcGx5U2VsZWN0b3JSdWxlcyhlbGVtZW50LCBjdXJyZW50UnVsZXMuc2VsZWN0b3JzKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBmaXJzdENoaWxkID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgbmV3Tm9kZSA9IF9jb252ZXJ0KGZpcnN0Q2hpbGQsIGNvbmZpZy5jbGVhblVwLCBjbGVhckludGVybmFscywgY29uZmlnLnVuZWRpdGFibGVDbGFzcyk7XG4gICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChuZXdOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBuZXdOb2RlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy51bmpvaW5OYnNwcykge1xuICAgICAgLy8gcmVwbGFjZSBqb2luZWQgbm9uLWJyZWFrYWJsZSBzcGFjZXMgd2l0aCB1bmpvaW5lZFxuICAgICAgdmFyIHR4dG5vZGVzID0gd3lzaWh0bWw1LmRvbS5nZXRUZXh0Tm9kZXMoZnJhZ21lbnQpO1xuICAgICAgZm9yICh2YXIgbiA9IHR4dG5vZGVzLmxlbmd0aDsgbi0tOykge1xuICAgICAgICB0eHRub2Rlc1tuXS5ub2RlVmFsdWUgPSB0eHRub2Rlc1tuXS5ub2RlVmFsdWUucmVwbGFjZSgvKFtcXFNcXHUwMEEwXSlcXHUwMEEwL2dpLCBcIiQxIFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhciBlbGVtZW50IGNvbnRlbnRzXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgLy8gSW5zZXJ0IG5ldyBET00gdHJlZVxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXG4gICAgcmV0dXJuIGlzU3RyaW5nID8gd3lzaWh0bWw1LnF1aXJrcy5nZXRDb3JyZWN0SW5uZXJIVE1MKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb252ZXJ0KG9sZE5vZGUsIGNsZWFuVXAsIGNsZWFySW50ZXJuYWxzLCB1bmVkaXRhYmxlQ2xhc3MpIHtcbiAgICB2YXIgb2xkTm9kZVR5cGUgICAgID0gb2xkTm9kZS5ub2RlVHlwZSxcbiAgICAgICAgb2xkQ2hpbGRzICAgICAgID0gb2xkTm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICBvbGRDaGlsZHNMZW5ndGggPSBvbGRDaGlsZHMubGVuZ3RoLFxuICAgICAgICBtZXRob2QgICAgICAgICAgPSBOT0RFX1RZUEVfTUFQUElOR1tvbGROb2RlVHlwZV0sXG4gICAgICAgIGkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgIGZyYWdtZW50LFxuICAgICAgICBuZXdOb2RlLFxuICAgICAgICBuZXdDaGlsZDtcblxuICAgIC8vIFBhc3NlcyBkaXJlY3RseSBlbGVtZXRzIHdpdGggdW5lZGl0YWJsZSBjbGFzc1xuICAgIGlmICh1bmVkaXRhYmxlQ2xhc3MgJiYgb2xkTm9kZVR5cGUgPT09IDEgJiYgd3lzaWh0bWw1LmRvbS5oYXNDbGFzcyhvbGROb2RlLCB1bmVkaXRhYmxlQ2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBvbGROb2RlO1xuICAgIH1cblxuICAgIG5ld05vZGUgPSBtZXRob2QgJiYgbWV0aG9kKG9sZE5vZGUsIGNsZWFySW50ZXJuYWxzKTtcblxuICAgIC8vIFJlbW92ZSBvciB1bndyYXAgbm9kZSBpbiBjYXNlIG9mIHJldHVybiB2YWx1ZSBudWxsIG9yIGZhbHNlXG4gICAgaWYgKCFuZXdOb2RlKSB7XG4gICAgICAgIGlmIChuZXdOb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gZmFsc2UgZGVmaW5lcyB0aGF0IHRhZyBzaG91bGQgYmUgcmVtb3ZlZCBidXQgY29udGVudHMgc2hvdWxkIHJlbWFpbiAodW53cmFwKVxuICAgICAgICAgICAgZnJhZ21lbnQgPSBvbGROb2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSBvbGRDaGlsZHNMZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgaWYgKG9sZENoaWxkc1tpXSkge1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gX2NvbnZlcnQob2xkQ2hpbGRzW2ldLCBjbGVhblVwLCBjbGVhckludGVybmFscywgdW5lZGl0YWJsZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvbGRDaGlsZHNbaV0gPT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZShuZXdDaGlsZCwgZnJhZ21lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3eXNpaHRtbDUuZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKG9sZE5vZGUpID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQob2xkTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRyeSB0byBtaW5pbWl6ZSBzdXJwbHVzIHNwYWNlc1xuICAgICAgICAgICAgaWYgKHd5c2lodG1sNS5sYW5nLmFycmF5KFtcbiAgICAgICAgICAgICAgICBcImRpdlwiLCBcInByZVwiLCBcInBcIixcbiAgICAgICAgICAgICAgICBcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiLFxuICAgICAgICAgICAgICAgIFwidWxcIiwgXCJvbFwiLCBcImxpXCIsXG4gICAgICAgICAgICAgICAgXCJkZFwiLCBcImRsXCIsXG4gICAgICAgICAgICAgICAgXCJmb290ZXJcIiwgXCJoZWFkZXJcIiwgXCJzZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJoMVwiLCBcImgyXCIsIFwiaDNcIiwgXCJoNFwiLCBcImg1XCIsIFwiaDZcIlxuICAgICAgICAgICAgXSkuY29udGFpbnMob2xkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiBvbGROb2RlLnBhcmVudE5vZGUubGFzdENoaWxkICE9PSBvbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGF0IGZpcnN0IHdoZW4gdW53cmFwaW5nIG5vbi10ZXh0ZmxvdyBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGlmICghb2xkTm9kZS5uZXh0U2libGluZyB8fCBvbGROb2RlLm5leHRTaWJsaW5nLm5vZGVUeXBlICE9PSAzIHx8ICEoL15cXHMvKS50ZXN0KG9sZE5vZGUubmV4dFNpYmxpbmcubm9kZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQob2xkTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgIGZyYWdtZW50Lm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVydHMgYWxsIGNoaWxkbm9kZXNcbiAgICBmb3IgKGk9MDsgaTxvbGRDaGlsZHNMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9sZENoaWxkc1tpXSkge1xuICAgICAgICBuZXdDaGlsZCA9IF9jb252ZXJ0KG9sZENoaWxkc1tpXSwgY2xlYW5VcCwgY2xlYXJJbnRlcm5hbHMsIHVuZWRpdGFibGVDbGFzcyk7XG4gICAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICAgIGlmIChvbGRDaGlsZHNbaV0gPT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cCBzZW5zZWxlc3MgPHNwYW4+IGVsZW1lbnRzXG4gICAgaWYgKGNsZWFuVXAgJiZcbiAgICAgICAgbmV3Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBERUZBVUxUX05PREVfTkFNRSAmJlxuICAgICAgICAoIW5ld05vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICgoL15cXHMqJC9naSkudGVzdChuZXdOb2RlLmlubmVySFRNTCkgJiYgKGNsZWFySW50ZXJuYWxzIHx8IChvbGROb2RlLmNsYXNzTmFtZSAhPT0gXCJfd3lzaWh0bWw1LXRlbXAtcGxhY2Vob2xkZXJcIiAmJiBvbGROb2RlLmNsYXNzTmFtZSAhPT0gXCJyYW5neVNlbGVjdGlvbkJvdW5kYXJ5XCIpKSkgfHxcbiAgICAgICAgICFuZXdOb2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICApIHtcbiAgICAgIGZyYWdtZW50ID0gbmV3Tm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHdoaWxlIChuZXdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobmV3Tm9kZS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnbWVudC5ub3JtYWxpemUpIHtcbiAgICAgICAgZnJhZ21lbnQubm9ybWFsaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfVxuXG4gICAgaWYgKG5ld05vZGUubm9ybWFsaXplKSB7XG4gICAgICBuZXdOb2RlLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcHBseVNlbGVjdG9yUnVsZXMgKGVsZW1lbnQsIHNlbGVjdG9yUnVsZXMpIHtcbiAgICB2YXIgc2VsLCBtZXRob2QsIGVscztcblxuICAgIGZvciAoc2VsIGluIHNlbGVjdG9yUnVsZXMpIHtcbiAgICAgIGlmIChzZWxlY3RvclJ1bGVzLmhhc093blByb3BlcnR5KHNlbCkpIHtcbiAgICAgICAgaWYgKHd5c2lodG1sNS5sYW5nLm9iamVjdChzZWxlY3RvclJ1bGVzW3NlbF0pLmlzRnVuY3Rpb24oKSkge1xuICAgICAgICAgIG1ldGhvZCA9IHNlbGVjdG9yUnVsZXNbc2VsXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Yoc2VsZWN0b3JSdWxlc1tzZWxdKSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtZW50SGFuZGxpbmdNZXRob2RzW3NlbGVjdG9yUnVsZXNbc2VsXV0pIHtcbiAgICAgICAgICBtZXRob2QgPSBlbGVtZW50SGFuZGxpbmdNZXRob2RzW3NlbGVjdG9yUnVsZXNbc2VsXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBlbHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgbWV0aG9kKGVsc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlRWxlbWVudChvbGROb2RlLCBjbGVhckludGVybmFscykge1xuICAgIHZhciBydWxlLFxuICAgICAgICBuZXdOb2RlLFxuICAgICAgICB0YWdSdWxlcyAgICA9IGN1cnJlbnRSdWxlcy50YWdzLFxuICAgICAgICBub2RlTmFtZSAgICA9IG9sZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgc2NvcGVOYW1lICAgPSBvbGROb2RlLnNjb3BlTmFtZSxcbiAgICAgICAgcmVuYW1lVGFnO1xuXG4gICAgLyoqXG4gICAgICogV2UgYWxyZWFkeSBwYXJzZWQgdGhhdCBlbGVtZW50XG4gICAgICogaWdub3JlIGl0ISAoeWVzLCB0aGlzIHNvbWV0aW1lcyBoYXBwZW5zIGluIElFOCB3aGVuIHRoZSBodG1sIGlzIGludmFsaWQpXG4gICAgICovXG4gICAgaWYgKG9sZE5vZGUuX3d5c2lodG1sNSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9sZE5vZGUuX3d5c2lodG1sNSA9IDE7XG5cbiAgICBpZiAob2xkTm9kZS5jbGFzc05hbWUgPT09IFwid3lzaWh0bWw1LXRlbXBcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSUUgaXMgdGhlIG9ubHkgYnJvd3NlciB3aG8gZG9lc24ndCBpbmNsdWRlIHRoZSBuYW1lc3BhY2UgaW4gdGhlXG4gICAgICogbm9kZU5hbWUsIHRoYXQncyB3aHkgd2UgaGF2ZSB0byBwcmVwZW5kIGl0IGJ5IG91cnNlbHZlc1xuICAgICAqIHNjb3BlTmFtZSBpcyBhIHByb3ByaWV0YXJ5IElFIGZlYXR1cmVcbiAgICAgKiByZWFkIG1vcmUgaGVyZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzQzODgodj12cy44NSkuYXNweFxuICAgICAqL1xuICAgIGlmIChzY29wZU5hbWUgJiYgc2NvcGVOYW1lICE9IFwiSFRNTFwiKSB7XG4gICAgICBub2RlTmFtZSA9IHNjb3BlTmFtZSArIFwiOlwiICsgbm9kZU5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGFpciBub2RlXG4gICAgICogSUUgaXMgYSBiaXQgYml0Y2h5IHdoZW4gaXQgY29tZXMgdG8gaW52YWxpZCBuZXN0ZWQgbWFya3VwIHdoaWNoIGluY2x1ZGVzIHVuY2xvc2VkIHRhZ3NcbiAgICAgKiBBIDxwPiBkb2Vzbid0IG5lZWQgdG8gYmUgY2xvc2VkIGFjY29yZGluZyBIVE1MNC01IHNwZWMsIHdlIHNpbXBseSByZXBsYWNlIGl0IHdpdGggYSA8ZGl2PiB0byBwcmVzZXJ2ZSBpdHMgY29udGVudCBhbmQgbGF5b3V0XG4gICAgICovXG4gICAgaWYgKFwib3V0ZXJIVE1MXCIgaW4gb2xkTm9kZSkge1xuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5hdXRvQ2xvc2VzVW5jbG9zZWRUYWdzKCkgJiZcbiAgICAgICAgICBvbGROb2RlLm5vZGVOYW1lID09PSBcIlBcIiAmJlxuICAgICAgICAgIG9sZE5vZGUub3V0ZXJIVE1MLnNsaWNlKC00KS50b0xvd2VyQ2FzZSgpICE9PSBcIjwvcD5cIikge1xuICAgICAgICBub2RlTmFtZSA9IFwiZGl2XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGVOYW1lIGluIHRhZ1J1bGVzKSB7XG4gICAgICBydWxlID0gdGFnUnVsZXNbbm9kZU5hbWVdO1xuICAgICAgaWYgKCFydWxlIHx8IHJ1bGUucmVtb3ZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChydWxlLnVud3JhcCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBydWxlID0gdHlwZW9mKHJ1bGUpID09PSBcInN0cmluZ1wiID8geyByZW5hbWVfdGFnOiBydWxlIH0gOiBydWxlO1xuICAgIH0gZWxzZSBpZiAob2xkTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBydWxlID0geyByZW5hbWVfdGFnOiBERUZBVUxUX05PREVfTkFNRSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgZW1wdHkgdW5rbm93biBlbGVtZW50c1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgdHlwZSBjb25kaXRpb24gaXMgbWV0IG9yIG5vZGUgc2hvdWxkIGJlIHJlbW92ZWQvdW53cmFwcGVkL3JlbmFtZWRcbiAgICBpZiAocnVsZS5vbmVfb2ZfdHlwZSAmJiAhX3Rlc3RUeXBlcyhvbGROb2RlLCBjdXJyZW50UnVsZXMsIHJ1bGUub25lX29mX3R5cGUsIGNsZWFySW50ZXJuYWxzKSkge1xuICAgICAgaWYgKHJ1bGUucmVtb3ZlX2FjdGlvbikge1xuICAgICAgICBpZiAocnVsZS5yZW1vdmVfYWN0aW9uID09PSBcInVud3JhcFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUucmVtb3ZlX2FjdGlvbiA9PT0gXCJyZW5hbWVcIikge1xuICAgICAgICAgIHJlbmFtZVRhZyA9IHJ1bGUucmVtb3ZlX2FjdGlvbl9yZW5hbWVfdG8gfHwgREVGQVVMVF9OT0RFX05BTUU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld05vZGUgPSBvbGROb2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChyZW5hbWVUYWcgfHwgcnVsZS5yZW5hbWVfdGFnIHx8IG5vZGVOYW1lKTtcbiAgICBfaGFuZGxlQXR0cmlidXRlcyhvbGROb2RlLCBuZXdOb2RlLCBydWxlLCBjbGVhckludGVybmFscyk7XG4gICAgX2hhbmRsZVN0eWxlcyhvbGROb2RlLCBuZXdOb2RlLCBydWxlKTtcblxuICAgIG9sZE5vZGUgPSBudWxsO1xuXG4gICAgaWYgKG5ld05vZGUubm9ybWFsaXplKSB7IG5ld05vZGUubm9ybWFsaXplKCk7IH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90ZXN0VHlwZXMob2xkTm9kZSwgcnVsZXMsIHR5cGVzLCBjbGVhckludGVybmFscykge1xuICAgIHZhciBkZWZpbml0aW9uLCB0eXBlO1xuXG4gICAgLy8gZG8gbm90IGludGVyZmVyZSB3aXRoIHBsYWNlaG9sZGVyIHNwYW4gb3IgcGFzdGluZyBjYXJldCBwb3NpdGlvbiBpcyBub3QgbWFpbnRhaW5lZFxuICAgIGlmIChvbGROb2RlLm5vZGVOYW1lID09PSBcIlNQQU5cIiAmJiAhY2xlYXJJbnRlcm5hbHMgJiYgKG9sZE5vZGUuY2xhc3NOYW1lID09PSBcIl93eXNpaHRtbDUtdGVtcC1wbGFjZWhvbGRlclwiIHx8IG9sZE5vZGUuY2xhc3NOYW1lID09PSBcInJhbmd5U2VsZWN0aW9uQm91bmRhcnlcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodHlwZSBpbiB0eXBlcykge1xuICAgICAgaWYgKHR5cGVzLmhhc093blByb3BlcnR5KHR5cGUpICYmIHJ1bGVzLnR5cGVfZGVmaW5pdGlvbnMgJiYgcnVsZXMudHlwZV9kZWZpbml0aW9uc1t0eXBlXSkge1xuICAgICAgICBkZWZpbml0aW9uID0gcnVsZXMudHlwZV9kZWZpbml0aW9uc1t0eXBlXTtcbiAgICAgICAgaWYgKF90ZXN0VHlwZShvbGROb2RlLCBkZWZpbml0aW9uKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5X2NvbnRhaW5zKGEsIG9iaikge1xuICAgICAgdmFyIGkgPSBhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgIGlmIChhW2ldID09PSBvYmopIHtcbiAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90ZXN0VHlwZShvbGROb2RlLCBkZWZpbml0aW9uKSB7XG5cbiAgICB2YXIgbm9kZUNsYXNzZXMgPSBvbGROb2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICAgICAgICBub2RlU3R5bGVzID0gIG9sZE5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIiksXG4gICAgICAgIGNsYXNzZXNMZW5ndGgsIHMsIHNfY29ycmVjdGVkLCBhLCBhdHRyLCBjdXJyZW50Q2xhc3MsIHN0eWxlUHJvcDtcblxuICAgIC8vIHRlc3QgZm9yIG1ldGhvZHNcbiAgICBpZiAoZGVmaW5pdGlvbi5tZXRob2RzKSB7XG4gICAgICBmb3IgKHZhciBtIGluIGRlZmluaXRpb24ubWV0aG9kcykge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5tZXRob2RzLmhhc093blByb3BlcnR5KG0pICYmIHR5cGVDZWNrTWV0aG9kc1ttXSkge1xuXG4gICAgICAgICAgaWYgKHR5cGVDZWNrTWV0aG9kc1ttXShvbGROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGVzdCBmb3IgY2xhc3NlcywgaWYgb25lIGZvdW5kIHJldHVybiB0cnVlXG4gICAgaWYgKG5vZGVDbGFzc2VzICYmIGRlZmluaXRpb24uY2xhc3Nlcykge1xuICAgICAgbm9kZUNsYXNzZXMgPSBub2RlQ2xhc3Nlcy5yZXBsYWNlKC9eXFxzKy9nLCAnJykucmVwbGFjZSgvXFxzKyQvZywgJycpLnNwbGl0KFdISVRFX1NQQUNFX1JFR19FWFApO1xuICAgICAgY2xhc3Nlc0xlbmd0aCA9IG5vZGVDbGFzc2VzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmNsYXNzZXNbbm9kZUNsYXNzZXNbaV1dKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0ZXN0IGZvciBzdHlsZXMsIGlmIG9uZSBmb3VuZCByZXR1cm4gdHJ1ZVxuICAgIGlmIChub2RlU3R5bGVzICYmIGRlZmluaXRpb24uc3R5bGVzKSB7XG5cbiAgICAgIG5vZGVTdHlsZXMgPSBub2RlU3R5bGVzLnNwbGl0KCc7Jyk7XG4gICAgICBmb3IgKHMgaW4gZGVmaW5pdGlvbi5zdHlsZXMpIHtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uc3R5bGVzLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgICAgZm9yICh2YXIgc3AgPSBub2RlU3R5bGVzLmxlbmd0aDsgc3AtLTspIHtcbiAgICAgICAgICAgIHN0eWxlUHJvcCA9IG5vZGVTdHlsZXNbc3BdLnNwbGl0KCc6Jyk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZVByb3BbMF0ucmVwbGFjZSgvXFxzL2csICcnKS50b0xvd2VyQ2FzZSgpID09PSBzKSB7XG4gICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLnN0eWxlc1tzXSA9PT0gdHJ1ZSB8fCBkZWZpbml0aW9uLnN0eWxlc1tzXSA9PT0gMSB8fCB3eXNpaHRtbDUubGFuZy5hcnJheShkZWZpbml0aW9uLnN0eWxlc1tzXSkuY29udGFpbnMoc3R5bGVQcm9wWzFdLnJlcGxhY2UoL1xccy9nLCAnJykudG9Mb3dlckNhc2UoKSkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0ZXN0IGZvciBhdHRyaWJ1dGVzIGluIGdlbmVyYWwgYWdhaW5zdCByZWdleCBtYXRjaFxuICAgIGlmIChkZWZpbml0aW9uLmF0dHJzKSB7XG4gICAgICAgIGZvciAoYSBpbiBkZWZpbml0aW9uLmF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5hdHRycy5oYXNPd25Qcm9wZXJ0eShhKSkge1xuICAgICAgICAgICAgICAgIGF0dHIgPSB3eXNpaHRtbDUuZG9tLmdldEF0dHJpYnV0ZShvbGROb2RlLCBhKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGF0dHIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLnNlYXJjaChkZWZpbml0aW9uLmF0dHJzW2FdKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlU3R5bGVzKG9sZE5vZGUsIG5ld05vZGUsIHJ1bGUpIHtcbiAgICB2YXIgcywgdjtcbiAgICBpZihydWxlICYmIHJ1bGUua2VlcF9zdHlsZXMpIHtcbiAgICAgIGZvciAocyBpbiBydWxlLmtlZXBfc3R5bGVzKSB7XG4gICAgICAgIGlmIChydWxlLmtlZXBfc3R5bGVzLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgICAgdiA9IChzID09PSBcImZsb2F0XCIpID8gb2xkTm9kZS5zdHlsZS5zdHlsZUZsb2F0IHx8IG9sZE5vZGUuc3R5bGUuY3NzRmxvYXQgOiBvbGROb2RlLnN0eWxlW3NdO1xuICAgICAgICAgIC8vIHZhbHVlIGNhbiBiZSByZWdleCBhbmQgaWYgc28gc2hvdWxkIG1hdGNoIG9yIHN0eWxlIHNraXBwZWRcbiAgICAgICAgICBpZiAocnVsZS5rZWVwX3N0eWxlc1tzXSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiAhKHJ1bGUua2VlcF9zdHlsZXNbc10udGVzdCh2KSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocyA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgICAvLyBJRSBjb21wYWJpbGl0eVxuICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZVsob2xkTm9kZS5zdHlsZS5zdHlsZUZsb2F0KSA/ICdzdHlsZUZsb2F0JzogJ2Nzc0Zsb2F0J10gPSB2O1xuICAgICAgICAgICB9IGVsc2UgaWYgKG9sZE5vZGUuc3R5bGVbc10pIHtcbiAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlW3NdID0gdjtcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVzQmVnaW5uaW5nV2l0aChiZWdpbm5pbmcsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgcmV0dXJuQXR0cmlidXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgYXR0ci5pbmRleE9mKGJlZ2lubmluZykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuQXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuQXR0cmlidXRlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jaGVja0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSwgbWV0aG9kTmFtZSwgbm9kZU5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gYXR0cmlidXRlQ2hlY2tNZXRob2RzW21ldGhvZE5hbWVdLFxuICAgICAgICBuZXdBdHRyaWJ1dGVWYWx1ZTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSB8fCAoYXR0cmlidXRlTmFtZSA9PT0gXCJhbHRcIiAmJiBub2RlTmFtZSA9PSBcIklNR1wiKSkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVWYWx1ZSA9IG1ldGhvZChhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YobmV3QXR0cmlidXRlVmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ld0F0dHJpYnV0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NoZWNrQXR0cmlidXRlcyhvbGROb2RlLCBsb2NhbF9hdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGdsb2JhbEF0dHJpYnV0ZXMgID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KGN1cnJlbnRSdWxlcy5hdHRyaWJ1dGVzIHx8IHt9KS5jbG9uZSgpLCAvLyBnbG9iYWwgdmFsdWVzIGZvciBjaGVjay9jb252ZXJ0IHZhbHVlcyBvZiBhdHRyaWJ1dGVzXG4gICAgICAgIGNoZWNrQXR0cmlidXRlcyAgID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KGdsb2JhbEF0dHJpYnV0ZXMpLm1lcmdlKCB3eXNpaHRtbDUubGFuZy5vYmplY3QobG9jYWxfYXR0cmlidXRlcyB8fCB7fSkuY2xvbmUoKSkuZ2V0KCksXG4gICAgICAgIGF0dHJpYnV0ZXMgICAgICAgID0ge30sXG4gICAgICAgIG9sZEF0dHJpYnV0ZXMgICAgID0gd3lzaWh0bWw1LmRvbS5nZXRBdHRyaWJ1dGVzKG9sZE5vZGUpLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lLCBuZXdWYWx1ZSwgbWF0Y2hpbmdBdHRyaWJ1dGVzO1xuXG4gICAgZm9yIChhdHRyaWJ1dGVOYW1lIGluIGNoZWNrQXR0cmlidXRlcykge1xuICAgICAgaWYgKCgvXFwqJC8pLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcblxuICAgICAgICBtYXRjaGluZ0F0dHJpYnV0ZXMgPSBfZ2V0QXR0cmlidXRlc0JlZ2lubmluZ1dpdGgoYXR0cmlidXRlTmFtZS5zbGljZSgwLC0xKSwgb2xkQXR0cmlidXRlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gbWF0Y2hpbmdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGltYXg7IGkrKykge1xuXG4gICAgICAgICAgbmV3VmFsdWUgPSBfY2hlY2tBdHRyaWJ1dGUobWF0Y2hpbmdBdHRyaWJ1dGVzW2ldLCBvbGRBdHRyaWJ1dGVzW21hdGNoaW5nQXR0cmlidXRlc1tpXV0sIGNoZWNrQXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSwgb2xkTm9kZS5ub2RlTmFtZSk7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1ttYXRjaGluZ0F0dHJpYnV0ZXNbaV1dID0gbmV3VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IF9jaGVja0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBvbGRBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLCBjaGVja0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0sIG9sZE5vZGUubm9kZU5hbWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvLyBUT0RPOiByZWZhY3Rvci4gVG9vIGxvbmcgdG8gcmVhZFxuICBmdW5jdGlvbiBfaGFuZGxlQXR0cmlidXRlcyhvbGROb2RlLCBuZXdOb2RlLCBydWxlLCBjbGVhckludGVybmFscykge1xuICAgIHZhciBhdHRyaWJ1dGVzICAgICAgICAgID0ge30sICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyZXNoIG5ldyBzZXQgb2YgYXR0cmlidXRlcyB0byBzZXQgb24gbmV3Tm9kZVxuICAgICAgICBzZXRDbGFzcyAgICAgICAgICAgID0gcnVsZS5zZXRfY2xhc3MsICAgICAgICAgICAgIC8vIGNsYXNzZXMgdG8gc2V0XG4gICAgICAgIGFkZENsYXNzICAgICAgICAgICAgPSBydWxlLmFkZF9jbGFzcywgICAgICAgICAgICAgLy8gYWRkIGNsYXNzZXMgYmFzZWQgb24gZXhpc3RpbmcgYXR0cmlidXRlc1xuICAgICAgICBhZGRTdHlsZSAgICAgICAgICAgID0gcnVsZS5hZGRfc3R5bGUsICAgICAgICAgICAgIC8vIGFkZCBzdHlsZXMgYmFzZWQgb24gZXhpc3RpbmcgYXR0cmlidXRlc1xuICAgICAgICBzZXRBdHRyaWJ1dGVzICAgICAgID0gcnVsZS5zZXRfYXR0cmlidXRlcywgICAgICAgIC8vIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgYWxsb3dlZENsYXNzZXMgICAgICA9IGN1cnJlbnRSdWxlcy5jbGFzc2VzLFxuICAgICAgICBpICAgICAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgY2xhc3NlcyAgICAgICAgICAgICA9IFtdLFxuICAgICAgICBzdHlsZXMgICAgICAgICAgICAgID0gW10sXG4gICAgICAgIG5ld0NsYXNzZXMgICAgICAgICAgPSBbXSxcbiAgICAgICAgb2xkQ2xhc3NlcyAgICAgICAgICA9IFtdLFxuICAgICAgICBjbGFzc2VzTGVuZ3RoLFxuICAgICAgICBuZXdDbGFzc2VzTGVuZ3RoLFxuICAgICAgICBjdXJyZW50Q2xhc3MsXG4gICAgICAgIG5ld0NsYXNzLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICBtZXRob2Q7XG5cbiAgICBpZiAoc2V0QXR0cmlidXRlcykge1xuICAgICAgYXR0cmlidXRlcyA9IHd5c2lodG1sNS5sYW5nLm9iamVjdChzZXRBdHRyaWJ1dGVzKS5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrL2NvbnZlcnQgdmFsdWVzIG9mIGF0dHJpYnV0ZXNcbiAgICBhdHRyaWJ1dGVzID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KGF0dHJpYnV0ZXMpLm1lcmdlKF9jaGVja0F0dHJpYnV0ZXMob2xkTm9kZSwgIHJ1bGUuY2hlY2tfYXR0cmlidXRlcykpLmdldCgpO1xuXG4gICAgaWYgKHNldENsYXNzKSB7XG4gICAgICBjbGFzc2VzLnB1c2goc2V0Q2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChhZGRDbGFzcykge1xuICAgICAgZm9yIChhdHRyaWJ1dGVOYW1lIGluIGFkZENsYXNzKSB7XG4gICAgICAgIG1ldGhvZCA9IGFkZENsYXNzTWV0aG9kc1thZGRDbGFzc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2xhc3MgPSBtZXRob2Qod3lzaWh0bWw1LmRvbS5nZXRBdHRyaWJ1dGUob2xkTm9kZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgICBpZiAodHlwZW9mKG5ld0NsYXNzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChuZXdDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWRkU3R5bGUpIHtcbiAgICAgIGZvciAoYXR0cmlidXRlTmFtZSBpbiBhZGRTdHlsZSkge1xuICAgICAgICBtZXRob2QgPSBhZGRTdHlsZU1ldGhvZHNbYWRkU3R5bGVbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3U3R5bGUgPSBtZXRob2Qod3lzaWh0bWw1LmRvbS5nZXRBdHRyaWJ1dGUob2xkTm9kZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgICBpZiAodHlwZW9mKG5ld1N0eWxlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG4gICAgaWYgKHR5cGVvZihhbGxvd2VkQ2xhc3NlcykgPT09IFwic3RyaW5nXCIgJiYgYWxsb3dlZENsYXNzZXMgPT09IFwiYW55XCIgJiYgb2xkTm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSkge1xuICAgICAgaWYgKGN1cnJlbnRSdWxlcy5jbGFzc2VzX2JsYWNrbGlzdCkge1xuICAgICAgICBvbGRDbGFzc2VzID0gb2xkTm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgaWYgKG9sZENsYXNzZXMpIHtcbiAgICAgICAgICBjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQob2xkQ2xhc3Nlcy5zcGxpdChXSElURV9TUEFDRV9SRUdfRVhQKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc2VzTGVuZ3RoID0gY2xhc3Nlcy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpPGNsYXNzZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRDbGFzcyA9IGNsYXNzZXNbaV07XG4gICAgICAgICAgaWYgKCFjdXJyZW50UnVsZXMuY2xhc3Nlc19ibGFja2xpc3RbY3VycmVudENsYXNzXSkge1xuICAgICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGN1cnJlbnRDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tcImNsYXNzXCJdID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkobmV3Q2xhc3NlcykudW5pcXVlKCkuam9pbihcIiBcIik7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1tcImNsYXNzXCJdID0gb2xkTm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgd3lzaWh0bWw1IHRlbXAgY2xhc3MgZG9lc24ndCBnZXQgc3RyaXBwZWQgb3V0XG4gICAgICBpZiAoIWNsZWFySW50ZXJuYWxzKSB7XG4gICAgICAgIGFsbG93ZWRDbGFzc2VzW1wiX3d5c2lodG1sNS10ZW1wLXBsYWNlaG9sZGVyXCJdID0gMTtcbiAgICAgICAgYWxsb3dlZENsYXNzZXNbXCJfcmFuZ3lTZWxlY3Rpb25Cb3VuZGFyeVwiXSA9IDE7XG4gICAgICAgIGFsbG93ZWRDbGFzc2VzW1wid3lzaXd5Zy10bXAtc2VsZWN0ZWQtY2VsbFwiXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBvbGQgY2xhc3NlcyBsYXN0XG4gICAgICBvbGRDbGFzc2VzID0gb2xkTm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgIGlmIChvbGRDbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChvbGRDbGFzc2VzLnNwbGl0KFdISVRFX1NQQUNFX1JFR19FWFApKTtcbiAgICAgIH1cbiAgICAgIGNsYXNzZXNMZW5ndGggPSBjbGFzc2VzLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpPGNsYXNzZXNMZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50Q2xhc3MgPSBjbGFzc2VzW2ldO1xuICAgICAgICBpZiAoYWxsb3dlZENsYXNzZXNbY3VycmVudENsYXNzXSkge1xuICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjdXJyZW50Q2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBhdHRyaWJ1dGVzW1wiY2xhc3NcIl0gPSB3eXNpaHRtbDUubGFuZy5hcnJheShuZXdDbGFzc2VzKS51bmlxdWUoKS5qb2luKFwiIFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGFibGUgc2VsZWN0aW9uIGNsYXNzIGlmIHByZXNlbnRcbiAgICBpZiAoYXR0cmlidXRlc1tcImNsYXNzXCJdICYmIGNsZWFySW50ZXJuYWxzKSB7XG4gICAgICBhdHRyaWJ1dGVzW1wiY2xhc3NcIl0gPSBhdHRyaWJ1dGVzW1wiY2xhc3NcIl0ucmVwbGFjZShcInd5c2l3eWctdG1wLXNlbGVjdGVkLWNlbGxcIiwgXCJcIik7XG4gICAgICBpZiAoKC9eXFxzKiQvZykudGVzdChhdHRyaWJ1dGVzW1wiY2xhc3NcIl0pKSB7XG4gICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW1wiY2xhc3NcIl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcy5sZW5ndGgpIHtcbiAgICAgIGF0dHJpYnV0ZXNbXCJzdHlsZVwiXSA9IHd5c2lodG1sNS5sYW5nLmFycmF5KHN0eWxlcykudW5pcXVlKCkuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgLy8gc2V0IGF0dHJpYnV0ZXMgb24gbmV3Tm9kZVxuICAgIGZvciAoYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAvLyBTZXR0aW5nIGF0dHJpYnV0ZXMgY2FuIGNhdXNlIGEganMgZXJyb3IgaW4gSUUgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzXG4gICAgICAvLyBlZy4gb24gYSA8aW1nPiB1bmRlciBodHRwcyB3aGVuIGl0J3MgbmV3IGF0dHJpYnV0ZSB2YWx1ZSBpcyBub24taHR0cHNcbiAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIHRoaXMgZnVydGhlciBhbmQgY2hlY2sgZm9yIHNtYXJ0ZXIgaGFuZGxpbmdcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgfSBjYXRjaChlKSB7fVxuICAgIH1cblxuICAgIC8vIElFOCBzb21ldGltZXMgbG9zZXMgdGhlIHdpZHRoL2hlaWdodCBhdHRyaWJ1dGVzIHdoZW4gdGhvc2UgYXJlIHNldCBiZWZvcmUgdGhlIFwic3JjXCJcbiAgICAvLyBzbyB3ZSBtYWtlIHN1cmUgdG8gc2V0IHRoZW0gYWdhaW5cbiAgICBpZiAoYXR0cmlidXRlcy5zcmMpIHtcbiAgICAgIGlmICh0eXBlb2YoYXR0cmlidXRlcy53aWR0aCkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBhdHRyaWJ1dGVzLndpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YoYXR0cmlidXRlcy5oZWlnaHQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGF0dHJpYnV0ZXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgSU5WSVNJQkxFX1NQQUNFX1JFR19FWFAgPSAvXFx1RkVGRi9nO1xuICBmdW5jdGlvbiBfaGFuZGxlVGV4dChvbGROb2RlKSB7XG4gICAgdmFyIG5leHRTaWJsaW5nID0gb2xkTm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUpIHtcbiAgICAgIC8vIENvbmNhdGVuYXRlIHRleHQgbm9kZXNcbiAgICAgIG5leHRTaWJsaW5nLmRhdGEgPSBvbGROb2RlLmRhdGEucmVwbGFjZShJTlZJU0lCTEVfU1BBQ0VfUkVHX0VYUCwgXCJcIikgKyBuZXh0U2libGluZy5kYXRhLnJlcGxhY2UoSU5WSVNJQkxFX1NQQUNFX1JFR19FWFAsIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcXHVGRUZGID0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSAodXNlZCBhcyBhIGhhY2sgaW4gY2VydGFpbiByaWNoIHRleHQgZWRpdGluZyBzaXR1YXRpb25zKVxuICAgICAgdmFyIGRhdGEgPSBvbGROb2RlLmRhdGEucmVwbGFjZShJTlZJU0lCTEVfU1BBQ0VfUkVHX0VYUCwgXCJcIik7XG4gICAgICByZXR1cm4gb2xkTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYW5kbGVDb21tZW50KG9sZE5vZGUpIHtcbiAgICBpZiAoY3VycmVudFJ1bGVzLmNvbW1lbnRzKSB7XG4gICAgICByZXR1cm4gb2xkTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQob2xkTm9kZS5ub2RlVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLSBhdHRyaWJ1dGUgY2hlY2tzIC0tLS0tLS0tLS0tLSBcXFxcXG4gIHZhciBhdHRyaWJ1dGVDaGVja01ldGhvZHMgPSB7XG4gICAgdXJsOiAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgUkVHX0VYUCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgIWF0dHJpYnV0ZVZhbHVlLm1hdGNoKFJFR19FWFApKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UoUkVHX0VYUCwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pKCksXG5cbiAgICBzcmM6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL14oXFwvfGh0dHBzPzpcXC9cXC8pL2k7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAhYXR0cmlidXRlVmFsdWUubWF0Y2goUkVHX0VYUCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIGhyZWY6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL14oI3xcXC98aHR0cHM/OlxcL1xcL3xtYWlsdG86KS9pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgIWF0dHJpYnV0ZVZhbHVlLm1hdGNoKFJFR19FWFApKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UoUkVHX0VYUCwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pKCksXG5cbiAgICBhbHQ6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL1teIGEtejAtOV9cXC1dL2dpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBcIlwiKTtcbiAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIG51bWJlcnM6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL1xcRC9nO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gKGF0dHJpYnV0ZVZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoUkVHX0VYUCwgXCJcIik7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZSB8fCBudWxsO1xuICAgICAgfTtcbiAgICB9KSgpLFxuXG4gICAgYW55OiAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tIHN0eWxlIGNvbnZlcnRlciAoY29udmVydHMgYW4gaHRtbCBhdHRyaWJ1dGUgdG8gYSBzdHlsZSkgLS0tLS0tLS0tLS0tIFxcXFxcbiAgdmFyIGFkZFN0eWxlTWV0aG9kcyA9IHtcbiAgICBhbGlnbl90ZXh0OiAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgbGVmdDogICAgIFwidGV4dC1hbGlnbjogbGVmdDtcIixcbiAgICAgICAgcmlnaHQ6ICAgIFwidGV4dC1hbGlnbjogcmlnaHQ7XCIsXG4gICAgICAgIGNlbnRlcjogICBcInRleHQtYWxpZ246IGNlbnRlcjtcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KSgpLFxuICB9O1xuXG4gIC8vIC0tLS0tLS0tLS0tLSBjbGFzcyBjb252ZXJ0ZXIgKGNvbnZlcnRzIGFuIGh0bWwgYXR0cmlidXRlIHRvIGEgY2xhc3MgbmFtZSkgLS0tLS0tLS0tLS0tIFxcXFxcbiAgdmFyIGFkZENsYXNzTWV0aG9kcyA9IHtcbiAgICBhbGlnbl9pbWc6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICBsZWZ0OiAgIFwid3lzaXd5Zy1mbG9hdC1sZWZ0XCIsXG4gICAgICAgIHJpZ2h0OiAgXCJ3eXNpd3lnLWZsb2F0LXJpZ2h0XCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdbU3RyaW5nKGF0dHJpYnV0ZVZhbHVlKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIGFsaWduX3RleHQ6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICBsZWZ0OiAgICAgXCJ3eXNpd3lnLXRleHQtYWxpZ24tbGVmdFwiLFxuICAgICAgICByaWdodDogICAgXCJ3eXNpd3lnLXRleHQtYWxpZ24tcmlnaHRcIixcbiAgICAgICAgY2VudGVyOiAgIFwid3lzaXd5Zy10ZXh0LWFsaWduLWNlbnRlclwiLFxuICAgICAgICBqdXN0aWZ5OiAgXCJ3eXNpd3lnLXRleHQtYWxpZ24tanVzdGlmeVwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nW1N0cmluZyhhdHRyaWJ1dGVWYWx1ZSkudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgIH0pKCksXG5cbiAgICBjbGVhcl9icjogKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIGxlZnQ6ICAgXCJ3eXNpd3lnLWNsZWFyLWxlZnRcIixcbiAgICAgICAgcmlnaHQ6ICBcInd5c2l3eWctY2xlYXItcmlnaHRcIixcbiAgICAgICAgYm90aDogICBcInd5c2l3eWctY2xlYXItYm90aFwiLFxuICAgICAgICBhbGw6ICAgIFwid3lzaXd5Zy1jbGVhci1ib3RoXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdbU3RyaW5nKGF0dHJpYnV0ZVZhbHVlKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIHNpemVfZm9udDogKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIFwiMVwiOiBcInd5c2l3eWctZm9udC1zaXplLXh4LXNtYWxsXCIsXG4gICAgICAgIFwiMlwiOiBcInd5c2l3eWctZm9udC1zaXplLXNtYWxsXCIsXG4gICAgICAgIFwiM1wiOiBcInd5c2l3eWctZm9udC1zaXplLW1lZGl1bVwiLFxuICAgICAgICBcIjRcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1sYXJnZVwiLFxuICAgICAgICBcIjVcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS14LWxhcmdlXCIsXG4gICAgICAgIFwiNlwiOiBcInd5c2l3eWctZm9udC1zaXplLXh4LWxhcmdlXCIsXG4gICAgICAgIFwiN1wiOiBcInd5c2l3eWctZm9udC1zaXplLXh4LWxhcmdlXCIsXG4gICAgICAgIFwiLVwiOiBcInd5c2l3eWctZm9udC1zaXplLXNtYWxsZXJcIixcbiAgICAgICAgXCIrXCI6IFwid3lzaXd5Zy1mb250LXNpemUtbGFyZ2VyXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdbU3RyaW5nKGF0dHJpYnV0ZVZhbHVlKS5jaGFyQXQoMCldO1xuICAgICAgfTtcbiAgICB9KSgpXG4gIH07XG5cbiAgLy8gY2hlY2tzIGlmIGVsZW1lbnQgaXMgcG9zc2libHkgdmlzaWJsZVxuICB2YXIgdHlwZUNlY2tNZXRob2RzID0ge1xuICAgIGhhc192aXNpYmxlX2NvbnRldDogKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHR4dCxcbiAgICAgICAgICBpc1Zpc2libGUgPSBmYWxzZSxcbiAgICAgICAgICB2aXNpYmxlRWxlbWVudHMgPSBbJ2ltZycsICd2aWRlbycsICdwaWN0dXJlJywgJ2JyJywgJ3NjcmlwdCcsICdub3NjcmlwdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHlsZScsICd0YWJsZScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ2F1ZGlvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N2ZycsICdpbnB1dCcsICdidXR0b24nLCAnc2VsZWN0JywndGV4dGFyZWEnLCAnY2FudmFzJ107XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuXG4gICAgICAgIC8vIGhhcyB2aXNpYmxlIGlubmVydGV4dC4gc28gaXMgdmlzaWJsZVxuICAgICAgICB0eHQgPSAoZWwuaW5uZXJUZXh0IHx8IGVsLnRleHRDb250ZW50KS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgICBpZiAodHh0ICYmIHR4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXRjaGVzIGxpc3Qgb2YgdmlzaWJsZSBkaW1lbnNpb25lZCBlbGVtZW50c1xuICAgICAgICBmb3IgKHZhciBpID0gdmlzaWJsZUVsZW1lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yKHZpc2libGVFbGVtZW50c1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBtZWFzdXJlIGRpbWVzaW9ucyBpbiBsYXN0IHJlc29ydC4gKGNhbiBmaW5kIG9ubHkgb2YgZWxlbWVudHMgaW4gZG9tKVxuICAgICAgICBpZiAoZWwub2Zmc2V0V2lkdGggJiYgZWwub2Zmc2V0V2lkdGggPiAwICYmIGVsLm9mZnNldEhlaWdodCAmJiBlbC5vZmZzZXRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH0pKClcbiAgfTtcblxuICB2YXIgZWxlbWVudEhhbmRsaW5nTWV0aG9kcyA9IHtcbiAgICB1bndyYXA6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB3eXNpaHRtbDUuZG9tLnVud3JhcChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcGFyc2UoZWxlbWVudE9ySHRtbF9jdXJyZW50LCBjb25maWdfY3VycmVudCk7XG59O1xuOy8qKlxuICogQ2hlY2tzIGZvciBlbXB0eSB0ZXh0IG5vZGUgY2hpbGRzIGFuZCByZW1vdmVzIHRoZW1cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGVsZW1lbnQgaW4gd2hpY2ggdG8gY2xlYW51cFxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5kb20ucmVtb3ZlRW1wdHlUZXh0Tm9kZXMoZWxlbWVudCk7XG4gKi9cbnd5c2lodG1sNS5kb20ucmVtb3ZlRW1wdHlUZXh0Tm9kZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBjaGlsZE5vZGUsXG4gICAgICBjaGlsZE5vZGVzICAgICAgICA9IHd5c2lodG1sNS5sYW5nLmFycmF5KG5vZGUuY2hpbGROb2RlcykuZ2V0KCksXG4gICAgICBjaGlsZE5vZGVzTGVuZ3RoICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgaSAgICAgICAgICAgICAgICAgPSAwO1xuICBmb3IgKDsgaTxjaGlsZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUgJiYgY2hpbGROb2RlLmRhdGEgPT09IFwiXCIpIHtcbiAgICAgIGNoaWxkTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZSk7XG4gICAgfVxuICB9XG59O1xuOy8qKlxuICogUmVuYW1lcyBhbiBlbGVtZW50IChlZy4gYSA8ZGl2PiB0byBhIDxwPikgYW5kIGtlZXBzIGl0cyBjaGlsZHNcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGxpc3QgZWxlbWVudCB3aGljaCBzaG91bGQgYmUgcmVuYW1lZFxuICogQHBhcmFtIHtFbGVtZW50fSBuZXdOb2RlTmFtZSBUaGUgZGVzaXJlZCB0YWcgbmFtZVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICA8IS0tIEFzc3VtZSB0aGUgZm9sbG93aW5nIGRvbTogLS0+XG4gKiAgICA8dWwgaWQ9XCJsaXN0XCI+XG4gKiAgICAgIDxsaT5lbWluZW08L2xpPlxuICogICAgICA8bGk+ZHIuIGRyZTwvbGk+XG4gKiAgICAgIDxsaT41MCBDZW50PC9saT5cbiAqICAgIDwvdWw+XG4gKlxuICogICAgPHNjcmlwdD5cbiAqICAgICAgd3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGlzdFwiKSwgXCJvbFwiKTtcbiAqICAgIDwvc2NyaXB0PlxuICpcbiAqICAgIDwhLS0gV2lsbCByZXN1bHQgaW46IC0tPlxuICogICAgPG9sPlxuICogICAgICA8bGk+ZW1pbmVtPC9saT5cbiAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICogICAgICA8bGk+NTAgQ2VudDwvbGk+XG4gKiAgICA8L29sPlxuICovXG53eXNpaHRtbDUuZG9tLnJlbmFtZUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBuZXdOb2RlTmFtZSkge1xuICB2YXIgbmV3RWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KG5ld05vZGVOYW1lKSxcbiAgICAgIGZpcnN0Q2hpbGQ7XG4gIHdoaWxlIChmaXJzdENoaWxkID0gZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgbmV3RWxlbWVudC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgfVxuICB3eXNpaHRtbDUuZG9tLmNvcHlBdHRyaWJ1dGVzKFtcImFsaWduXCIsIFwiY2xhc3NOYW1lXCJdKS5mcm9tKGVsZW1lbnQpLnRvKG5ld0VsZW1lbnQpO1xuICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0VsZW1lbnQsIGVsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG47LyoqXG4gKiBUYWtlcyBhbiBlbGVtZW50LCByZW1vdmVzIGl0IGFuZCByZXBsYWNlcyBpdCB3aXRoIGl0J3MgY2hpbGRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIG5vZGUgd2hpY2ggdG8gcmVwbGFjZSB3aXRoIGl0J3MgY2hpbGQgbm9kZXNcbiAqIEBleGFtcGxlXG4gKiAgICA8ZGl2IGlkPVwiZm9vXCI+XG4gKiAgICAgIDxzcGFuPmhlbGxvPC9zcGFuPlxuICogICAgPC9kaXY+XG4gKiAgICA8c2NyaXB0PlxuICogICAgICAvLyBSZW1vdmUgI2ZvbyBhbmQgcmVwbGFjZSB3aXRoIGl0J3MgY2hpbGRyZW5cbiAqICAgICAgd3lzaWh0bWw1LmRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmb29cIikpO1xuICogICAgPC9zY3JpcHQ+XG4gKi9cbnd5c2lodG1sNS5kb20ucmVwbGFjZVdpdGhDaGlsZE5vZGVzID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmcmFnbWVudCA9IG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICB9XG4gIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQsIG5vZGUpO1xuICBub2RlID0gZnJhZ21lbnQgPSBudWxsO1xufTtcbjsvKipcbiAqIFVud3JhcHMgYW4gdW5vcmRlcmVkL29yZGVyZWQgbGlzdFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgbGlzdCBlbGVtZW50IHdoaWNoIHNob3VsZCBiZSB1bndyYXBwZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgPCEtLSBBc3N1bWUgdGhlIGZvbGxvd2luZyBkb206IC0tPlxuICogICAgPHVsIGlkPVwibGlzdFwiPlxuICogICAgICA8bGk+ZW1pbmVtPC9saT5cbiAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICogICAgICA8bGk+NTAgQ2VudDwvbGk+XG4gKiAgICA8L3VsPlxuICpcbiAqICAgIDxzY3JpcHQ+XG4gKiAgICAgIHd5c2lodG1sNS5kb20ucmVzb2x2ZUxpc3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXN0XCIpKTtcbiAqICAgIDwvc2NyaXB0PlxuICpcbiAqICAgIDwhLS0gV2lsbCByZXN1bHQgaW46IC0tPlxuICogICAgZW1pbmVtPGJyPlxuICogICAgZHIuIGRyZTxicj5cbiAqICAgIDUwIENlbnQ8YnI+XG4gKi9cbihmdW5jdGlvbihkb20pIHtcbiAgZnVuY3Rpb24gX2lzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKG5vZGUpID09PSBcImJsb2NrXCI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNMaW5lQnJlYWsobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIkJSXCI7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwZW5kTGluZUJyZWFrKGVsZW1lbnQpIHtcbiAgICB2YXIgbGluZUJyZWFrID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGxpbmVCcmVhayk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlTGlzdChsaXN0LCB1c2VMaW5lQnJlYWtzKSB7XG4gICAgaWYgKCFsaXN0Lm5vZGVOYW1lLm1hdGNoKC9eKE1FTlV8VUx8T0wpJC8pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRvYyAgICAgICAgICAgICA9IGxpc3Qub3duZXJEb2N1bWVudCxcbiAgICAgICAgZnJhZ21lbnQgICAgICAgID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gd3lzaWh0bWw1LmRvbS5kb21Ob2RlKGxpc3QpLnByZXYoe2lnbm9yZUJsYW5rVGV4dHM6IHRydWV9KSxcbiAgICAgICAgZmlyc3RDaGlsZCxcbiAgICAgICAgbGFzdENoaWxkLFxuICAgICAgICBpc0xhc3RDaGlsZCxcbiAgICAgICAgc2hvdWxkQXBwZW5kTGluZUJyZWFrLFxuICAgICAgICBwYXJhZ3JhcGgsXG4gICAgICAgIGxpc3RJdGVtO1xuXG4gICAgaWYgKHVzZUxpbmVCcmVha3MpIHtcbiAgICAgIC8vIEluc2VydCBsaW5lIGJyZWFrIGlmIGxpc3QgaXMgYWZ0ZXIgYSBub24tYmxvY2sgZWxlbWVudFxuICAgICAgaWYgKHByZXZpb3VzU2libGluZyAmJiAhX2lzQmxvY2tFbGVtZW50KHByZXZpb3VzU2libGluZykgJiYgIV9pc0xpbmVCcmVhayhwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgIF9hcHBlbmRMaW5lQnJlYWsoZnJhZ21lbnQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobGlzdEl0ZW0gPSAobGlzdC5maXJzdEVsZW1lbnRDaGlsZCB8fCBsaXN0LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIGxhc3RDaGlsZCA9IGxpc3RJdGVtLmxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGZpcnN0Q2hpbGQgPSBsaXN0SXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgaXNMYXN0Q2hpbGQgICAgICAgICAgID0gZmlyc3RDaGlsZCA9PT0gbGFzdENoaWxkO1xuICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBiZWZvcmUgYXBwZW5kaW5nIGl0IHRvIHRoZSBmcmFnbWVudCwgYXMgaXQgb3RoZXJ3aXNlIHdpbGwgbG9zZSBzdHlsZSBpbmZvcm1hdGlvblxuICAgICAgICAgIHNob3VsZEFwcGVuZExpbmVCcmVhayA9IGlzTGFzdENoaWxkICYmICFfaXNCbG9ja0VsZW1lbnQoZmlyc3RDaGlsZCkgJiYgIV9pc0xpbmVCcmVhayhmaXJzdENoaWxkKTtcbiAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kTGluZUJyZWFrKSB7XG4gICAgICAgICAgICBfYXBwZW5kTGluZUJyZWFrKGZyYWdtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0SXRlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpc3RJdGVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGxpc3RJdGVtID0gKGxpc3QuZmlyc3RFbGVtZW50Q2hpbGQgfHwgbGlzdC5maXJzdENoaWxkKSkge1xuICAgICAgICBpZiAobGlzdEl0ZW0ucXVlcnlTZWxlY3RvciAmJiBsaXN0SXRlbS5xdWVyeVNlbGVjdG9yKFwiZGl2LCBwLCB1bCwgb2wsIG1lbnUsIGJsb2NrcXVvdGUsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDZcIikpIHtcbiAgICAgICAgICB3aGlsZSAoZmlyc3RDaGlsZCA9IGxpc3RJdGVtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhZ3JhcGggPSBkb2MuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgICAgd2hpbGUgKGZpcnN0Q2hpbGQgPSBsaXN0SXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGguYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBhcmFncmFwaCk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaXN0SXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChmcmFnbWVudCwgbGlzdCk7XG4gIH1cblxuICBkb20ucmVzb2x2ZUxpc3QgPSByZXNvbHZlTGlzdDtcbn0pKHd5c2lodG1sNS5kb20pO1xuOy8qKlxuICogU2FuZGJveCBmb3IgZXhlY3V0aW5nIGphdmFzY3JpcHQsIHBhcnNpbmcgY3NzIHN0eWxlcyBhbmQgZG9pbmcgZG9tIG9wZXJhdGlvbnMgaW4gYSBzZWN1cmUgd2F5XG4gKlxuICogQnJvd3NlciBDb21wYXRpYmlsaXR5OlxuICogIC0gU2VjdXJlIGluIE1TSUUgNissIGJ1dCBvbmx5IHdoZW4gdGhlIHVzZXIgaGFzbid0IG1hZGUgY2hhbmdlcyB0byBoaXMgc2VjdXJpdHkgbGV2ZWwgXCJyZXN0cmljdGVkXCJcbiAqICAtIFBhcnRpYWxseSBzZWN1cmUgaW4gb3RoZXIgYnJvd3NlcnMgKEZpcmVmb3gsIE9wZXJhLCBTYWZhcmksIENocm9tZSwgLi4uKVxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBjbGFzcyBjYW4ndCBiZW5lZml0IGZyb20gdGhlIEhUTUw1IHNhbmRib3ggYXR0cmlidXRlIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XG4gKiAgICAtIHNhbmRib3hpbmcgZG9lc24ndCB3b3JrIGNvcnJlY3RseSB3aXRoIGlubGluZWQgY29udGVudCAoc3JjPVwiamF2YXNjcmlwdDonPGh0bWw+Li4uPC9odG1sPidcIilcbiAqICAgIC0gc2FuZGJveGluZyBvZiBwaHlzaWNhbCBkb2N1bWVudHMgY2F1c2VzIHRoYXQgdGhlIGRvbSBpc24ndCBhY2Nlc3NpYmxlIGFueW1vcmUgZnJvbSB0aGUgb3V0c2lkZSAoaWZyYW1lLmNvbnRlbnRXaW5kb3csIC4uLilcbiAqICAgIC0gc2V0dGluZyB0aGUgXCJhbGxvdy1zYW1lLW9yaWdpblwiIGZsYWcgd291bGQgZml4IHRoYXQsIGJ1dCB0aGVuIHN0aWxsIGphdmFzY3JpcHQgYW5kIGRvbSBldmVudHMgcmVmdXNlIHRvIGZpcmVcbiAqICAgIC0gdGhlcmVmb3JlIHRoZSBcImFsbG93LXNjcmlwdHNcIiBmbGFnIGlzIG5lZWRlZCwgd2hpY2ggdGhlbiB3b3VsZCBkZWFjdGl2YXRlIGFueSBzZWN1cml0eSwgYXMgdGhlIGpzIGV4ZWN1dGVkIGluc2lkZSB0aGUgaWZyYW1lXG4gKiAgICAgIGNhbiBkbyBhbnl0aGluZyBhcyBpZiB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgd2Fzbid0IHNldFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWFkeUNhbGxiYWNrXSBNZXRob2QgdGhhdCBnZXRzIGludm9rZWQgd2hlbiB0aGUgc2FuZGJveCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgbmV3IHd5c2lodG1sNS5kb20uU2FuZGJveChmdW5jdGlvbihzYW5kYm94KSB7XG4gKiAgICAgIHNhbmRib3guZ2V0V2luZG93KCkuZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSAnPGltZyBzcmM9Zm9vLmdpZiBvbmVycm9yPVwiYWxlcnQoZG9jdW1lbnQuY29va2llKVwiPic7XG4gKiAgICB9KTtcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgLyoqXG4gICAgICAgKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAqL1xuICAgICAgZG9jICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LFxuICAgICAgLyoqXG4gICAgICAgKiBQcm9wZXJ0aWVzIHRvIHVuc2V0L3Byb3RlY3Qgb24gdGhlIHdpbmRvdyBvYmplY3RcbiAgICAgICAqL1xuICAgICAgd2luZG93UHJvcGVydGllcyAgICA9IFtcbiAgICAgICAgXCJwYXJlbnRcIiwgXCJ0b3BcIiwgXCJvcGVuZXJcIiwgXCJmcmFtZUVsZW1lbnRcIiwgXCJmcmFtZXNcIixcbiAgICAgICAgXCJsb2NhbFN0b3JhZ2VcIiwgXCJnbG9iYWxTdG9yYWdlXCIsIFwic2Vzc2lvblN0b3JhZ2VcIiwgXCJpbmRleGVkREJcIlxuICAgICAgXSxcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyBvbiB0aGUgd2luZG93IG9iamVjdCB3aGljaCBhcmUgc2V0IHRvIGFuIGVtcHR5IGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIHdpbmRvd1Byb3BlcnRpZXMyICAgPSBbXG4gICAgICAgIFwib3BlblwiLCBcImNsb3NlXCIsIFwib3BlbkRpYWxvZ1wiLCBcInNob3dNb2RhbERpYWxvZ1wiLFxuICAgICAgICBcImFsZXJ0XCIsIFwiY29uZmlybVwiLCBcInByb21wdFwiLFxuICAgICAgICBcIm9wZW5EYXRhYmFzZVwiLCBcInBvc3RNZXNzYWdlXCIsXG4gICAgICAgIFwiWE1MSHR0cFJlcXVlc3RcIiwgXCJYRG9tYWluUmVxdWVzdFwiXG4gICAgICBdLFxuICAgICAgLyoqXG4gICAgICAgKiBQcm9wZXJ0aWVzIHRvIHVuc2V0L3Byb3RlY3Qgb24gdGhlIGRvY3VtZW50IG9iamVjdFxuICAgICAgICovXG4gICAgICBkb2N1bWVudFByb3BlcnRpZXMgID0gW1xuICAgICAgICBcInJlZmVycmVyXCIsXG4gICAgICAgIFwid3JpdGVcIiwgXCJvcGVuXCIsIFwiY2xvc2VcIlxuICAgICAgXTtcblxuICB3eXNpaHRtbDUuZG9tLlNhbmRib3ggPSBCYXNlLmV4dGVuZChcbiAgICAvKiogQHNjb3BlIHd5c2lodG1sNS5kb20uU2FuZGJveC5wcm90b3R5cGUgKi8ge1xuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHJlYWR5Q2FsbGJhY2ssIGNvbmZpZykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IHJlYWR5Q2FsbGJhY2sgfHwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OO1xuICAgICAgdGhpcy5jb25maWcgICA9IHd5c2lodG1sNS5sYW5nLm9iamVjdCh7fSkubWVyZ2UoY29uZmlnKS5nZXQoKTtcbiAgICAgIHRoaXMuZWRpdGFibGVBcmVhICAgPSB0aGlzLl9jcmVhdGVJZnJhbWUoKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0SW50bzogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZihlbGVtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbGVtZW50ID0gZG9jLmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZWRpdGFibGVBcmVhKTtcbiAgICB9LFxuXG4gICAgZ2V0SWZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkaXRhYmxlQXJlYTtcbiAgICB9LFxuXG4gICAgZ2V0V2luZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlYWR5RXJyb3IoKTtcbiAgICB9LFxuXG4gICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVhZHlFcnJvcigpO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpZnJhbWUgPSB0aGlzLmdldElmcmFtZSgpO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LFxuXG4gICAgX3JlYWR5RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3lzaWh0bWw1LlNhbmRib3g6IFNhbmRib3ggaWZyYW1lIGlzbid0IGxvYWRlZCB5ZXRcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHNhbmRib3ggaWZyYW1lXG4gICAgICpcbiAgICAgKiBTb21lIGltcG9ydGFudCBub3RlczpcbiAgICAgKiAgLSBXZSBjYW4ndCB1c2UgSFRNTDUgc2FuZGJveCBmb3Igbm93OlxuICAgICAqICAgIHNldHRpbmcgaXQgY2F1c2VzIHRoYXQgdGhlIGlmcmFtZSdzIGRvbSBjYW4ndCBiZSBhY2Nlc3NlZCBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICogICAgVGhlcmVmb3JlIHdlIG5lZWQgdG8gc2V0IHRoZSBcImFsbG93LXNhbWUtb3JpZ2luXCIgZmxhZyB3aGljaCBlbmFibGVzIGFjY2Vzc2luZyB0aGUgaWZyYW1lJ3MgZG9tXG4gICAgICogICAgQnV0IHRoZW4gdGhlcmUncyBhbm90aGVyIHByb2JsZW0sIERPTSBldmVudHMgKGZvY3VzLCBibHVyLCBjaGFuZ2UsIGtleXByZXNzLCAuLi4pIGFyZW4ndCBmaXJlZC5cbiAgICAgKiAgICBJbiBvcmRlciB0byBtYWtlIHRoaXMgaGFwcGVuIHdlIG5lZWQgdG8gc2V0IHRoZSBcImFsbG93LXNjcmlwdHNcIiBmbGFnLlxuICAgICAqICAgIEEgY29tYmluYXRpb24gb2YgYWxsb3ctc2NyaXB0cyBhbmQgYWxsb3ctc2FtZS1vcmlnaW4gaXMgYWxtb3N0IHRoZSBzYW1lIGFzIHNldHRpbmcgbm8gc2FuZGJveCBhdHRyaWJ1dGUgYXQgYWxsLlxuICAgICAqICAtIENocm9tZSAmIFNhZmFyaSwgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgc2FuZGJveGluZyBjb3JyZWN0bHkgd2hlbiB0aGUgaWZyYW1lJ3MgaHRtbCBpcyBpbmxpbmVkIChubyBwaHlzaWNhbCBkb2N1bWVudClcbiAgICAgKiAgLSBJRSBuZWVkcyB0byBoYXZlIHRoZSBzZWN1cml0eT1cInJlc3RyaWN0ZWRcIiBhdHRyaWJ1dGUgc2V0IGJlZm9yZSB0aGUgaWZyYW1lIGlzXG4gICAgICogICAgaW5zZXJ0ZWQgaW50byB0aGUgZG9tIHRyZWVcbiAgICAgKiAgLSBCZWxpZXZlIGl0IG9yIG5vdCBidXQgaW4gSUUgXCJzZWN1cml0eVwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIikgaXMgZmFsc2UsIGV2ZW5cbiAgICAgKiAgICB0aG91Z2ggaXQgc3VwcG9ydHMgaXRcbiAgICAgKiAgLSBXaGVuIGFuIGlmcmFtZSBoYXMgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCIsIGluIElFIGV2YWwoKSAmIGV4ZWNTY3JpcHQoKSBkb24ndCB3b3JrIGFueW1vcmVcbiAgICAgKiAgLSBJRSBkb2Vzbid0IGZpcmUgdGhlIG9ubG9hZCBldmVudCB3aGVuIHRoZSBjb250ZW50IGlzIGlubGluZWQgaW4gdGhlIHNyYyBhdHRyaWJ1dGUsIHRoZXJlZm9yZSB3ZSByZWx5XG4gICAgICogICAgb24gdGhlIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudFxuICAgICAqL1xuICAgIF9jcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgICA9IHRoaXMsXG4gICAgICAgICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICBpZnJhbWUuY2xhc3NOYW1lID0gXCJ3eXNpaHRtbDUtc2FuZGJveFwiO1xuICAgICAgd3lzaWh0bWw1LmRvbS5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgXCJzZWN1cml0eVwiOiAgICAgICAgICAgXCJyZXN0cmljdGVkXCIsXG4gICAgICAgIFwiYWxsb3d0cmFuc3BhcmVuY3lcIjogIFwidHJ1ZVwiLFxuICAgICAgICBcImZyYW1lYm9yZGVyXCI6ICAgICAgICAwLFxuICAgICAgICBcIndpZHRoXCI6ICAgICAgICAgICAgICAwLFxuICAgICAgICBcImhlaWdodFwiOiAgICAgICAgICAgICAwLFxuICAgICAgICBcIm1hcmdpbndpZHRoXCI6ICAgICAgICAwLFxuICAgICAgICBcIm1hcmdpbmhlaWdodFwiOiAgICAgICAwXG4gICAgICB9KS5vbihpZnJhbWUpO1xuXG4gICAgICAvLyBTZXR0aW5nIHRoZSBzcmMgbGlrZSB0aGlzIHByZXZlbnRzIHNzbCB3YXJuaW5ncyBpbiBJRTZcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci50aHJvd3NNaXhlZENvbnRlbnRXYXJuaW5nV2hlbklmcmFtZVNyY0lzRW1wdHkoKSkge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJqYXZhc2NyaXB0Oic8aHRtbD48L2h0bWw+J1wiO1xuICAgICAgfVxuXG4gICAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgICAgdGhhdC5fb25Mb2FkSWZyYW1lKGlmcmFtZSk7XG4gICAgICB9O1xuXG4gICAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KGlmcmFtZS5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgICAgICB0aGF0Ll9vbkxvYWRJZnJhbWUoaWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGlmcmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIGlmcmFtZSBoYXMgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqL1xuICAgIF9vbkxvYWRJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZSkge1xuICAgICAgLy8gZG9uJ3QgcmVzdW1lIHdoZW4gdGhlIGlmcmFtZSBnb3QgdW5sb2FkZWQgKGVnLiBieSByZW1vdmluZyBpdCBmcm9tIHRoZSBkb20pXG4gICAgICBpZiAoIXd5c2lodG1sNS5kb20uY29udGFpbnMoZG9jLmRvY3VtZW50RWxlbWVudCwgaWZyYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgaWZyYW1lV2luZG93ICAgPSBpZnJhbWUuY29udGVudFdpbmRvdyxcbiAgICAgICAgICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LFxuICAgICAgICAgIGNoYXJzZXQgICAgICAgID0gZG9jLmNoYXJhY3RlclNldCB8fCBkb2MuY2hhcnNldCB8fCBcInV0Zi04XCIsXG4gICAgICAgICAgc2FuZGJveEh0bWwgICAgPSB0aGlzLl9nZXRIdG1sKHtcbiAgICAgICAgICAgIGNoYXJzZXQ6ICAgICAgY2hhcnNldCxcbiAgICAgICAgICAgIHN0eWxlc2hlZXRzOiAgdGhpcy5jb25maWcuc3R5bGVzaGVldHNcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBiYXNpYyBkb20gdHJlZSBpbmNsdWRpbmcgcHJvcGVyIERPQ1RZUEUgYW5kIGNoYXJzZXRcbiAgICAgIGlmcmFtZURvY3VtZW50Lm9wZW4oXCJ0ZXh0L2h0bWxcIiwgXCJyZXBsYWNlXCIpO1xuICAgICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2FuZGJveEh0bWwpO1xuICAgICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcblxuICAgICAgdGhpcy5nZXRXaW5kb3cgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGlmcmFtZS5jb250ZW50V2luZG93OyB9O1xuICAgICAgdGhpcy5nZXREb2N1bWVudCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7IH07XG5cbiAgICAgIC8vIENhdGNoIGpzIGVycm9ycyBhbmQgcGFzcyB0aGVtIHRvIHRoZSBwYXJlbnQncyBvbmVycm9yIGV2ZW50XG4gICAgICAvLyBhZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIikgZG9lc24ndCB3b3JrIHByb3Blcmx5IGluIHNvbWUgYnJvd3NlcnNcbiAgICAgIC8vIFRPRE86IGFwcGFyZW50bHkgdGhpcyBkb2Vzbid0IHdvcmsgaW4gSUU5IVxuICAgICAgaWZyYW1lV2luZG93Lm9uZXJyb3IgPSBmdW5jdGlvbihlcnJvck1lc3NhZ2UsIGZpbGVOYW1lLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInd5c2lodG1sNS5TYW5kYm94OiBcIiArIGVycm9yTWVzc2FnZSwgZmlsZU5hbWUsIGxpbmVOdW1iZXIpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c1NhbmRib3hlZElmcmFtZXMoKSkge1xuICAgICAgICAvLyBVbnNldCBhIGJ1bmNoIG9mIHNlbnNpdGl2ZSB2YXJpYWJsZXNcbiAgICAgICAgLy8gUGxlYXNlIG5vdGU6IFRoaXMgaXNuJ3QgaGFjayBzYWZlIVxuICAgICAgICAvLyBJdCBtb3JlIG9yIGxlc3MganVzdCB0YWtlcyBjYXJlIG9mIGJhc2ljIGF0dGFja3MgYW5kIHByZXZlbnRzIGFjY2lkZW50YWwgdGhlZnQgb2Ygc2Vuc2l0aXZlIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIElFIGlzIHNlY3VyZSB0aG91Z2gsIHdoaWNoIGlzIHRoZSBtb3N0IGltcG9ydGFudCB0aGluZywgc2luY2UgSUUgaXMgdGhlIG9ubHkgYnJvd3Nlciwgd2hvXG4gICAgICAgIC8vIHRha2VzIG92ZXIgc2NyaXB0cyAmIHN0eWxlcyBpbnRvIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50cyB3aGVuIGNvcGllZCBmcm9tIGV4dGVybmFsIHdlYnNpdGVzXG4gICAgICAgIC8vIG9yIGFwcGxpY2F0aW9ucyAoTWljcm9zb2Z0IFdvcmQsIC4uLilcbiAgICAgICAgdmFyIGksIGxlbmd0aDtcbiAgICAgICAgZm9yIChpPTAsIGxlbmd0aD13aW5kb3dQcm9wZXJ0aWVzLmxlbmd0aDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX3Vuc2V0KGlmcmFtZVdpbmRvdywgd2luZG93UHJvcGVydGllc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpPTAsIGxlbmd0aD13aW5kb3dQcm9wZXJ0aWVzMi5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl91bnNldChpZnJhbWVXaW5kb3csIHdpbmRvd1Byb3BlcnRpZXMyW2ldLCB3eXNpaHRtbDUuRU1QVFlfRlVOQ1RJT04pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaT0wLCBsZW5ndGg9ZG9jdW1lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX3Vuc2V0KGlmcmFtZURvY3VtZW50LCBkb2N1bWVudFByb3BlcnRpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCB3b3JrIGluIFNhZmFyaSA1XG4gICAgICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk5MjQ2MS9pcy1pdC1wb3NzaWJsZS10by1vdmVycmlkZS1kb2N1bWVudC1jb29raWUtaW4td2Via2l0XG4gICAgICAgIHRoaXMuX3Vuc2V0KGlmcmFtZURvY3VtZW50LCBcImNvb2tpZVwiLCBcIlwiLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAvLyBUcmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5jYWxsYmFjayh0aGF0KTsgfSwgMCk7XG4gICAgfSxcblxuICAgIF9nZXRIdG1sOiBmdW5jdGlvbih0ZW1wbGF0ZVZhcnMpIHtcbiAgICAgIHZhciBzdHlsZXNoZWV0cyA9IHRlbXBsYXRlVmFycy5zdHlsZXNoZWV0cyxcbiAgICAgICAgICBodG1sICAgICAgICA9IFwiXCIsXG4gICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgIGxlbmd0aDtcbiAgICAgIHN0eWxlc2hlZXRzID0gdHlwZW9mKHN0eWxlc2hlZXRzKSA9PT0gXCJzdHJpbmdcIiA/IFtzdHlsZXNoZWV0c10gOiBzdHlsZXNoZWV0cztcbiAgICAgIGlmIChzdHlsZXNoZWV0cykge1xuICAgICAgICBsZW5ndGggPSBzdHlsZXNoZWV0cy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaHRtbCArPSAnPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCInICsgc3R5bGVzaGVldHNbaV0gKyAnXCI+JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcGxhdGVWYXJzLnN0eWxlc2hlZXRzID0gaHRtbDtcblxuICAgICAgcmV0dXJuIHd5c2lodG1sNS5sYW5nLnN0cmluZyhcbiAgICAgICAgJzwhRE9DVFlQRSBodG1sPjxodG1sPjxoZWFkPidcbiAgICAgICAgKyAnPG1ldGEgY2hhcnNldD1cIiN7Y2hhcnNldH1cIj4je3N0eWxlc2hlZXRzfTwvaGVhZD4nXG4gICAgICAgICsgJzxib2R5PjwvYm9keT48L2h0bWw+J1xuICAgICAgKS5pbnRlcnBvbGF0ZSh0ZW1wbGF0ZVZhcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gdW5zZXQvb3ZlcnJpZGUgZXhpc3RpbmcgdmFyaWFibGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAvLyBNYWtlIGNvb2tpZSB1bnJlYWRhYmxlIGFuZCB1bndyaXRhYmxlXG4gICAgICogICAgdGhpcy5fdW5zZXQoZG9jdW1lbnQsIFwiY29va2llXCIsIFwiXCIsIHRydWUpO1xuICAgICAqL1xuICAgIF91bnNldDogZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIHNldHRlcikge1xuICAgICAgdHJ5IHsgb2JqZWN0W3Byb3BlcnR5XSA9IHZhbHVlOyB9IGNhdGNoKGUpIHt9XG5cbiAgICAgIHRyeSB7IG9iamVjdC5fX2RlZmluZUdldHRlcl9fKHByb3BlcnR5LCBmdW5jdGlvbigpIHsgcmV0dXJuIHZhbHVlOyB9KTsgfSBjYXRjaChlKSB7fVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICB0cnkgeyBvYmplY3QuX19kZWZpbmVTZXR0ZXJfXyhwcm9wZXJ0eSwgZnVuY3Rpb24oKSB7fSk7IH0gY2F0Y2goZSkge31cbiAgICAgIH1cblxuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5jcmFzaGVzV2hlbkRlZmluZVByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdmFsdWU7IH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zZXQgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgY29uZmlnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIGRvYyA9IGRvY3VtZW50O1xuICB3eXNpaHRtbDUuZG9tLkNvbnRlbnRFZGl0YWJsZUFyZWEgPSBCYXNlLmV4dGVuZCh7XG4gICAgICBnZXRDb250ZW50RWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgICAgfSxcblxuICAgICAgZ2V0V2luZG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgfSxcblxuICAgICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICB9LFxuXG4gICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ocmVhZHlDYWxsYmFjaywgY29uZmlnLCBjb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHJlYWR5Q2FsbGJhY2sgfHwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OO1xuICAgICAgICB0aGlzLmNvbmZpZyAgID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHt9KS5tZXJnZShjb25maWcpLmdldCgpO1xuICAgICAgICBpZiAoY29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLl9iaW5kRWxlbWVudChjb250ZW50RWRpdGFibGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5fY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBjcmVhdGVzIGEgbmV3IGNvbnRlbnRlZGl0YWJsZSBhbmQgaW5pdGlhdGVzIGl0XG4gICAgICBfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJ3eXNpaHRtbDUtc2FuZGJveFwiO1xuICAgICAgICB0aGlzLl9sb2FkRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuXG4gICAgICAvLyBpbml0aWF0ZXMgYW4gYWxscmVhZHkgZXhpc3RlbnQgY29udGVudGVkaXRhYmxlXG4gICAgICBfYmluZEVsZW1lbnQ6IGZ1bmN0aW9uKGNvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICBjb250ZW50RWRpdGFibGUuY2xhc3NOYW1lID0gKGNvbnRlbnRFZGl0YWJsZS5jbGFzc05hbWUgJiYgY29udGVudEVkaXRhYmxlLmNsYXNzTmFtZSAhPSAnJykgPyBjb250ZW50RWRpdGFibGUuY2xhc3NOYW1lICsgXCIgd3lzaWh0bWw1LXNhbmRib3hcIiA6IFwid3lzaWh0bWw1LXNhbmRib3hcIjtcbiAgICAgICAgdGhpcy5fbG9hZEVsZW1lbnQoY29udGVudEVkaXRhYmxlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRFZGl0YWJsZTtcbiAgICAgIH0sXG5cbiAgICAgIF9sb2FkRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgY29udGVudEV4aXN0cykge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKCFjb250ZW50RXhpc3RzKSB7XG4gICAgICAgICAgICB2YXIgc2FuZGJveEh0bWwgPSB0aGlzLl9nZXRIdG1sKCk7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHNhbmRib3hIdG1sO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXRXaW5kb3cgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldzsgfTtcbiAgICAgICAgdGhpcy5nZXREb2N1bWVudCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50OyB9O1xuXG4gICAgICAgIC8vIENhdGNoIGpzIGVycm9ycyBhbmQgcGFzcyB0aGVtIHRvIHRoZSBwYXJlbnQncyBvbmVycm9yIGV2ZW50XG4gICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiKSBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICAvLyBUT0RPOiBhcHBhcmVudGx5IHRoaXMgZG9lc24ndCB3b3JrIGluIElFOSFcbiAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBhbmQgYmluZCB0aGUgZXJyb3JzIGxvZ2ljIGZvciBjb250ZW50ZWRpdGJsZSBtb2RlXG4gICAgICAgIC8qaWZyYW1lV2luZG93Lm9uZXJyb3IgPSBmdW5jdGlvbihlcnJvck1lc3NhZ2UsIGZpbGVOYW1lLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3lzaWh0bWw1LlNhbmRib3g6IFwiICsgZXJyb3JNZXNzYWdlLCBmaWxlTmFtZSwgbGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aGF0LmNhbGxiYWNrKHRoYXQpOyB9LCAwKTtcbiAgICAgIH0sXG5cbiAgICAgIF9nZXRIdG1sOiBmdW5jdGlvbih0ZW1wbGF0ZVZhcnMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbjsoZnVuY3Rpb24oKSB7XG4gIHZhciBtYXBwaW5nID0ge1xuICAgIFwiY2xhc3NOYW1lXCI6IFwiY2xhc3NcIlxuICB9O1xuICB3eXNpaHRtbDUuZG9tLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG1hcHBpbmdbaV0gfHwgaSwgYXR0cmlidXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSkoKTtcbjt3eXNpaHRtbDUuZG9tLnNldFN0eWxlcyA9IGZ1bmN0aW9uKHN0eWxlcykge1xuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKHR5cGVvZihzdHlsZXMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgKz0gXCI7XCIgKyBzdHlsZXM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgaW4gc3R5bGVzKSB7XG4gICAgICAgIGlmIChpID09PSBcImZsb2F0XCIpIHtcbiAgICAgICAgICBzdHlsZS5jc3NGbG9hdCA9IHN0eWxlc1tpXTtcbiAgICAgICAgICBzdHlsZS5zdHlsZUZsb2F0ID0gc3R5bGVzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW2ldID0gc3R5bGVzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbjsvKipcbiAqIFNpbXVsYXRlIEhUTUw1IHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICpcbiAqIE5lZWRlZCBzaW5jZVxuICogICAgLSBkaXZbY29udGVudEVkaXRhYmxlXSBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGl0XG4gKiAgICAtIG9sZGVyIGJyb3dzZXJzIChzdWNoIGFzIElFOCBhbmQgRmlyZWZveCAzLjYpIGRvbid0IHN1cHBvcnQgaXQgYXQgYWxsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCBJbnN0YW5jZSBvZiBtYWluIHd5c2lodG1sNS5FZGl0b3IgY2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gdmlldyBJbnN0YW5jZSBvZiB3eXNpaHRtbDUudmlld3MuKiBjbGFzc1xuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlaG9sZGVyVGV4dFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICB3eXNpaHRtbC5kb20uc2ltdWxhdGVQbGFjZWhvbGRlcih0aGlzLCBjb21wb3NlciwgXCJGb29iYXJcIik7XG4gKi9cbihmdW5jdGlvbihkb20pIHtcbiAgZG9tLnNpbXVsYXRlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihlZGl0b3IsIHZpZXcsIHBsYWNlaG9sZGVyVGV4dCkge1xuICAgIHZhciBDTEFTU19OQU1FID0gXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICB1bnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjb21wb3NlcklzVmlzaWJsZSAgID0gdmlldy5lbGVtZW50Lm9mZnNldFdpZHRoID4gMCAmJiB2aWV3LmVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICAgICAgICBpZiAodmlldy5oYXNQbGFjZWhvbGRlclNldCgpKSB7XG4gICAgICAgICAgICB2aWV3LmNsZWFyKCk7XG4gICAgICAgICAgICB2aWV3LmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NlcklzVmlzaWJsZSApIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsID0gdmlldy5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWwuZm9jdXNOb2RlIHx8ICFzZWwuYW5jaG9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgdmlldy5zZWxlY3Rpb24uc2VsZWN0Tm9kZSh2aWV3LmVsZW1lbnQuZmlyc3RDaGlsZCB8fCB2aWV3LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZpZXcucGxhY2Vob2xkZXJTZXQgPSBmYWxzZTtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Modmlldy5lbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHZpZXcuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2aWV3LnBsYWNlaG9sZGVyU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuc2V0VmFsdWUocGxhY2Vob2xkZXJUZXh0KTtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyh2aWV3LmVsZW1lbnQsIENMQVNTX05BTUUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIGVkaXRvclxuICAgICAgLm9uKFwic2V0X3BsYWNlaG9sZGVyXCIsIHNldClcbiAgICAgIC5vbihcInVuc2V0X3BsYWNlaG9sZGVyXCIsIHVuc2V0KVxuICAgICAgLm9uKFwiZm9jdXM6Y29tcG9zZXJcIiwgdW5zZXQpXG4gICAgICAub24oXCJwYXN0ZTpjb21wb3NlclwiLCB1bnNldClcbiAgICAgIC5vbihcImJsdXI6Y29tcG9zZXJcIiwgc2V0KTtcblxuICAgIHNldCgpO1xuICB9O1xufSkod3lzaWh0bWw1LmRvbSk7XG47KGZ1bmN0aW9uKGRvbSkge1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoXCJ0ZXh0Q29udGVudFwiIGluIGRvY3VtZW50RWxlbWVudCkge1xuICAgIGRvbS5zZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHRleHQpIHtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICB9O1xuICB9IGVsc2UgaWYgKFwiaW5uZXJUZXh0XCIgaW4gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgZG9tLnNldFRleHRDb250ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgdGV4dCkge1xuICAgICAgZWxlbWVudC5pbm5lclRleHQgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lclRleHQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50LCB0ZXh0KSB7XG4gICAgICBlbGVtZW50Lm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgfTtcblxuICAgIGRvbS5nZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVWYWx1ZTtcbiAgICB9O1xuICB9XG59KSh3eXNpaHRtbDUuZG9tKTtcblxuOy8qKlxuICogR2V0IGEgc2V0IG9mIGF0dHJpYnV0ZSBmcm9tIG9uZSBlbGVtZW50XG4gKlxuICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgaGFzQXR0cmlidXRlL2dldEF0dHJpYnV0ZSwgZm9yIGV4YW1wbGU6XG4gKiAgICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gKiAgICB0ZC5nZXRBdHRyaWJ1dGUoXCJyb3dzcGFuXCIpOyAvLyA9PiBcIjFcIiBpbiBJRVxuICpcbiAqIFRoZXJlZm9yZSB3ZSBoYXZlIHRvIGNoZWNrIHRoZSBlbGVtZW50J3Mgb3V0ZXJIVE1MIGZvciB0aGUgYXR0cmlidXRlXG4qL1xuXG53eXNpaHRtbDUuZG9tLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5vZGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIEhBU19HRVRfQVRUUklCVVRFX0JVRyA9ICF3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0dldEF0dHJpYnV0ZUNvcnJlY3RseSgpO1xuICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBhdHRyaWJ1dGVOYW1lID09IFwic3JjXCIgJiYgd3lzaWh0bWw1LmRvbS5pc0xvYWRlZEltYWdlKG5vZGUpID09PSB0cnVlKSB7XG4gICAgLy8gR2V0ICdzcmMnIGF0dHJpYnV0ZSB2YWx1ZSB2aWEgb2JqZWN0IHByb3BlcnR5IHNpbmNlIHRoaXMgd2lsbCBhbHdheXMgY29udGFpbiB0aGVcbiAgICAvLyBmdWxsIGFic29sdXRlIHVybCAoaHR0cDovLy4uLilcbiAgICAvLyB0aGlzIGZpeGVzIGEgdmVyeSBhbm5veWluZyBidWcgaW4gZmlyZWZveCAodmVyIDMuNiAmIDQpIGFuZCBJRSA4IHdoZXJlIGltYWdlcyBjb3BpZWQgZnJvbSB0aGUgc2FtZSBob3N0XG4gICAgLy8gd2lsbCBoYXZlIHJlbGF0aXZlIHBhdGhzLCB3aGljaCB0aGUgc2FuaXRpemVyIHN0cmlwcyBvdXQgKHNlZSBhdHRyaWJ1dGVDaGVja01ldGhvZHMudXJsKVxuICAgIHJldHVybiBub2RlLnNyYztcbiAgfSBlbHNlIGlmIChIQVNfR0VUX0FUVFJJQlVURV9CVUcgJiYgXCJvdXRlckhUTUxcIiBpbiBub2RlKSB7XG4gICAgLy8gRG9uJ3QgdHJ1c3QgZ2V0QXR0cmlidXRlL2hhc0F0dHJpYnV0ZSBpbiBJRSA2LTgsIGluc3RlYWQgY2hlY2sgdGhlIGVsZW1lbnQncyBvdXRlckhUTUxcbiAgICB2YXIgb3V0ZXJIVE1MICAgICAgPSBub2RlLm91dGVySFRNTC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAvLyBUT0RPOiBUaGlzIG1pZ2h0IG5vdCB3b3JrIGZvciBhdHRyaWJ1dGVzIHdpdGhvdXQgdmFsdWU6IDxpbnB1dCBkaXNhYmxlZD5cbiAgICAgICAgaGFzQXR0cmlidXRlICAgPSBvdXRlckhUTUwuaW5kZXhPZihcIiBcIiArIGF0dHJpYnV0ZU5hbWUgKyAgXCI9XCIpICE9IC0xO1xuXG4gICAgcmV0dXJuIGhhc0F0dHJpYnV0ZSA/IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIDogbnVsbDtcbiAgfSBlbHNle1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfVxufTtcbjsvKipcbiAqIEdldCBhbGwgYXR0cmlidXRlcyBvZiBhbiBlbGVtZW50XG4gKlxuICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgaGFzQXR0cmlidXRlL2dldEF0dHJpYnV0ZSwgZm9yIGV4YW1wbGU6XG4gKiAgICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gKiAgICB0ZC5nZXRBdHRyaWJ1dGUoXCJyb3dzcGFuXCIpOyAvLyA9PiBcIjFcIiBpbiBJRVxuICpcbiAqIFRoZXJlZm9yZSB3ZSBoYXZlIHRvIGNoZWNrIHRoZSBlbGVtZW50J3Mgb3V0ZXJIVE1MIGZvciB0aGUgYXR0cmlidXRlXG4qL1xuXG53eXNpaHRtbDUuZG9tLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBIQVNfR0VUX0FUVFJJQlVURV9CVUcgPSAhd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkoKSxcbiAgICAgIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBbXSxcbiAgICAgIGF0dHI7XG5cbiAgZm9yIChhdHRyIGluIG5vZGUuYXR0cmlidXRlcykge1xuICAgIGlmICgobm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5ICYmIG5vZGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgfHwgKCFub2RlLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUuYXR0cmlidXRlcywgYXR0cikpKSAge1xuICAgICAgaWYgKG5vZGUuYXR0cmlidXRlc1thdHRyXS5zcGVjaWZpZWQpIHtcbiAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIgJiYgbm9kZS5hdHRyaWJ1dGVzW2F0dHJdLm5hbWUudG9Mb3dlckNhc2UoKSA9PSBcInNyY1wiICYmIHd5c2lodG1sNS5kb20uaXNMb2FkZWRJbWFnZShub2RlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbJ3NyYyddID0gbm9kZS5zcmM7XG4gICAgICAgIH0gZWxzZSBpZiAod3lzaWh0bWw1LmxhbmcuYXJyYXkoWydyb3dzcGFuJywgJ2NvbHNwYW4nXSkuY29udGFpbnMobm9kZS5hdHRyaWJ1dGVzW2F0dHJdLm5hbWUudG9Mb3dlckNhc2UoKSkgJiYgSEFTX0dFVF9BVFRSSUJVVEVfQlVHKSB7XG4gICAgICAgICAgaWYgKG5vZGUuYXR0cmlidXRlc1thdHRyXS52YWx1ZSAhPT0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tub2RlLmF0dHJpYnV0ZXNbYXR0cl0ubmFtZV0gPSBub2RlLmF0dHJpYnV0ZXNbYXR0cl0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbbm9kZS5hdHRyaWJ1dGVzW2F0dHJdLm5hbWVdID0gbm9kZS5hdHRyaWJ1dGVzW2F0dHJdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTs7LyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgaXMgYSBwcm9wZXIgbG9hZGVkIGltYWdlXG4gICAqIEZJWE1FOiBSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIHVua25vd24gKENocm9tZSwgU2FmYXJpKVxuKi9cblxud3lzaWh0bWw1LmRvbS5pc0xvYWRlZEltYWdlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbm9kZS5jb21wbGV0ZSAmJiAhbm9kZS5tb3pNYXRjaGVzU2VsZWN0b3IoXCI6LW1vei1icm9rZW5cIik7XG4gIH0gY2F0Y2goZSkge1xuICAgIGlmIChub2RlLmNvbXBsZXRlICYmIG5vZGUucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG47KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuXG4gICAgdmFyIGFwaSA9IHd5c2lodG1sNS5kb207XG5cbiAgICB2YXIgTWFwQ2VsbCA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgIHRoaXMuZWwgPSBjZWxsO1xuICAgICAgdGhpcy5pc0NvbHNwYW49IGZhbHNlO1xuICAgICAgdGhpcy5pc1Jvd3NwYW49IGZhbHNlO1xuICAgICAgdGhpcy5maXJzdENvbD0gdHJ1ZTtcbiAgICAgIHRoaXMubGFzdENvbD0gdHJ1ZTtcbiAgICAgIHRoaXMuZmlyc3RSb3c9IHRydWU7XG4gICAgICB0aGlzLmxhc3RSb3c9IHRydWU7XG4gICAgICB0aGlzLmlzUmVhbD0gdHJ1ZTtcbiAgICAgIHRoaXMuc3BhbkNvbGxlY3Rpb249IFtdO1xuICAgICAgdGhpcy5tb2RpZmllZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgVGFibGVNb2RpZnllckJ5Q2VsbCA9IGZ1bmN0aW9uIChjZWxsLCB0YWJsZSkge1xuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICAgICAgICAgIHRoaXMudGFibGUgPSBhcGkuZ2V0UGFyZW50RWxlbWVudChjZWxsLCB7IG5vZGVOYW1lOiBbXCJUQUJMRVwiXSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICAgICAgICAgICAgdGhpcy5jZWxsID0gdGhpcy50YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCd0aCwgdGQnKVswXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBxdWVyeUluTGlzdChsaXN0LCBxdWVyeSkge1xuICAgICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgICBxO1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgbGVuID0gbGlzdC5sZW5ndGg7IGUgPCBsZW47IGUrKykge1xuICAgICAgICAgICAgcSA9IGxpc3RbZV0ucXVlcnlTZWxlY3RvckFsbChxdWVyeSk7XG4gICAgICAgICAgICBpZiAocSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IHEubGVuZ3RoOyBpLS07IHJldC51bnNoaWZ0KHFbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIocmVmZXJlbmNlTm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHROb2RlKG5vZGUsIHRhZykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHdoaWxlIChlbGVtZW50Lm5vZGVUeXBlICE9MSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIXRhZyB8fCB0YWcgPT0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBUYWJsZU1vZGlmeWVyQnlDZWxsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBhZGRTcGFubmVkQ2VsbFRvTWFwOiBmdW5jdGlvbihjZWxsLCBtYXAsIHIsIGMsIGNzcGFuLCByc3Bhbikge1xuICAgICAgICAgICAgdmFyIHNwYW5Db2xsZWN0ID0gW10sXG4gICAgICAgICAgICAgICAgcm1heCA9IHIgKyAoKHJzcGFuKSA/IHBhcnNlSW50KHJzcGFuLCAxMCkgLSAxIDogMCksXG4gICAgICAgICAgICAgICAgY21heCA9IGMgKyAoKGNzcGFuKSA/IHBhcnNlSW50KGNzcGFuLCAxMCkgLSAxIDogMCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHJyID0gcjsgcnIgPD0gcm1heDsgcnIrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwW3JyXSA9PSBcInVuZGVmaW5lZFwiKSB7IG1hcFtycl0gPSBbXTsgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNjID0gYzsgY2MgPD0gY21heDsgY2MrKykge1xuICAgICAgICAgICAgICAgICAgICBtYXBbcnJdW2NjXSA9IG5ldyBNYXBDZWxsKGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbcnJdW2NjXS5pc0NvbHNwYW4gPSAoY3NwYW4gJiYgcGFyc2VJbnQoY3NwYW4sIDEwKSA+IDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbcnJdW2NjXS5pc1Jvd3NwYW4gPSAocnNwYW4gJiYgcGFyc2VJbnQocnNwYW4sIDEwKSA+IDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbcnJdW2NjXS5maXJzdENvbCA9IGNjID09IGM7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtycl1bY2NdLmxhc3RDb2wgPSBjYyA9PSBjbWF4O1xuICAgICAgICAgICAgICAgICAgICBtYXBbcnJdW2NjXS5maXJzdFJvdyA9IHJyID09IHI7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtycl1bY2NdLmxhc3RSb3cgPSByciA9PSBybWF4O1xuICAgICAgICAgICAgICAgICAgICBtYXBbcnJdW2NjXS5pc1JlYWwgPSBjYyA9PSBjICYmIHJyID09IHI7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtycl1bY2NdLnNwYW5Db2xsZWN0aW9uID0gc3BhbkNvbGxlY3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgc3BhbkNvbGxlY3QucHVzaChtYXBbcnJdW2NjXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldENlbGxBc01vZGlmaWVkOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICBjZWxsLm1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjZWxsLnNwYW5Db2xsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDAsIHNtYXggPSBjZWxsLnNwYW5Db2xsZWN0aW9uLmxlbmd0aDsgcyA8IHNtYXg7IHMrKykge1xuICAgICAgICAgICAgICAgIGNlbGwuc3BhbkNvbGxlY3Rpb25bc10ubW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0VGFibGVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IFtdO1xuICAgICAgICAgICAgdmFyIHRhYmxlUm93cyA9IHRoaXMuZ2V0VGFibGVSb3dzKCksXG4gICAgICAgICAgICAgICAgcmlkeCwgcm93LCBjZWxscywgY2lkeCwgY2VsbCxcbiAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgIGNzcGFuLCByc3BhbjtcblxuICAgICAgICAgICAgZm9yIChyaWR4ID0gMDsgcmlkeCA8IHRhYmxlUm93cy5sZW5ndGg7IHJpZHgrKykge1xuICAgICAgICAgICAgICAgIHJvdyA9IHRhYmxlUm93c1tyaWR4XTtcbiAgICAgICAgICAgICAgICBjZWxscyA9IHRoaXMuZ2V0Um93Q2VsbHMocm93KTtcbiAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hcFtyaWR4XSA9PSBcInVuZGVmaW5lZFwiKSB7IG1hcFtyaWR4XSA9IFtdOyB9XG4gICAgICAgICAgICAgICAgZm9yIChjaWR4ID0gMDsgY2lkeCA8IGNlbGxzLmxlbmd0aDsgY2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwgPSBjZWxsc1tjaWR4XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjZWxsIGFsbHJlYWR5IHNldCBtZWFucyBpdCBpcyBzZXQgYnkgY29sIG9yIHJvd3NwYW4sXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGluY3JlYXNlIGNvbHMgaW5kZXggdW50aWwgZnJlZSBjb2wgaXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBtYXBbcmlkeF1bY10gIT0gXCJ1bmRlZmluZWRcIikgeyBjKys7IH1cblxuICAgICAgICAgICAgICAgICAgICBjc3BhbiA9IGFwaS5nZXRBdHRyaWJ1dGUoY2VsbCwgJ2NvbHNwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgcnNwYW4gPSBhcGkuZ2V0QXR0cmlidXRlKGNlbGwsICdyb3dzcGFuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcGFuIHx8IHJzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNwYW5uZWRDZWxsVG9NYXAoY2VsbCwgbWFwLCByaWR4LCBjLCBjc3BhbiwgcnNwYW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGMgKyAoKGNzcGFuKSA/IHBhcnNlSW50KGNzcGFuLCAxMCkgOiAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFtyaWR4XVtjXSA9IG5ldyBNYXBDZWxsKGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFJvd0NlbGxzOiBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgIHZhciBpbmxpbmVUYWJsZXMgPSB0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlJyksXG4gICAgICAgICAgICAgICAgaW5saW5lQ2VsbHMgPSAoaW5saW5lVGFibGVzKSA/IHF1ZXJ5SW5MaXN0KGlubGluZVRhYmxlcywgJ3RoLCB0ZCcpIDogW10sXG4gICAgICAgICAgICAgICAgYWxsQ2VsbHMgPSByb3cucXVlcnlTZWxlY3RvckFsbCgndGgsIHRkJyksXG4gICAgICAgICAgICAgICAgdGFibGVDZWxscyA9IChpbmxpbmVDZWxscy5sZW5ndGggPiAwKSA/IHd5c2lodG1sNS5sYW5nLmFycmF5KGFsbENlbGxzKS53aXRob3V0KGlubGluZUNlbGxzKSA6IGFsbENlbGxzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGFibGVDZWxscztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUYWJsZVJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpbmxpbmVUYWJsZXMgPSB0aGlzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlJyksXG4gICAgICAgICAgICAgIGlubGluZVJvd3MgPSAoaW5saW5lVGFibGVzKSA/IHF1ZXJ5SW5MaXN0KGlubGluZVRhYmxlcywgJ3RyJykgOiBbXSxcbiAgICAgICAgICAgICAgYWxsUm93cyA9IHRoaXMudGFibGUucXVlcnlTZWxlY3RvckFsbCgndHInKSxcbiAgICAgICAgICAgICAgdGFibGVSb3dzID0gKGlubGluZVJvd3MubGVuZ3RoID4gMCkgPyB3eXNpaHRtbDUubGFuZy5hcnJheShhbGxSb3dzKS53aXRob3V0KGlubGluZVJvd3MpIDogYWxsUm93cztcblxuICAgICAgICAgIHJldHVybiB0YWJsZVJvd3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWFwSW5kZXg6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICB2YXIgcl9sZW5ndGggPSB0aGlzLm1hcC5sZW5ndGgsXG4gICAgICAgICAgICAgIGNfbGVuZ3RoID0gKHRoaXMubWFwICYmIHRoaXMubWFwWzBdKSA/IHRoaXMubWFwWzBdLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciByX2lkeCA9IDA7cl9pZHggPCByX2xlbmd0aDsgcl9pZHgrKykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBjX2lkeCA9IDA7Y19pZHggPCBjX2xlbmd0aDsgY19pZHgrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFwW3JfaWR4XVtjX2lkeF0uZWwgPT09IGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geydyb3cnOiByX2lkeCwgJ2NvbCc6IGNfaWR4fTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RWxlbWVudEF0SW5kZXg6IGZ1bmN0aW9uKGlkeCkge1xuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZU1hcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwW2lkeC5yb3ddICYmIHRoaXMubWFwW2lkeC5yb3ddW2lkeC5jb2xdICYmIHRoaXMubWFwW2lkeC5yb3ddW2lkeC5jb2xdLmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwW2lkeC5yb3ddW2lkeC5jb2xdLmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TWFwRWxzVG86IGZ1bmN0aW9uKHRvX2NlbGwpIHtcbiAgICAgICAgICAgIHZhciBlbHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGFibGVNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaWR4X3N0YXJ0ID0gdGhpcy5nZXRNYXBJbmRleCh0aGlzLmNlbGwpO1xuICAgICAgICAgICAgdGhpcy5pZHhfZW5kID0gdGhpcy5nZXRNYXBJbmRleCh0b19jZWxsKTtcblxuICAgICAgICAgICAgLy8gc3dpdGNoIGluZGV4ZXMgaWYgc3RhcnQgaXMgYmlnZ2VyIHRoYW4gZW5kXG4gICAgICAgICAgICBpZiAodGhpcy5pZHhfc3RhcnQucm93ID4gdGhpcy5pZHhfZW5kLnJvdyB8fCAodGhpcy5pZHhfc3RhcnQucm93ID09IHRoaXMuaWR4X2VuZC5yb3cgJiYgdGhpcy5pZHhfc3RhcnQuY29sID4gdGhpcy5pZHhfZW5kLmNvbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcF9pZHggPSB0aGlzLmlkeF9zdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeF9zdGFydCA9IHRoaXMuaWR4X2VuZDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeF9lbmQgPSB0ZW1wX2lkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlkeF9zdGFydC5jb2wgPiB0aGlzLmlkeF9lbmQuY29sKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBfY2lkeCA9IHRoaXMuaWR4X3N0YXJ0LmNvbDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeF9zdGFydC5jb2wgPSB0aGlzLmlkeF9lbmQuY29sO1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4X2VuZC5jb2wgPSB0ZW1wX2NpZHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkeF9zdGFydCAhPSBudWxsICYmIHRoaXMuaWR4X2VuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gdGhpcy5pZHhfc3RhcnQucm93LCBtYXhyID0gdGhpcy5pZHhfZW5kLnJvdzsgcm93IDw9IG1heHI7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IHRoaXMuaWR4X3N0YXJ0LmNvbCwgbWF4YyA9IHRoaXMuaWR4X2VuZC5jb2w7IGNvbCA8PSBtYXhjOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2godGhpcy5tYXBbcm93XVtjb2xdLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JkZXJTZWxlY3Rpb25FbmRzOiBmdW5jdGlvbihzZWNvbmRjZWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRhYmxlTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlkeF9zdGFydCA9IHRoaXMuZ2V0TWFwSW5kZXgodGhpcy5jZWxsKTtcbiAgICAgICAgICAgIHRoaXMuaWR4X2VuZCA9IHRoaXMuZ2V0TWFwSW5kZXgoc2Vjb25kY2VsbCk7XG5cbiAgICAgICAgICAgIC8vIHN3aXRjaCBpbmRleGVzIGlmIHN0YXJ0IGlzIGJpZ2dlciB0aGFuIGVuZFxuICAgICAgICAgICAgaWYgKHRoaXMuaWR4X3N0YXJ0LnJvdyA+IHRoaXMuaWR4X2VuZC5yb3cgfHwgKHRoaXMuaWR4X3N0YXJ0LnJvdyA9PSB0aGlzLmlkeF9lbmQucm93ICYmIHRoaXMuaWR4X3N0YXJ0LmNvbCA+IHRoaXMuaWR4X2VuZC5jb2wpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBfaWR4ID0gdGhpcy5pZHhfc3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhfc3RhcnQgPSB0aGlzLmlkeF9lbmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhfZW5kID0gdGVtcF9pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pZHhfc3RhcnQuY29sID4gdGhpcy5pZHhfZW5kLmNvbCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wX2NpZHggPSB0aGlzLmlkeF9zdGFydC5jb2w7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhfc3RhcnQuY29sID0gdGhpcy5pZHhfZW5kLmNvbDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeF9lbmQuY29sID0gdGVtcF9jaWR4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFwic3RhcnRcIjogdGhpcy5tYXBbdGhpcy5pZHhfc3RhcnQucm93XVt0aGlzLmlkeF9zdGFydC5jb2xdLmVsLFxuICAgICAgICAgICAgICAgIFwiZW5kXCI6IHRoaXMubWFwW3RoaXMuaWR4X2VuZC5yb3ddW3RoaXMuaWR4X2VuZC5jb2xdLmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNlbGxzOiBmdW5jdGlvbih0YWcsIG5yLCBhdHRycykge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMudGFibGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmcmFnID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBjZWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBucjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIG5vbiBicmVha2luZyBzcGFjZVxuICAgICAgICAgICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXHUwMGEwXCIpKTtcblxuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZXR1cm5zIG5leHQgcmVhbCBjZWxsIChub3QgcGFydCBvZiBzcGFubmVkIGNlbGwgdW5sZXNzIGZpcnN0KSBvbiByb3cgaWYgc2VsZWN0ZWQgaW5kZXggaXMgbm90IHJlYWwuIEkgbm8gcmVhbCBjZWxscyAtMSB3aWxsIGJlIHJldHVybmVkXG4gICAgICAgIGNvcnJlY3RDb2xJbmRleEZvclVucmVhbHM6IGZ1bmN0aW9uKGNvbCwgcm93KSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMubWFwW3Jvd10sXG4gICAgICAgICAgICAgICAgY29ycklkeCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGNvbDsgaSA8IGNvbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJbaV0uaXNSZWFsKXtcbiAgICAgICAgICAgICAgICAgICAgY29ycklkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3JySWR4O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExhc3ROZXdDZWxsT25Sb3c6IGZ1bmN0aW9uKHJvdywgcm93TGltaXQpIHtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IHRoaXMuZ2V0Um93Q2VsbHMocm93KSxcbiAgICAgICAgICAgICAgICBjZWxsLCBpZHg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNpZHggPSAwLCBjbWF4ID0gY2VsbHMubGVuZ3RoOyBjaWR4IDwgY21heDsgY2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IGNlbGxzW2NpZHhdO1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoaXMuZ2V0TWFwSW5kZXgoY2VsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gZmFsc2UgfHwgKHR5cGVvZiByb3dMaW1pdCAhPSBcInVuZGVmaW5lZFwiICYmIGlkeC5yb3cgIT0gcm93TGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUVtcHR5VGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gdGhpcy50YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZCwgdGgnKTtcbiAgICAgICAgICAgIGlmICghY2VsbHMgfHwgY2VsbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KHRoaXMudGFibGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU3BsaXRzIG1lcmdlZCBjZWxsIG9uIHJvdyB0byB1bmlxdWUgY2VsbHNcbiAgICAgICAgc3BsaXRSb3dUb0NlbGxzOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICBpZiAoY2VsbC5pc0NvbHNwYW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sc3BhbiA9IHBhcnNlSW50KGFwaS5nZXRBdHRyaWJ1dGUoY2VsbC5lbCwgJ2NvbHNwYW4nKSB8fCAxLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIGNUeXBlID0gY2VsbC5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDZWxscyA9IHRoaXMuY3JlYXRlQ2VsbHMoY1R5cGUsIGNvbHNwYW4gLTEpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcihjZWxsLmVsLCBuZXdDZWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGwuZWwucmVtb3ZlQXR0cmlidXRlKCdjb2xzcGFuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UmVhbFJvd0VsOiBmdW5jdGlvbihmb3JjZSwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgciA9IG51bGwsXG4gICAgICAgICAgICAgICAgYyA9IG51bGw7XG5cbiAgICAgICAgICAgIGlkeCA9IGlkeCB8fCB0aGlzLmlkeDtcblxuICAgICAgICAgICAgZm9yICh2YXIgY2lkeCA9IDAsIGNtYXggPSB0aGlzLm1hcFtpZHgucm93XS5sZW5ndGg7IGNpZHggPCBjbWF4OyBjaWR4KyspIHtcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5tYXBbaWR4LnJvd11bY2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKGMuaXNSZWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBhcGkuZ2V0UGFyZW50RWxlbWVudChjLmVsLCB7IG5vZGVOYW1lOiBbXCJUUlwiXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAociA9PT0gbnVsbCAmJiBmb3JjZSkge1xuICAgICAgICAgICAgICAgIHIgPSBhcGkuZ2V0UGFyZW50RWxlbWVudCh0aGlzLm1hcFtpZHgucm93XVtpZHguY29sXS5lbCwgeyBub2RlTmFtZTogW1wiVFJcIl0gfSkgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5qZWN0Um93QXQ6IGZ1bmN0aW9uKHJvdywgY29sLCBjb2xzcGFuLCBjVHlwZSwgYykge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmdldFJlYWxSb3dFbChmYWxzZSwgeydyb3cnOiByb3csICdjb2wnOiBjb2x9KSxcbiAgICAgICAgICAgICAgICBuZXdfY2VsbHMgPSB0aGlzLmNyZWF0ZUNlbGxzKGNUeXBlLCBjb2xzcGFuKTtcblxuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbl9jaWR4ID0gdGhpcy5jb3JyZWN0Q29sSW5kZXhGb3JVbnJlYWxzKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICBpZiAobl9jaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIodGhpcy5nZXRSb3dDZWxscyhyKVtuX2NpZHhdLCBuZXdfY2VsbHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIuaW5zZXJ0QmVmb3JlKG5ld19jZWxscywgci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByciA9IHRoaXMudGFibGUub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgIHJyLmFwcGVuZENoaWxkKG5ld19jZWxscyk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIoYXBpLmdldFBhcmVudEVsZW1lbnQoYy5lbCwgeyBub2RlTmFtZTogW1wiVFJcIl0gfSksIHJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYW5NZXJnZTogZnVuY3Rpb24odG8pIHtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgICAgIHRoaXMuc2V0VGFibGVNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaWR4X3N0YXJ0ID0gdGhpcy5nZXRNYXBJbmRleCh0aGlzLmNlbGwpO1xuICAgICAgICAgICAgdGhpcy5pZHhfZW5kID0gdGhpcy5nZXRNYXBJbmRleCh0aGlzLnRvKTtcblxuICAgICAgICAgICAgLy8gc3dpdGNoIGluZGV4ZXMgaWYgc3RhcnQgaXMgYmlnZ2VyIHRoYW4gZW5kXG4gICAgICAgICAgICBpZiAodGhpcy5pZHhfc3RhcnQucm93ID4gdGhpcy5pZHhfZW5kLnJvdyB8fCAodGhpcy5pZHhfc3RhcnQucm93ID09IHRoaXMuaWR4X2VuZC5yb3cgJiYgdGhpcy5pZHhfc3RhcnQuY29sID4gdGhpcy5pZHhfZW5kLmNvbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcF9pZHggPSB0aGlzLmlkeF9zdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeF9zdGFydCA9IHRoaXMuaWR4X2VuZDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeF9lbmQgPSB0ZW1wX2lkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlkeF9zdGFydC5jb2wgPiB0aGlzLmlkeF9lbmQuY29sKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBfY2lkeCA9IHRoaXMuaWR4X3N0YXJ0LmNvbDtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeF9zdGFydC5jb2wgPSB0aGlzLmlkeF9lbmQuY29sO1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4X2VuZC5jb2wgPSB0ZW1wX2NpZHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHRoaXMuaWR4X3N0YXJ0LnJvdywgbWF4ciA9IHRoaXMuaWR4X2VuZC5yb3c7IHJvdyA8PSBtYXhyOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IHRoaXMuaWR4X3N0YXJ0LmNvbCwgbWF4YyA9IHRoaXMuaWR4X2VuZC5jb2w7IGNvbCA8PSBtYXhjOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBbcm93XVtjb2xdLmlzQ29sc3BhbiB8fCB0aGlzLm1hcFtyb3ddW2NvbF0uaXNSb3dzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWNyZWFzZUNlbGxTcGFuOiBmdW5jdGlvbihjZWxsLCBzcGFuKSB7XG4gICAgICAgICAgICB2YXIgbnIgPSBwYXJzZUludChhcGkuZ2V0QXR0cmlidXRlKGNlbGwuZWwsIHNwYW4pLCAxMCkgLSAxO1xuICAgICAgICAgICAgaWYgKG5yID49IDEpIHtcbiAgICAgICAgICAgICAgICBjZWxsLmVsLnNldEF0dHJpYnV0ZShzcGFuLCBucik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGwuZWwucmVtb3ZlQXR0cmlidXRlKHNwYW4pO1xuICAgICAgICAgICAgICAgIGlmIChzcGFuID09ICdjb2xzcGFuJykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmlzQ29sc3BhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9PSAncm93c3BhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5pc1Jvd3NwYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbC5maXJzdENvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2VsbC5sYXN0Q29sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjZWxsLmZpcnN0Um93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjZWxsLmxhc3RSb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNlbGwuaXNSZWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVTdXJwbHVzTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJvdywgY2VsbCwgcmlkeCwgcm1heCwgY2lkeCwgY21heCwgYWxsUm93c3BhbjtcblxuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZU1hcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICAgICAgcmlkeCA9IDA7XG4gICAgICAgICAgICAgICAgcm1heCA9IHRoaXMubWFwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKDtyaWR4IDwgcm1heDsgcmlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMubWFwW3JpZHhdO1xuICAgICAgICAgICAgICAgICAgICBhbGxSb3dzcGFuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2lkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNtYXggPSByb3cubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgY2lkeCA8IGNtYXg7IGNpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IHJvd1tjaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFwaS5nZXRBdHRyaWJ1dGUoY2VsbC5lbCwgXCJyb3dzcGFuXCIpICYmIHBhcnNlSW50KGFwaS5nZXRBdHRyaWJ1dGUoY2VsbC5lbCwgXCJyb3dzcGFuXCIpLCAxMCkgPiAxICYmIGNlbGwuZmlyc3RSb3cgIT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsUm93c3BhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxSb3dzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBjaWR4IDwgY21heDsgY2lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNyZWFzZUNlbGxTcGFuKHJvd1tjaWR4XSwgJ3Jvd3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByb3dzIHdpdGhvdXQgY2VsbHNcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVSb3dzID0gdGhpcy5nZXRUYWJsZVJvd3MoKTtcbiAgICAgICAgICAgICAgICByaWR4ID0gMDtcbiAgICAgICAgICAgICAgICBybWF4ID0gdGFibGVSb3dzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKDtyaWR4IDwgcm1heDsgcmlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHRhYmxlUm93c1tyaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5jaGlsZE5vZGVzLmxlbmd0aCA9PSAwICYmICgvXlxccyokLy50ZXN0KHJvdy50ZXh0Q29udGVudCB8fCByb3cuaW5uZXJUZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQocm93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaWxsTWlzc2luZ0NlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByX21heCA9IDAsXG4gICAgICAgICAgICAgICAgY19tYXggPSAwLFxuICAgICAgICAgICAgICAgIHByZXZjZWxsID0gbnVsbDtcblxuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZU1hcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIG1heGltYWwgZGltZW5zaW9ucyBvZiBicm9rZW4gdGFibGVcbiAgICAgICAgICAgICAgICByX21heCA9IHRoaXMubWFwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByaWR4ID0gMDsgcmlkeCA8IHJfbWF4OyByaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFwW3JpZHhdLmxlbmd0aCA+IGNfbWF4KSB7IGNfbWF4ID0gdGhpcy5tYXBbcmlkeF0ubGVuZ3RoOyB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcl9tYXg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNfbWF4OyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFwW3Jvd10gJiYgIXRoaXMubWFwW3Jvd11bY29sXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwW3Jvd11bY29sXSA9IG5ldyBNYXBDZWxsKHRoaXMuY3JlYXRlQ2VsbHMoJ3RkJywgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2Y2VsbCA9IHRoaXMubWFwW3Jvd11bY29sLTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmNlbGwgJiYgcHJldmNlbGwuZWwgJiYgcHJldmNlbGwuZWwucGFyZW50KSB7IC8vIGlmIHBhcmVudCBkb2VzIG5vdCBleGlzdCBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFmdGVyKHRoaXMubWFwW3Jvd11bY29sLTFdLmVsLCB0aGlzLm1hcFtyb3ddW2NvbF0uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlY3RpZnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbW92ZUVtcHR5VGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU3VycGx1c0xpbmVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsTWlzc2luZ0NlbGxzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bm1lcmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY3RpZnkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFibGVNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeCA9IHRoaXMuZ2V0TWFwSW5kZXgodGhpcy5jZWxsKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0NlbGwgPSB0aGlzLm1hcFt0aGlzLmlkeC5yb3ddW3RoaXMuaWR4LmNvbF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzcGFuID0gKGFwaS5nZXRBdHRyaWJ1dGUodGhpc0NlbGwuZWwsIFwiY29sc3BhblwiKSkgPyBwYXJzZUludChhcGkuZ2V0QXR0cmlidXRlKHRoaXNDZWxsLmVsLCBcImNvbHNwYW5cIiksIDEwKSA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjVHlwZSA9IHRoaXNDZWxsLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0NlbGwuaXNSb3dzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93c3BhbiA9IHBhcnNlSW50KGFwaS5nZXRBdHRyaWJ1dGUodGhpc0NlbGwuZWwsIFwicm93c3BhblwiKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd3NwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbnIgPSAxLCBtYXhyID0gcm93c3BhbiAtIDE7IG5yIDw9IG1heHI7IG5yKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFJvd0F0KHRoaXMuaWR4LnJvdyArIG5yLCB0aGlzLmlkeC5jb2wsIGNvbHNwYW4sIGNUeXBlLCB0aGlzQ2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0NlbGwuZWwucmVtb3ZlQXR0cmlidXRlKCdyb3dzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdFJvd1RvQ2VsbHModGhpc0NlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBtZXJnZXMgY2VsbHMgZnJvbSBzdGFydCBjZWxsIChkZWZpbmVkIGluIGNyZWF0aW5nIG9iaikgdG8gXCJ0b1wiIGNlbGxcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uKHRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWN0aWZ5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5NZXJnZSh0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3NwYW4gPSB0aGlzLmlkeF9lbmQucm93IC0gdGhpcy5pZHhfc3RhcnQucm93ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNwYW4gPSB0aGlzLmlkeF9lbmQuY29sIC0gdGhpcy5pZHhfc3RhcnQuY29sICsgMTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSB0aGlzLmlkeF9zdGFydC5yb3csIG1heHIgPSB0aGlzLmlkeF9lbmQucm93OyByb3cgPD0gbWF4cjsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IHRoaXMuaWR4X3N0YXJ0LmNvbCwgbWF4YyA9IHRoaXMuaWR4X2VuZC5jb2w7IGNvbCA8PSBtYXhjOyBjb2wrKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyA9PSB0aGlzLmlkeF9zdGFydC5yb3cgJiYgY29sID09IHRoaXMuaWR4X3N0YXJ0LmNvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93c3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwW3Jvd11bY29sXS5lbC5zZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nLCByb3dzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sc3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwW3Jvd11bY29sXS5lbC5zZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nLCBjb2xzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZmVyIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoL15cXHMqPGJyXFwvPz5cXHMqJC8udGVzdCh0aGlzLm1hcFtyb3ddW2NvbF0uZWwuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbdGhpcy5pZHhfc3RhcnQucm93XVt0aGlzLmlkeF9zdGFydC5jb2xdLmVsLmlubmVySFRNTCArPSAnICcgKyB0aGlzLm1hcFtyb3ddW2NvbF0uZWwuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5tYXBbcm93XVtjb2xdLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWN0aWZ5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRG8gbm90IGtub3cgaG93IHRvIG1lcmdlIGFsbHJlYWR5IG1lcmdlZCBjZWxscy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZWNyZWFzZXMgcm93c3BhbiBvZiBhIGNlbGwgaWYgaXQgaXMgZG9uZSBvbiBmaXJzdCBjZWxsIG9mIHJvd3NwYW4gcm93IChyZWFsIGNlbGwpXG4gICAgICAgIC8vIENlbGwgaXMgbW92ZWQgdG8gbmV4dCByb3cgKGlmIGl0IGlzIHJlYWwpXG4gICAgICAgIGNvbGxhcHNlQ2VsbFRvTmV4dFJvdzogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgdmFyIGNlbGxJZHggPSB0aGlzLmdldE1hcEluZGV4KGNlbGwuZWwpLFxuICAgICAgICAgICAgICAgIG5ld1Jvd0lkeCA9IGNlbGxJZHgucm93ICsgMSxcbiAgICAgICAgICAgICAgICBuZXdJZHggPSB7J3Jvdyc6IG5ld1Jvd0lkeCwgJ2NvbCc6IGNlbGxJZHguY29sfTtcblxuICAgICAgICAgICAgaWYgKG5ld1Jvd0lkeCA8IHRoaXMubWFwLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0UmVhbFJvd0VsKGZhbHNlLCBuZXdJZHgpO1xuICAgICAgICAgICAgICAgIGlmIChyb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5fY2lkeCA9IHRoaXMuY29ycmVjdENvbEluZGV4Rm9yVW5yZWFscyhuZXdJZHguY29sLCBuZXdJZHgucm93KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5fY2lkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcih0aGlzLmdldFJvd0NlbGxzKHJvdylbbl9jaWR4XSwgY2VsbC5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENlbGwgPSB0aGlzLmdldExhc3ROZXdDZWxsT25Sb3cocm93LCBuZXdSb3dJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RDZWxsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIobGFzdENlbGwsIGNlbGwuZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuaW5zZXJ0QmVmb3JlKGNlbGwuZWwsIHJvdy5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZShjZWxsLmVsLCAncm93c3BhbicpLCAxMCkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmVsLnNldEF0dHJpYnV0ZSgncm93c3BhbicsIHBhcnNlSW50KGFwaS5nZXRBdHRyaWJ1dGUoY2VsbC5lbCwgJ3Jvd3NwYW4nKSwgMTApIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmVsLnJlbW92ZUF0dHJpYnV0ZSgncm93c3BhbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJlbW92ZXMgYSBjZWxsIHdoZW4gcmVtb3ZpbmcgYSByb3dcbiAgICAgICAgLy8gSWYgaXMgcm93c3BhbiBjZWxsIHRoZW4gZGVjcmVhc2VzIHRoZSByb3dzcGFuXG4gICAgICAgIC8vIGFuZCBtb3ZlcyBjZWxsIHRvIG5leHQgcm93IGlmIG5lZWRlZCAoaXMgZmlyc3QgY2VsbCBvZiByb3dzcGFuKVxuICAgICAgICByZW1vdmVSb3dDZWxsOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICBpZiAoY2VsbC5pc1JlYWwpIHtcbiAgICAgICAgICAgICAgIGlmIChjZWxsLmlzUm93c3Bhbikge1xuICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2VDZWxsVG9OZXh0Um93KGNlbGwpO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KGNlbGwuZWwpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZShjZWxsLmVsLCAncm93c3BhbicpLCAxMCkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZWwuc2V0QXR0cmlidXRlKCdyb3dzcGFuJywgcGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZShjZWxsLmVsLCAncm93c3BhbicpLCAxMCkgLSAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmVsLnJlbW92ZUF0dHJpYnV0ZSgncm93c3BhbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSb3dFbGVtZW50c0J5Q2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGFibGVNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaWR4ID0gdGhpcy5nZXRNYXBJbmRleCh0aGlzLmNlbGwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWR4ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBtb2RSb3cgPSB0aGlzLm1hcFt0aGlzLmlkeC5yb3ddO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNpZHggPSAwLCBjbWF4ID0gbW9kUm93Lmxlbmd0aDsgY2lkeCA8IGNtYXg7IGNpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kUm93W2NpZHhdLmlzUmVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHMucHVzaChtb2RSb3dbY2lkeF0uZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbHVtbkVsZW1lbnRzQnlDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZU1hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZHggPSB0aGlzLmdldE1hcEluZGV4KHRoaXMuY2VsbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcmlkeCA9IDAsIHJtYXggPSB0aGlzLm1hcC5sZW5ndGg7IHJpZHggPCBybWF4OyByaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFwW3JpZHhdW3RoaXMuaWR4LmNvbF0gJiYgdGhpcy5tYXBbcmlkeF1bdGhpcy5pZHguY29sXS5pc1JlYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5tYXBbcmlkeF1bdGhpcy5pZHguY29sXS5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2VsbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgcm93IG9mIHNlbGVjdGVkIGNlbGxcbiAgICAgICAgcmVtb3ZlUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvbGRSb3cgPSBhcGkuZ2V0UGFyZW50RWxlbWVudCh0aGlzLmNlbGwsIHsgbm9kZU5hbWU6IFtcIlRSXCJdIH0pO1xuICAgICAgICAgICAgaWYgKG9sZFJvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFibGVNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeCA9IHRoaXMuZ2V0TWFwSW5kZXgodGhpcy5jZWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RSb3cgPSB0aGlzLm1hcFt0aGlzLmlkeC5yb3ddO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjaWR4ID0gMCwgY21heCA9IG1vZFJvdy5sZW5ndGg7IGNpZHggPCBjbWF4OyBjaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kUm93W2NpZHhdLm1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDZWxsQXNNb2RpZmllZChtb2RSb3dbY2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUm93Q2VsbChtb2RSb3dbY2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQob2xkUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVDb2xDZWxsOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICBpZiAoY2VsbC5pc0NvbHNwYW4pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZShjZWxsLmVsLCAnY29sc3BhbicpLCAxMCkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZWwuc2V0QXR0cmlidXRlKCdjb2xzcGFuJywgcGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZShjZWxsLmVsLCAnY29sc3BhbicpLCAxMCkgLSAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmVsLnJlbW92ZUF0dHJpYnV0ZSgnY29sc3BhbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbC5pc1JlYWwpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KGNlbGwuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRhYmxlTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlkeCA9IHRoaXMuZ2V0TWFwSW5kZXgodGhpcy5jZWxsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkeCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByaWR4ID0gMCwgcm1heCA9IHRoaXMubWFwLmxlbmd0aDsgcmlkeCA8IHJtYXg7IHJpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFwW3JpZHhdW3RoaXMuaWR4LmNvbF0ubW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2VsbEFzTW9kaWZpZWQodGhpcy5tYXBbcmlkeF1bdGhpcy5pZHguY29sXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbENlbGwodGhpcy5tYXBbcmlkeF1bdGhpcy5pZHguY29sXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVtb3ZlcyByb3cgb3IgY29sdW1uIGJ5IHNlbGVjdGVkIGNlbGwgZWxlbWVudFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKHdoYXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY3RpZnkoKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAod2hhdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyb3cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVSb3coKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbHVtbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbHVtbigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWN0aWZ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkUm93OiBmdW5jdGlvbih3aGVyZSkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMudGFibGUub3duZXJEb2N1bWVudDtcblxuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZU1hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZHggPSB0aGlzLmdldE1hcEluZGV4KHRoaXMuY2VsbCk7XG4gICAgICAgICAgICBpZiAod2hlcmUgPT0gXCJiZWxvd1wiICYmIGFwaS5nZXRBdHRyaWJ1dGUodGhpcy5jZWxsLCAncm93c3BhbicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHgucm93ID0gdGhpcy5pZHgucm93ICsgcGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZSh0aGlzLmNlbGwsICdyb3dzcGFuJyksIDEwKSAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkeCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kUm93ID0gdGhpcy5tYXBbdGhpcy5pZHgucm93XSxcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByaWR4ID0gMCwgcm1heCA9IG1vZFJvdy5sZW5ndGg7IHJpZHggPCBybWF4OyByaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RSb3dbcmlkeF0ubW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2VsbEFzTW9kaWZpZWQobW9kUm93W3JpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUm93Q2VsbChtb2RSb3dbcmlkeF0sIG5ld1Jvdywgd2hlcmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh3aGVyZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcih0aGlzLmdldFJlYWxSb3dFbCh0cnVlKSwgbmV3Um93KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Fib3ZlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjciA9IGFwaS5nZXRQYXJlbnRFbGVtZW50KHRoaXMubWFwW3RoaXMuaWR4LnJvd11bdGhpcy5pZHguY29sXS5lbCwgeyBub2RlTmFtZTogW1wiVFJcIl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdSb3csIGNyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFJvd0NlbGw6IGZ1bmN0aW9uKGNlbGwsIHJvdywgd2hlcmUpIHtcbiAgICAgICAgICAgIHZhciBjb2xTcGFuQXR0ciA9IChjZWxsLmlzQ29sc3BhbikgPyB7XCJjb2xzcGFuXCIgOiBhcGkuZ2V0QXR0cmlidXRlKGNlbGwuZWwsICdjb2xzcGFuJyl9IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChjZWxsLmlzUmVhbCkge1xuICAgICAgICAgICAgICAgIGlmICh3aGVyZSAhPSAnYWJvdmUnICYmIGNlbGwuaXNSb3dzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZWwuc2V0QXR0cmlidXRlKCdyb3dzcGFuJywgcGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZShjZWxsLmVsLCdyb3dzcGFuJyksIDEwKSArIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUNlbGxzKCd0ZCcsIDEsIGNvbFNwYW5BdHRyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAod2hlcmUgIT0gJ2Fib3ZlJyAmJiBjZWxsLmlzUm93c3BhbiAmJiBjZWxsLmxhc3RSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlQ2VsbHMoJ3RkJywgMSwgY29sU3BhbkF0dHIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMuaXNSb3dzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZWwuYXR0cigncm93c3BhbicsIHBhcnNlSW50KGFwaS5nZXRBdHRyaWJ1dGUoY2VsbC5lbCwgJ3Jvd3NwYW4nKSwgMTApICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24od2hlcmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY3RpZnkoKSkge1xuICAgICAgICAgICAgICAgIGlmICh3aGVyZSA9PSAnYmVsb3cnIHx8IHdoZXJlID09ICdhYm92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSb3cod2hlcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2hlcmUgPT0gJ2JlZm9yZScgfHwgd2hlcmUgPT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbHVtbih3aGVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZENvbENlbGw6IGZ1bmN0aW9uIChjZWxsLCByaWR4LCB3aGVyZSkge1xuICAgICAgICAgICAgdmFyIGRvQWRkLFxuICAgICAgICAgICAgICAgIGNUeXBlID0gY2VsbC5lbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIGRlZmluZXMgYWRkIGNlbGwgdnMgZXhwYW5kIGNlbGwgY29uZGl0aW9uc1xuICAgICAgICAgICAgLy8gdHJ1ZSBtZWFucyBhZGRcbiAgICAgICAgICAgIHN3aXRjaCAod2hlcmUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmVmb3JlXCI6XG4gICAgICAgICAgICAgICAgICAgIGRvQWRkID0gKCFjZWxsLmlzQ29sc3BhbiB8fCBjZWxsLmZpcnN0Q29sKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWZ0ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgZG9BZGQgPSAoIWNlbGwuaXNDb2xzcGFuIHx8IGNlbGwubGFzdENvbCB8fCAoY2VsbC5pc0NvbHNwYW4gJiYgYy5lbCA9PSB0aGlzLmNlbGwpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRvQWRkKXtcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGEgY2VsbCBiZWZvcmUgb3IgYWZ0ZXIgY3VycmVudCBjZWxsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdoZXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJiZWZvcmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jcmVhdGVDZWxscyhjVHlwZSwgMSksIGNlbGwuZWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFmdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcihjZWxsLmVsLCB0aGlzLmNyZWF0ZUNlbGxzKGNUeXBlLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZXMgaWYgY2VsbCBoYXMgcm93c3BhblxuICAgICAgICAgICAgICAgIGlmIChjZWxsLmlzUm93c3Bhbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNlbGxBZGRXaXRoUm93c3BhbihjZWxsLCByaWR4KzEsIHdoZXJlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwYW5kcyBjZWxsXG4gICAgICAgICAgICAgICAgY2VsbC5lbC5zZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nLCAgcGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZShjZWxsLmVsLCAnY29sc3BhbicpLCAxMCkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDb2x1bW46IGZ1bmN0aW9uKHdoZXJlKSB7XG4gICAgICAgICAgICB2YXIgcm93LCBtb2RDZWxsO1xuXG4gICAgICAgICAgICB0aGlzLnNldFRhYmxlTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlkeCA9IHRoaXMuZ2V0TWFwSW5kZXgodGhpcy5jZWxsKTtcbiAgICAgICAgICAgIGlmICh3aGVyZSA9PSBcImFmdGVyXCIgJiYgYXBpLmdldEF0dHJpYnV0ZSh0aGlzLmNlbGwsICdjb2xzcGFuJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5pZHguY29sID0gdGhpcy5pZHguY29sICsgcGFyc2VJbnQoYXBpLmdldEF0dHJpYnV0ZSh0aGlzLmNlbGwsICdjb2xzcGFuJyksIDEwKSAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkeCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByaWR4ID0gMCwgcm1heCA9IHRoaXMubWFwLmxlbmd0aDsgcmlkeCA8IHJtYXg7IHJpZHgrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gdGhpcy5tYXBbcmlkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dbdGhpcy5pZHguY29sXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kQ2VsbCA9IHJvd1t0aGlzLmlkeC5jb2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RDZWxsLm1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDZWxsQXNNb2RpZmllZChtb2RDZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbENlbGwobW9kQ2VsbCwgcmlkeCAsIHdoZXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVDZWxsQWRkV2l0aFJvd3NwYW46IGZ1bmN0aW9uIChjZWxsLCByaWR4LCB3aGVyZSkge1xuICAgICAgICAgICAgdmFyIGFkZFJvd3NOciA9IHBhcnNlSW50KGFwaS5nZXRBdHRyaWJ1dGUodGhpcy5jZWxsLCAncm93c3BhbicpLCAxMCkgLSAxLFxuICAgICAgICAgICAgICAgIGNyb3cgPSBhcGkuZ2V0UGFyZW50RWxlbWVudChjZWxsLmVsLCB7IG5vZGVOYW1lOiBbXCJUUlwiXSB9KSxcbiAgICAgICAgICAgICAgICBjVHlwZSA9IGNlbGwuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGNpZHgsIHRlbXBfcl9jZWxscyxcbiAgICAgICAgICAgICAgICBkb2MgPSB0aGlzLnRhYmxlLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgbnJvdztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRSb3dzTnI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNpZHggPSB0aGlzLmNvcnJlY3RDb2xJbmRleEZvclVucmVhbHModGhpcy5pZHguY29sLCAocmlkeCArIGkpKTtcbiAgICAgICAgICAgICAgICBjcm93ID0gbmV4dE5vZGUoY3JvdywgJ3RyJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHdoZXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJlZm9yZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wX3JfY2VsbHMgPSB0aGlzLmdldFJvd0NlbGxzKGNyb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2lkeCA+IDAgJiYgdGhpcy5tYXBbcmlkeCArIGldW3RoaXMuaWR4LmNvbF0uZWwgIT0gdGVtcF9yX2NlbGxzW2NpZHhdICYmIGNpZHggPT0gdGVtcF9yX2NlbGxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZnRlcih0ZW1wX3JfY2VsbHNbY2lkeF0sIHRoaXMuY3JlYXRlQ2VsbHMoY1R5cGUsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBfcl9jZWxsc1tjaWR4XS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmNyZWF0ZUNlbGxzKGNUeXBlLCAxKSwgdGVtcF9yX2NlbGxzW2NpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFmdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFmdGVyKHRoaXMuZ2V0Um93Q2VsbHMoY3JvdylbY2lkeF0sIHRoaXMuY3JlYXRlQ2VsbHMoY1R5cGUsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3cuaW5zZXJ0QmVmb3JlKHRoaXMuY3JlYXRlQ2VsbHMoY1R5cGUsIDEpLCBjcm93LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbnJvdyA9IGRvYy5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgICAgICBucm93LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlQ2VsbHMoY1R5cGUsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChucm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXBpLnRhYmxlID0ge1xuICAgICAgICBnZXRDZWxsc0JldHdlZW46IGZ1bmN0aW9uKGNlbGwxLCBjZWxsMikge1xuICAgICAgICAgICAgdmFyIGMxID0gbmV3IFRhYmxlTW9kaWZ5ZXJCeUNlbGwoY2VsbDEpO1xuICAgICAgICAgICAgcmV0dXJuIGMxLmdldE1hcEVsc1RvKGNlbGwyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDZWxsczogZnVuY3Rpb24oY2VsbCwgd2hlcmUpIHtcbiAgICAgICAgICAgIHZhciBjID0gbmV3IFRhYmxlTW9kaWZ5ZXJCeUNlbGwoY2VsbCk7XG4gICAgICAgICAgICBjLmFkZCh3aGVyZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2VsbHM6IGZ1bmN0aW9uKGNlbGwsIHdoYXQpIHtcbiAgICAgICAgICAgIHZhciBjID0gbmV3IFRhYmxlTW9kaWZ5ZXJCeUNlbGwoY2VsbCk7XG4gICAgICAgICAgICBjLnJlbW92ZSh3aGF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZUNlbGxzQmV0d2VlbjogZnVuY3Rpb24oY2VsbDEsIGNlbGwyKSB7XG4gICAgICAgICAgICB2YXIgYzEgPSBuZXcgVGFibGVNb2RpZnllckJ5Q2VsbChjZWxsMSk7XG4gICAgICAgICAgICBjMS5tZXJnZShjZWxsMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5tZXJnZUNlbGw6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHZhciBjID0gbmV3IFRhYmxlTW9kaWZ5ZXJCeUNlbGwoY2VsbCk7XG4gICAgICAgICAgICBjLnVubWVyZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcmRlclNlbGVjdGlvbkVuZHM6IGZ1bmN0aW9uKGNlbGwsIGNlbGwyKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBUYWJsZU1vZGlmeWVyQnlDZWxsKGNlbGwpO1xuICAgICAgICAgICAgcmV0dXJuIGMub3JkZXJTZWxlY3Rpb25FbmRzKGNlbGwyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmRleE9mOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBUYWJsZU1vZGlmeWVyQnlDZWxsKGNlbGwpO1xuICAgICAgICAgICAgYy5zZXRUYWJsZU1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGMuZ2V0TWFwSW5kZXgoY2VsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluZENlbGw6IGZ1bmN0aW9uKHRhYmxlLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBjID0gbmV3IFRhYmxlTW9kaWZ5ZXJCeUNlbGwobnVsbCwgdGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIGMuZ2V0RWxlbWVudEF0SW5kZXgoaWR4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5kUm93QnlDZWxsOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBUYWJsZU1vZGlmeWVyQnlDZWxsKGNlbGwpO1xuICAgICAgICAgICAgcmV0dXJuIGMuZ2V0Um93RWxlbWVudHNCeUNlbGwoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5kQ29sdW1uQnlDZWxsOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBUYWJsZU1vZGlmeWVyQnlDZWxsKGNlbGwpO1xuICAgICAgICAgICAgcmV0dXJuIGMuZ2V0Q29sdW1uRWxlbWVudHNCeUNlbGwoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5NZXJnZTogZnVuY3Rpb24oY2VsbDEsIGNlbGwyKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBUYWJsZU1vZGlmeWVyQnlDZWxsKGNlbGwxKTtcbiAgICAgICAgICAgIHJldHVybiBjLmNhbk1lcmdlKGNlbGwyKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG59KSh3eXNpaHRtbDUpO1xuOy8vIGRvZXMgYSBzZWxlY3RvciBxdWVyeSBvbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzXG5cbnd5c2lodG1sNS5kb20ucXVlcnkgPSBmdW5jdGlvbihlbGVtZW50cywgcXVlcnkpIHtcbiAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgIHE7XG5cbiAgICBpZiAoZWxlbWVudHMubm9kZVR5cGUpIHtcbiAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGUgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGUgPCBsZW47IGUrKykge1xuICAgICAgICBxID0gZWxlbWVudHNbZV0ucXVlcnlTZWxlY3RvckFsbChxdWVyeSk7XG4gICAgICAgIGlmIChxKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSBxLmxlbmd0aDsgaS0tOyByZXQudW5zaGlmdChxW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG47d3lzaWh0bWw1LmRvbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKGRvY3VtZW50RWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbihjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjb250YWluZXIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGNvbnRhaW5lciwgZWxlbWVudCApIHtcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RtcHZhci9qc2RvbS9ibG9iLzY4MWE4NTI0YjY2MzI4MWEwZjU4MzQ4YzYxMjljOGMxODRlZmM2MmMvbGliL2pzZG9tL2xldmVsMy9jb3JlLmpzIC8vIE1JVCBsaWNlbnNlXG4gICAgICB2YXIgdGhpc093bmVyLCBvdGhlck93bmVyO1xuXG4gICAgICBpZiggY29udGFpbmVyLm5vZGVUeXBlID09PSA5KSAvLyBOb2RlLkRPQ1VNRU5UX05PREVcbiAgICAgICAgdGhpc093bmVyID0gY29udGFpbmVyO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzT3duZXIgPSBjb250YWluZXIub3duZXJEb2N1bWVudDtcblxuICAgICAgaWYoIGVsZW1lbnQubm9kZVR5cGUgPT09IDkpIC8vIE5vZGUuRE9DVU1FTlRfTk9ERVxuICAgICAgICBvdGhlck93bmVyID0gZWxlbWVudDtcbiAgICAgIGVsc2VcbiAgICAgICAgb3RoZXJPd25lciA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcblxuICAgICAgaWYoIGNvbnRhaW5lciA9PT0gZWxlbWVudCApIHJldHVybiAwO1xuICAgICAgaWYoIGNvbnRhaW5lciA9PT0gZWxlbWVudC5vd25lckRvY3VtZW50ICkgcmV0dXJuIDQgKyAxNjsgLy9Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyArIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZO1xuICAgICAgaWYoIGNvbnRhaW5lci5vd25lckRvY3VtZW50ID09PSBlbGVtZW50ICkgcmV0dXJuIDIgKyA4OyAgLy9Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyArIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlM7XG4gICAgICBpZiggdGhpc093bmVyICE9PSBvdGhlck93bmVyICkgcmV0dXJuIDE7IC8vIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEO1xuXG4gICAgICAvLyBUZXh0IG5vZGVzIGZvciBhdHRyaWJ1dGVzIGRvZXMgbm90IGhhdmUgYSBfcGFyZW50Tm9kZS4gU28gd2UgbmVlZCB0byBmaW5kIHRoZW0gYXMgYXR0cmlidXRlIGNoaWxkLlxuICAgICAgaWYoIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLyAmJiBjb250YWluZXIuY2hpbGROb2RlcyAmJiB3eXNpaHRtbDUubGFuZy5hcnJheShjb250YWluZXIuY2hpbGROb2RlcykuaW5kZXhPZiggZWxlbWVudCApICE9PSAtMSlcbiAgICAgICAgcmV0dXJuIDQgKyAxNjsgLy9Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyArIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZO1xuXG4gICAgICBpZiggZWxlbWVudC5ub2RlVHlwZSA9PT0gMiAvKk5vZGUuQVRUUklCVVRFX05PREUqLyAmJiBlbGVtZW50LmNoaWxkTm9kZXMgJiYgd3lzaWh0bWw1LmxhbmcuYXJyYXkoZWxlbWVudC5jaGlsZE5vZGVzKS5pbmRleE9mKCBjb250YWluZXIgKSAhPT0gLTEpXG4gICAgICAgIHJldHVybiAyICsgODsgLy9Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyArIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlM7XG5cbiAgICAgIHZhciBwb2ludCA9IGNvbnRhaW5lcjtcbiAgICAgIHZhciBwYXJlbnRzID0gWyBdO1xuICAgICAgdmFyIHByZXZpb3VzID0gbnVsbDtcbiAgICAgIHdoaWxlKCBwb2ludCApIHtcbiAgICAgICAgaWYoIHBvaW50ID09IGVsZW1lbnQgKSByZXR1cm4gMiArIDg7IC8vTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgKyBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TO1xuICAgICAgICBwYXJlbnRzLnB1c2goIHBvaW50ICk7XG4gICAgICAgIHBvaW50ID0gcG9pbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHBvaW50ID0gZWxlbWVudDtcbiAgICAgIHByZXZpb3VzID0gbnVsbDtcbiAgICAgIHdoaWxlKCBwb2ludCApIHtcbiAgICAgICAgaWYoIHBvaW50ID09IGNvbnRhaW5lciApIHJldHVybiA0ICsgMTY7IC8vTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgKyBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWTtcbiAgICAgICAgdmFyIGxvY2F0aW9uX2luZGV4ID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkocGFyZW50cykuaW5kZXhPZiggcG9pbnQgKTtcbiAgICAgICAgaWYoIGxvY2F0aW9uX2luZGV4ICE9PSAtMSkge1xuICAgICAgICAgdmFyIHNtYWxsZXN0X2NvbW1vbl9hbmNlc3RvciA9IHBhcmVudHNbIGxvY2F0aW9uX2luZGV4IF07XG4gICAgICAgICB2YXIgdGhpc19pbmRleCA9IHd5c2lodG1sNS5sYW5nLmFycmF5KHNtYWxsZXN0X2NvbW1vbl9hbmNlc3Rvci5jaGlsZE5vZGVzKS5pbmRleE9mKCBwYXJlbnRzW2xvY2F0aW9uX2luZGV4IC0gMV0pOy8vc21hbGxlc3RfY29tbW9uX2FuY2VzdG9yLmNoaWxkTm9kZXMudG9BcnJheSgpLmluZGV4T2YoIHBhcmVudHNbbG9jYXRpb25faW5kZXggLSAxXSApO1xuICAgICAgICAgdmFyIG90aGVyX2luZGV4ID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoc21hbGxlc3RfY29tbW9uX2FuY2VzdG9yLmNoaWxkTm9kZXMpLmluZGV4T2YoIHByZXZpb3VzICk7IC8vc21hbGxlc3RfY29tbW9uX2FuY2VzdG9yLmNoaWxkTm9kZXMudG9BcnJheSgpLmluZGV4T2YoIHByZXZpb3VzICk7XG4gICAgICAgICBpZiggdGhpc19pbmRleCA+IG90aGVyX2luZGV4ICkge1xuICAgICAgICAgICAgICAgcmV0dXJuIDI7IC8vTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkc7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIDQ7IC8vTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBwb2ludDtcbiAgICAgICAgcG9pbnQgPSBwb2ludC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDE7IC8vTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQ7XG4gICAgfTtcbiAgfVxufSkoKTtcbjt3eXNpaHRtbDUuZG9tLnVud3JhcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgd3lzaWh0bWw1LmRvbS5pbnNlcnQobm9kZS5sYXN0Q2hpbGQpLmFmdGVyKG5vZGUpO1xuICAgIH1cbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH1cbn07Oy8qIFxuICogTWV0aG9kcyBmb3IgZmV0Y2hpbmcgcGFzdGVkIGh0bWwgYmVmb3JlIGl0IGdldHMgaW5zZXJ0ZWQgaW50byBjb250ZW50XG4qKi9cblxuLyogTW9kZXJuIGV2ZW50LmNsaXBib2FyZERhdGEgZHJpdmVuIGFwcHJvYWNoLlxuICogQWR2YW50YWdlIGlzIHRoYXQgaXQgZG9lcyBub3QgaGF2ZSB0byBsb29zZSBzZWxlY3Rpb24gb3IgbW9kaWZ5IGRvbSB0byBjYXRjaCB0aGUgZGF0YS4gXG4gKiBJRSBkb2VzIG5vdCBzdXBwb3J0IHRob3VnaC5cbioqL1xud3lzaWh0bWw1LmRvbS5nZXRQYXN0ZWRIdG1sID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGh0bWw7XG4gIGlmIChldmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgaWYgKHd5c2lodG1sNS5sYW5nLmFycmF5KGV2ZW50LmNsaXBib2FyZERhdGEudHlwZXMpLmNvbnRhaW5zKCd0ZXh0L2h0bWwnKSkge1xuICAgICAgaHRtbCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgfSBlbHNlIGlmICh3eXNpaHRtbDUubGFuZy5hcnJheShldmVudC5jbGlwYm9hcmREYXRhLnR5cGVzKS5jb250YWlucygndGV4dC9wbGFpbicpKSB7XG4gICAgICBodG1sID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpKS5lc2NhcGVIVE1MKHRydWUsIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbDtcbn07XG5cbi8qIE9sZGVyIHRlbXByb3JhcnkgY29udGVudGVkaXRhYmxlIGFzIHBhc3RlIHNvdXJjZSBjYXRjaGVyIG1ldGhvZCBmb3IgZmFsbGJhY2tzICovXG53eXNpaHRtbDUuZG9tLmdldFBhc3RlZEh0bWxXaXRoRGl2ID0gZnVuY3Rpb24gKGNvbXBvc2VyLCBmKSB7XG4gIHZhciBzZWxCb29rbWFyayA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpLFxuICAgICAgZG9jID0gY29tcG9zZXIuZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgY2xlYW5lckRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgXG4gIGRvYy5ib2R5LmFwcGVuZENoaWxkKGNsZWFuZXJEaXYpO1xuXG4gIGNsZWFuZXJEaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuICBjbGVhbmVyRGl2LnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG4gIGNsZWFuZXJEaXYuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXG4gIGNsZWFuZXJEaXYuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICBjbGVhbmVyRGl2LmZvY3VzKCk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEJvb2ttYXJrKHNlbEJvb2ttYXJrKTtcbiAgICBmKGNsZWFuZXJEaXYuaW5uZXJIVE1MKTtcbiAgICBjbGVhbmVyRGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xlYW5lckRpdik7XG4gIH0sIDApO1xufTs7LyoqXG4gKiBGaXggbW9zdCBjb21tb24gaHRtbCBmb3JtYXR0aW5nIG1pc2JlaGF2aW9ycyBvZiBicm93c2VycyBpbXBsZW1lbnRhdGlvbiB3aGVuIGluc2VydGluZ1xuICogY29udGVudCB2aWEgY29weSAmIHBhc3RlIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIEBhdXRob3IgQ2hyaXN0b3BoZXIgQmx1bVxuICovXG53eXNpaHRtbDUucXVpcmtzLmNsZWFuUGFzdGVkSFRNTCA9IChmdW5jdGlvbigpIHtcblxuICB2YXIgc3R5bGVUb1JlZ2V4ID0gZnVuY3Rpb24gKHN0eWxlU3RyKSB7XG4gICAgdmFyIHRyaW1tZWRTdHIgPSB3eXNpaHRtbDUubGFuZy5zdHJpbmcoc3R5bGVTdHIpLnRyaW0oKSxcbiAgICAgICAgZXNjYXBlZFN0ciA9IHRyaW1tZWRTdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpO1xuXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKCg/IV5cIiArIGVzY2FwZWRTdHIgKyBcIiQpLikqJFwiLCBcImlcIik7XG4gIH07XG5cbiAgdmFyIGV4dGVuZFJ1bGVzV2l0aFN0eWxlRXhjZXB0aW9ucyA9IGZ1bmN0aW9uIChydWxlcywgZXhjZXB0U3R5bGVzKSB7XG4gICAgdmFyIG5ld1J1bGVzID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHJ1bGVzKS5jbG9uZSh0cnVlKSxcbiAgICAgICAgdGFnLCBzdHlsZTtcblxuICAgIGZvciAodGFnIGluIG5ld1J1bGVzLnRhZ3MpIHtcblxuICAgICAgaWYgKG5ld1J1bGVzLnRhZ3MuaGFzT3duUHJvcGVydHkodGFnKSkge1xuICAgICAgICBpZiAobmV3UnVsZXMudGFnc1t0YWddLmtlZXBfc3R5bGVzKSB7XG4gICAgICAgICAgZm9yIChzdHlsZSBpbiBuZXdSdWxlcy50YWdzW3RhZ10ua2VlcF9zdHlsZXMpIHtcbiAgICAgICAgICAgIGlmIChuZXdSdWxlcy50YWdzW3RhZ10ua2VlcF9zdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgIGlmIChleGNlcHRTdHlsZXNbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgbmV3UnVsZXMudGFnc1t0YWddLmtlZXBfc3R5bGVzW3N0eWxlXSA9IHN0eWxlVG9SZWdleChleGNlcHRTdHlsZXNbc3R5bGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdSdWxlcztcbiAgfTtcblxuICB2YXIgcGlja1J1bGVzZXQgPSBmdW5jdGlvbihydWxlc2V0LCBodG1sKSB7XG4gICAgdmFyIHBpY2tlZFNldCwgZGVmYXVsdFNldDtcblxuICAgIGlmICghcnVsZXNldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHJ1bGVzZXQubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGlmICghcnVsZXNldFtpXS5jb25kaXRpb24pIHtcbiAgICAgICAgZGVmYXVsdFNldCA9IHJ1bGVzZXRbaV0uc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHJ1bGVzZXRbaV0uY29uZGl0aW9uICYmIHJ1bGVzZXRbaV0uY29uZGl0aW9uLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgcmV0dXJuIHJ1bGVzZXRbaV0uc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0U2V0O1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XG4gICAgdmFyIGV4Y2VwdFN0eWxlcyA9IHtcbiAgICAgICAgICAnY29sb3InOiB3eXNpaHRtbDUuZG9tLmdldFN0eWxlKFwiY29sb3JcIikuZnJvbShvcHRpb25zLnJlZmVyZW5jZU5vZGUpLFxuICAgICAgICAgICdmb250U2l6ZSc6IHd5c2lodG1sNS5kb20uZ2V0U3R5bGUoXCJmb250LXNpemVcIikuZnJvbShvcHRpb25zLnJlZmVyZW5jZU5vZGUpXG4gICAgICAgIH0sXG4gICAgICAgIHJ1bGVzID0gZXh0ZW5kUnVsZXNXaXRoU3R5bGVFeGNlcHRpb25zKHBpY2tSdWxlc2V0KG9wdGlvbnMucnVsZXMsIGh0bWwpIHx8IHt9LCBleGNlcHRTdHlsZXMpLFxuICAgICAgICBuZXdIdG1sO1xuXG4gICAgbmV3SHRtbCA9IHd5c2lodG1sNS5kb20ucGFyc2UoaHRtbCwge1xuICAgICAgXCJydWxlc1wiOiBydWxlcyxcbiAgICAgIFwiY2xlYW5VcFwiOiB0cnVlLCAvLyA8c3Bhbj4gZWxlbWVudHMsIGVtcHR5IG9yIHdpdGhvdXQgYXR0cmlidXRlcywgc2hvdWxkIGJlIHJlbW92ZWQvcmVwbGFjZWQgd2l0aCB0aGVpciBjb250ZW50XG4gICAgICBcImNvbnRleHRcIjogb3B0aW9ucy5yZWZlcmVuY2VOb2RlLm93bmVyRG9jdW1lbnQsXG4gICAgICBcInVuZWRpdGFibGVDbGFzc1wiOiBvcHRpb25zLnVuZWRpdGFibGVDbGFzcyxcbiAgICAgIFwiY2xlYXJJbnRlcm5hbHNcIiA6IHRydWUsIC8vIGRvbid0IHBhc3RlIHRlbXByb3Jhcnkgc2VsZWN0aW9uIGFuZCBvdGhlciBtYXJraW5nc1xuICAgICAgXCJ1bmpvaW5OYnNwc1wiIDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ld0h0bWw7XG4gIH07XG5cbn0pKCk7Oy8qKlxuICogSUUgYW5kIE9wZXJhIGxlYXZlIGFuIGVtcHR5IHBhcmFncmFwaCBpbiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgYWZ0ZXIgY2xlYXJpbmcgaXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGVudEVkaXRhYmxlRWxlbWVudCBUaGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgdG8gb2JzZXJ2ZSBmb3IgY2xlYXJpbmcgZXZlbnRzXG4gKiBAZXhhcGxlXG4gKiAgICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nKG15Q29udGVudEVkaXRhYmxlRWxlbWVudCk7XG4gKi9cbnd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBjbGVhcklmTmVjZXNzYXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChpbm5lckhUTUwgPT0gXCI8cD4mbmJzcDs8L3A+XCIgfHxcbiAgICAgICAgICBpbm5lckhUTUwgPT0gXCI8cD4mbmJzcDs8L3A+PHA+Jm5ic3A7PC9wPlwiKSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24oY29tcG9zZXIpIHtcbiAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoY29tcG9zZXIuZWxlbWVudCwgW1wiY3V0XCIsIFwia2V5ZG93blwiXSwgY2xlYXJJZk5lY2Vzc2FyeSk7XG4gIH07XG59KSgpO1xuOy8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NjQzOThcbi8vXG4vLyBJbiBGaXJlZm94IHRoaXM6XG4vLyAgICAgIHZhciBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbi8vICAgICAgZC5pbm5lckhUTUwgPSc8YSBocmVmPVwiflwiPjwvYT4nO1xuLy8gICAgICBkLmlubmVySFRNTDtcbi8vIHdpbGwgcmVzdWx0IGluOlxuLy8gICAgICA8YSBocmVmPVwiJTdFXCI+PC9hPlxuLy8gd2hpY2ggaXMgd3JvbmdcbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIFRJTERFX0VTQ0FQRUQgPSBcIiU3RVwiO1xuICB3eXNpaHRtbDUucXVpcmtzLmdldENvcnJlY3RJbm5lckhUTUwgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwuaW5kZXhPZihUSUxERV9FU0NBUEVEKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBpbm5lckhUTUw7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzV2l0aFRpbGRlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2hyZWYqPSd+J10sIFtzcmMqPSd+J11cIiksXG4gICAgICAgIHVybCxcbiAgICAgICAgdXJsVG9TZWFyY2gsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgaTtcbiAgICBmb3IgKGk9MCwgbGVuZ3RoPWVsZW1lbnRzV2l0aFRpbGRlLmxlbmd0aDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgdXJsICAgICAgICAgPSBlbGVtZW50c1dpdGhUaWxkZVtpXS5ocmVmIHx8IGVsZW1lbnRzV2l0aFRpbGRlW2ldLnNyYztcbiAgICAgIHVybFRvU2VhcmNoID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKHVybCkucmVwbGFjZShcIn5cIikuYnkoVElMREVfRVNDQVBFRCk7XG4gICAgICBpbm5lckhUTUwgICA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyhpbm5lckhUTUwpLnJlcGxhY2UodXJsVG9TZWFyY2gpLmJ5KHVybCk7XG4gICAgfVxuICAgIHJldHVybiBpbm5lckhUTUw7XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOy8qKlxuICogRm9yY2UgcmVyZW5kZXJpbmcgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBOZWVkZWQgdG8gZml4IGRpc3BsYXkgbWlzYmVoYXZpb3JzIG9mIElFXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IG9iamVjdCB3aGljaCBuZWVkcyB0byBiZSByZXJlbmRlcmVkXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoZG9jdW1lbnQuYm9keSk7XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUUgPSBcInd5c2lodG1sNS1xdWlya3MtcmVkcmF3XCI7XG5cbiAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgd3lzaWh0bWw1LmRvbS5hZGRDbGFzcyhlbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICB3eXNpaHRtbDUuZG9tLnJlbW92ZUNsYXNzKGVsZW1lbnQsIENMQVNTX05BTUUpO1xuXG4gICAgLy8gRm9sbG93aW5nIGhhY2sgaXMgbmVlZGVkIGZvciBmaXJlZm94IHRvIG1ha2Ugc3VyZSB0aGF0IGltYWdlIHJlc2l6ZSBoYW5kbGVzIGFyZSBwcm9wZXJseSByZW1vdmVkXG4gICAgdHJ5IHtcbiAgICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBkb2MuZXhlY0NvbW1hbmQoXCJpdGFsaWNcIiwgZmFsc2UsIG51bGwpO1xuICAgICAgZG9jLmV4ZWNDb21tYW5kKFwiaXRhbGljXCIsIGZhbHNlLCBudWxsKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuO3d5c2lodG1sNS5xdWlya3MudGFibGVDZWxsc1NlbGVjdGlvbiA9IGZ1bmN0aW9uKGVkaXRhYmxlLCBlZGl0b3IpIHtcblxuICAgIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgICBzZWxlY3QgPSB7XG4gICAgICAgICAgICB0YWJsZTogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgY2VsbHM6IG51bGwsXG4gICAgICAgICAgICBzZWxlY3Q6IHNlbGVjdENlbGxzXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvbl9jbGFzcyA9IFwid3lzaXd5Zy10bXAtc2VsZWN0ZWQtY2VsbFwiLFxuICAgICAgICBtb3ZlSGFuZGxlciA9IG51bGwsXG4gICAgICAgIHVwSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpbml0ICgpIHtcblxuICAgICAgICBkb20ub2JzZXJ2ZShlZGl0YWJsZSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KGV2ZW50LnRhcmdldCwgeyBub2RlTmFtZTogW1wiVERcIiwgXCJUSFwiXSB9KTtcbiAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGhhbmRsZVNlbGVjdGlvbk1vdXNlZG93bih0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTZWxlY3Rpb25Nb3VzZWRvd24gKHRhcmdldCkge1xuICAgICAgc2VsZWN0LnN0YXJ0ID0gdGFyZ2V0O1xuICAgICAgc2VsZWN0LmVuZCA9IHRhcmdldDtcbiAgICAgIHNlbGVjdC5jZWxscyA9IFt0YXJnZXRdO1xuICAgICAgc2VsZWN0LnRhYmxlID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0LnN0YXJ0LCB7IG5vZGVOYW1lOiBbXCJUQUJMRVwiXSB9KTtcblxuICAgICAgaWYgKHNlbGVjdC50YWJsZSkge1xuICAgICAgICByZW1vdmVDZWxsU2VsZWN0aW9ucygpO1xuICAgICAgICBkb20uYWRkQ2xhc3ModGFyZ2V0LCBzZWxlY3Rpb25fY2xhc3MpO1xuICAgICAgICBtb3ZlSGFuZGxlciA9IGRvbS5vYnNlcnZlKGVkaXRhYmxlLCBcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICB1cEhhbmRsZXIgPSBkb20ub2JzZXJ2ZShlZGl0YWJsZSwgXCJtb3VzZXVwXCIsIGhhbmRsZU1vdXNlVXApO1xuICAgICAgICBlZGl0b3IuZmlyZShcInRhYmxlc2VsZWN0c3RhcnRcIikuZmlyZShcInRhYmxlc2VsZWN0c3RhcnQ6Y29tcG9zZXJcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBzZWxlY3Rpb24gY2xhc3Nlc1xuICAgIGZ1bmN0aW9uIHJlbW92ZUNlbGxTZWxlY3Rpb25zICgpIHtcbiAgICAgICAgaWYgKGVkaXRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRDZWxscyA9IGVkaXRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgc2VsZWN0aW9uX2NsYXNzKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZENlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Moc2VsZWN0ZWRDZWxsc1tpXSwgc2VsZWN0aW9uX2NsYXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU2VsZWN0aW9ucyAoY2VsbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKGNlbGxzW2ldLCBzZWxlY3Rpb25fY2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSAoZXZlbnQpIHtcbiAgICAgIHZhciBjdXJUYWJsZSA9IG51bGwsXG4gICAgICAgICAgY2VsbCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGV2ZW50LnRhcmdldCwgeyBub2RlTmFtZTogW1wiVERcIixcIlRIXCJdIH0pLFxuICAgICAgICAgIG9sZEVuZDtcblxuICAgICAgaWYgKGNlbGwgJiYgc2VsZWN0LnRhYmxlICYmIHNlbGVjdC5zdGFydCkge1xuICAgICAgICBjdXJUYWJsZSA9ICBkb20uZ2V0UGFyZW50RWxlbWVudChjZWxsLCB7IG5vZGVOYW1lOiBbXCJUQUJMRVwiXSB9KTtcbiAgICAgICAgaWYgKGN1clRhYmxlICYmIGN1clRhYmxlID09PSBzZWxlY3QudGFibGUpIHtcbiAgICAgICAgICByZW1vdmVDZWxsU2VsZWN0aW9ucygpO1xuICAgICAgICAgIG9sZEVuZCA9IHNlbGVjdC5lbmQ7XG4gICAgICAgICAgc2VsZWN0LmVuZCA9IGNlbGw7XG4gICAgICAgICAgc2VsZWN0LmNlbGxzID0gZG9tLnRhYmxlLmdldENlbGxzQmV0d2VlbihzZWxlY3Quc3RhcnQsIGNlbGwpO1xuICAgICAgICAgIGlmIChzZWxlY3QuY2VsbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZWRpdG9yLmNvbXBvc2VyLnNlbGVjdGlvbi5kZXNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRTZWxlY3Rpb25zKHNlbGVjdC5jZWxscyk7XG4gICAgICAgICAgaWYgKHNlbGVjdC5lbmQgIT09IG9sZEVuZCkge1xuICAgICAgICAgICAgZWRpdG9yLmZpcmUoXCJ0YWJsZXNlbGVjdGNoYW5nZVwiKS5maXJlKFwidGFibGVzZWxlY3RjaGFuZ2U6Y29tcG9zZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VVcCAoZXZlbnQpIHtcbiAgICAgIG1vdmVIYW5kbGVyLnN0b3AoKTtcbiAgICAgIHVwSGFuZGxlci5zdG9wKCk7XG4gICAgICBlZGl0b3IuZmlyZShcInRhYmxlc2VsZWN0XCIpLmZpcmUoXCJ0YWJsZXNlbGVjdDpjb21wb3NlclwiKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGJpbmRTaWRlY2xpY2soKTtcbiAgICAgIH0sMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZFNpZGVjbGljayAoKSB7XG4gICAgICAgIHZhciBzaWRlQ2xpY2tIYW5kbGVyID0gZG9tLm9ic2VydmUoZWRpdGFibGUub3duZXJEb2N1bWVudCwgXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHNpZGVDbGlja0hhbmRsZXIuc3RvcCgpO1xuICAgICAgICAgIGlmIChkb20uZ2V0UGFyZW50RWxlbWVudChldmVudC50YXJnZXQsIHsgbm9kZU5hbWU6IFtcIlRBQkxFXCJdIH0pICE9IHNlbGVjdC50YWJsZSkge1xuICAgICAgICAgICAgICByZW1vdmVDZWxsU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgICBzZWxlY3QudGFibGUgPSBudWxsO1xuICAgICAgICAgICAgICBzZWxlY3Quc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICBzZWxlY3QuZW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgZWRpdG9yLmZpcmUoXCJ0YWJsZXVuc2VsZWN0XCIpLmZpcmUoXCJ0YWJsZXVuc2VsZWN0OmNvbXBvc2VyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0Q2VsbHMgKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgc2VsZWN0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHNlbGVjdC5lbmQgPSBlbmQ7XG4gICAgICAgIHNlbGVjdC50YWJsZSA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdC5zdGFydCwgeyBub2RlTmFtZTogW1wiVEFCTEVcIl0gfSk7XG4gICAgICAgIHNlbGVjdGVkQ2VsbHMgPSBkb20udGFibGUuZ2V0Q2VsbHNCZXR3ZWVuKHNlbGVjdC5zdGFydCwgc2VsZWN0LmVuZCk7XG4gICAgICAgIGFkZFNlbGVjdGlvbnMoc2VsZWN0ZWRDZWxscyk7XG4gICAgICAgIGJpbmRTaWRlY2xpY2soKTtcbiAgICAgICAgZWRpdG9yLmZpcmUoXCJ0YWJsZXNlbGVjdFwiKS5maXJlKFwidGFibGVzZWxlY3Q6Y29tcG9zZXJcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXQoKTtcblxufTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBSR0JBX1JFR0VYICAgICA9IC9ecmdiYVxcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooW1xcZFxcLl0rKVxccypcXCkvaSxcbiAgICAgIFJHQl9SRUdFWCAgICAgID0gL15yZ2JcXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKlxcKS9pLFxuICAgICAgSEVYNl9SRUdFWCAgICAgPSAvXiMoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkvaSxcbiAgICAgIEhFWDNfUkVHRVggICAgID0gL14jKFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pL2k7XG5cbiAgdmFyIHBhcmFtX1JFR1ggPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKF58XFxcXHN8OylcIiArIHAgKyBcIlxcXFxzKjpcXFxccypbXjskXStcIiAsIFwiZ2lcIik7XG4gIH07XG5cbiAgd3lzaWh0bWw1LnF1aXJrcy5zdHlsZVBhcnNlciA9IHtcblxuICAgIHBhcnNlQ29sb3I6IGZ1bmN0aW9uKHN0eWxlc1N0ciwgcGFyYW1OYW1lKSB7XG4gICAgICB2YXIgcGFyYW1SZWdleCA9IHBhcmFtX1JFR1gocGFyYW1OYW1lKSxcbiAgICAgICAgICBwYXJhbXMgPSBzdHlsZXNTdHIubWF0Y2gocGFyYW1SZWdleCksXG4gICAgICAgICAgcmFkaXggPSAxMCxcbiAgICAgICAgICBzdHIsIGNvbG9yTWF0Y2g7XG5cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhcmFtcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBwYXJhbXNbaV0gPSB3eXNpaHRtbDUubGFuZy5zdHJpbmcocGFyYW1zW2ldLnNwbGl0KCc6JylbMV0pLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aC0xXTtcblxuICAgICAgICBpZiAoUkdCQV9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgICBjb2xvck1hdGNoID0gc3RyLm1hdGNoKFJHQkFfUkVHRVgpO1xuICAgICAgICB9IGVsc2UgaWYgKFJHQl9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgICBjb2xvck1hdGNoID0gc3RyLm1hdGNoKFJHQl9SRUdFWCk7XG4gICAgICAgIH0gZWxzZSBpZiAoSEVYNl9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgICBjb2xvck1hdGNoID0gc3RyLm1hdGNoKEhFWDZfUkVHRVgpO1xuICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgIH0gZWxzZSBpZiAoSEVYM19SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgICBjb2xvck1hdGNoID0gc3RyLm1hdGNoKEhFWDNfUkVHRVgpO1xuICAgICAgICAgIGNvbG9yTWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICBjb2xvck1hdGNoLnB1c2goMSk7XG4gICAgICAgICAgcmV0dXJuIHd5c2lodG1sNS5sYW5nLmFycmF5KGNvbG9yTWF0Y2gpLm1hcChmdW5jdGlvbihkLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiAoaWR4IDwgMykgPyAocGFyc2VJbnQoZCwgMTYpICogMTYpICsgcGFyc2VJbnQoZCwgMTYpOiBwYXJzZUZsb2F0KGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbG9yTWF0Y2gpIHtcbiAgICAgICAgICBjb2xvck1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKCFjb2xvck1hdGNoWzNdKSB7XG4gICAgICAgICAgICBjb2xvck1hdGNoLnB1c2goMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3eXNpaHRtbDUubGFuZy5hcnJheShjb2xvck1hdGNoKS5tYXAoZnVuY3Rpb24oZCwgaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gKGlkeCA8IDMpID8gcGFyc2VJbnQoZCwgcmFkaXgpOiBwYXJzZUZsb2F0KGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHVucGFyc2VDb2xvcjogZnVuY3Rpb24odmFsLCBwcm9wcykge1xuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcyA9PSBcImhleFwiKSB7XG4gICAgICAgICAgcmV0dXJuICh2YWxbMF0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpICsgKHZhbFsxXS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkgKyAodmFsWzJdLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcyA9PSBcImhhc2hcIikge1xuICAgICAgICAgIHJldHVybiBcIiNcIiArICh2YWxbMF0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpICsgKHZhbFsxXS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkgKyAodmFsWzJdLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcyA9PSBcInJnYlwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwicmdiKFwiICsgdmFsWzBdICsgXCIsXCIgKyB2YWxbMV0gKyBcIixcIiArIHZhbFsyXSArIFwiKVwiO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzID09IFwicmdiYVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIHZhbFswXSArIFwiLFwiICsgdmFsWzFdICsgXCIsXCIgKyB2YWxbMl0gKyBcIixcIiArIHZhbFszXSArIFwiKVwiO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzID09IFwiY3N2XCIpIHtcbiAgICAgICAgICByZXR1cm4gIHZhbFswXSArIFwiLFwiICsgdmFsWzFdICsgXCIsXCIgKyB2YWxbMl0gKyBcIixcIiArIHZhbFszXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsWzNdICYmIHZhbFszXSAhPT0gMSkge1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgdmFsWzBdICsgXCIsXCIgKyB2YWxbMV0gKyBcIixcIiArIHZhbFsyXSArIFwiLFwiICsgdmFsWzNdICsgXCIpXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJyZ2IoXCIgKyB2YWxbMF0gKyBcIixcIiArIHZhbFsxXSArIFwiLFwiICsgdmFsWzJdICsgXCIpXCI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBhcnNlRm9udFNpemU6IGZ1bmN0aW9uKHN0eWxlc1N0cikge1xuICAgICAgdmFyIHBhcmFtcyA9IHN0eWxlc1N0ci5tYXRjaChwYXJhbV9SRUdYKCdmb250LXNpemUnKSk7XG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB3eXNpaHRtbDUubGFuZy5zdHJpbmcocGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXS5zcGxpdCgnOicpWzFdKS50cmltKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG59KSh3eXNpaHRtbDUpO1xuOy8qKlxuICogU2VsZWN0aW9uIEFQSVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICB2YXIgc2VsZWN0aW9uID0gbmV3IHd5c2lodG1sNS5TZWxlY3Rpb24oZWRpdG9yKTtcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICBmdW5jdGlvbiBfZ2V0Q3VtdWxhdGl2ZU9mZnNldFRvcChlbGVtZW50KSB7XG4gICAgdmFyIHRvcCA9IDA7XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZG8ge1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b3A7XG4gIH1cblxuICAvLyBQcm92aWRlcyB0aGUgZGVwdGggb2YgYGBkZXNjZW5kYW50YGAgcmVsYXRpdmUgdG8gYGBhbmNlc3RvcmBgXG4gIGZ1bmN0aW9uIGdldERlcHRoKGFuY2VzdG9yLCBkZXNjZW5kYW50KSB7XG4gICAgICB2YXIgcmV0ID0gMDtcbiAgICAgIHdoaWxlIChkZXNjZW5kYW50ICE9PSBhbmNlc3Rvcikge1xuICAgICAgICAgIHJldCsrO1xuICAgICAgICAgIGRlc2NlbmRhbnQgPSBkZXNjZW5kYW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKCFkZXNjZW5kYW50KVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBkZXNjZW5kYW50IG9mIGFuY2VzdG9yIVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBTaG91bGQgZml4IHRoZSBvYnRhaW5lZCByYW5nZXMgdGhhdCBjYW5ub3Qgc3Vycm9uZCBjb250ZW50cyBub3JtYWxseSB0byBhcHBseSBjaGFuZ2VzIHVwb25cbiAgLy8gQmVpbmcgY29uc2lkZXJhdGUgdG8gZmlyZWZveCB0aGF0IHNldHMgcmFuZ2Ugc3RhcnQgc3RhcnQgb3V0IG9mIHNwYW4gYW5kIGVuZCBpbnNpZGUgb24gZG91YmxlY2xpY2sgaW5pdGlhdGVkIHNlbGVjdGlvblxuICBmdW5jdGlvbiBleHBhbmRSYW5nZVRvU3Vycm91bmQocmFuZ2UpIHtcbiAgICAgIGlmIChyYW5nZS5jYW5TdXJyb3VuZENvbnRlbnRzKCkpIHJldHVybjtcblxuICAgICAgdmFyIGNvbW1vbiA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLFxuICAgICAgICAgIHN0YXJ0X2RlcHRoID0gZ2V0RGVwdGgoY29tbW9uLCByYW5nZS5zdGFydENvbnRhaW5lciksXG4gICAgICAgICAgZW5kX2RlcHRoID0gZ2V0RGVwdGgoY29tbW9uLCByYW5nZS5lbmRDb250YWluZXIpO1xuXG4gICAgICB3aGlsZSghcmFuZ2UuY2FuU3Vycm91bmRDb250ZW50cygpKSB7XG4gICAgICAgIC8vIEluIHRoZSBmb2xsb3dpbmcgYnJhbmNoZXMsIHdlIGNhbm5vdCBqdXN0IGRlY3JlbWVudCB0aGUgZGVwdGggdmFyaWFibGVzIGJlY2F1c2UgdGhlIHNldFN0YXJ0QmVmb3JlL3NldEVuZEFmdGVyIG1heSBtb3ZlIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHJhbmdlIG1vcmUgdGhhbiBvbmUgbGV2ZWwgcmVsYXRpdmUgdG8gYGBjb21tb25gYC4gU28gd2UgbmVlZCB0byByZWNvbXB1dGUgdGhlIGRlcHRoLlxuICAgICAgICBpZiAoc3RhcnRfZGVwdGggPiBlbmRfZGVwdGgpIHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKHJhbmdlLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHN0YXJ0X2RlcHRoID0gZ2V0RGVwdGgoY29tbW9uLCByYW5nZS5zdGFydENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihyYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgICAgICAgZW5kX2RlcHRoID0gZ2V0RGVwdGgoY29tbW9uLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICB3eXNpaHRtbDUuU2VsZWN0aW9uID0gQmFzZS5leHRlbmQoXG4gICAgLyoqIEBzY29wZSB3eXNpaHRtbDUuU2VsZWN0aW9uLnByb3RvdHlwZSAqLyB7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGVkaXRvciwgY29udGFpbiwgdW5zZWxlY3RhYmxlQ2xhc3MpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG91ciBleHRlcm5hbCByYW5nZSBsaWJyYXJ5IGlzIGluaXRpYWxpemVkXG4gICAgICB3aW5kb3cucmFuZ3kuaW5pdCgpO1xuXG4gICAgICB0aGlzLmVkaXRvciAgID0gZWRpdG9yO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGVkaXRvci5jb21wb3NlcjtcbiAgICAgIHRoaXMuZG9jICAgICAgPSB0aGlzLmNvbXBvc2VyLmRvYztcbiAgICAgIHRoaXMuY29udGFpbiA9IGNvbnRhaW47XG4gICAgICB0aGlzLnVuc2VsZWN0YWJsZUNsYXNzID0gdW5zZWxlY3RhYmxlQ2xhc3MgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzZWxlY3Rpb24gYXMgYSBib29rbWFyayB0byBiZSBhYmxlIHRvIGxhdGVyIHJlc3RvcmUgaXRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBnZXRCb29rbWFyazogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICBpZiAocmFuZ2UpIGV4cGFuZFJhbmdlVG9TdXJyb3VuZChyYW5nZSk7XG4gICAgICByZXR1cm4gcmFuZ2UgJiYgcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIGEgc2VsZWN0aW9uIHJldHJpZXZlZCB2aWEgd3lzaWh0bWw1LlNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm9va21hcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib29rbWFyayBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbihib29rbWFyaykge1xuICAgICAgaWYgKCFib29rbWFyaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKGJvb2ttYXJrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYXJldCBpbiBmcm9udCBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIGVsZW1lbnQgb3IgdGV4dCBub2RlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBjYXJldCBpbiBmcm9udCBvZlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNldEJlZm9yZShteUVsZW1lbnQpO1xuICAgICAqL1xuICAgIHNldEJlZm9yZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICByYW5nZS5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhcmV0IGFmdGVyIHRoZSBnaXZlbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgZWxlbWVudCBvciB0ZXh0IG5vZGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGluIGZyb250IG9mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2V0QmVmb3JlKG15RWxlbWVudCk7XG4gICAgICovXG4gICAgc2V0QWZ0ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKTtcblxuICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihub2RlKTtcbiAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U2VsZWN0aW9uKHJhbmdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWJpbGl0eSB0byBzZWxlY3QvbWFyayBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBub2RlL2VsZW1lbnQgdG8gc2VsZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2VsZWN0Tm9kZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15LWltYWdlXCIpKTtcbiAgICAgKi9cbiAgICBzZWxlY3ROb2RlOiBmdW5jdGlvbihub2RlLCBhdm9pZEludmlzaWJsZVNwYWNlKSB7XG4gICAgICB2YXIgcmFuZ2UgICAgICAgICAgID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpLFxuICAgICAgICAgIGlzRWxlbWVudCAgICAgICA9IG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUsXG4gICAgICAgICAgY2FuSGF2ZUhUTUwgICAgID0gXCJjYW5IYXZlSFRNTFwiIGluIG5vZGUgPyBub2RlLmNhbkhhdmVIVE1MIDogKG5vZGUubm9kZU5hbWUgIT09IFwiSU1HXCIpLFxuICAgICAgICAgIGNvbnRlbnQgICAgICAgICA9IGlzRWxlbWVudCA/IG5vZGUuaW5uZXJIVE1MIDogbm9kZS5kYXRhLFxuICAgICAgICAgIGlzRW1wdHkgICAgICAgICA9IChjb250ZW50ID09PSBcIlwiIHx8IGNvbnRlbnQgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpLFxuICAgICAgICAgIGRpc3BsYXlTdHlsZSAgICA9IGRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShub2RlKSxcbiAgICAgICAgICBpc0Jsb2NrRWxlbWVudCAgPSAoZGlzcGxheVN0eWxlID09PSBcImJsb2NrXCIgfHwgZGlzcGxheVN0eWxlID09PSBcImxpc3QtaXRlbVwiKTtcblxuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50ICYmIGNhbkhhdmVIVE1MICYmICFhdm9pZEludmlzaWJsZVNwYWNlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNhcmV0IGlzIHZpc2libGUgaW4gbm9kZSBieSBpbnNlcnRpbmcgYSB6ZXJvIHdpZHRoIG5vIGJyZWFraW5nIHNwYWNlXG4gICAgICAgIHRyeSB7IG5vZGUuaW5uZXJIVE1MID0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRTsgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuSGF2ZUhUTUwpIHtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkhhdmVIVE1MICYmIGlzRW1wdHkgJiYgaXNFbGVtZW50KSB7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKGlzQmxvY2tFbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuSGF2ZUhUTUwgJiYgaXNFbXB0eSkge1xuICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5vZGUgd2hpY2ggY29udGFpbnMgdGhlIHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29udHJvbFJhbmdlXSAob25seSBJRSkgV2hldGhlciBpdCBzaG91bGQgcmV0dXJuIHRoZSBzZWxlY3RlZCBDb250cm9sUmFuZ2UgZWxlbWVudCB3aGVuIHRoZSBzZWxlY3Rpb24gdHlwZSBpcyBhIFwiQ29udHJvbFJhbmdlXCJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIGNhcmV0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgbm9kZVRoYXRDb250YWluc0NhcmV0ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAqL1xuICAgIGdldFNlbGVjdGVkTm9kZTogZnVuY3Rpb24oY29udHJvbFJhbmdlKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uLFxuICAgICAgICAgIHJhbmdlO1xuXG4gICAgICBpZiAoY29udHJvbFJhbmdlICYmIHRoaXMuZG9jLnNlbGVjdGlvbiAmJiB0aGlzLmRvYy5zZWxlY3Rpb24udHlwZSA9PT0gXCJDb250cm9sXCIpIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByYW5nZS5pdGVtKDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKHRoaXMuZG9jKTtcbiAgICAgIGlmIChzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBzZWxlY3Rpb24uYW5jaG9yTm9kZSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gdGhpcy5nZXRSYW5nZSh0aGlzLmRvYyk7XG4gICAgICAgIHJldHVybiByYW5nZSA/IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIDogdGhpcy5kb2MuYm9keTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZml4U2VsQm9yZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICBleHBhbmRSYW5nZVRvU3Vycm91bmQocmFuZ2UpO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZE93bk5vZGVzOiBmdW5jdGlvbihjb250cm9sUmFuZ2UpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24sXG4gICAgICAgICAgcmFuZ2VzID0gdGhpcy5nZXRPd25SYW5nZXMoKSxcbiAgICAgICAgICBvd25Ob2RlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4aSA9IHJhbmdlcy5sZW5ndGg7IGkgPCBtYXhpOyBpKyspIHtcbiAgICAgICAgICBvd25Ob2Rlcy5wdXNoKHJhbmdlc1tpXS5jb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCB0aGlzLmRvYy5ib2R5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvd25Ob2RlcztcbiAgICB9LFxuXG4gICAgZmluZE5vZGVzSW5TZWxlY3Rpb246IGZ1bmN0aW9uKG5vZGVUeXBlcykge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZ2V0T3duUmFuZ2VzKCksXG4gICAgICAgICAgbm9kZXMgPSBbXSwgY3VyTm9kZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4aSA9IHJhbmdlcy5sZW5ndGg7IGkgPCBtYXhpOyBpKyspIHtcbiAgICAgICAgY3VyTm9kZXMgPSByYW5nZXNbaV0uZ2V0Tm9kZXMoWzFdLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gd3lzaWh0bWw1LmxhbmcuYXJyYXkobm9kZVR5cGVzKS5jb250YWlucyhub2RlLm5vZGVOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGN1ck5vZGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LFxuXG4gICAgY29udGFpbnNVbmVkaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1bmVkaXRhYmxlcyA9IHRoaXMuZ2V0T3duVW5lZGl0YWJsZXMoKSxcbiAgICAgICAgICBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4aSA9IHVuZWRpdGFibGVzLmxlbmd0aDsgaSA8IG1heGk7IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmNvbnRhaW5zTm9kZSh1bmVkaXRhYmxlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGRlbGV0ZUNvbnRlbnRzOiBmdW5jdGlvbigpICB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5nZXRPd25SYW5nZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHJhbmdlc1tpXS5kZWxldGVDb250ZW50cygpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2VzWzBdKTtcbiAgICB9LFxuXG4gICAgZ2V0UHJldmlvdXNOb2RlOiBmdW5jdGlvbihub2RlLCBpZ25vcmVFbXB0eSkge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBub2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB0aGlzLmNvbnRhaW4pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBub2RlLnByZXZpb3VzU2libGluZyxcbiAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgIGlmIChyZXQgPT09IHRoaXMuY29udGFpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldCAmJiByZXQubm9kZVR5cGUgIT09IDMgJiYgcmV0Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAvLyBkbyBub3QgY291bnQgY29tbWVudHMgYW5kIG90aGVyIG5vZGUgdHlwZXNcbiAgICAgICAgIHJldCA9IHRoaXMuZ2V0UHJldmlvdXNOb2RlKHJldCwgaWdub3JlRW1wdHkpO1xuICAgICAgfSBlbHNlIGlmIChyZXQgJiYgcmV0Lm5vZGVUeXBlID09PSAzICYmICgvXlxccyokLykudGVzdChyZXQudGV4dENvbnRlbnQpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBjb3VudCBlbXB0eSB0ZXh0bm9kZXMgYXMgcHJldml1cyBub2Rlc1xuICAgICAgICByZXQgPSB0aGlzLmdldFByZXZpb3VzTm9kZShyZXQsIGlnbm9yZUVtcHR5KTtcbiAgICAgIH0gZWxzZSBpZiAoaWdub3JlRW1wdHkgJiYgcmV0ICYmIHJldC5ub2RlVHlwZSA9PT0gMSAmJiAhd3lzaWh0bWw1LmxhbmcuYXJyYXkoW1wiQlJcIiwgXCJIUlwiLCBcIklNR1wiXSkuY29udGFpbnMocmV0Lm5vZGVOYW1lKSAmJiAoL15bXFxzXSokLykudGVzdChyZXQuaW5uZXJIVE1MKSkge1xuICAgICAgICAvLyBEbyBub3QgY291bnQgZW1wdHkgbm9kZXMgaWYgcGFyYW0gc2V0LlxuICAgICAgICAvLyBDb250ZW50ZWRpdGFibGUgdGVuZHMgdG8gYnlwYXNzIGFuZCBkZWxldGUgdGhlc2Ugc2lsZW50bHkgd2hlbiBkZWxldGluZyB3aXRoIGNhcmV0XG4gICAgICAgIHJldCA9IHRoaXMuZ2V0UHJldmlvdXNOb2RlKHJldCwgaWdub3JlRW1wdHkpO1xuICAgICAgfSBlbHNlIGlmICghcmV0ICYmIG5vZGUgIT09IHRoaXMuY29udGFpbikge1xuICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuY29udGFpbikge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5nZXRQcmV2aW91c05vZGUocGFyZW50LCBpZ25vcmVFbXB0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChyZXQgIT09IHRoaXMuY29udGFpbikgPyByZXQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uUGFyZW50c0J5VGFnOiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmdldFNlbGVjdGVkT3duTm9kZXMoKSxcbiAgICAgICAgICBjdXJFbCwgcGFyZW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4aSA9IG5vZGVzLmxlbmd0aDsgaSA8IG1heGk7IGkrKykge1xuICAgICAgICBjdXJFbCA9IChub2Rlc1tpXS5ub2RlTmFtZSAmJiAgbm9kZXNbaV0ubm9kZU5hbWUgPT09ICdMSScpID8gbm9kZXNbaV0gOiB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQobm9kZXNbaV0sIHsgbm9kZU5hbWU6IFsnTEknXX0sIGZhbHNlLCB0aGlzLmNvbnRhaW4pO1xuICAgICAgICBpZiAoY3VyRWwpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VyRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKHBhcmVudHMubGVuZ3RoKSA/IHBhcmVudHMgOiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRSYW5nZVRvTm9kZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICAgIHNOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgICBwb3MgPSByYW5nZS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgIGxhc3RSID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpO1xuXG4gICAgICAgIGxhc3RSLnNlbGVjdE5vZGVDb250ZW50cyhzTm9kZSk7XG4gICAgICAgIGxhc3RSLnNldFN0YXJ0KHNOb2RlLCBwb3MpO1xuICAgICAgICByZXR1cm4gbGFzdFI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNhcmV0SXNMYXN0SW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyksXG4gICAgICAgICAgcyA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgZW5kYyA9IHRoaXMuZ2V0UmFuZ2VUb05vZGVFbmQoKS5jbG9uZUNvbnRlbnRzKCksXG4gICAgICAgICAgZW5kdHh0ID0gZW5kYy50ZXh0Q29udGVudDtcblxuICAgICAgcmV0dXJuICgvXlxccyokLykudGVzdChlbmR0eHQpO1xuICAgIH0sXG5cbiAgICBjYXJldElzRmlyc3RJblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKSxcbiAgICAgICAgICBzID0gdGhpcy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICBzdGFydE5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgIFxuICAgICAgaWYgKHN0YXJ0Tm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbGxhcHNlZCgpICYmIChzdGFydE5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUgJiYgKC9eXFxzKiQvKS50ZXN0KHN0YXJ0Tm9kZS5kYXRhLnN1YnN0cigwLHJhbmdlLnN0YXJ0T2Zmc2V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5zZWxlY3ROb2RlQ29udGVudHModGhpcy5nZXRSYW5nZSgpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgICAgICAgci5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzQ29sbGFwc2VkKCkgJiYgKHIuc3RhcnRDb250YWluZXIgPT09IHMuYW5jaG9yTm9kZSB8fCByLmVuZENvbnRhaW5lciA9PT0gcy5hbmNob3JOb2RlKSAmJiByLnN0YXJ0T2Zmc2V0ID09PSBzLmFuY2hvck9mZnNldCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNhcmV0SXNJblRoZUJlZ2lubmlnOiBmdW5jdGlvbihvZk5vZGUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBub2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICAgICAgICBvZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgICAgICBpZiAob2ZOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIChvZmZzZXQgPT09IDAgJiYgKG5vZGUubm9kZU5hbWUgJiYgbm9kZS5ub2RlTmFtZSA9PT0gb2ZOb2RlLnRvVXBwZXJDYXNlKCkgfHwgd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KG5vZGUucGFyZW50Tm9kZSwgeyBub2RlTmFtZTogb2ZOb2RlIH0sIDEpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChvZmZzZXQgPT09IDAgJiYgIXRoaXMuZ2V0UHJldmlvdXNOb2RlKG5vZGUsIHRydWUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXJldElzQmVmb3JlVW5lZGl0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICBub2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICAgICAgb2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICB2YXIgcHJldk5vZGUgPSB0aGlzLmdldFByZXZpb3VzTm9kZShub2RlLCB0cnVlKTtcbiAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgdmFyIHVuZWRpdGFibGVzID0gdGhpcy5nZXRPd25VbmVkaXRhYmxlcygpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXhpID0gdW5lZGl0YWJsZXMubGVuZ3RoOyBpIDwgbWF4aTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocHJldk5vZGUgPT09IHVuZWRpdGFibGVzW2ldKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmVkaXRhYmxlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogRmlndXJlIG91dCBhIG1ldGhvZCBmcm9tIGZvbGxvd2luZyAyIHRoYXQgd291bGQgd29yayB1bml2ZXJzYWxseVxuICAgIGV4ZWN1dGVBbmRSZXN0b3JlUmFuZ3k6IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICB2YXIgd2luID0gdGhpcy5kb2MuZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2MucGFyZW50V2luZG93LFxuICAgICAgICAgIHNlbCA9IHJhbmd5LnNhdmVTZWxlY3Rpb24od2luKTtcblxuICAgICAgaWYgKCFzZWwpIHtcbiAgICAgICAgbWV0aG9kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1ldGhvZCgpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFuZ3kucmVzdG9yZVNlbGVjdGlvbihzZWwpO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBoYXMgcHJvYmxlbXMgaW4gY2hyb21lIDEyLiBpbnZlc3RpZ2F0ZSBibG9jayBsZXZlbCBhbmQgdW5lZGl0YWJsZSBhcmVhIGluYmV0d2VlblxuICAgIGV4ZWN1dGVBbmRSZXN0b3JlOiBmdW5jdGlvbihtZXRob2QsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgdmFyIGJvZHkgICAgICAgICAgICAgICAgICA9IHRoaXMuZG9jLmJvZHksXG4gICAgICAgICAgb2xkU2Nyb2xsVG9wICAgICAgICAgID0gcmVzdG9yZVNjcm9sbFBvc2l0aW9uICYmIGJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgIG9sZFNjcm9sbExlZnQgICAgICAgICA9IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiAmJiBib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgY2xhc3NOYW1lICAgICAgICAgICAgID0gXCJfd3lzaWh0bWw1LXRlbXAtcGxhY2Vob2xkZXJcIixcbiAgICAgICAgICBwbGFjZWhvbGRlckh0bWwgICAgICAgPSAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3NOYW1lICsgJ1wiPicgKyB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFICsgJzwvc3Bhbj4nLFxuICAgICAgICAgIHJhbmdlICAgICAgICAgICAgICAgICA9IHRoaXMuZ2V0UmFuZ2UodHJ1ZSksXG4gICAgICAgICAgY2FyZXRQbGFjZWhvbGRlcixcbiAgICAgICAgICBuZXdDYXJldFBsYWNlaG9sZGVyLFxuICAgICAgICAgIG5leHRTaWJsaW5nLCBwcmV2U2libGluZyxcbiAgICAgICAgICBub2RlLCBub2RlMiwgcmFuZ2UyLFxuICAgICAgICAgIG5ld1JhbmdlO1xuXG4gICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBleGVjdXRlIGFuZCBzYXkgZ29vZGJ5ZVxuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICBtZXRob2QoYm9keSwgYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcmFuZ2UyID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICBub2RlMiA9IHJhbmdlMi5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQocGxhY2Vob2xkZXJIdG1sKTtcbiAgICAgICAgcmFuZ2UyLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgcmFuZ2UyLmluc2VydE5vZGUobm9kZTIpO1xuICAgICAgICByYW5nZTIuZGV0YWNoKCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQocGxhY2Vob2xkZXJIdG1sKTtcbiAgICAgIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG5cbiAgICAgIGlmIChub2RlMikge1xuICAgICAgICBjYXJldFBsYWNlaG9sZGVyID0gdGhpcy5jb250YWluLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZShjYXJldFBsYWNlaG9sZGVyWzBdKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoY2FyZXRQbGFjZWhvbGRlcltjYXJldFBsYWNlaG9sZGVyLmxlbmd0aCAtMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHBvdGVudGlhbCBlcnJvciBkb2Vzbid0IGNhdXNlIG91ciBwbGFjZWhvbGRlciBlbGVtZW50IHRvIGJlIGxlZnQgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGU7IH0sIDApO1xuICAgICAgfVxuICAgICAgY2FyZXRQbGFjZWhvbGRlciA9IHRoaXMuY29udGFpbi5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiICsgY2xhc3NOYW1lKTtcbiAgICAgIGlmIChjYXJldFBsYWNlaG9sZGVyICYmIGNhcmV0UGxhY2Vob2xkZXIubGVuZ3RoKSB7XG4gICAgICAgIG5ld1JhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpO1xuICAgICAgICBuZXh0U2libGluZyA9IGNhcmV0UGxhY2Vob2xkZXJbMF0ubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChjYXJldFBsYWNlaG9sZGVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmV2U2libGluZyA9IGNhcmV0UGxhY2Vob2xkZXJbY2FyZXRQbGFjZWhvbGRlci5sZW5ndGggLTFdLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlNpYmxpbmcgJiYgbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydEJlZm9yZShuZXh0U2libGluZyk7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kQWZ0ZXIocHJldlNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NhcmV0UGxhY2Vob2xkZXIgPSB0aGlzLmRvYy5jcmVhdGVUZXh0Tm9kZSh3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKTtcbiAgICAgICAgICBkb20uaW5zZXJ0KG5ld0NhcmV0UGxhY2Vob2xkZXIpLmFmdGVyKGNhcmV0UGxhY2Vob2xkZXJbMF0pO1xuICAgICAgICAgIG5ld1JhbmdlLnNldFN0YXJ0QmVmb3JlKG5ld0NhcmV0UGxhY2Vob2xkZXIpO1xuICAgICAgICAgIG5ld1JhbmdlLnNldEVuZEFmdGVyKG5ld0NhcmV0UGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKG5ld1JhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGNhcmV0UGxhY2Vob2xkZXIubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICBjYXJldFBsYWNlaG9sZGVyW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FyZXRQbGFjZWhvbGRlcltpXSk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgZm9yIHdoZW4gYWxsIGhlbGwgYnJlYWtzIGxvb3NlXG4gICAgICAgIHRoaXMuY29udGFpbi5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgIGJvZHkuc2Nyb2xsVG9wICA9IG9sZFNjcm9sbFRvcDtcbiAgICAgICAgYm9keS5zY3JvbGxMZWZ0ID0gb2xkU2Nyb2xsTGVmdDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGl0IGFnYWluLCBqdXN0IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBpcyBkZWZpbml0ZWx5IG91dCBvZiB0aGUgZG9tIHRyZWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhcmV0UGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYXJldFBsYWNlaG9sZGVyKTtcbiAgICAgIH0gY2F0Y2goZTIpIHt9XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgbmV3UmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgICBuZXdSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQgfHwgMCk7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihuZXdSYW5nZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBodG1sIGF0IHRoZSBjYXJldCBwb3NpdGlvbiBhbmQgbW92ZSB0aGUgY3Vyc29yIGFmdGVyIHRoZSBpbnNlcnRlZCBodG1sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBIVE1MIHN0cmluZyB0byBpbnNlcnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHNlbGVjdGlvbi5pbnNlcnRIVE1MKFwiPHA+Zm9vYmFyPC9wPlwiKTtcbiAgICAgKi9cbiAgICBpbnNlcnRIVE1MOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICB2YXIgcmFuZ2UgICAgID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpLFxuICAgICAgICAgIG5vZGUgPSB0aGlzLmRvYy5jcmVhdGVFbGVtZW50KCdESVYnKSxcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICBsYXN0Q2hpbGQ7XG5cbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIGxhc3RDaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuXG4gICAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmluc2VydE5vZGUoZnJhZ21lbnQpO1xuXG4gICAgICBpZiAobGFzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuc2V0QWZ0ZXIobGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY2FyZXQgcG9zaXRpb24gYW5kIG1vdmUgdGhlIGN1cnNvciBiZWhpbmQgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIEhUTUwgc3RyaW5nIHRvIGluc2VydFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLmluc2VydE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJmb29iYXJcIikpO1xuICAgICAqL1xuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgbm9kZSB0byBzdXJyb3VuZCB0aGUgc2VsZWN0ZWQgZWxlbWVudHMgd2l0aFxuICAgICAqL1xuICAgIHN1cnJvdW5kOiBmdW5jdGlvbihub2RlT3B0aW9ucykge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZ2V0T3duUmFuZ2VzKCksXG4gICAgICAgICAgbm9kZSwgbm9kZXMgPSBbXTtcbiAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBub2RlID0gdGhpcy5kb2MuY3JlYXRlRWxlbWVudChub2RlT3B0aW9ucy5ub2RlTmFtZSk7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChub2RlT3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IG5vZGVPcHRpb25zLmNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU9wdGlvbnMuY3NzU3R5bGUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBub2RlT3B0aW9ucy5jc3NTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIG9ubHkgd29ya3Mgd2hlbiB0aGUgcmFuZ2UgYm91bmRhcmllcyBhcmUgbm90IG92ZXJsYXBwaW5nIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgcmFuZ2VzW2ldLnN1cnJvdW5kQ29udGVudHMobm9kZSk7XG4gICAgICAgICAgdGhpcy5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAvLyBmYWxsYmFja1xuICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQocmFuZ2VzW2ldLmV4dHJhY3RDb250ZW50cygpKTtcbiAgICAgICAgICByYW5nZXNbaV0uaW5zZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH0sXG5cbiAgICBkZWJsb2NrQW5kU3Vycm91bmQ6IGZ1bmN0aW9uKG5vZGVPcHRpb25zKSB7XG4gICAgICB2YXIgdGVtcEVsZW1lbnQgPSB0aGlzLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICByYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKSxcbiAgICAgICAgICB0ZW1wRGl2RWxlbWVudHMsXG4gICAgICAgICAgdGVtcEVsZW1lbnRzLFxuICAgICAgICAgIGZpcnN0Q2hpbGQ7XG5cbiAgICAgIHRlbXBFbGVtZW50LmNsYXNzTmFtZSA9IG5vZGVPcHRpb25zLmNsYXNzTmFtZTtcblxuICAgICAgdGhpcy5jb21wb3Nlci5jb21tYW5kcy5leGVjKFwiZm9ybWF0QmxvY2tcIiwgbm9kZU9wdGlvbnMubm9kZU5hbWUsIG5vZGVPcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICB0ZW1wRGl2RWxlbWVudHMgPSB0aGlzLmNvbnRhaW4ucXVlcnlTZWxlY3RvckFsbChcIi5cIiArIG5vZGVPcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICBpZiAodGVtcERpdkVsZW1lbnRzWzBdKSB7XG4gICAgICAgIHRlbXBEaXZFbGVtZW50c1swXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZW1wRWxlbWVudCwgdGVtcERpdkVsZW1lbnRzWzBdKTtcblxuICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZSh0ZW1wRGl2RWxlbWVudHNbMF0pO1xuICAgICAgICByYW5nZS5zZXRFbmRBZnRlcih0ZW1wRGl2RWxlbWVudHNbdGVtcERpdkVsZW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdGVtcEVsZW1lbnRzID0gcmFuZ2UuZXh0cmFjdENvbnRlbnRzKCk7XG5cbiAgICAgICAgd2hpbGUgKHRlbXBFbGVtZW50cy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZCA9IHRlbXBFbGVtZW50cy5maXJzdENoaWxkO1xuICAgICAgICAgIGlmIChmaXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiYgd3lzaWh0bWw1LmRvbS5oYXNDbGFzcyhmaXJzdENoaWxkLCBub2RlT3B0aW9ucy5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICB3aGlsZSAoZmlyc3RDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIHRlbXBFbGVtZW50LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSAhPT0gXCJCUlwiKSB7IHRlbXBFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZG9jLmNyZWF0ZUVsZW1lbnQoJ2JyJykpOyB9XG4gICAgICAgICAgICB0ZW1wRWxlbWVudHMucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBFbGVtZW50LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcEVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGVtcEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBpbnRvIHRoZSB2aWV3XG4gICAgICogRklYTUU6IFRoaXMgaXMgYSBiaXQgaGFja3ksIHRoZXJlIG1pZ2h0IGJlIGEgc21hcnRlciB3YXkgb2YgZG9pbmcgdGhpc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZG9jICAgICAgICAgICA9IHRoaXMuZG9jLFxuICAgICAgICAgIHRvbGVyYW5jZSAgICAgPSA1LCAvLyBweFxuICAgICAgICAgIGhhc1Njcm9sbEJhcnMgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgIHRlbXBFbGVtZW50ICAgPSBkb2MuX3d5c2lodG1sNVNjcm9sbEludG9WaWV3RWxlbWVudCA9IGRvYy5fd3lzaWh0bWw1U2Nyb2xsSW50b1ZpZXdFbGVtZW50IHx8IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgbmVlZHMgY29udGVudCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBpdCdzIHBvc2l0aW9uIHByb3Blcmx5XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICB9KSgpLFxuICAgICAgICAgIG9mZnNldFRvcDtcblxuICAgICAgaWYgKGhhc1Njcm9sbEJhcnMpIHtcbiAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRlbXBFbGVtZW50KTtcbiAgICAgICAgb2Zmc2V0VG9wID0gX2dldEN1bXVsYXRpdmVPZmZzZXRUb3AodGVtcEVsZW1lbnQpO1xuICAgICAgICB0ZW1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KTtcbiAgICAgICAgaWYgKG9mZnNldFRvcCA+PSAoZG9jLmJvZHkuc2Nyb2xsVG9wICsgZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQgLSB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgZG9jLmJvZHkuc2Nyb2xsVG9wID0gb2Zmc2V0VG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBsaW5lIHdoZXJlIHRoZSBjYXJldCBpcyBpblxuICAgICAqL1xuICAgIHNlbGVjdExpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU2VsZWN0aW9uTW9kaWZ5KCkpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0TGluZV9XM0MoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kb2Muc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdExpbmVfTVNJRSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL1NlbGVjdGlvbi9tb2RpZnlcbiAgICAgKi9cbiAgICBfc2VsZWN0TGluZV9XM0M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdpbiAgICAgICA9IHRoaXMuZG9jLmRlZmF1bHRWaWV3LFxuICAgICAgICAgIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHNlbGVjdGlvbi5tb2RpZnkoXCJtb3ZlXCIsIFwibGVmdFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgIHNlbGVjdGlvbi5tb2RpZnkoXCJleHRlbmRcIiwgXCJyaWdodFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICB9LFxuXG4gICAgX3NlbGVjdExpbmVfTVNJRTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZ2UgICAgICAgPSB0aGlzLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKSxcbiAgICAgICAgICByYW5nZVRvcCAgICA9IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgICAgIHNjcm9sbFdpZHRoID0gdGhpcy5kb2MuYm9keS5zY3JvbGxXaWR0aCxcbiAgICAgICAgICByYW5nZUJvdHRvbSxcbiAgICAgICAgICByYW5nZUVuZCxcbiAgICAgICAgICBtZWFzdXJlTm9kZSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGo7XG5cbiAgICAgIGlmICghcmFuZ2UubW92ZVRvUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFuZ2VUb3AgPT09IDApIHtcbiAgICAgICAgLy8gRG9uJ3Qga25vdyB3aHksIGJ1dCB3aGVuIHRoZSBzZWxlY3Rpb24gZW5kcyBhdCB0aGUgZW5kIG9mIGEgbGluZVxuICAgICAgICAvLyByYW5nZS5ib3VuZGluZ1RvcCBpcyAwXG4gICAgICAgIG1lYXN1cmVOb2RlID0gdGhpcy5kb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMuaW5zZXJ0Tm9kZShtZWFzdXJlTm9kZSk7XG4gICAgICAgIHJhbmdlVG9wID0gbWVhc3VyZU5vZGUub2Zmc2V0VG9wO1xuICAgICAgICBtZWFzdXJlTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1lYXN1cmVOb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmFuZ2VUb3AgKz0gMTtcblxuICAgICAgZm9yIChpPS0xMDsgaTxzY3JvbGxXaWR0aDsgaSs9Mikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJhbmdlLm1vdmVUb1BvaW50KGksIHJhbmdlVG9wKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaChlMSkge31cbiAgICAgIH1cblxuICAgICAgLy8gSW52ZXN0aWdhdGUgdGhlIGZvbGxvd2luZyBpbiBvcmRlciB0byBoYW5kbGUgbXVsdGkgbGluZSBzZWxlY3Rpb25zXG4gICAgICAvLyByYW5nZUJvdHRvbSA9IHJhbmdlVG9wICsgKHJhbmdlSGVpZ2h0ID8gKHJhbmdlSGVpZ2h0IC0gMSkgOiAwKTtcbiAgICAgIHJhbmdlQm90dG9tID0gcmFuZ2VUb3A7XG4gICAgICByYW5nZUVuZCA9IHRoaXMuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgZm9yIChqPXNjcm9sbFdpZHRoOyBqPj0wOyBqLS0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZUVuZC5tb3ZlVG9Qb2ludChqLCByYW5nZUJvdHRvbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2goZTIpIHt9XG4gICAgICB9XG5cbiAgICAgIHJhbmdlLnNldEVuZFBvaW50KFwiRW5kVG9FbmRcIiwgcmFuZ2VFbmQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSxcblxuICAgIGdldFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uID8gc2VsZWN0aW9uLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH0sXG5cbiAgICBnZXROb2RlczogZnVuY3Rpb24obm9kZVR5cGUsIGZpbHRlcikge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5nZXROb2Rlcyhbbm9kZVR5cGVdLCBmaWx0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaXhSYW5nZU92ZXJmbG93OiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgaWYgKHRoaXMuY29udGFpbiAmJiB0aGlzLmNvbnRhaW4uZmlyc3RDaGlsZCAmJiByYW5nZSkge1xuICAgICAgICB2YXIgY29udGFpbm1lbnQgPSByYW5nZS5jb21wYXJlTm9kZSh0aGlzLmNvbnRhaW4pO1xuICAgICAgICBpZiAoY29udGFpbm1lbnQgIT09IDIpIHtcbiAgICAgICAgICBpZiAoY29udGFpbm1lbnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKHRoaXMuY29udGFpbi5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5tZW50ID09PSAwKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcih0aGlzLmNvbnRhaW4ubGFzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5tZW50ID09PSAzKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZSh0aGlzLmNvbnRhaW4uZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcih0aGlzLmNvbnRhaW4ubGFzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGV0ZWN0SW5saW5lUmFuZ2VQcm9ibGVtcyhyYW5nZSkpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNFbGVtZW50U2libGluZyA9IHJhbmdlLmVuZENvbnRhaW5lci5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgIGlmIChwcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQocHJldmlvdXNFbGVtZW50U2libGluZywgdGhpcy5fZW5kT2Zmc2V0Rm9yTm9kZShwcmV2aW91c0VsZW1lbnRTaWJsaW5nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9lbmRPZmZzZXRGb3JOb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgcmV0dXJuIHJhbmdlLmVuZE9mZnNldDtcbiAgICB9LFxuXG4gICAgX2RldGVjdElubGluZVJhbmdlUHJvYmxlbXM6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLmVuZENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByYW5nZS5lbmRPZmZzZXQgPT0gMCAmJlxuICAgICAgICBwb3NpdGlvbiAmIDQgLy9Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lOR1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uKGRvbnRGaXgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmIHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gICAgICBpZiAoZG9udEZpeCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmZpeFJhbmdlT3ZlcmZsb3cocmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSxcblxuICAgIGdldE93blVuZWRpdGFibGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhbGxVbmVkaXRhYmxlcyA9IGRvbS5xdWVyeSh0aGlzLmNvbnRhaW4sICcuJyArIHRoaXMudW5zZWxlY3RhYmxlQ2xhc3MpLFxuICAgICAgICAgIGRlZXBVbmVkaXRhYmxlcyA9IGRvbS5xdWVyeShhbGxVbmVkaXRhYmxlcywgJy4nICsgdGhpcy51bnNlbGVjdGFibGVDbGFzcyk7XG5cbiAgICAgIHJldHVybiB3eXNpaHRtbDUubGFuZy5hcnJheShhbGxVbmVkaXRhYmxlcykud2l0aG91dChkZWVwVW5lZGl0YWJsZXMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJhbmdlcyB0aGF0IGJlbG9uZyBvbmx5IHRvIHRoaXMgZWRpdGFibGVcbiAgICAvLyBOZWVkZWQgYXMgdW5lZGl0YWJsZSBibG9jayBpbiBjb250ZW50ZWRpdGFiZWwgY2FuIHNwbGl0IHJhbmdlIGludG8gcGllY2VzXG4gICAgLy8gSWYgbWFuaXB1bGF0aW5nIGNvbnRlbnQgcmV2ZXJzZSBsb29wIGlzIHVzdWFsbHkgbmVlZGVkIGFzIG1hbmlwdWxhdGlvbiBjYW4gc2hpZnQgc3Vic2VxdWVudCByYW5nZXNcbiAgICBnZXRPd25SYW5nZXM6IGZ1bmN0aW9uKCkgIHtcbiAgICAgIHZhciByYW5nZXMgPSBbXSxcbiAgICAgICAgICByID0gdGhpcy5nZXRSYW5nZSgpLFxuICAgICAgICAgIHRtcFJhbmdlcztcblxuICAgICAgaWYgKHIpIHsgcmFuZ2VzLnB1c2gocik7IH1cblxuICAgICAgaWYgKHRoaXMudW5zZWxlY3RhYmxlQ2xhc3MgJiYgdGhpcy5jb250YWluICYmIHIpIHtcbiAgICAgICAgICB2YXIgdW5lZGl0YWJsZXMgPSB0aGlzLmdldE93blVuZWRpdGFibGVzKCksXG4gICAgICAgICAgICAgIHRtcFJhbmdlO1xuICAgICAgICAgIGlmICh1bmVkaXRhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW1heCA9IHVuZWRpdGFibGVzLmxlbmd0aDsgaSA8IGltYXg7IGkrKykge1xuICAgICAgICAgICAgICB0bXBSYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGptYXggPSByYW5nZXMubGVuZ3RoOyBqIDwgam1heDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlc1tqXSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChyYW5nZXNbal0uY29tcGFyZU5vZGUodW5lZGl0YWJsZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgc2VsZWN0aW9uIGluc2lkZSB1bmVkaXRhYmxlLiByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAvL3NlY3Rpb24gYmVnaW5zIGJlZm9yZSBhbmQgZW5kcyBhZnRlciB1bmVkaXRhYmxlLiBzcGlsdFxuICAgICAgICAgICAgICAgICAgICAgIHRtcFJhbmdlID0gcmFuZ2VzW2pdLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB0bXBSYW5nZS5zZXRFbmRCZWZvcmUodW5lZGl0YWJsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgIHRtcFJhbmdlcy5wdXNoKHRtcFJhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHRtcFJhbmdlID0gcmFuZ2VzW2pdLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB0bXBSYW5nZS5zZXRTdGFydEFmdGVyKHVuZWRpdGFibGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICB0bXBSYW5nZXMucHVzaCh0bXBSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGFsbCBvdGhlciBjYXNlcyB1bmVkaXRhYmxlIGRvZXMgbm90IHRvdWNoIHNlbGVjdGlvbi4gZG9udCBtb2RpZnlcbiAgICAgICAgICAgICAgICAgICAgICB0bXBSYW5nZXMucHVzaChyYW5nZXNbal0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYW5nZXMgPSB0bXBSYW5nZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmdldFNlbGVjdGlvbih0aGlzLmRvYy5kZWZhdWx0VmlldyB8fCB0aGlzLmRvYy5wYXJlbnRXaW5kb3cpO1xuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICB2YXIgd2luICAgICAgID0gdGhpcy5kb2MuZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2MucGFyZW50V2luZG93LFxuICAgICAgICAgIHNlbGVjdGlvbiA9IHJhbmd5LmdldFNlbGVjdGlvbih3aW4pO1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbi5zZXRTaW5nbGVSYW5nZShyYW5nZSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgfSxcblxuICAgIGlzQ29sbGFwc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uKCkuaXNDb2xsYXBzZWQ7XG4gICAgfSxcblxuICAgIGdldEh0bWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uKCkudG9IdG1sKCk7XG4gICAgfSxcblxuICAgIGlzRW5kVG9FbmRJbk5vZGU6IGZ1bmN0aW9uKG5vZGVOYW1lcykge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpLFxuICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcixcbiAgICAgICAgICBzdGFydE5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICBlbmROb2RlID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xuXG5cbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0Tm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiAhKC9eXFxzKiQvKS50ZXN0KHN0YXJ0Tm9kZS5kYXRhLnN1YnN0cihyYW5nZS5zdGFydE9mZnNldCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZE5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUgJiYgISgvXlxccyokLykudGVzdChlbmROb2RlLmRhdGEuc3Vic3RyKHJhbmdlLmVuZE9mZnNldCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0Tm9kZSAmJiBzdGFydE5vZGUgIT09IHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoc3RhcnROb2RlLm5vZGVUeXBlICE9PSB3eXNpaHRtbDUuVEVYVF9OT0RFICYmICF3eXNpaHRtbDUuZG9tLmNvbnRhaW5zKHBhcmVudEVsZW1lbnQsIHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHd5c2lodG1sNS5kb20uZG9tTm9kZShzdGFydE5vZGUpLnByZXYoe2lnbm9yZUJsYW5rVGV4dHM6IHRydWV9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChlbmROb2RlICYmIGVuZE5vZGUgIT09IHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZW5kTm9kZS5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiAhd3lzaWh0bWw1LmRvbS5jb250YWlucyhwYXJlbnRFbGVtZW50LCBlbmROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod3lzaWh0bWw1LmRvbS5kb21Ob2RlKGVuZE5vZGUpLm5leHQoe2lnbm9yZUJsYW5rVGV4dHM6IHRydWV9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmROb2RlID0gZW5kTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh3eXNpaHRtbDUubGFuZy5hcnJheShub2RlTmFtZXMpLmNvbnRhaW5zKHBhcmVudEVsZW1lbnQubm9kZU5hbWUpKSA/IHBhcmVudEVsZW1lbnQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBzZWwgJiYgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgfSk7XG5cbn0pKHd5c2lodG1sNSk7XG47LyoqXG4gKiBJbnNwaXJlZCBieSB0aGUgcmFuZ3kgQ1NTIEFwcGxpZXIgbW9kdWxlIHdyaXR0ZW4gYnkgVGltIERvd24gYW5kIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9yYW5neS9cbiAqXG4gKiBjaGFuZ2VkIGluIG9yZGVyIHRvIGJlIGFibGUgLi4uXG4gKiAgICAtIHRvIHVzZSBjdXN0b20gdGFnc1xuICogICAgLSB0byBkZXRlY3QgYW5kIHJlcGxhY2Ugc2ltaWxhciBjc3MgY2xhc3NlcyB2aWEgcmVnIGV4cFxuICovXG4oZnVuY3Rpb24od3lzaWh0bWw1LCByYW5neSkge1xuICB2YXIgZGVmYXVsdFRhZ05hbWUgPSBcInNwYW5cIjtcblxuICB2YXIgUkVHX0VYUF9XSElURV9TUEFDRSA9IC9cXHMrL2c7XG5cbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNzc0NsYXNzLCByZWdFeHApIHtcbiAgICBpZiAoIWVsLmNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGluZ0NsYXNzTmFtZXMgPSBlbC5jbGFzc05hbWUubWF0Y2gocmVnRXhwKSB8fCBbXTtcbiAgICByZXR1cm4gbWF0Y2hpbmdDbGFzc05hbWVzW21hdGNoaW5nQ2xhc3NOYW1lcy5sZW5ndGggLSAxXSA9PT0gY3NzQ2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNTdHlsZUF0dHIoZWwsIHJlZ0V4cCkge1xuICAgIGlmICghZWwuZ2V0QXR0cmlidXRlIHx8ICFlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoaW5nU3R5bGVzID0gZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpLm1hdGNoKHJlZ0V4cCk7XG4gICAgcmV0dXJuICAoZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpLm1hdGNoKHJlZ0V4cCkpID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGUoZWwsIGNzc1N0eWxlLCByZWdFeHApIHtcbiAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICByZW1vdmVTdHlsZShlbCwgcmVnRXhwKTtcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgJiYgISgvXlxccyokLykudGVzdChlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBjc3NTdHlsZSArIFwiO1wiICsgZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBjc3NTdHlsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBjc3NTdHlsZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNzc0NsYXNzLCByZWdFeHApIHtcbiAgICBpZiAoZWwuY2xhc3NOYW1lKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbCwgcmVnRXhwKTtcbiAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIiArIGNzc0NsYXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSBjc3NDbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgcmVnRXhwKSB7XG4gICAgaWYgKGVsLmNsYXNzTmFtZSkge1xuICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UocmVnRXhwLCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTdHlsZShlbCwgcmVnRXhwKSB7XG4gICAgdmFyIHMsXG4gICAgICAgIHMyID0gW107XG4gICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgcyA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5zcGxpdCgnOycpO1xuICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGlmICghc1tpXS5tYXRjaChyZWdFeHApICYmICEoL15cXHMqJC8pLnRlc3Qoc1tpXSkpIHtcbiAgICAgICAgICBzMi5wdXNoKHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczIubGVuZ3RoKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzMi5qb2luKCc7JykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoaW5nU3R5bGVSZWdleHAoZWwsIHN0eWxlKSB7XG4gICAgdmFyIHJlZ2V4ZXMgPSBbXSxcbiAgICAgICAgc1NwbGl0ID0gc3R5bGUuc3BsaXQoJzsnKSxcbiAgICAgICAgZWxTdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgIGlmIChlbFN0eWxlKSB7XG4gICAgICBlbFN0eWxlID0gZWxTdHlsZS5yZXBsYWNlKC9cXHMvZ2ksICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmVnZXhlcy5wdXNoKG5ldyBSZWdFeHAoXCIoXnxcXFxcc3w7KVwiICsgc3R5bGUucmVwbGFjZSgvXFxzL2dpLCAnJykucmVwbGFjZSgvKFtcXChcXCldKS9naSwgXCJcXFxcJDFcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFwiO1wiLCBcIjs/XCIpLnJlcGxhY2UoL3JnYlxcXFxcXCgoXFxkKyksKFxcZCspLChcXGQrKVxcXFxcXCkvZ2ksIFwiXFxcXHM/cmdiXFxcXCgkMSxcXFxccz8kMixcXFxccz8kM1xcXFwpXCIpLCBcImdpXCIpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHNTcGxpdC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICAgIGlmICghKC9eXFxzKiQvKS50ZXN0KHNTcGxpdFtpXSkpIHtcbiAgICAgICAgICByZWdleGVzLnB1c2gobmV3IFJlZ0V4cChcIihefFxcXFxzfDspXCIgKyBzU3BsaXRbaV0ucmVwbGFjZSgvXFxzL2dpLCAnJykucmVwbGFjZSgvKFtcXChcXCldKS9naSwgXCJcXFxcJDFcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFwiO1wiLCBcIjs/XCIpLnJlcGxhY2UoL3JnYlxcXFxcXCgoXFxkKyksKFxcZCspLChcXGQrKVxcXFxcXCkvZ2ksIFwiXFxcXHM/cmdiXFxcXCgkMSxcXFxccz8kMixcXFxccz8kM1xcXFwpXCIpLCBcImdpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptYXggPSByZWdleGVzLmxlbmd0aDsgaiA8IGptYXg7IGorKykge1xuICAgICAgICBpZiAoZWxTdHlsZS5tYXRjaChyZWdleGVzW2pdKSkge1xuICAgICAgICAgIHJldHVybiByZWdleGVzW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNYXRjaGluZ0FsbHJlYWR5KG5vZGUsIHRhZ3MsIHN0eWxlLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiBnZXRNYXRjaGluZ1N0eWxlUmVnZXhwKG5vZGUsIHN0eWxlKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5kb20uaGFzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRhZ3MsIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhcmVNYXRjaGluZ0FsbHJlYWR5KG5vZGVzLCB0YWdzLCBzdHlsZSwgY2xhc3NOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgaWYgKCFpc01hdGNoaW5nQWxscmVhZHkobm9kZXNbaV0sIHRhZ3MsIHN0eWxlLCBjbGFzc05hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA/IHRydWUgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU9yQ2hhbmdlU3R5bGUoZWwsIHN0eWxlLCByZWdFeHApIHtcblxuICAgIHZhciBleGFjdFJlZ2V4ID0gZ2V0TWF0Y2hpbmdTdHlsZVJlZ2V4cChlbCwgc3R5bGUpO1xuICAgIGlmIChleGFjdFJlZ2V4KSB7XG4gICAgICAvLyBhZGRpbmcgc2FtZSBzdHlsZSB2YWx1ZSBvbiBwcm9wZXJ0eSBhZ2FpbiByZW1vdmVzIHN0eWxlXG4gICAgICByZW1vdmVTdHlsZShlbCwgZXhhY3RSZWdleCk7XG4gICAgICByZXR1cm4gXCJyZW1vdmVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWRkaW5nIG5ldyBzdHlsZSB2YWx1ZSBjaGFuZ2VzIHZhbHVlXG4gICAgICBhZGRTdHlsZShlbCwgc3R5bGUsIHJlZ0V4cCk7XG4gICAgICByZXR1cm4gXCJjaGFuZ2VcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNTYW1lQ2xhc3NlcyhlbDEsIGVsMikge1xuICAgIHJldHVybiBlbDEuY2xhc3NOYW1lLnJlcGxhY2UoUkVHX0VYUF9XSElURV9TUEFDRSwgXCIgXCIpID09IGVsMi5jbGFzc05hbWUucmVwbGFjZShSRUdfRVhQX1dISVRFX1NQQUNFLCBcIiBcIik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlV2l0aE93bkNoaWxkcmVuKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCwgZWwpO1xuICAgIH1cbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWxlbWVudHNIYXZlU2FtZU5vbkNsYXNzQXR0cmlidXRlcyhlbDEsIGVsMikge1xuICAgIGlmIChlbDEuYXR0cmlidXRlcy5sZW5ndGggIT0gZWwyLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbDEuYXR0cmlidXRlcy5sZW5ndGgsIGF0dHIxLCBhdHRyMiwgbmFtZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhdHRyMSA9IGVsMS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgbmFtZSA9IGF0dHIxLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIpIHtcbiAgICAgICAgYXR0cjIgPSBlbDIuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obmFtZSk7XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgIT0gYXR0cjIuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgJiYgYXR0cjEubm9kZVZhbHVlICE9PSBhdHRyMi5ub2RlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NwbGl0UG9pbnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKHJhbmd5LmRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAob2Zmc2V0ID09IDApIHtcbiAgICAgICAgcmV0dXJuICEhbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSBub2RlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gISFub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCA+IDAgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Tm9kZUF0KG5vZGUsIGRlc2NlbmRhbnROb2RlLCBkZXNjZW5kYW50T2Zmc2V0LCBjb250YWluZXIpIHtcbiAgICB2YXIgbmV3Tm9kZTtcbiAgICBpZiAocmFuZ3kuZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoZGVzY2VuZGFudE5vZGUpKSB7XG4gICAgICBpZiAoZGVzY2VuZGFudE9mZnNldCA9PSAwKSB7XG4gICAgICAgIGRlc2NlbmRhbnRPZmZzZXQgPSByYW5neS5kb20uZ2V0Tm9kZUluZGV4KGRlc2NlbmRhbnROb2RlKTtcbiAgICAgICAgZGVzY2VuZGFudE5vZGUgPSBkZXNjZW5kYW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfSBlbHNlIGlmIChkZXNjZW5kYW50T2Zmc2V0ID09IGRlc2NlbmRhbnROb2RlLmxlbmd0aCkge1xuICAgICAgICBkZXNjZW5kYW50T2Zmc2V0ID0gcmFuZ3kuZG9tLmdldE5vZGVJbmRleChkZXNjZW5kYW50Tm9kZSkgKyAxO1xuICAgICAgICBkZXNjZW5kYW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2RlID0gcmFuZ3kuZG9tLnNwbGl0RGF0YU5vZGUoZGVzY2VuZGFudE5vZGUsIGRlc2NlbmRhbnRPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5ld05vZGUpIHtcbiAgICAgIGlmICghY29udGFpbmVyIHx8IGRlc2NlbmRhbnROb2RlICE9PSBjb250YWluZXIpIHtcblxuICAgICAgICBuZXdOb2RlID0gZGVzY2VuZGFudE5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgaWYgKG5ld05vZGUuaWQpIHtcbiAgICAgICAgICBuZXdOb2RlLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgd2hpbGUgKChjaGlsZCA9IGRlc2NlbmRhbnROb2RlLmNoaWxkTm9kZXNbZGVzY2VuZGFudE9mZnNldF0pKSB7XG4gICAgICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ3kuZG9tLmluc2VydEFmdGVyKG5ld05vZGUsIGRlc2NlbmRhbnROb2RlKTtcblxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGRlc2NlbmRhbnROb2RlID09IG5vZGUpID8gbmV3Tm9kZSA6ICBzcGxpdE5vZGVBdChub2RlLCBuZXdOb2RlLnBhcmVudE5vZGUsIHJhbmd5LmRvbS5nZXROb2RlSW5kZXgobmV3Tm9kZSksIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBNZXJnZShmaXJzdE5vZGUpIHtcbiAgICB0aGlzLmlzRWxlbWVudE1lcmdlID0gKGZpcnN0Tm9kZS5ub2RlVHlwZSA9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFKTtcbiAgICB0aGlzLmZpcnN0VGV4dE5vZGUgPSB0aGlzLmlzRWxlbWVudE1lcmdlID8gZmlyc3ROb2RlLmxhc3RDaGlsZCA6IGZpcnN0Tm9kZTtcbiAgICB0aGlzLnRleHROb2RlcyA9IFt0aGlzLmZpcnN0VGV4dE5vZGVdO1xuICB9XG5cbiAgTWVyZ2UucHJvdG90eXBlID0ge1xuICAgIGRvTWVyZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRleHRCaXRzID0gW10sIHRleHROb2RlLCBwYXJlbnQsIHRleHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy50ZXh0Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGV4dE5vZGUgPSB0aGlzLnRleHROb2Rlc1tpXTtcbiAgICAgICAgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgdGV4dEJpdHNbaV0gPSB0ZXh0Tm9kZS5kYXRhO1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgaWYgKCFwYXJlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5maXJzdFRleHROb2RlLmRhdGEgPSB0ZXh0ID0gdGV4dEJpdHMuam9pbihcIlwiKTtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnRleHROb2Rlcy5sZW5ndGgsIGxlbiA9IDA7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGxlbiArPSB0aGlzLnRleHROb2Rlc1tpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGV4dEJpdHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Qml0c1tpXSA9IFwiJ1wiICsgdGhpcy50ZXh0Tm9kZXNbaV0uZGF0YSArIFwiJ1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiW01lcmdlKFwiICsgdGV4dEJpdHMuam9pbihcIixcIikgKyBcIildXCI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhUTUxBcHBsaWVyKHRhZ05hbWVzLCBjc3NDbGFzcywgc2ltaWxhckNsYXNzUmVnRXhwLCBub3JtYWxpemUsIGNzc1N0eWxlLCBzaW1pbGFyU3R5bGVSZWdFeHAsIGNvbnRhaW5lcikge1xuICAgIHRoaXMudGFnTmFtZXMgPSB0YWdOYW1lcyB8fCBbZGVmYXVsdFRhZ05hbWVdO1xuICAgIHRoaXMuY3NzQ2xhc3MgPSBjc3NDbGFzcyB8fCAoKGNzc0NsYXNzID09PSBmYWxzZSkgPyBmYWxzZSA6IFwiXCIpO1xuICAgIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwID0gc2ltaWxhckNsYXNzUmVnRXhwO1xuICAgIHRoaXMuY3NzU3R5bGUgPSBjc3NTdHlsZSB8fCBcIlwiO1xuICAgIHRoaXMuc2ltaWxhclN0eWxlUmVnRXhwID0gc2ltaWxhclN0eWxlUmVnRXhwO1xuICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuICAgIHRoaXMuYXBwbHlUb0FueVRhZ05hbWUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIEhUTUxBcHBsaWVyLnByb3RvdHlwZSA9IHtcbiAgICBnZXRBbmNlc3RvcldpdGhDbGFzczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNzc0NsYXNzTWF0Y2g7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjc3NDbGFzc01hdGNoID0gdGhpcy5jc3NDbGFzcyA/IGhhc0NsYXNzKG5vZGUsIHRoaXMuY3NzQ2xhc3MsIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwKSA6ICh0aGlzLmNzc1N0eWxlICE9PSBcIlwiKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSAmJiBub2RlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPSBcImZhbHNlXCIgJiYgIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiBjc3NDbGFzc01hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJucyBwYXJlbnRzIG9mIG5vZGUgd2l0aCBnaXZlbiBzdHlsZSBhdHRyaWJ1dGVcbiAgICBnZXRBbmNlc3RvcldpdGhTdHlsZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNzc1N0eWxlTWF0Y2g7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjc3NTdHlsZU1hdGNoID0gdGhpcy5jc3NTdHlsZSA/IGhhc1N0eWxlQXR0cihub2RlLCB0aGlzLnNpbWlsYXJTdHlsZVJlZ0V4cCkgOiBmYWxzZTtcblxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9IFwiZmFsc2VcIiAmJiByYW5neS5kb20uYXJyYXlDb250YWlucyh0aGlzLnRhZ05hbWVzLCBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgY3NzU3R5bGVNYXRjaCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGdldE1hdGNoaW5nQW5jZXN0b3I6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHRoaXMuZ2V0QW5jZXN0b3JXaXRoQ2xhc3Mobm9kZSksXG4gICAgICAgICAgbWF0Y2hUeXBlID0gZmFsc2U7XG5cbiAgICAgIGlmICghYW5jZXN0b3IpIHtcbiAgICAgICAgYW5jZXN0b3IgPSB0aGlzLmdldEFuY2VzdG9yV2l0aFN0eWxlKG5vZGUpO1xuICAgICAgICBpZiAoYW5jZXN0b3IpIHtcbiAgICAgICAgICBtYXRjaFR5cGUgPSBcInN0eWxlXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmNzc1N0eWxlKSB7XG4gICAgICAgICAgbWF0Y2hUeXBlID0gXCJjbGFzc1wiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwiZWxlbWVudFwiOiBhbmNlc3RvcixcbiAgICAgICAgXCJ0eXBlXCI6IG1hdGNoVHlwZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gTm9ybWFsaXplcyBub2RlcyBhZnRlciBhcHBseWluZyBhIENTUyBjbGFzcyB0byBhIFJhbmdlLlxuICAgIHBvc3RBcHBseTogZnVuY3Rpb24odGV4dE5vZGVzLCByYW5nZSkge1xuICAgICAgdmFyIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXSwgbGFzdE5vZGUgPSB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICB2YXIgbWVyZ2VzID0gW10sIGN1cnJlbnRNZXJnZTtcblxuICAgICAgdmFyIHJhbmdlU3RhcnROb2RlID0gZmlyc3ROb2RlLCByYW5nZUVuZE5vZGUgPSBsYXN0Tm9kZTtcbiAgICAgIHZhciByYW5nZVN0YXJ0T2Zmc2V0ID0gMCwgcmFuZ2VFbmRPZmZzZXQgPSBsYXN0Tm9kZS5sZW5ndGg7XG5cbiAgICAgIHZhciB0ZXh0Tm9kZSwgcHJlY2VkaW5nVGV4dE5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbaV07XG4gICAgICAgIHByZWNlZGluZ1RleHROb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwcmVjZWRpbmdUZXh0Tm9kZSA9IHRoaXMuZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZSh0ZXh0Tm9kZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWNlZGluZ1RleHROb2RlKSB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50TWVyZ2UpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNZXJnZSA9IG5ldyBNZXJnZShwcmVjZWRpbmdUZXh0Tm9kZSk7XG4gICAgICAgICAgICBtZXJnZXMucHVzaChjdXJyZW50TWVyZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50TWVyZ2UudGV4dE5vZGVzLnB1c2godGV4dE5vZGUpO1xuICAgICAgICAgIGlmICh0ZXh0Tm9kZSA9PT0gZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0Tm9kZSA9IGN1cnJlbnRNZXJnZS5maXJzdFRleHROb2RlO1xuICAgICAgICAgICAgcmFuZ2VTdGFydE9mZnNldCA9IHJhbmdlU3RhcnROb2RlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHROb2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgcmFuZ2VFbmROb2RlID0gY3VycmVudE1lcmdlLmZpcnN0VGV4dE5vZGU7XG4gICAgICAgICAgICByYW5nZUVuZE9mZnNldCA9IGN1cnJlbnRNZXJnZS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE1lcmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVGVzdCB3aGV0aGVyIHRoZSBmaXJzdCBub2RlIGFmdGVyIHRoZSByYW5nZSBuZWVkcyBtZXJnaW5nXG4gICAgICBpZihsYXN0Tm9kZSAmJiBsYXN0Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBuZXh0VGV4dE5vZGUgPSB0aGlzLmdldEFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGUobGFzdE5vZGUucGFyZW50Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChuZXh0VGV4dE5vZGUpIHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRNZXJnZSkge1xuICAgICAgICAgICAgY3VycmVudE1lcmdlID0gbmV3IE1lcmdlKGxhc3ROb2RlKTtcbiAgICAgICAgICAgIG1lcmdlcy5wdXNoKGN1cnJlbnRNZXJnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXMucHVzaChuZXh0VGV4dE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBEbyB0aGUgbWVyZ2VzXG4gICAgICBpZiAobWVyZ2VzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBtZXJnZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBtZXJnZXNbaV0uZG9NZXJnZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgcmFuZ2UgYm91bmRhcmllc1xuICAgICAgICByYW5nZS5zZXRTdGFydChyYW5nZVN0YXJ0Tm9kZSwgcmFuZ2VTdGFydE9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChyYW5nZUVuZE5vZGUsIHJhbmdlRW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZTogZnVuY3Rpb24obm9kZSwgZm9yd2FyZCkge1xuICAgICAgICB2YXIgaXNUZXh0Tm9kZSA9IChub2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5URVhUX05PREUpO1xuICAgICAgICB2YXIgZWwgPSBpc1RleHROb2RlID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZTtcbiAgICAgICAgdmFyIGFkamFjZW50Tm9kZTtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCI7XG4gICAgICAgIGlmIChpc1RleHROb2RlKSB7XG4gICAgICAgICAgLy8gQ2FuIG1lcmdlIGlmIHRoZSBub2RlJ3MgcHJldmlvdXMvbmV4dCBzaWJsaW5nIGlzIGEgdGV4dCBub2RlXG4gICAgICAgICAgYWRqYWNlbnROb2RlID0gbm9kZVtwcm9wTmFtZV07XG4gICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSAmJiBhZGphY2VudE5vZGUubm9kZVR5cGUgPT0gd3lzaWh0bWw1LlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuIGFkamFjZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ29tcGFyZSBlbGVtZW50IHdpdGggaXRzIHNpYmxpbmdcbiAgICAgICAgICBhZGphY2VudE5vZGUgPSBlbFtwcm9wTmFtZV07XG4gICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSAmJiB0aGlzLmFyZUVsZW1lbnRzTWVyZ2VhYmxlKG5vZGUsIGFkamFjZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGphY2VudE5vZGVbZm9yd2FyZCA/IFwiZmlyc3RDaGlsZFwiIDogXCJsYXN0Q2hpbGRcIl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBhcmVFbGVtZW50c01lcmdlYWJsZTogZnVuY3Rpb24oZWwxLCBlbDIpIHtcbiAgICAgIHJldHVybiByYW5neS5kb20uYXJyYXlDb250YWlucyh0aGlzLnRhZ05hbWVzLCAoZWwxLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgJiYgcmFuZ3kuZG9tLmFycmF5Q29udGFpbnModGhpcy50YWdOYW1lcywgKGVsMi50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICYmIGhhc1NhbWVDbGFzc2VzKGVsMSwgZWwyKVxuICAgICAgICAmJiBlbGVtZW50c0hhdmVTYW1lTm9uQ2xhc3NBdHRyaWJ1dGVzKGVsMSwgZWwyKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZXNbMF0pO1xuICAgICAgaWYgKHRoaXMuY3NzQ2xhc3MpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdGhpcy5jc3NDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNzc1N0eWxlKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0aGlzLmNzc1N0eWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1RleHROb2RlOiBmdW5jdGlvbih0ZXh0Tm9kZSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgcmFuZ3kuZG9tLmFycmF5Q29udGFpbnModGhpcy50YWdOYW1lcywgcGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5jc3NDbGFzcykge1xuICAgICAgICAgIGFkZENsYXNzKHBhcmVudCwgdGhpcy5jc3NDbGFzcywgdGhpcy5zaW1pbGFyQ2xhc3NSZWdFeHApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNzc1N0eWxlKSB7XG4gICAgICAgICAgYWRkU3R5bGUocGFyZW50LCB0aGlzLmNzc1N0eWxlLCB0aGlzLnNpbWlsYXJTdHlsZVJlZ0V4cCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKHJhbmd5LmRvbS5nZXREb2N1bWVudCh0ZXh0Tm9kZSkpO1xuICAgICAgICB0ZXh0Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGV4dE5vZGUpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzUmVtb3ZhYmxlOiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAgICAgICAgICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGVsLmNsYXNzTmFtZSkudHJpbSgpID09PSBcIlwiICYmXG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAhZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8XG4gICAgICAgICAgICAgICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkudHJpbSgpID09PSBcIlwiXG4gICAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIHVuZG9Ub1RleHROb2RlOiBmdW5jdGlvbih0ZXh0Tm9kZSwgcmFuZ2UsIGFuY2VzdG9yV2l0aENsYXNzLCBhbmNlc3RvcldpdGhTdHlsZSkge1xuICAgICAgdmFyIHN0eWxlTW9kZSA9IChhbmNlc3RvcldpdGhDbGFzcykgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3RvcldpdGhDbGFzcyB8fCBhbmNlc3RvcldpdGhTdHlsZSxcbiAgICAgICAgICBzdHlsZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGlmICghcmFuZ2UuY29udGFpbnNOb2RlKGFuY2VzdG9yKSkge1xuICAgICAgICAvLyBTcGxpdCBvdXQgdGhlIHBvcnRpb24gb2YgdGhlIGFuY2VzdG9yIGZyb20gd2hpY2ggd2UgY2FuIHJlbW92ZSB0aGUgQ1NTIGNsYXNzXG4gICAgICAgIHZhciBhbmNlc3RvclJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgYW5jZXN0b3JSYW5nZS5zZWxlY3ROb2RlKGFuY2VzdG9yKTtcblxuICAgICAgICBpZiAoYW5jZXN0b3JSYW5nZS5pc1BvaW50SW5SYW5nZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkgJiYgaXNTcGxpdFBvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KSkge1xuICAgICAgICAgICAgc3BsaXROb2RlQXQoYW5jZXN0b3IsIHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0LCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihhbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2VzdG9yUmFuZ2UuaXNQb2ludEluUmFuZ2UocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSAmJiBpc1NwbGl0UG9pbnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSkge1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBzcGxpdE5vZGVBdChhbmNlc3RvciwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFzdHlsZU1vZGUgJiYgdGhpcy5zaW1pbGFyQ2xhc3NSZWdFeHApIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoYW5jZXN0b3IsIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlTW9kZSAmJiB0aGlzLnNpbWlsYXJTdHlsZVJlZ0V4cCkge1xuICAgICAgICBzdHlsZUNoYW5nZWQgPSAocmVtb3ZlT3JDaGFuZ2VTdHlsZShhbmNlc3RvciwgdGhpcy5jc3NTdHlsZSwgdGhpcy5zaW1pbGFyU3R5bGVSZWdFeHApID09PSBcImNoYW5nZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzUmVtb3ZhYmxlKGFuY2VzdG9yKSAmJiAhc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgIHJlcGxhY2VXaXRoT3duQ2hpbGRyZW4oYW5jZXN0b3IpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZXM7XG4gICAgICAgIGZvciAodmFyIHJpID0gcmFuZ2UubGVuZ3RoOyByaS0tOykge1xuICAgICAgICAgICAgdGV4dE5vZGVzID0gcmFuZ2VbcmldLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG5cbiAgICAgICAgICAgIGlmICghdGV4dE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVDb250YWluZXIocmFuZ2VbcmldLmVuZENvbnRhaW5lci5vd25lckRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICByYW5nZVtyaV0uc3Vycm91bmRDb250ZW50cyhub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGUocmFuZ2VbcmldLCBub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFuZ2VbcmldLnNwbGl0Qm91bmRhcmllcygpO1xuICAgICAgICAgICAgdGV4dE5vZGVzID0gcmFuZ2VbcmldLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG4gICAgICAgICAgICBpZiAodGV4dE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdGV4dE5vZGU7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRNYXRjaGluZ0FuY2VzdG9yKHRleHROb2RlKS5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VG9UZXh0Tm9kZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmFuZ2VbcmldLnNldFN0YXJ0KHRleHROb2Rlc1swXSwgMCk7XG4gICAgICAgICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgcmFuZ2VbcmldLnNldEVuZCh0ZXh0Tm9kZSwgdGV4dE5vZGUubGVuZ3RoKTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RBcHBseSh0ZXh0Tm9kZXMsIHJhbmdlW3JpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVuZG9Ub1JhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgdmFyIHRleHROb2RlcywgdGV4dE5vZGUsIGFuY2VzdG9yV2l0aENsYXNzLCBhbmNlc3RvcldpdGhTdHlsZSwgYW5jZXN0b3I7XG4gICAgICBmb3IgKHZhciByaSA9IHJhbmdlLmxlbmd0aDsgcmktLTspIHtcblxuICAgICAgICAgIHRleHROb2RlcyA9IHJhbmdlW3JpXS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuICAgICAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZVtyaV0uc3BsaXRCb3VuZGFyaWVzKCk7XG4gICAgICAgICAgICB0ZXh0Tm9kZXMgPSByYW5nZVtyaV0uZ2V0Tm9kZXMoW3d5c2lodG1sNS5URVhUX05PREVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHJhbmdlW3JpXS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpO1xuICAgICAgICAgICAgcmFuZ2VbcmldLmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgICAgICByYW5nZVtyaV0uc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICAgIHRleHROb2RlcyA9IFtub2RlXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VbcmldLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcblxuICAgICAgICAgICAgICBhbmNlc3RvciA9IHRoaXMuZ2V0TWF0Y2hpbmdBbmNlc3Rvcih0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgIGlmIChhbmNlc3Rvci50eXBlID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZG9Ub1RleHROb2RlKHRleHROb2RlLCByYW5nZVtyaV0sIGZhbHNlLCBhbmNlc3Rvci5lbGVtZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNlc3Rvci5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmRvVG9UZXh0Tm9kZSh0ZXh0Tm9kZSwgcmFuZ2VbcmldLCBhbmNlc3Rvci5lbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW4gPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlKHJhbmdlW3JpXSwgdGV4dE5vZGVzWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VbcmldLnNldFN0YXJ0KHRleHROb2Rlc1swXSwgMCk7XG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByYW5nZVtyaV0uc2V0RW5kKHRleHROb2RlLCB0ZXh0Tm9kZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgdGhpcy5wb3N0QXBwbHkodGV4dE5vZGVzLCByYW5nZVtyaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3ROb2RlOiBmdW5jdGlvbihyYW5nZSwgbm9kZSkge1xuICAgICAgdmFyIGlzRWxlbWVudCAgICAgICA9IG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUsXG4gICAgICAgICAgY2FuSGF2ZUhUTUwgICAgID0gXCJjYW5IYXZlSFRNTFwiIGluIG5vZGUgPyBub2RlLmNhbkhhdmVIVE1MIDogdHJ1ZSxcbiAgICAgICAgICBjb250ZW50ICAgICAgICAgPSBpc0VsZW1lbnQgPyBub2RlLmlubmVySFRNTCA6IG5vZGUuZGF0YSxcbiAgICAgICAgICBpc0VtcHR5ICAgICAgICAgPSAoY29udGVudCA9PT0gXCJcIiB8fCBjb250ZW50ID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKTtcblxuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50ICYmIGNhbkhhdmVIVE1MKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNhcmV0IGlzIHZpc2libGUgaW4gbm9kZSBieSBpbnNlcnRpbmcgYSB6ZXJvIHdpZHRoIG5vIGJyZWFraW5nIHNwYWNlXG4gICAgICAgIHRyeSB7IG5vZGUuaW5uZXJIVE1MID0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRTsgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50KSB7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFbXB0eSkge1xuICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VGV4dFNlbGVjdGVkQnlSYW5nZTogZnVuY3Rpb24odGV4dE5vZGUsIHJhbmdlKSB7XG4gICAgICB2YXIgdGV4dFJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgdGV4dFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXh0Tm9kZSk7XG5cbiAgICAgIHZhciBpbnRlcnNlY3Rpb25SYW5nZSA9IHRleHRSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UpO1xuICAgICAgdmFyIHRleHQgPSBpbnRlcnNlY3Rpb25SYW5nZSA/IGludGVyc2VjdGlvblJhbmdlLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgdGV4dFJhbmdlLmRldGFjaCgpO1xuXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9LFxuXG4gICAgaXNBcHBsaWVkVG9SYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgIHZhciBhbmNlc3RvcnMgPSBbXSxcbiAgICAgICAgICBhcHBsaWVkVHlwZSA9IFwiZnVsbFwiLFxuICAgICAgICAgIGFuY2VzdG9yLCBzdHlsZUFuY2VzdG9yLCB0ZXh0Tm9kZXM7XG5cbiAgICAgIGZvciAodmFyIHJpID0gcmFuZ2UubGVuZ3RoOyByaS0tOykge1xuXG4gICAgICAgIHRleHROb2RlcyA9IHJhbmdlW3JpXS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuICAgICAgICBpZiAoIXRleHROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhbmNlc3RvciA9IHRoaXMuZ2V0TWF0Y2hpbmdBbmNlc3RvcihyYW5nZVtyaV0uc3RhcnRDb250YWluZXIpLmVsZW1lbnQ7XG5cbiAgICAgICAgICByZXR1cm4gKGFuY2VzdG9yKSA/IHtcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjogW2FuY2VzdG9yXSxcbiAgICAgICAgICAgIFwiY292ZXJhZ2VcIjogYXBwbGllZFR5cGVcbiAgICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dE5vZGVzLmxlbmd0aCwgc2VsZWN0ZWRUZXh0OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFRleHRTZWxlY3RlZEJ5UmFuZ2UodGV4dE5vZGVzW2ldLCByYW5nZVtyaV0pO1xuICAgICAgICAgIGFuY2VzdG9yID0gdGhpcy5nZXRNYXRjaGluZ0FuY2VzdG9yKHRleHROb2Rlc1tpXSkuZWxlbWVudDtcbiAgICAgICAgICBpZiAoYW5jZXN0b3IgJiYgc2VsZWN0ZWRUZXh0ICE9IFwiXCIpIHtcbiAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcblxuICAgICAgICAgICAgaWYgKHd5c2lodG1sNS5kb20uZ2V0VGV4dE5vZGVzKGFuY2VzdG9yLCB0cnVlKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgYXBwbGllZFR5cGUgPSBcImZ1bGxcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZFR5cGUgPT09IFwiZnVsbFwiKSB7XG4gICAgICAgICAgICAgIGFwcGxpZWRUeXBlID0gXCJpbmxpbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgICAgICAgYXBwbGllZFR5cGUgPSBcInBhcnRpYWxcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKGFuY2VzdG9ycy5sZW5ndGgpID8ge1xuICAgICAgICBcImVsZW1lbnRzXCI6IGFuY2VzdG9ycyxcbiAgICAgICAgXCJjb3ZlcmFnZVwiOiBhcHBsaWVkVHlwZVxuICAgICAgfSA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICB0b2dnbGVSYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgIHZhciBpc0FwcGxpZWQgPSB0aGlzLmlzQXBwbGllZFRvUmFuZ2UocmFuZ2UpLFxuICAgICAgICAgIHBhcmVudHNFeGFjdE1hdGNoO1xuXG4gICAgICBpZiAoaXNBcHBsaWVkKSB7XG4gICAgICAgIGlmIChpc0FwcGxpZWQuY292ZXJhZ2UgPT09IFwiZnVsbFwiKSB7XG4gICAgICAgICAgdGhpcy51bmRvVG9SYW5nZShyYW5nZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcHBsaWVkLmNvdmVyYWdlID09PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgcGFyZW50c0V4YWN0TWF0Y2ggPSBhcmVNYXRjaGluZ0FsbHJlYWR5KGlzQXBwbGllZC5lbGVtZW50cywgdGhpcy50YWdOYW1lcywgdGhpcy5jc3NTdHlsZSwgdGhpcy5jc3NDbGFzcyk7XG4gICAgICAgICAgdGhpcy51bmRvVG9SYW5nZShyYW5nZSk7XG4gICAgICAgICAgaWYgKCFwYXJlbnRzRXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVRvUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwYXJ0aWFsXG4gICAgICAgICAgaWYgKCFhcmVNYXRjaGluZ0FsbHJlYWR5KGlzQXBwbGllZC5lbGVtZW50cywgdGhpcy50YWdOYW1lcywgdGhpcy5jc3NTdHlsZSwgdGhpcy5jc3NDbGFzcykpIHtcbiAgICAgICAgICAgIHRoaXMudW5kb1RvUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGx5VG9SYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUb1JhbmdlKHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd3lzaWh0bWw1LnNlbGVjdGlvbi5IVE1MQXBwbGllciA9IEhUTUxBcHBsaWVyO1xuXG59KSh3eXNpaHRtbDUsIHJhbmd5KTtcbjsvKipcbiAqIFJpY2ggVGV4dCBRdWVyeS9Gb3JtYXR0aW5nIENvbW1hbmRzXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHZhciBjb21tYW5kcyA9IG5ldyB3eXNpaHRtbDUuQ29tbWFuZHMoZWRpdG9yKTtcbiAqL1xud3lzaWh0bWw1LkNvbW1hbmRzID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LkNvbW1hbmRzLnByb3RvdHlwZSAqLyB7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciAgID0gZWRpdG9yO1xuICAgIHRoaXMuY29tcG9zZXIgPSBlZGl0b3IuY29tcG9zZXI7XG4gICAgdGhpcy5kb2MgICAgICA9IHRoaXMuY29tcG9zZXIuZG9jO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBnaXZlbiBjb21tYW5kXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBjb21tYW5kIHN0cmluZyB3aGljaCB0byBjaGVjayAoZWcuIFwiYm9sZFwiLCBcIml0YWxpY1wiLCBcImluc2VydFVub3JkZXJlZExpc3RcIilcbiAgICogQGV4YW1wbGVcbiAgICogICAgY29tbWFuZHMuc3VwcG9ydHMoXCJjcmVhdGVMaW5rXCIpO1xuICAgKi9cbiAgc3VwcG9ydDogZnVuY3Rpb24oY29tbWFuZCkge1xuICAgIHJldHVybiB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0NvbW1hbmQodGhpcy5kb2MsIGNvbW1hbmQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBnaXZlbiBjb21tYW5kXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBjb21tYW5kIHN0cmluZyB3aGljaCB0byBleGVjdXRlIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSBUaGUgY29tbWFuZCB2YWx1ZSBwYXJhbWV0ZXIsIG5lZWRlZCBmb3Igc29tZSBjb21tYW5kcyAoXCJjcmVhdGVMaW5rXCIsIFwiaW5zZXJ0SW1hZ2VcIiwgLi4uKSwgb3B0aW9uYWwgZm9yIGNvbW1hbmRzIHRoYXQgZG9uJ3QgcmVxdWlyZSBvbmUgKFwiYm9sZFwiLCBcInVuZGVybGluZVwiLCAuLi4pXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRJbWFnZVwiLCBcImh0dHA6Ly9hMS50d2ltZy5jb20vcHJvZmlsZV9pbWFnZXMvMTEzODY4NjU1L3NjaHJlaV90d2l0dGVyX3JlYXNvbmFibHlfc21hbGwuanBnXCIpO1xuICAgKi9cbiAgZXhlYzogZnVuY3Rpb24oY29tbWFuZCwgdmFsdWUpIHtcbiAgICB2YXIgb2JqICAgICA9IHd5c2lodG1sNS5jb21tYW5kc1tjb21tYW5kXSxcbiAgICAgICAgYXJncyAgICA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGFyZ3VtZW50cykuZ2V0KCksXG4gICAgICAgIG1ldGhvZCAgPSBvYmogJiYgb2JqLmV4ZWMsXG4gICAgICAgIHJlc3VsdCAgPSBudWxsO1xuXG4gICAgdGhpcy5lZGl0b3IuZmlyZShcImJlZm9yZWNvbW1hbmQ6Y29tcG9zZXJcIik7XG5cbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5jb21wb3Nlcik7XG4gICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGZvciBidWdneSBmaXJlZm94XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5lZGl0b3IuZmlyZShcImFmdGVyY29tbWFuZDpjb21wb3NlclwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGNvbW1hbmQgaXMgYWN0aXZlXG4gICAqIElmIHRoZSBjYXJldCBpcyB3aXRoaW4gYSBib2xkIHRleHQsIHRoZW4gY2FsbGluZyB0aGlzIHdpdGggY29tbWFuZCBcImJvbGRcIiBzaG91bGQgcmV0dXJuIHRydWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbW1hbmRWYWx1ZV0gVGhlIGNvbW1hbmQgdmFsdWUgcGFyYW1ldGVyIChlZy4gZm9yIFwiaW5zZXJ0SW1hZ2VcIiB0aGUgaW1hZ2Ugc3JjKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb21tYW5kIGlzIGFjdGl2ZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB2YXIgaXNDdXJyZW50U2VsZWN0aW9uQm9sZCA9IGNvbW1hbmRzLnN0YXRlKFwiYm9sZFwiKTtcbiAgICovXG4gIHN0YXRlOiBmdW5jdGlvbihjb21tYW5kLCBjb21tYW5kVmFsdWUpIHtcbiAgICB2YXIgb2JqICAgICA9IHd5c2lodG1sNS5jb21tYW5kc1tjb21tYW5kXSxcbiAgICAgICAgYXJncyAgICA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGFyZ3VtZW50cykuZ2V0KCksXG4gICAgICAgIG1ldGhvZCAgPSBvYmogJiYgb2JqLnN0YXRlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmNvbXBvc2VyKTtcbiAgICAgIHJldHVybiBtZXRob2QuYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGZvciBidWdneSBmaXJlZm94XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5xdWVyeUNvbW1hbmRTdGF0ZShjb21tYW5kKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qIEdldCBjb21tYW5kIHN0YXRlIHBhcnNlZCB2YWx1ZSBpZiBjb21tYW5kIGhhcyBzdGF0ZVZhbHVlIHBhcnNpbmcgZnVuY3Rpb24gKi9cbiAgc3RhdGVWYWx1ZTogZnVuY3Rpb24oY29tbWFuZCkge1xuICAgIHZhciBvYmogICAgID0gd3lzaWh0bWw1LmNvbW1hbmRzW2NvbW1hbmRdLFxuICAgICAgICBhcmdzICAgID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoYXJndW1lbnRzKS5nZXQoKSxcbiAgICAgICAgbWV0aG9kICA9IG9iaiAmJiBvYmouc3RhdGVWYWx1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5jb21wb3Nlcik7XG4gICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuO3d5c2lodG1sNS5jb21tYW5kcy5ib2xkID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlY1dpdGhUb2dnbGUoY29tcG9zZXIsIGNvbW1hbmQsIFwiYlwiKTtcbiAgfSxcblxuICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAvLyBlbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUoXCJib2xkXCIpIHJlc3VsdHM6XG4gICAgLy8gZmlyZWZveDogb25seSA8Yj5cbiAgICAvLyBjaHJvbWU6ICA8Yj4sIDxzdHJvbmc+LCA8aDE+LCA8aDI+LCAuLi5cbiAgICAvLyBpZTogICAgICA8Yj4sIDxzdHJvbmc+XG4gICAgLy8gb3BlcmE6ICAgPGI+LCA8c3Ryb25nPlxuICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcImJcIik7XG4gIH1cbn07XG5cbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIE5PREVfTkFNRSA9IFwiQVwiLFxuICAgICAgZG9tICAgICAgID0gd3lzaWh0bWw1LmRvbTtcblxuICBmdW5jdGlvbiBfZm9ybWF0KGNvbXBvc2VyLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGRvYyAgICAgICAgICAgICA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgdGVtcENsYXNzICAgICAgID0gXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyAoK25ldyBEYXRlKCkpLFxuICAgICAgICB0ZW1wQ2xhc3NSZWdFeHAgPSAvbm9uLW1hdGNoaW5nLWNsYXNzL2csXG4gICAgICAgIGkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgYW5jaG9ycyxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBoYXNFbGVtZW50Q2hpbGQsXG4gICAgICAgIGlzRW1wdHksXG4gICAgICAgIGVsZW1lbnRUb1NldENhcmV0QWZ0ZXIsXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICB3aGl0ZVNwYWNlLFxuICAgICAgICBqO1xuICAgIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgdW5kZWYsIE5PREVfTkFNRSwgdGVtcENsYXNzLCB0ZW1wQ2xhc3NSZWdFeHAsIHVuZGVmLCB1bmRlZiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgYW5jaG9ycyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKE5PREVfTkFNRSArIFwiLlwiICsgdGVtcENsYXNzKTtcbiAgICBsZW5ndGggID0gYW5jaG9ycy5sZW5ndGg7XG4gICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuY2hvciA9IGFuY2hvcnNbaV07XG4gICAgICBhbmNob3IucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICBmb3IgKGogaW4gYXR0cmlidXRlcykge1xuICAgICAgICAvLyBEbyBub3Qgc2V0IGF0dHJpYnV0ZSBcInRleHRcIiBhcyBpdCBpcyBtZWFudCBmb3Igc2V0dGluZyBzdHJpbmcgdmFsdWUgaWYgY3JlYXRlZCBsaW5rIGhhcyBubyB0ZXh0dWFsIGRhdGFcbiAgICAgICAgaWYgKGogIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZShqLCBhdHRyaWJ1dGVzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnRUb1NldENhcmV0QWZ0ZXIgPSBhbmNob3I7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgdGV4dENvbnRlbnQgPSBkb20uZ2V0VGV4dENvbnRlbnQoYW5jaG9yKTtcbiAgICAgIGhhc0VsZW1lbnRDaGlsZCA9ICEhYW5jaG9yLnF1ZXJ5U2VsZWN0b3IoXCIqXCIpO1xuICAgICAgaXNFbXB0eSA9IHRleHRDb250ZW50ID09PSBcIlwiIHx8IHRleHRDb250ZW50ID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgaWYgKCFoYXNFbGVtZW50Q2hpbGQgJiYgaXNFbXB0eSkge1xuICAgICAgICBkb20uc2V0VGV4dENvbnRlbnQoYW5jaG9yLCBhdHRyaWJ1dGVzLnRleHQgfHwgYW5jaG9yLmhyZWYpO1xuICAgICAgICB3aGl0ZVNwYWNlID0gZG9jLmNyZWF0ZVRleHROb2RlKFwiIFwiKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEFmdGVyKGFuY2hvcik7XG4gICAgICAgIGRvbS5pbnNlcnQod2hpdGVTcGFjZSkuYWZ0ZXIoYW5jaG9yKTtcbiAgICAgICAgZWxlbWVudFRvU2V0Q2FyZXRBZnRlciA9IHdoaXRlU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihlbGVtZW50VG9TZXRDYXJldEFmdGVyKTtcbiAgfVxuXG4gIC8vIENoYW5nZXMgYXR0cmlidXRlcyBvZiBsaW5rc1xuICBmdW5jdGlvbiBfY2hhbmdlTGlua3MoY29tcG9zZXIsIGFuY2hvcnMsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgb2xkQXR0cnM7XG4gICAgZm9yICh2YXIgYSA9IGFuY2hvcnMubGVuZ3RoOyBhLS07KSB7XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgb2xkIGF0dHJpYnV0ZXNcbiAgICAgIG9sZEF0dHJzID0gYW5jaG9yc1thXS5hdHRyaWJ1dGVzO1xuICAgICAgZm9yICh2YXIgb2EgPSBvbGRBdHRycy5sZW5ndGg7IG9hLS07KSB7XG4gICAgICAgIGFuY2hvcnNbYV0ucmVtb3ZlQXR0cmlidXRlKG9sZEF0dHJzLml0ZW0ob2EpLm5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICAgIGZvciAodmFyIGogaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShqKSkge1xuICAgICAgICAgIGFuY2hvcnNbYV0uc2V0QXR0cmlidXRlKGosIGF0dHJpYnV0ZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluayA9IHtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBVc2UgSFRNTEFwcGxpZXIgb3IgZm9ybWF0SW5saW5lIGhlcmVcbiAgICAgKlxuICAgICAqIFR1cm5zIHNlbGVjdGlvbiBpbnRvIGEgbGlua1xuICAgICAqIElmIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGEgbGluaywgaXQganVzdCBjaGFuZ2VzIHRoZSBhdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIC8vIGVpdGhlciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluay5leGVjKGNvbXBvc2VyLCBcImNyZWF0ZUxpbmtcIiwgXCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiKTtcbiAgICAgKiAgICAvLyAuLi4gb3IgLi4uXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmNyZWF0ZUxpbmsuZXhlYyhjb21wb3NlciwgXCJjcmVhdGVMaW5rXCIsIHsgaHJlZjogXCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIgfSk7XG4gICAgICovXG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHZhbHVlKSB7XG4gICAgICB2YXIgYW5jaG9ycyA9IHRoaXMuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpO1xuICAgICAgaWYgKGFuY2hvcnMpIHtcbiAgICAgICAgLy8gU2VsZWN0aW9uIGNvbnRhaW5zIGxpbmtzIHRoZW4gY2hhbmdlIGF0dHJpYnV0ZXMgb2YgdGhlc2UgbGlua3NcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9jaGFuZ2VMaW5rcyhjb21wb3NlciwgYW5jaG9ycywgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBsaW5rc1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgPyB2YWx1ZSA6IHsgaHJlZjogdmFsdWUgfTtcbiAgICAgICAgX2Zvcm1hdChjb21wb3NlciwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcIkFcIik7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tO1xuXG4gIGZ1bmN0aW9uIF9yZW1vdmVGb3JtYXQoY29tcG9zZXIsIGFuY2hvcnMpIHtcbiAgICB2YXIgbGVuZ3RoICA9IGFuY2hvcnMubGVuZ3RoLFxuICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBjb2RlRWxlbWVudCxcbiAgICAgICAgdGV4dENvbnRlbnQ7XG4gICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuY2hvciAgICAgID0gYW5jaG9yc1tpXTtcbiAgICAgIGNvZGVFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoYW5jaG9yLCB7IG5vZGVOYW1lOiBcImNvZGVcIiB9KTtcbiAgICAgIHRleHRDb250ZW50ID0gZG9tLmdldFRleHRDb250ZW50KGFuY2hvcik7XG5cbiAgICAgIC8vIGlmIDxhPiBjb250YWlucyB1cmwtbGlrZSB0ZXh0IGNvbnRlbnQsIHJlbmFtZSBpdCB0byA8Y29kZT4gdG8gcHJldmVudCByZS1hdXRvbGlua2luZ1xuICAgICAgLy8gZWxzZSByZXBsYWNlIDxhPiB3aXRoIGl0cyBjaGlsZE5vZGVzXG4gICAgICBpZiAodGV4dENvbnRlbnQubWF0Y2goZG9tLmF1dG9MaW5rLlVSTF9SRUdfRVhQKSAmJiAhY29kZUVsZW1lbnQpIHtcbiAgICAgICAgLy8gPGNvZGU+IGVsZW1lbnQgaXMgdXNlZCB0byBwcmV2ZW50IGxhdGVyIGF1dG8tbGlua2luZyBvZiB0aGUgY29udGVudFxuICAgICAgICBjb2RlRWxlbWVudCA9IGRvbS5yZW5hbWVFbGVtZW50KGFuY2hvciwgXCJjb2RlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyhhbmNob3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5yZW1vdmVMaW5rID0ge1xuICAgIC8qXG4gICAgICogSWYgc2VsZWN0aW9uIGlzIGEgbGluaywgaXQgcmVtb3ZlcyB0aGUgbGluayBhbmQgd3JhcHMgaXQgd2l0aCBhIDxjb2RlPiBlbGVtZW50XG4gICAgICogVGhlIDxjb2RlPiBlbGVtZW50IGlzIG5lZWRlZCB0byBhdm9pZCBhdXRvIGxpbmtpbmdcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmNyZWF0ZUxpbmsuZXhlYyhjb21wb3NlciwgXCJyZW1vdmVMaW5rXCIpO1xuICAgICAqL1xuXG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHZhciBhbmNob3JzID0gdGhpcy5zdGF0ZShjb21wb3NlciwgY29tbWFuZCk7XG4gICAgICBpZiAoYW5jaG9ycykge1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3JlbW92ZUZvcm1hdChjb21wb3NlciwgYW5jaG9ycyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcIkFcIik7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcbjsvKipcbiAqIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZm9udFNpemVcIikgd2lsbCBjcmVhdGUgZWl0aGVyIGlubGluZSBzdHlsZXMgKGZpcmVmb3gsIGNocm9tZSkgb3IgdXNlIGZvbnQgdGFnc1xuICogd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICogSW5zdGVhZCB3ZSBzZXQgYSBjc3MgY2xhc3NcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgUkVHX0VYUCA9IC93eXNpd3lnLWZvbnQtc2l6ZS1bMC05YS16XFwtXSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9udFNpemUgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHNpemUpIHtcbiAgICAgICAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjV2l0aFRvZ2dsZShjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1mb250LXNpemUtXCIgKyBzaXplLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBzaXplKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1mb250LXNpemUtXCIgKyBzaXplLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOy8qIEluIGNhc2UgZm9udCBzaXplIGFkanVzdG1lbnQgdG8gYW55IG51bWJlciBkZWZpbmVkIGJ5IHVzZXIgaXMgcHJlZmVycmVkLCB3ZSBjYW5ub3QgdXNlIGNsYXNzZXMgYW5kIG11c3QgdXNlIGlubGluZSBzdHlsZXMuICovXG4oZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBSRUdfRVhQID0gLyhcXHN8Xilmb250LXNpemVcXHMqOlxccypbXjtcXHNdKzs/L2dpO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5mb250U2l6ZVN0eWxlID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBzaXplKSB7XG4gICAgICBzaXplID0gKHR5cGVvZihzaXplKSA9PSBcIm9iamVjdFwiKSA/IHNpemUuc2l6ZSA6IHNpemU7XG4gICAgICBpZiAoISgvXlxccyokLykudGVzdChzaXplKSkge1xuICAgICAgICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWNXaXRoVG9nZ2xlKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgZmFsc2UsIGZhbHNlLCBcImZvbnQtc2l6ZTpcIiArIHNpemUsIFJFR19FWFApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHNpemUpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgZmFsc2UsIGZhbHNlLCBcImZvbnQtc2l6ZVwiLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGVWYWx1ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHZhciBzdCA9IHRoaXMuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpLFxuICAgICAgICAgIHN0eWxlU3RyLCBmb250c2l6ZU1hdGNoZXMsXG4gICAgICAgICAgdmFsID0gZmFsc2U7XG5cbiAgICAgIGlmIChzdCAmJiB3eXNpaHRtbDUubGFuZy5vYmplY3Qoc3QpLmlzQXJyYXkoKSkge1xuICAgICAgICAgIHN0ID0gc3RbMF07XG4gICAgICB9XG4gICAgICBpZiAoc3QpIHtcbiAgICAgICAgc3R5bGVTdHIgPSBzdC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChzdHlsZVN0cikge1xuICAgICAgICAgIHJldHVybiB3eXNpaHRtbDUucXVpcmtzLnN0eWxlUGFyc2VyLnBhcnNlRm9udFNpemUoc3R5bGVTdHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcbjsvKipcbiAqIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZm9yZUNvbG9yXCIpIHdpbGwgY3JlYXRlIGVpdGhlciBpbmxpbmUgc3R5bGVzIChmaXJlZm94LCBjaHJvbWUpIG9yIHVzZSBmb250IHRhZ3NcbiAqIHdoaWNoIHdlIGRvbid0IHdhbnRcbiAqIEluc3RlYWQgd2Ugc2V0IGEgY3NzIGNsYXNzXG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIFJFR19FWFAgPSAvd3lzaXd5Zy1jb2xvci1bMC05YS16XSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9yZUNvbG9yID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWNXaXRoVG9nZ2xlKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgXCJ3eXNpd3lnLWNvbG9yLVwiICsgY29sb3IsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1jb2xvci1cIiArIGNvbG9yLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOy8qKlxuICogZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJmb3JlQ29sb3JcIikgd2lsbCBjcmVhdGUgZWl0aGVyIGlubGluZSBzdHlsZXMgKGZpcmVmb3gsIGNocm9tZSkgb3IgdXNlIGZvbnQgdGFnc1xuICogd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICogSW5zdGVhZCB3ZSBzZXQgYSBjc3MgY2xhc3NcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgUkVHX0VYUCA9IC8oXFxzfF4pY29sb3JcXHMqOlxccypbXjtcXHNdKzs/L2dpO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5mb3JlQ29sb3JTdHlsZSA9IHtcbiAgICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCwgY29sb3IpIHtcbiAgICAgIHZhciBjb2xvclZhbHMgID0gd3lzaWh0bWw1LnF1aXJrcy5zdHlsZVBhcnNlci5wYXJzZUNvbG9yKCh0eXBlb2YoY29sb3IpID09IFwib2JqZWN0XCIpID8gXCJjb2xvcjpcIiArIGNvbG9yLmNvbG9yIDogXCJjb2xvcjpcIiArIGNvbG9yLCBcImNvbG9yXCIpLFxuICAgICAgICAgIGNvbFN0cmluZztcblxuICAgICAgaWYgKGNvbG9yVmFscykge1xuICAgICAgICBjb2xTdHJpbmcgPSBcImNvbG9yOiByZ2IoXCIgKyBjb2xvclZhbHNbMF0gKyAnLCcgKyBjb2xvclZhbHNbMV0gKyAnLCcgKyBjb2xvclZhbHNbMl0gKyAnKTsnO1xuICAgICAgICBpZiAoY29sb3JWYWxzWzNdICE9PSAxKSB7XG4gICAgICAgICAgY29sU3RyaW5nICs9IFwiY29sb3I6IHJnYmEoXCIgKyBjb2xvclZhbHNbMF0gKyAnLCcgKyBjb2xvclZhbHNbMV0gKyAnLCcgKyBjb2xvclZhbHNbMl0gKyAnLCcgKyBjb2xvclZhbHNbM10gKyAnKTsnO1xuICAgICAgICB9XG4gICAgICAgIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlY1dpdGhUb2dnbGUoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBmYWxzZSwgZmFsc2UsIGNvbFN0cmluZywgUkVHX0VYUCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBmYWxzZSwgZmFsc2UsIFwiY29sb3JcIiwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlVmFsdWU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBwcm9wcykge1xuICAgICAgdmFyIHN0ID0gdGhpcy5zdGF0ZShjb21wb3NlciwgY29tbWFuZCksXG4gICAgICAgICAgY29sb3JTdHI7XG5cbiAgICAgIGlmIChzdCAmJiB3eXNpaHRtbDUubGFuZy5vYmplY3Qoc3QpLmlzQXJyYXkoKSkge1xuICAgICAgICBzdCA9IHN0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3QpIHtcbiAgICAgICAgY29sb3JTdHIgPSBzdC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChjb2xvclN0cikge1xuICAgICAgICAgIGlmIChjb2xvclN0cikge1xuICAgICAgICAgICAgdmFsID0gd3lzaWh0bWw1LnF1aXJrcy5zdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbG9yU3RyLCBcImNvbG9yXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHd5c2lodG1sNS5xdWlya3Muc3R5bGVQYXJzZXIudW5wYXJzZUNvbG9yKHZhbCwgcHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9O1xufSkod3lzaWh0bWw1KTtcbjsvKiBJbiBjYXNlIGJhY2tncm91bmQgYWRqdXN0bWVudCB0byBhbnkgY29sb3IgZGVmaW5lZCBieSB1c2VyIGlzIHByZWZlcnJlZCwgd2UgY2Fubm90IHVzZSBjbGFzc2VzIGFuZCBtdXN0IHVzZSBpbmxpbmUgc3R5bGVzLiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgUkVHX0VYUCA9IC8oXFxzfF4pYmFja2dyb3VuZC1jb2xvclxccyo6XFxzKlteO1xcc10rOz8vZ2k7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmJnQ29sb3JTdHlsZSA9IHtcbiAgICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCwgY29sb3IpIHtcbiAgICAgIHZhciBjb2xvclZhbHMgID0gd3lzaWh0bWw1LnF1aXJrcy5zdHlsZVBhcnNlci5wYXJzZUNvbG9yKCh0eXBlb2YoY29sb3IpID09IFwib2JqZWN0XCIpID8gXCJiYWNrZ3JvdW5kLWNvbG9yOlwiICsgY29sb3IuY29sb3IgOiBcImJhY2tncm91bmQtY29sb3I6XCIgKyBjb2xvciwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIpLFxuICAgICAgICAgIGNvbFN0cmluZztcblxuICAgICAgaWYgKGNvbG9yVmFscykge1xuICAgICAgICBjb2xTdHJpbmcgPSBcImJhY2tncm91bmQtY29sb3I6IHJnYihcIiArIGNvbG9yVmFsc1swXSArICcsJyArIGNvbG9yVmFsc1sxXSArICcsJyArIGNvbG9yVmFsc1syXSArICcpOyc7XG4gICAgICAgIGlmIChjb2xvclZhbHNbM10gIT09IDEpIHtcbiAgICAgICAgICBjb2xTdHJpbmcgKz0gXCJiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKFwiICsgY29sb3JWYWxzWzBdICsgJywnICsgY29sb3JWYWxzWzFdICsgJywnICsgY29sb3JWYWxzWzJdICsgJywnICsgY29sb3JWYWxzWzNdICsgJyk7JztcbiAgICAgICAgfVxuICAgICAgICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWNXaXRoVG9nZ2xlKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgZmFsc2UsIGZhbHNlLCBjb2xTdHJpbmcsIFJFR19FWFApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgZmFsc2UsIGZhbHNlLCBcImJhY2tncm91bmQtY29sb3JcIiwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlVmFsdWU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBwcm9wcykge1xuICAgICAgdmFyIHN0ID0gdGhpcy5zdGF0ZShjb21wb3NlciwgY29tbWFuZCksXG4gICAgICAgICAgY29sb3JTdHIsXG4gICAgICAgICAgdmFsID0gZmFsc2U7XG5cbiAgICAgIGlmIChzdCAmJiB3eXNpaHRtbDUubGFuZy5vYmplY3Qoc3QpLmlzQXJyYXkoKSkge1xuICAgICAgICBzdCA9IHN0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3QpIHtcbiAgICAgICAgY29sb3JTdHIgPSBzdC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChjb2xvclN0cikge1xuICAgICAgICAgIHZhbCA9IHd5c2lodG1sNS5xdWlya3Muc3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb2xvclN0ciwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIpO1xuICAgICAgICAgIHJldHVybiB3eXNpaHRtbDUucXVpcmtzLnN0eWxlUGFyc2VyLnVucGFyc2VDb2xvcih2YWwsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9O1xufSkod3lzaWh0bWw1KTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gICAgICAgICAgICAgICAgICAgICA9IHd5c2lodG1sNS5kb20sXG4gICAgICAvLyBGb2xsb3dpbmcgZWxlbWVudHMgYXJlIGdyb3VwZWRcbiAgICAgIC8vIHdoZW4gdGhlIGNhcmV0IGlzIHdpdGhpbiBhIEgxIGFuZCB0aGUgSDQgaXMgaW52b2tlZCwgdGhlIEgxIHNob3VsZCB0dXJuIGludG8gSDRcbiAgICAgIC8vIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBINCB3aXRoaW4gYSBIMSB3aGljaCB3b3VsZCByZXN1bHQgaW4gc2VtYW50aWNhbGx5IGludmFsaWQgaHRtbFxuICAgICAgQkxPQ0tfRUxFTUVOVFNfR1JPVVAgICAgPSBbXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIiwgXCJQXCIsIFwiUFJFXCIsIFwiRElWXCJdO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2ltaWxpYXIgY2xhc3NlcyAoYmFzZWQgb24gY2xhc3NSZWdFeHApXG4gICAqIGFuZCBhZGQgdGhlIGRlc2lyZWQgY2xhc3MgbmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUpIHtcbiAgICAgIF9yZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1JlZ0V4cCk7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyhlbGVtZW50LmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lKS50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hZGRTdHlsZShlbGVtZW50LCBjc3NTdHlsZSwgc3R5bGVSZWdFeHApIHtcbiAgICBfcmVtb3ZlU3R5bGUoZWxlbWVudCwgc3R5bGVSZWdFeHApO1xuICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpICsgXCIgXCIgKyBjc3NTdHlsZSkudHJpbSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgY3NzU3R5bGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1JlZ0V4cCkge1xuICAgIHZhciByZXQgPSBjbGFzc1JlZ0V4cC50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoY2xhc3NSZWdFeHAsIFwiXCIpO1xuICAgIGlmICh3eXNpaHRtbDUubGFuZy5zdHJpbmcoZWxlbWVudC5jbGFzc05hbWUpLnRyaW0oKSA9PSAnJykge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZW1vdmVTdHlsZShlbGVtZW50LCBzdHlsZVJlZ0V4cCkge1xuICAgIHZhciByZXQgPSBzdHlsZVJlZ0V4cC50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgXCJcIikucmVwbGFjZShzdHlsZVJlZ0V4cCwgXCJcIikpO1xuICAgIGlmICh3eXNpaHRtbDUubGFuZy5zdHJpbmcoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgXCJcIikudHJpbSgpID09ICcnKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZW1vdmVMYXN0Q2hpbGRJZkxpbmVCcmVhayhub2RlKSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuICAgIGlmIChsYXN0Q2hpbGQgJiYgX2lzTGluZUJyZWFrKGxhc3RDaGlsZCkpIHtcbiAgICAgIGxhc3RDaGlsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxhc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2lzTGluZUJyZWFrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gXCJCUlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgbmF0aXZlIHF1ZXJ5IGNvbW1hbmRcbiAgICogYW5kIGlmIG5lY2Vzc2FyeSBtb2RpZnkgdGhlIGluc2VydGVkIG5vZGUncyBjbGFzc05hbWVcbiAgICovXG4gIGZ1bmN0aW9uIF9leGVjQ29tbWFuZChkb2MsIGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRPd25SYW5nZXMoKTtcbiAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOyl7XG4gICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHJhbmdlc1tpXSk7XG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBldmVudExpc3RlbmVyID0gZG9tLm9ic2VydmUoZG9jLCBcIkRPTU5vZGVJbnNlcnRlZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgIGRpc3BsYXlTdHlsZTtcbiAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlICE9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3BsYXlTdHlsZSA9IGRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbSh0YXJnZXQpO1xuICAgICAgICAgIGlmIChkaXNwbGF5U3R5bGUuc3Vic3RyKDAsIDYpICE9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBvbmx5IGJsb2NrIGVsZW1lbnRzIHJlY2VpdmUgdGhlIGdpdmVuIGNsYXNzXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG5vZGVOYW1lKTtcblxuICAgICAgaWYgKGV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lci5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3NlbGVjdGlvbldyYXAoY29tcG9zZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoY29tcG9zZXIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdExpbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgc3Vycm91bmRlZE5vZGVzID0gY29tcG9zZXIuc2VsZWN0aW9uLnN1cnJvdW5kKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbWF4ID0gc3Vycm91bmRlZE5vZGVzLmxlbmd0aDsgaSA8IGltYXg7IGkrKykge1xuICAgICAgd3lzaWh0bWw1LmRvbS5saW5lQnJlYWtzKHN1cnJvdW5kZWROb2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICBfcmVtb3ZlTGFzdENoaWxkSWZMaW5lQnJlYWsoc3Vycm91bmRlZE5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICAvLyByZXRoaW5rIHJlc3RvcmluZyBzZWxlY3Rpb25cbiAgICAvLyBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0Tm9kZShlbGVtZW50LCB3eXNpaHRtbDUuYnJvd3Nlci5kaXNwbGF5c0NhcmV0SW5FbXB0eUNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYXNDbGFzc2VzKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gISF3eXNpaHRtbDUubGFuZy5zdHJpbmcoZWxlbWVudC5jbGFzc05hbWUpLnRyaW0oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYXNTdHlsZXMoZWxlbWVudCkge1xuICAgIHJldHVybiAhIXd5c2lodG1sNS5sYW5nLnN0cmluZyhlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJykudHJpbSgpO1xuICB9XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwKSB7XG4gICAgICB2YXIgZG9jICAgICAgICAgICAgID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIGJsb2NrRWxlbWVudHMgICAgPSB0aGlzLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwKSxcbiAgICAgICAgICB1c2VMaW5lQnJlYWtzICAgPSBjb21wb3Nlci5jb25maWcudXNlTGluZUJyZWFrcyxcbiAgICAgICAgICBkZWZhdWx0Tm9kZU5hbWUgPSB1c2VMaW5lQnJlYWtzID8gXCJESVZcIiA6IFwiUFwiLFxuICAgICAgICAgIHNlbGVjdGVkTm9kZXMsIGNsYXNzUmVtb3ZlQWN0aW9uLCBibG9ja1JlbmFtZUZvdW5kLCBzdHlsZVJlbW92ZUFjdGlvbiwgYmxvY2tFbGVtZW50O1xuICAgICAgbm9kZU5hbWUgPSB0eXBlb2Yobm9kZU5hbWUpID09PSBcInN0cmluZ1wiID8gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA6IG5vZGVOYW1lO1xuXG4gICAgICBpZiAoYmxvY2tFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlUmFuZ3koZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgYiA9IGJsb2NrRWxlbWVudHMubGVuZ3RoOyBiLS07KSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NSZWdFeHApIHtcbiAgICAgICAgICAgICAgY2xhc3NSZW1vdmVBY3Rpb24gPSBfcmVtb3ZlQ2xhc3MoYmxvY2tFbGVtZW50c1tiXSwgY2xhc3NSZWdFeHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlUmVnRXhwKSB7XG4gICAgICAgICAgICAgIHN0eWxlUmVtb3ZlQWN0aW9uID0gX3JlbW92ZVN0eWxlKGJsb2NrRWxlbWVudHNbYl0sIHN0eWxlUmVnRXhwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChzdHlsZVJlbW92ZUFjdGlvbiB8fCBjbGFzc1JlbW92ZUFjdGlvbikgJiYgbm9kZU5hbWUgPT09IG51bGwgJiYgYmxvY2tFbGVtZW50c1tiXS5ub2RlTmFtZSAhPSBkZWZhdWx0Tm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgLy8gZG9udCByZW5hbWUgb3IgcmVtb3ZlIGVsZW1lbnQgd2hlbiBqdXN0IHNldHRpbmcgYmxvY2sgZm9ybWF0aW5nIGNsYXNzIG9yIHN0eWxlXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhhc0NsYXNzZXMgPSBfaGFzQ2xhc3NlcyhibG9ja0VsZW1lbnRzW2JdKSxcbiAgICAgICAgICAgICAgICBoYXNTdHlsZXMgPSBfaGFzU3R5bGVzKGJsb2NrRWxlbWVudHNbYl0pO1xuXG4gICAgICAgICAgICBpZiAoIWhhc0NsYXNzZXMgJiYgIWhhc1N0eWxlcyAmJiAodXNlTGluZUJyZWFrcyB8fCBub2RlTmFtZSA9PT0gXCJQXCIpKSB7XG4gICAgICAgICAgICAgIC8vIEluc2VydCBhIGxpbmUgYnJlYWsgYWZ0ZXJ3YXJkcyBhbmQgYmVmb3Jld2FyZHMgd2hlbiB0aGVyZSBhcmUgc2libGluZ3NcbiAgICAgICAgICAgICAgLy8gdGhhdCBhcmUgbm90IG9mIHR5cGUgbGluZSBicmVhayBvciBibG9jayBlbGVtZW50XG4gICAgICAgICAgICAgIHd5c2lodG1sNS5kb20ubGluZUJyZWFrcyhibG9ja0VsZW1lbnRzW2JdKS5hZGQoKTtcbiAgICAgICAgICAgICAgZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyhibG9ja0VsZW1lbnRzW2JdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHN0eWxpbmcgaXMga2VwdCBieSByZW5hbWluZyB0aGUgZWxlbWVudCB0byBhIDxkaXY+IG9yIDxwPiBhbmQgY29weWluZyBvdmVyIHRoZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgIGRvbS5yZW5hbWVFbGVtZW50KGJsb2NrRWxlbWVudHNbYl0sIG5vZGVOYW1lID09PSBcIlBcIiA/IFwiRElWXCIgOiBkZWZhdWx0Tm9kZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHNpbWlsaWFyIGJsb2NrIGVsZW1lbnQgYW5kIHJlbmFtZSBpdCAoPGgyIGNsYXNzPVwiZm9vXCI+PC9oMj4gID0+ICA8aDEgY2xhc3M9XCJmb29cIj48L2gxPilcbiAgICAgIGlmIChub2RlTmFtZSA9PT0gbnVsbCB8fCB3eXNpaHRtbDUubGFuZy5hcnJheShCTE9DS19FTEVNRU5UU19HUk9VUCkuY29udGFpbnMobm9kZU5hbWUpKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMgPSBjb21wb3Nlci5zZWxlY3Rpb24uZmluZE5vZGVzSW5TZWxlY3Rpb24oQkxPQ0tfRUxFTUVOVFNfR1JPVVApLmNvbmNhdChjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWRPd25Ob2RlcygpKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlUmFuZ3koZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBuLS07KSB7XG4gICAgICAgICAgICBibG9ja0VsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGVzW25dLCB7XG4gICAgICAgICAgICAgIG5vZGVOYW1lOiBCTE9DS19FTEVNRU5UU19HUk9VUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYmxvY2tFbGVtZW50ID09IGNvbXBvc2VyLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgYmxvY2tFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW5hbWUgY3VycmVudCBibG9jayBlbGVtZW50IHRvIG5ldyBibG9jayBlbGVtZW50IGFuZCBhZGQgY2xhc3NcbiAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbS5yZW5hbWVFbGVtZW50KGJsb2NrRWxlbWVudCwgbm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBfYWRkQ2xhc3MoYmxvY2tFbGVtZW50LCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNzc1N0eWxlKSB7XG4gICAgICAgICAgICAgICAgICBfYWRkU3R5bGUoYmxvY2tFbGVtZW50LCBjc3NTdHlsZSwgc3R5bGVSZWdFeHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmxvY2tSZW5hbWVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChibG9ja1JlbmFtZUZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9zZWxlY3Rpb25XcmFwKGNvbXBvc2VyLCB7XG4gICAgICAgIFwibm9kZU5hbWVcIjogKG5vZGVOYW1lIHx8IGRlZmF1bHROb2RlTmFtZSksXG4gICAgICAgIFwiY2xhc3NOYW1lXCI6IGNsYXNzTmFtZSB8fCBudWxsLFxuICAgICAgICBcImNzc1N0eWxlXCI6IGNzc1N0eWxlIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwLCBjc3NTdHlsZSwgc3R5bGVSZWdFeHApIHtcbiAgICAgIHZhciBub2RlcyA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE93bk5vZGVzKCksXG4gICAgICAgICAgcGFyZW50cyA9IFtdLFxuICAgICAgICAgIHBhcmVudDtcblxuICAgICAgbm9kZU5hbWUgPSB0eXBlb2Yobm9kZU5hbWUpID09PSBcInN0cmluZ1wiID8gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA6IG5vZGVOYW1lO1xuXG4gICAgICAvL3ZhciBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4aSA9IG5vZGVzLmxlbmd0aDsgaSA8IG1heGk7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChub2Rlc1tpXSwge1xuICAgICAgICAgIG5vZGVOYW1lOiAgICAgbm9kZU5hbWUsXG4gICAgICAgICAgY2xhc3NOYW1lOiAgICBjbGFzc05hbWUsXG4gICAgICAgICAgY2xhc3NSZWdFeHA6ICBjbGFzc1JlZ0V4cCxcbiAgICAgICAgICBjc3NTdHlsZTogICAgIGNzc1N0eWxlLFxuICAgICAgICAgIHN0eWxlUmVnRXhwOiAgc3R5bGVSZWdFeHBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgd3lzaWh0bWw1LmxhbmcuYXJyYXkocGFyZW50cykuaW5kZXhPZihwYXJlbnQpID09IC0xKSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cblxuXG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOy8qIEZvcm1hdHMgYmxvY2sgZm9yIGFzIGEgPHByZT48Y29kZSBjbGFzcz1cImNsYXNzbmFtZVwiPjwvY29kZT48L3ByZT4gYmxvY2tcbiAqIFVzZWZ1bCBpbiBjb25qdWN0aW9uIGZvciBzeXRheCBoaWdobGlnaHQgdXRpbGl0eTogaGlnaGxpZ2h0LmpzXG4gKlxuICogVXNhZ2U6XG4gKlxuICogZWRpdG9ySW5zdGFuY2UuY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImZvcm1hdENvZGVcIiwgXCJsYW5ndWFnZS1odG1sXCIpO1xuKi9cblxud3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdENvZGUgPSB7XG5cbiAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIGNsYXNzbmFtZSkge1xuICAgIHZhciBwcmUgPSB0aGlzLnN0YXRlKGNvbXBvc2VyKSxcbiAgICAgICAgY29kZSwgcmFuZ2UsIHNlbGVjdGVkTm9kZXM7XG4gICAgaWYgKHByZSkge1xuICAgICAgLy8gY2FyZXQgaXMgYWxyZWFkeSB3aXRoaW4gYSA8cHJlPjxjb2RlPi4uLjwvY29kZT48L3ByZT5cbiAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZShmdW5jdGlvbigpIHtcbiAgICAgICAgY29kZSA9IHByZS5xdWVyeVNlbGVjdG9yKFwiY29kZVwiKTtcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMocHJlKTtcbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICB3eXNpaHRtbDUuZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2Rlcyhjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdyYXAgaW4gPHByZT48Y29kZT4uLi48L2NvZGU+PC9wcmU+XG4gICAgICByYW5nZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgc2VsZWN0ZWROb2RlcyA9IHJhbmdlLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgcHJlID0gY29tcG9zZXIuZG9jLmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICBjb2RlID0gY29tcG9zZXIuZG9jLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIpO1xuXG4gICAgICBpZiAoY2xhc3NuYW1lKSB7XG4gICAgICAgIGNvZGUuY2xhc3NOYW1lID0gY2xhc3NuYW1lO1xuICAgICAgfVxuXG4gICAgICBwcmUuYXBwZW5kQ2hpbGQoY29kZSk7XG4gICAgICBjb2RlLmFwcGVuZENoaWxkKHNlbGVjdGVkTm9kZXMpO1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShwcmUpO1xuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUocHJlKTtcbiAgICB9XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyKSB7XG4gICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbGVjdGVkTm9kZS5ub2RlTmFtZSAmJiBzZWxlY3RlZE5vZGUubm9kZU5hbWUgPT0gXCJQUkVcIiYmXG4gICAgICAgIHNlbGVjdGVkTm9kZS5maXJzdENoaWxkICYmIHNlbGVjdGVkTm9kZS5maXJzdENoaWxkLm5vZGVOYW1lICYmIHNlbGVjdGVkTm9kZS5maXJzdENoaWxkLm5vZGVOYW1lID09IFwiQ09ERVwiKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJDT0RFXCIgfSkgJiYgd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJQUkVcIiB9KTtcbiAgICB9XG4gIH1cbn07Oy8qKlxuICogZm9ybWF0SW5saW5lIHNjZW5hcmlvcyBmb3IgdGFnIFwiQlwiICh8ID0gY2FyZXQsIHxmb298ID0gc2VsZWN0ZWQgdGV4dClcbiAqXG4gKiAgICMxIGNhcmV0IGluIHVuZm9ybWF0dGVkIHRleHQ6XG4gKiAgICAgIGFiY2RlZmd8XG4gKiAgIG91dHB1dDpcbiAqICAgICAgYWJjZGVmZzxiPnw8L2I+XG4gKlxuICogICAjMiB1bmZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkOlxuICogICAgICBhYmN8ZGVnfGhcbiAqICAgb3V0cHV0OlxuICogICAgICBhYmM8Yj58ZGVnfDwvYj5oXG4gKlxuICogICAjMyB1bmZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzOlxuICogICAgICBhYnxjIDxzcGFuPmRlZmd8aDwvc3Bhbj5cbiAqICAgb3V0cHV0OlxuICogICAgICBhYjxiPnxjIDwvYj48c3Bhbj48Yj5kZWZnPC9iPnxoPC9zcGFuPlxuICpcbiAqICAgIzQgZm9ybWF0dGVkIHRleHQgZW50aXJlbHkgc2VsZWN0ZWRcbiAqICAgICAgPGI+fGFiY3w8L2I+XG4gKiAgIG91dHB1dDpcbiAqICAgICAgfGFiY3xcbiAqXG4gKiAgICM1IGZvcm1hdHRlZCB0ZXh0IHBhcnRpYWxseSBzZWxlY3RlZFxuICogICAgICA8Yj5hYnxjfDwvYj5cbiAqICAgb3V0cHV0OlxuICogICAgICA8Yj5hYjwvYj58Y3xcbiAqXG4gKiAgICM2IGZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzXG4gKiAgICAgIDxzcGFuPmFifGM8L3NwYW4+IDxiPmRlfGZnaDwvYj5cbiAqICAgb3V0cHV0OlxuICogICAgICA8c3Bhbj5hYnxjPC9zcGFuPiBkZXw8Yj5mZ2g8L2I+XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIC8vIFRyZWF0IDxiPiBhcyA8c3Ryb25nPiBhbmQgdmljZSB2ZXJzYVxuICAgICAgQUxJQVNfTUFQUElORyA9IHtcbiAgICAgICAgXCJzdHJvbmdcIjogXCJiXCIsXG4gICAgICAgIFwiZW1cIjogICAgIFwiaVwiLFxuICAgICAgICBcImJcIjogICAgICBcInN0cm9uZ1wiLFxuICAgICAgICBcImlcIjogICAgICBcImVtXCJcbiAgICAgIH0sXG4gICAgICBodG1sQXBwbGllciA9IHt9O1xuXG4gIGZ1bmN0aW9uIF9nZXRUYWdOYW1lcyh0YWdOYW1lKSB7XG4gICAgdmFyIGFsaWFzID0gQUxJQVNfTUFQUElOR1t0YWdOYW1lXTtcbiAgICByZXR1cm4gYWxpYXMgPyBbdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhbGlhcy50b0xvd2VyQ2FzZSgpXSA6IFt0YWdOYW1lLnRvTG93ZXJDYXNlKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwLCBjb250YWluZXIpIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IHRhZ05hbWU7XG4gICAgXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWRlbnRpZmllciArPSBcIjpcIiArIGNsYXNzTmFtZTtcbiAgICB9XG4gICAgaWYgKGNzc1N0eWxlKSB7XG4gICAgICBpZGVudGlmaWVyICs9IFwiOlwiICsgY3NzU3R5bGU7XG4gICAgfVxuXG4gICAgaWYgKCFodG1sQXBwbGllcltpZGVudGlmaWVyXSkge1xuICAgICAgaHRtbEFwcGxpZXJbaWRlbnRpZmllcl0gPSBuZXcgd3lzaWh0bWw1LnNlbGVjdGlvbi5IVE1MQXBwbGllcihfZ2V0VGFnTmFtZXModGFnTmFtZSksIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHAsIHRydWUsIGNzc1N0eWxlLCBzdHlsZVJlZ0V4cCwgY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbEFwcGxpZXJbaWRlbnRpZmllcl07XG4gIH1cblxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCB0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwLCBjc3NTdHlsZSwgc3R5bGVSZWdFeHAsIGRvbnRSZXN0b3JlU2VsZWN0LCBub0NsZWFudXApIHtcbiAgICAgIHZhciByYW5nZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLFxuICAgICAgICAgIG93blJhbmdlcyA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRPd25SYW5nZXMoKTtcblxuICAgICAgaWYgKCFvd25SYW5nZXMgfHwgb3duUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgICAgX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwLCBjb21wb3Nlci5lbGVtZW50KS50b2dnbGVSYW5nZShvd25SYW5nZXMpO1xuXG4gICAgICBpZiAoIWRvbnRSZXN0b3JlU2VsZWN0KSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG93blJhbmdlc1swXS5zdGFydENvbnRhaW5lciwgIG93blJhbmdlc1swXS5zdGFydE9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChcbiAgICAgICAgICBvd25SYW5nZXNbb3duUmFuZ2VzLmxlbmd0aCAtIDFdLmVuZENvbnRhaW5lcixcbiAgICAgICAgICBvd25SYW5nZXNbb3duUmFuZ2VzLmxlbmd0aCAtIDFdLmVuZE9mZnNldFxuICAgICAgICApO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHJhbmdlKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghbm9DbGVhbnVwKSB7XG4gICAgICAgICAgICBjb21wb3Nlci5jbGVhblVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIW5vQ2xlYW51cCkge1xuICAgICAgICBjb21wb3Nlci5jbGVhblVwKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEV4ZWN1dGVzIHNvIHRoYXQgaWYgY29sbGFwc2VkIGNhcmV0IGlzIGluIGEgc3RhdGUgYW5kIGV4ZWN1dGluZyB0aGF0IHN0YXRlIGl0IHNob3VsZCB1bmZvcm1hdCB0aGF0IHN0YXRlXG4gICAgLy8gSXQgaXMgYWNoaWV2ZWQgYnkgc2VsZWN0aW5nIHRoZSBlbnRpcmUgc3RhdGUgZWxlbWVudCBiZWZvcmUgZXhlY3V0aW5nLlxuICAgIC8vIFRoaXMgd29ya3Mgb24gYnVpbHQgaW4gY29udGVudGVkaXRhYmxlIGlubGluZSBmb3JtYXQgY29tbWFuZHNcbiAgICBleGVjV2l0aFRvZ2dsZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHAsIGNzc1N0eWxlLCBzdHlsZVJlZ0V4cCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgdGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwKSAmJlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJlxuICAgICAgICAhY29tcG9zZXIuc2VsZWN0aW9uLmNhcmV0SXNMYXN0SW5TZWxlY3Rpb24oKSAmJlxuICAgICAgICAhY29tcG9zZXIuc2VsZWN0aW9uLmNhcmV0SXNGaXJzdEluU2VsZWN0aW9uKClcbiAgICAgICkge1xuICAgICAgICB2YXIgc3RhdGVfZWxlbWVudCA9IHRoYXQuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApWzBdO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVSYW5neShmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gc3RhdGVfZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZWxlY3ROb2RlKHN0YXRlX2VsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgY29tbWFuZCwgdGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgdGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwKSAmJiAhY29tcG9zZXIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVSYW5neShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgY29tbWFuZCwgdGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgY3NzU3R5bGUsIHN0eWxlUmVnRXhwLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHAsIGNzc1N0eWxlLCBzdHlsZVJlZ0V4cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCB0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwLCBjc3NTdHlsZSwgc3R5bGVSZWdFeHApIHtcbiAgICAgIHZhciBkb2MgICAgICAgICAgID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIGFsaWFzVGFnTmFtZSAgPSBBTElBU19NQVBQSU5HW3RhZ05hbWVdIHx8IHRhZ05hbWUsXG4gICAgICAgICAgb3duUmFuZ2VzLCBpc0FwcGxpZWQ7XG5cbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IGNvbnRhaW5zIGEgbm9kZSB3aXRoIHRoZSBkZXNpcmVkIHRhZ05hbWVcbiAgICAgIGlmICghd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aFRhZ05hbWUoZG9jLCB0YWdOYW1lKSAmJlxuICAgICAgICAgICF3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZShkb2MsIGFsaWFzVGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZG9jdW1lbnQgY29udGFpbnMgYSBub2RlIHdpdGggdGhlIGRlc2lyZWQgY2xhc3NOYW1lXG4gICAgICBpZiAoY2xhc3NOYW1lICYmICF3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoQ2xhc3NOYW1lKGRvYywgY2xhc3NOYW1lKSkge1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvd25SYW5nZXMgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0T3duUmFuZ2VzKCk7XG5cbiAgICAgIGlmICghb3duUmFuZ2VzIHx8IG93blJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpc0FwcGxpZWQgPSBfZ2V0QXBwbGllcih0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwLCBjc3NTdHlsZSwgc3R5bGVSZWdFeHAsIGNvbXBvc2VyLmVsZW1lbnQpLmlzQXBwbGllZFRvUmFuZ2Uob3duUmFuZ2VzKTtcblxuICAgICAgcmV0dXJuIChpc0FwcGxpZWQgJiYgaXNBcHBsaWVkLmVsZW1lbnRzKSA/IGlzQXBwbGllZC5lbGVtZW50cyA6IGZhbHNlO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7XG47KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRCbG9ja1F1b3RlID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSxcbiAgICAgICAgICBlbmRUb0VuZFBhcmVudCA9IGNvbXBvc2VyLnNlbGVjdGlvbi5pc0VuZFRvRW5kSW5Ob2RlKFsnSDEnLCAnSDInLCAnSDMnLCAnSDQnLCAnSDUnLCAnSDYnLCAnUCddKSxcbiAgICAgICAgICBwcmV2Tm9kZSwgbmV4dE5vZGU7XG5cbiAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgaWYgKGNvbXBvc2VyLmNvbmZpZy51c2VMaW5lQnJlYWtzKSB7XG4gICAgICAgICAgICAgd3lzaWh0bWw1LmRvbS5saW5lQnJlYWtzKHN0YXRlKS5hZGQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS51bndyYXAoc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb21wb3Nlci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdExpbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGVuZFRvRW5kUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgcW91dGVFbCA9IGVuZFRvRW5kUGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpO1xuICAgICAgICAgICAgd3lzaWh0bWw1LmRvbS5pbnNlcnQocW91dGVFbCkuYWZ0ZXIoZW5kVG9FbmRQYXJlbnQpO1xuICAgICAgICAgICAgcW91dGVFbC5hcHBlbmRDaGlsZChlbmRUb0VuZFBhcmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zdXJyb3VuZCh7bm9kZU5hbWU6IFwiYmxvY2txdW90ZVwifSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZSAgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCksXG4gICAgICAgICAgbm9kZSA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiQkxPQ0tRVU9URVwiIH0sIGZhbHNlLCBjb21wb3Nlci5lbGVtZW50KTtcblxuICAgICAgcmV0dXJuIChub2RlKSA/IG5vZGUgOiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbn0pKHd5c2lodG1sNSk7O3d5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRIVE1MID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCwgaHRtbCkge1xuICAgIGlmIChjb21wb3Nlci5jb21tYW5kcy5zdXBwb3J0KGNvbW1hbmQpKSB7XG4gICAgICBjb21wb3Nlci5kb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIGh0bWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0SFRNTChodG1sKTtcbiAgICB9XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBOT0RFX05BTUUgPSBcIklNR1wiO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRJbWFnZSA9IHtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIDxpbWc+XG4gICAgICogSWYgc2VsZWN0aW9uIGlzIGFscmVhZHkgYW4gaW1hZ2UgbGluaywgaXQgcmVtb3ZlcyBpdFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAvLyBlaXRoZXIgLi4uXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydEltYWdlLmV4ZWMoY29tcG9zZXIsIFwiaW5zZXJ0SW1hZ2VcIiwgXCJodHRwOi8vd3d3Lmdvb2dsZS5kZS9sb2dvLmpwZ1wiKTtcbiAgICAgKiAgICAvLyAuLi4gb3IgLi4uXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydEltYWdlLmV4ZWMoY29tcG9zZXIsIFwiaW5zZXJ0SW1hZ2VcIiwgeyBzcmM6IFwiaHR0cDovL3d3dy5nb29nbGUuZGUvbG9nby5qcGdcIiwgdGl0bGU6IFwiZm9vXCIgfSk7XG4gICAgICovXG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHR5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgPyB2YWx1ZSA6IHsgc3JjOiB2YWx1ZSB9O1xuXG4gICAgICB2YXIgZG9jICAgICA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBpbWFnZSAgID0gdGhpcy5zdGF0ZShjb21wb3NlciksXG4gICAgICAgICAgdGV4dE5vZGUsXG4gICAgICAgICAgcGFyZW50O1xuXG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgLy8gSW1hZ2UgYWxyZWFkeSBzZWxlY3RlZCwgc2V0IHRoZSBjYXJldCBiZWZvcmUgaXQgYW5kIGRlbGV0ZSBpdFxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QmVmb3JlKGltYWdlKTtcbiAgICAgICAgcGFyZW50ID0gaW1hZ2UucGFyZW50Tm9kZTtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGltYWdlKTtcblxuICAgICAgICAvLyBhbmQgaXQncyBwYXJlbnQgPGE+IHRvbyBpZiBpdCBoYXNuJ3QgZ290IGFueSBvdGhlciByZWxldmFudCBjaGlsZCBub2Rlc1xuICAgICAgICB3eXNpaHRtbDUuZG9tLnJlbW92ZUVtcHR5VGV4dE5vZGVzKHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZU5hbWUgPT09IFwiQVwiICYmICFwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihwYXJlbnQpO1xuICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJlZm94IGFuZCBpZSBzb21ldGltZXMgZG9uJ3QgcmVtb3ZlIHRoZSBpbWFnZSBoYW5kbGVzLCBldmVuIHRob3VnaCB0aGUgaW1hZ2UgZ290IHJlbW92ZWRcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoY29tcG9zZXIuZWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW1hZ2UgPSBkb2MuY3JlYXRlRWxlbWVudChOT0RFX05BTUUpO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSB7XG4gICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZShpID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDogaSwgdmFsdWVbaV0pO1xuICAgICAgfVxuXG4gICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0Tm9kZShpbWFnZSk7XG4gICAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZygpKSB7XG4gICAgICAgIHRleHROb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0Tm9kZSh0ZXh0Tm9kZSk7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcih0ZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIoaW1hZ2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIpIHtcbiAgICAgIHZhciBkb2MgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgc2VsZWN0ZWROb2RlLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgaW1hZ2VzSW5TZWxlY3Rpb247XG5cbiAgICAgIGlmICghd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aFRhZ05hbWUoZG9jLCBOT0RFX05BTUUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgaWYgKCFzZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWROb2RlLm5vZGVOYW1lID09PSBOT0RFX05BTUUpIHtcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBwZXJmZWN0bHkgaW4gSUVcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkTm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkTm9kZS5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0VGV4dCgpO1xuICAgICAgdGV4dCA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyh0ZXh0KS50cmltKCk7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGltYWdlc0luU2VsZWN0aW9uID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldE5vZGVzKHd5c2lodG1sNS5FTEVNRU5UX05PREUsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09IFwiSU1HXCI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGltYWdlc0luU2VsZWN0aW9uLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWFnZXNJblNlbGVjdGlvblswXTtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIExJTkVfQlJFQUsgPSBcIjxicj5cIiArICh3eXNpaHRtbDUuYnJvd3Nlci5uZWVkc1NwYWNlQWZ0ZXJMaW5lQnJlYWsoKSA/IFwiIFwiIDogXCJcIik7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydExpbmVCcmVhayA9IHtcbiAgICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgY29tcG9zZXIuZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5hdXRvU2Nyb2xsc1RvQ2FyZXQoKSkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiaW5zZXJ0SFRNTFwiLCBMSU5FX0JSRUFLKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7XG47d3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydE9yZGVyZWRMaXN0ID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRMaXN0LmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwiT0xcIik7XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRMaXN0LnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcIk9MXCIpO1xuICB9XG59O1xuO3d5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRVbm9yZGVyZWRMaXN0ID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRMaXN0LmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwiVUxcIik7XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRMaXN0LnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcIlVMXCIpO1xuICB9XG59O1xuO3d5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRMaXN0ID0gKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuXG4gIHZhciBpc05vZGUgPSBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gW25hbWVdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbiA9IG5hbWUubGVuZ3RoOyBuLS07KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSBuYW1lW25dKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBmaW5kTGlzdEVsID0gZnVuY3Rpb24obm9kZSwgbm9kZU5hbWUsIGNvbXBvc2VyKSB7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgICBvdGhlcjogZmFsc2VcbiAgICAgICAgfTtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICB2YXIgcGFyZW50TGkgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQobm9kZSwgeyBub2RlTmFtZTogXCJMSVwiIH0pLFxuICAgICAgICAgIG90aGVyTm9kZU5hbWUgPSAobm9kZU5hbWUgPT09IFwiVUxcIikgPyBcIk9MXCIgOiBcIlVMXCI7XG5cbiAgICAgIGlmIChpc05vZGUobm9kZSwgbm9kZU5hbWUpKSB7XG4gICAgICAgIHJldC5lbCA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGlzTm9kZShub2RlLCBvdGhlck5vZGVOYW1lKSkge1xuICAgICAgICByZXQgPSB7XG4gICAgICAgICAgZWw6IG5vZGUsXG4gICAgICAgICAgb3RoZXI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50TGkpIHtcbiAgICAgICAgaWYgKGlzTm9kZShwYXJlbnRMaS5wYXJlbnROb2RlLCBub2RlTmFtZSkpIHtcbiAgICAgICAgICByZXQuZWwgPSBwYXJlbnRMaS5wYXJlbnROb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShwYXJlbnRMaS5wYXJlbnROb2RlLCBvdGhlck5vZGVOYW1lKSkge1xuICAgICAgICAgIHJldCA9IHtcbiAgICAgICAgICAgIGVsIDogcGFyZW50TGkucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIG90aGVyOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRvIG5vdCBjb3VudCBsaXN0IGVsZW1lbnRzIG91dHNpZGUgb2YgY29tcG9zZXJcbiAgICBpZiAocmV0LmVsICYmICFjb21wb3Nlci5lbGVtZW50LmNvbnRhaW5zKHJldC5lbCkpIHtcbiAgICAgIHJldC5lbCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgaGFuZGxlU2FtZVR5cGVMaXN0ID0gZnVuY3Rpb24oZWwsIG5vZGVOYW1lLCBjb21wb3Nlcikge1xuICAgIHZhciBvdGhlck5vZGVOYW1lID0gKG5vZGVOYW1lID09PSBcIlVMXCIpID8gXCJPTFwiIDogXCJVTFwiLFxuICAgICAgICBvdGhlckxpc3RzLCBpbm5lckxpc3RzO1xuICAgIC8vIFVud3JhcCBsaXN0XG4gICAgLy8gPHVsPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvdWw+XG4gICAgLy8gYmVjb21lczpcbiAgICAvLyBmb288YnI+YmFyPGJyPlxuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZShmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvdGhlckxpc3RzID0gZ2V0TGlzdHNJblNlbGVjdGlvbihvdGhlck5vZGVOYW1lLCBjb21wb3Nlcik7XG4gICAgICBpZiAob3RoZXJMaXN0cy5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IG90aGVyTGlzdHMubGVuZ3RoOyBsLS07KSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50KG90aGVyTGlzdHNbbF0sIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbm5lckxpc3RzID0gZ2V0TGlzdHNJblNlbGVjdGlvbihbJ09MJywgJ1VMJ10sIGNvbXBvc2VyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGlubmVyTGlzdHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZXNvbHZlTGlzdChpbm5lckxpc3RzW2ldLCBjb21wb3Nlci5jb25maWcudXNlTGluZUJyZWFrcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3lzaWh0bWw1LmRvbS5yZXNvbHZlTGlzdChlbCwgY29tcG9zZXIuY29uZmlnLnVzZUxpbmVCcmVha3MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVPdGhlclR5cGVMaXN0ID0gIGZ1bmN0aW9uKGVsLCBub2RlTmFtZSwgY29tcG9zZXIpIHtcbiAgICB2YXIgb3RoZXJOb2RlTmFtZSA9IChub2RlTmFtZSA9PT0gXCJVTFwiKSA/IFwiT0xcIiA6IFwiVUxcIjtcbiAgICAvLyBUdXJuIGFuIG9yZGVyZWQgbGlzdCBpbnRvIGFuIHVub3JkZXJlZCBsaXN0XG4gICAgLy8gPG9sPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvb2w+XG4gICAgLy8gYmVjb21lczpcbiAgICAvLyA8dWw+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC91bD5cbiAgICAvLyBBbHNvIHJlbmFtZSBvdGhlciBsaXN0cyBpbiBzZWxlY3Rpb25cbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmUoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVuYW1lTGlzdHMgPSBbZWxdLmNvbmNhdChnZXRMaXN0c0luU2VsZWN0aW9uKG90aGVyTm9kZU5hbWUsIGNvbXBvc2VyKSk7XG5cbiAgICAgIC8vIEFsbCBzZWxlY3Rpb24gaW5uZXIgbGlzdHMgZ2V0IHJlbmFtZWQgdG9vXG4gICAgICBmb3IgKHZhciBsID0gcmVuYW1lTGlzdHMubGVuZ3RoOyBsLS07KSB7XG4gICAgICAgIHd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudChyZW5hbWVMaXN0c1tsXSwgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdldExpc3RzSW5TZWxlY3Rpb24gPSBmdW5jdGlvbihub2RlTmFtZSwgY29tcG9zZXIpIHtcbiAgICAgIHZhciByYW5nZXMgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0T3duUmFuZ2VzKCksXG4gICAgICAgICAgcmVuYW1lTGlzdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgciA9IHJhbmdlcy5sZW5ndGg7IHItLTspIHtcbiAgICAgICAgcmVuYW1lTGlzdHMgPSByZW5hbWVMaXN0cy5jb25jYXQocmFuZ2VzW3JdLmdldE5vZGVzKFsxXSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHJldHVybiBpc05vZGUobm9kZSwgbm9kZU5hbWUpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW5hbWVMaXN0cztcbiAgfTtcblxuICB2YXIgY3JlYXRlTGlzdEZhbGxiYWNrID0gZnVuY3Rpb24obm9kZU5hbWUsIGNvbXBvc2VyKSB7XG4gICAgLy8gRmFsbGJhY2sgZm9yIENyZWF0ZSBsaXN0XG4gICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlUmFuZ3koZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGVtcENsYXNzTmFtZSA9ICBcIl93eXNpaHRtbDUtdGVtcC1cIiArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgIHRlbXBFbGVtZW50ID0gY29tcG9zZXIuc2VsZWN0aW9uLmRlYmxvY2tBbmRTdXJyb3VuZCh7XG4gICAgICAgICAgICBcIm5vZGVOYW1lXCI6IFwiZGl2XCIsXG4gICAgICAgICAgICBcImNsYXNzTmFtZVwiOiB0ZW1wQ2xhc3NOYW1lXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaXNFbXB0eSwgbGlzdDtcblxuICAgICAgLy8gVGhpcyBzcGFjZSBjYXVzZXMgbmV3IGxpc3RzIHRvIG5ldmVyIGJyZWFrIG9uIGVudGVyIFxuICAgICAgdmFyIElOVklTSUJMRV9TUEFDRV9SRUdfRVhQID0gL1xcdUZFRkYvZztcbiAgICAgIHRlbXBFbGVtZW50LmlubmVySFRNTCA9IHRlbXBFbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKElOVklTSUJMRV9TUEFDRV9SRUdfRVhQLCBcIlwiKTtcbiAgICAgIFxuICAgICAgaWYgKHRlbXBFbGVtZW50KSB7XG4gICAgICAgIGlzRW1wdHkgPSB3eXNpaHRtbDUubGFuZy5hcnJheShbXCJcIiwgXCI8YnI+XCIsIHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0VdKS5jb250YWlucyh0ZW1wRWxlbWVudC5pbm5lckhUTUwpO1xuICAgICAgICBsaXN0ID0gd3lzaWh0bWw1LmRvbS5jb252ZXJ0VG9MaXN0KHRlbXBFbGVtZW50LCBub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBjb21wb3Nlci5wYXJlbnQuY29uZmlnLnVuZWRpdGFibGVDb250YWluZXJDbGFzc25hbWUpO1xuICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZWxlY3ROb2RlKGxpc3QucXVlcnlTZWxlY3RvcihcImxpXCIpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lKSB7XG4gICAgICB2YXIgZG9jICAgICAgICAgICA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBjbWQgICAgICAgICAgID0gKG5vZGVOYW1lID09PSBcIk9MXCIpID8gXCJpbnNlcnRPcmRlcmVkTGlzdFwiIDogXCJpbnNlcnRVbm9yZGVyZWRMaXN0XCIsXG4gICAgICAgICAgc2VsZWN0ZWROb2RlICA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICBsaXN0ICAgICAgICAgID0gZmluZExpc3RFbChzZWxlY3RlZE5vZGUsIG5vZGVOYW1lLCBjb21wb3Nlcik7XG5cbiAgICAgIGlmICghbGlzdC5lbCnCoHtcbiAgICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY21kKSkge1xuICAgICAgICAgIGRvYy5leGVjQ29tbWFuZChjbWQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjcmVhdGVMaXN0RmFsbGJhY2sobm9kZU5hbWUsIGNvbXBvc2VyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsaXN0Lm90aGVyKSB7XG4gICAgICAgIGhhbmRsZU90aGVyVHlwZUxpc3QobGlzdC5lbCwgbm9kZU5hbWUsIGNvbXBvc2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVNhbWVUeXBlTGlzdChsaXN0LmVsLCBub2RlTmFtZSwgY29tcG9zZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lKSB7XG4gICAgICB2YXIgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpLFxuICAgICAgICAgIGxpc3QgICAgICAgICA9IGZpbmRMaXN0RWwoc2VsZWN0ZWROb2RlLCBub2RlTmFtZSwgY29tcG9zZXIpO1xuXG4gICAgICByZXR1cm4gKGxpc3QuZWwgJiYgIWxpc3Qub3RoZXIpID8gbGlzdC5lbCA6IGZhbHNlO1xuICAgIH1cbiAgfTtcblxufSkod3lzaWh0bWw1KTs7d3lzaWh0bWw1LmNvbW1hbmRzLml0YWxpYyA9IHtcbiAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWNXaXRoVG9nZ2xlKGNvbXBvc2VyLCBjb21tYW5kLCBcImlcIik7XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgLy8gZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKFwiaXRhbGljXCIpIHJlc3VsdHM6XG4gICAgLy8gZmlyZWZveDogb25seSA8aT5cbiAgICAvLyBjaHJvbWU6ICA8aT4sIDxlbT4sIDxibG9ja3F1b3RlPiwgLi4uXG4gICAgLy8gaWU6ICAgICAgPGk+LCA8ZW0+XG4gICAgLy8gb3BlcmE6ICAgb25seSA8aT5cbiAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJpXCIpO1xuICB9XG59O1xuOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUUgID0gXCJ3eXNpd3lnLXRleHQtYWxpZ24tY2VudGVyXCIsXG4gICAgICBSRUdfRVhQICAgICA9IC93eXNpd3lnLXRleHQtYWxpZ24tWzAtOWEtel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlDZW50ZXIgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suZXhlYyhjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLnN0YXRlKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7XG47KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgQ0xBU1NfTkFNRSAgPSBcInd5c2l3eWctdGV4dC1hbGlnbi1sZWZ0XCIsXG4gICAgICBSRUdfRVhQICAgICA9IC93eXNpd3lnLXRleHQtYWxpZ24tWzAtOWEtel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlMZWZ0ID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLmV4ZWMoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5zdGF0ZShjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUUgID0gXCJ3eXNpd3lnLXRleHQtYWxpZ24tcmlnaHRcIixcbiAgICAgIFJFR19FWFAgICAgID0gL3d5c2l3eWctdGV4dC1hbGlnbi1bMC05YS16XSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuanVzdGlmeVJpZ2h0ID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLmV4ZWMoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5zdGF0ZShjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUUgID0gXCJ3eXNpd3lnLXRleHQtYWxpZ24tanVzdGlmeVwiLFxuICAgICAgUkVHX0VYUCAgICAgPSAvd3lzaXd5Zy10ZXh0LWFsaWduLVswLTlhLXpdKy9nO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5qdXN0aWZ5RnVsbCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5leGVjKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBTVFlMRV9TVFIgID0gXCJ0ZXh0LWFsaWduOiByaWdodDtcIixcbiAgICAgIFJFR19FWFAgPSAvKFxcc3xeKXRleHQtYWxpZ25cXHMqOlxccypbXjtcXHNdKzs/L2dpO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5hbGlnblJpZ2h0U3R5bGUgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suZXhlYyhjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBudWxsLCBudWxsLCBTVFlMRV9TVFIsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgbnVsbCwgbnVsbCwgU1RZTEVfU1RSLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIFNUWUxFX1NUUiAgPSBcInRleHQtYWxpZ246IGxlZnQ7XCIsXG4gICAgICBSRUdfRVhQID0gLyhcXHN8Xil0ZXh0LWFsaWduXFxzKjpcXHMqW147XFxzXSs7Py9naTtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuYWxpZ25MZWZ0U3R5bGUgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suZXhlYyhjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBudWxsLCBudWxsLCBTVFlMRV9TVFIsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgbnVsbCwgbnVsbCwgU1RZTEVfU1RSLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIFNUWUxFX1NUUiAgPSBcInRleHQtYWxpZ246IGNlbnRlcjtcIixcbiAgICAgIFJFR19FWFAgPSAvKFxcc3xeKXRleHQtYWxpZ25cXHMqOlxccypbXjtcXHNdKzs/L2dpO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5hbGlnbkNlbnRlclN0eWxlID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLmV4ZWMoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgbnVsbCwgbnVsbCwgU1RZTEVfU1RSLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLnN0YXRlKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIG51bGwsIG51bGwsIFNUWUxFX1NUUiwgUkVHX0VYUCk7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcbjt3eXNpaHRtbDUuY29tbWFuZHMucmVkbyA9IHtcbiAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIpIHtcbiAgICByZXR1cm4gY29tcG9zZXIudW5kb01hbmFnZXIucmVkbygpO1xuICB9LFxuXG4gIHN0YXRlOiBmdW5jdGlvbihjb21wb3Nlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbjt3eXNpaHRtbDUuY29tbWFuZHMudW5kZXJsaW5lID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlY1dpdGhUb2dnbGUoY29tcG9zZXIsIGNvbW1hbmQsIFwidVwiKTtcbiAgfSxcblxuICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJ1XCIpO1xuICB9XG59O1xuO3d5c2lodG1sNS5jb21tYW5kcy51bmRvID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3Nlcikge1xuICAgIHJldHVybiBjb21wb3Nlci51bmRvTWFuYWdlci51bmRvKCk7XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuO3d5c2lodG1sNS5jb21tYW5kcy5jcmVhdGVUYWJsZSA9IHtcbiAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHZhbHVlKSB7XG4gICAgICB2YXIgY29sLCByb3csIGh0bWw7XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29scyAmJiB2YWx1ZS5yb3dzICYmIHBhcnNlSW50KHZhbHVlLmNvbHMsIDEwKSA+IDAgJiYgcGFyc2VJbnQodmFsdWUucm93cywgMTApID4gMCkge1xuICAgICAgICAgIGlmICh2YWx1ZS50YWJsZVN0eWxlKSB7XG4gICAgICAgICAgICBodG1sID0gXCI8dGFibGUgc3R5bGU9XFxcIlwiICsgdmFsdWUudGFibGVTdHlsZSArIFwiXFxcIj5cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbCA9IFwiPHRhYmxlPlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sICs9IFwiPHRib2R5PlwiO1xuICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdmFsdWUucm93czsgcm93ICsrKSB7XG4gICAgICAgICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHZhbHVlLmNvbHM7IGNvbCArKykge1xuICAgICAgICAgICAgICAgICAgaHRtbCArPSBcIjx0ZD4mbmJzcDs8L3RkPlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbCArPSBcIjwvdGJvZHk+PC90YWJsZT5cIjtcbiAgICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiaW5zZXJ0SFRNTFwiLCBodG1sKTtcbiAgICAgICAgICAvL2NvbXBvc2VyLnNlbGVjdGlvbi5pbnNlcnRIVE1MKGh0bWwpO1xuICAgICAgfVxuXG5cbiAgfSxcblxuICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbjt3eXNpaHRtbDUuY29tbWFuZHMubWVyZ2VUYWJsZUNlbGxzID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgaWYgKGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uICYmIGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLnN0YXJ0ICYmIGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLmVuZCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSkge1xuICAgICAgICAgICAgICB3eXNpaHRtbDUuZG9tLnRhYmxlLnVubWVyZ2VDZWxsKGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLnN0YXJ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3eXNpaHRtbDUuZG9tLnRhYmxlLm1lcmdlQ2VsbHNCZXR3ZWVuKGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLnN0YXJ0LCBjb21wb3Nlci50YWJsZVNlbGVjdGlvbi5lbmQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfSxcblxuICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIGlmIChjb21wb3Nlci50YWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBzdGFydCA9IGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQgPSBjb21wb3Nlci50YWJsZVNlbGVjdGlvbi5lbmQ7XG4gICAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBzdGFydCA9PSBlbmQgJiZcbiAgICAgICAgICAgICAgKChcbiAgICAgICAgICAgICAgICAgIHd5c2lodG1sNS5kb20uZ2V0QXR0cmlidXRlKHN0YXJ0LCBcImNvbHNwYW5cIikgJiZcbiAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHd5c2lodG1sNS5kb20uZ2V0QXR0cmlidXRlKHN0YXJ0LCBcImNvbHNwYW5cIiksIDEwKSA+IDFcbiAgICAgICAgICAgICAgKSB8fCAoXG4gICAgICAgICAgICAgICAgICB3eXNpaHRtbDUuZG9tLmdldEF0dHJpYnV0ZShzdGFydCwgXCJyb3dzcGFuXCIpICYmXG4gICAgICAgICAgICAgICAgICBwYXJzZUludCh3eXNpaHRtbDUuZG9tLmdldEF0dHJpYnV0ZShzdGFydCwgXCJyb3dzcGFuXCIpLCAxMCkgPiAxXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbc3RhcnRdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbjt3eXNpaHRtbDUuY29tbWFuZHMuYWRkVGFibGVDZWxscyA9IHtcbiAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHZhbHVlKSB7XG4gICAgICBpZiAoY29tcG9zZXIudGFibGVTZWxlY3Rpb24gJiYgY29tcG9zZXIudGFibGVTZWxlY3Rpb24uc3RhcnQgJiYgY29tcG9zZXIudGFibGVTZWxlY3Rpb24uZW5kKSB7XG5cbiAgICAgICAgICAvLyBzd2l0Y2hlcyBzdGFydCBhbmQgZW5kIGlmIHN0YXJ0IGlzIGJpZ2dlciB0aGFuIGVuZCAocmV2ZXJzZSBzZWxlY3Rpb24pXG4gICAgICAgICAgdmFyIHRhYmxlU2VsZWN0ID0gd3lzaWh0bWw1LmRvbS50YWJsZS5vcmRlclNlbGVjdGlvbkVuZHMoY29tcG9zZXIudGFibGVTZWxlY3Rpb24uc3RhcnQsIGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLmVuZCk7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiYmVmb3JlXCIgfHwgdmFsdWUgPT0gXCJhYm92ZVwiKSB7XG4gICAgICAgICAgICAgIHd5c2lodG1sNS5kb20udGFibGUuYWRkQ2VsbHModGFibGVTZWxlY3Quc3RhcnQsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwiYWZ0ZXJcIiB8fCB2YWx1ZSA9PSBcImJlbG93XCIpIHtcbiAgICAgICAgICAgICAgd3lzaWh0bWw1LmRvbS50YWJsZS5hZGRDZWxscyh0YWJsZVNlbGVjdC5lbmQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY29tcG9zZXIudGFibGVTZWxlY3Rpb24uc2VsZWN0KHRhYmxlU2VsZWN0LnN0YXJ0LCB0YWJsZVNlbGVjdC5lbmQpO1xuICAgICAgICAgIH0sMCk7XG4gICAgICB9XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG47d3lzaWh0bWw1LmNvbW1hbmRzLmRlbGV0ZVRhYmxlQ2VsbHMgPSB7XG4gIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCB2YWx1ZSkge1xuICAgICAgaWYgKGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uICYmIGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLnN0YXJ0ICYmIGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLmVuZCkge1xuICAgICAgICAgIHZhciB0YWJsZVNlbGVjdCA9IHd5c2lodG1sNS5kb20udGFibGUub3JkZXJTZWxlY3Rpb25FbmRzKGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLnN0YXJ0LCBjb21wb3Nlci50YWJsZVNlbGVjdGlvbi5lbmQpLFxuICAgICAgICAgICAgICBpZHggPSB3eXNpaHRtbDUuZG9tLnRhYmxlLmluZGV4T2YodGFibGVTZWxlY3Quc3RhcnQpLFxuICAgICAgICAgICAgICBzZWxDZWxsLFxuICAgICAgICAgICAgICB0YWJsZSA9IGNvbXBvc2VyLnRhYmxlU2VsZWN0aW9uLnRhYmxlO1xuXG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS50YWJsZS5yZW1vdmVDZWxscyh0YWJsZVNlbGVjdC5zdGFydCwgdmFsdWUpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIC8vIG1vdmUgc2VsZWN0aW9uIHRvIG5leHQgb3IgcHJldmlvdXMgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgc2VsQ2VsbCA9IHd5c2lodG1sNS5kb20udGFibGUuZmluZENlbGwodGFibGUsIGlkeCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFzZWxDZWxsKXtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcInJvd1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsQ2VsbCA9IHd5c2lodG1sNS5kb20udGFibGUuZmluZENlbGwodGFibGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyb3dcIjogaWR4LnJvdyAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sXCI6IGlkeC5jb2xcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiY29sdW1uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxDZWxsID0gd3lzaWh0bWw1LmRvbS50YWJsZS5maW5kQ2VsbCh0YWJsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInJvd1wiOiBpZHgucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbFwiOiBpZHguY29sIC0gMVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzZWxDZWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3Nlci50YWJsZVNlbGVjdGlvbi5zZWxlY3Qoc2VsQ2VsbCwgc2VsQ2VsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKTtcblxuICAgICAgfVxuICB9LFxuXG4gIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuO3d5c2lodG1sNS5jb21tYW5kcy5pbmRlbnRMaXN0ID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCwgdmFsdWUpIHtcbiAgICB2YXIgbGlzdEVscyA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25QYXJlbnRzQnlUYWcoJ0xJJyk7XG4gICAgaWYgKGxpc3RFbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyeVRvUHVzaExpTGV2ZWwobGlzdEVscywgY29tcG9zZXIuc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHRyeVRvUHVzaExpTGV2ZWw6IGZ1bmN0aW9uKGxpTm9kZXMsIHNlbGVjdGlvbikge1xuICAgIHZhciBsaXN0VGFnLCBsaXN0LCBwcmV2TGksIGxpTm9kZSwgcHJldkxpTGlzdCxcbiAgICAgICAgZm91bmQgPSBmYWxzZTtcblxuICAgIHNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVJhbmd5KGZ1bmN0aW9uKCkge1xuXG4gICAgICBmb3IgKHZhciBpID0gbGlOb2Rlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbGlOb2RlID0gbGlOb2Rlc1tpXTtcbiAgICAgICAgbGlzdFRhZyA9IChsaU5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ09MJykgPyAnT0wnIDogJ1VMJztcbiAgICAgICAgbGlzdCA9IGxpTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobGlzdFRhZyk7XG4gICAgICAgIHByZXZMaSA9IHd5c2lodG1sNS5kb20uZG9tTm9kZShsaU5vZGUpLnByZXYoe25vZGVUeXBlczogW3d5c2lodG1sNS5FTEVNRU5UX05PREVdfSk7XG4gICAgICAgIHByZXZMaUxpc3QgPSAocHJldkxpKSA/IHByZXZMaS5xdWVyeVNlbGVjdG9yKCd1bCwgb2wnKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKHByZXZMaSkge1xuICAgICAgICAgIGlmIChwcmV2TGlMaXN0KSB7XG4gICAgICAgICAgICBwcmV2TGlMaXN0LmFwcGVuZENoaWxkKGxpTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQobGlOb2RlKTtcbiAgICAgICAgICAgIHByZXZMaS5hcHBlbmRDaGlsZChsaXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbn07XG47d3lzaWh0bWw1LmNvbW1hbmRzLm91dGRlbnRMaXN0ID0ge1xuICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCwgdmFsdWUpIHtcbiAgICB2YXIgbGlzdEVscyA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25QYXJlbnRzQnlUYWcoJ0xJJyk7XG4gICAgaWYgKGxpc3RFbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyeVRvUHVsbExpTGV2ZWwobGlzdEVscywgY29tcG9zZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgdHJ5VG9QdWxsTGlMZXZlbDogZnVuY3Rpb24obGlOb2RlcywgY29tcG9zZXIpIHtcbiAgICB2YXIgbGlzdE5vZGUsIG91dGVyTGlzdE5vZGUsIG91dGVyTGlOb2RlLCBsaXN0LCBwcmV2TGksIGxpTm9kZSwgYWZ0ZXJMaXN0LFxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVJhbmd5KGZ1bmN0aW9uKCkge1xuXG4gICAgICBmb3IgKHZhciBpID0gbGlOb2Rlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbGlOb2RlID0gbGlOb2Rlc1tpXTtcbiAgICAgICAgaWYgKGxpTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgbGlzdE5vZGUgPSBsaU5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICAgIGlmIChsaXN0Tm9kZS50YWdOYW1lID09PSAnT0wnIHx8IGxpc3ROb2RlLnRhZ05hbWUgPT09ICdVTCcpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgb3V0ZXJMaXN0Tm9kZSA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChsaXN0Tm9kZS5wYXJlbnROb2RlLCB7IG5vZGVOYW1lOiBbJ09MJywgJ1VMJ119LCBmYWxzZSwgY29tcG9zZXIuZWxlbWVudCk7XG4gICAgICAgICAgICBvdXRlckxpTm9kZSA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChsaXN0Tm9kZS5wYXJlbnROb2RlLCB7IG5vZGVOYW1lOiBbJ0xJJ119LCBmYWxzZSwgY29tcG9zZXIuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmIChvdXRlckxpc3ROb2RlICYmIG91dGVyTGlOb2RlKSB7XG5cbiAgICAgICAgICAgICAgaWYgKGxpTm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGFmdGVyTGlzdCA9IHRoYXQuZ2V0QWZ0ZXJMaXN0KGxpc3ROb2RlLCBsaU5vZGUpO1xuICAgICAgICAgICAgICAgIGxpTm9kZS5hcHBlbmRDaGlsZChhZnRlckxpc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dGVyTGlzdE5vZGUuaW5zZXJ0QmVmb3JlKGxpTm9kZSwgb3V0ZXJMaU5vZGUubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIGlmIChsaU5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBhZnRlckxpc3QgPSB0aGF0LmdldEFmdGVyTGlzdChsaXN0Tm9kZSwgbGlOb2RlKTtcbiAgICAgICAgICAgICAgICBsaU5vZGUuYXBwZW5kQ2hpbGQoYWZ0ZXJMaXN0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSBsaU5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGotLTspIHtcbiAgICAgICAgICAgICAgICBsaXN0Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsaU5vZGUuY2hpbGROb2Rlc1tqXSwgbGlzdE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGlzdE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSwgbGlzdE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICBsaU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaU5vZGUpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFudXBcbiAgICAgICAgICAgIGlmIChsaXN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxpc3ROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGlzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9LFxuXG4gIGdldEFmdGVyTGlzdDogZnVuY3Rpb24obGlzdE5vZGUsIGxpTm9kZSkge1xuICAgIHZhciBub2RlTmFtZSA9IGxpc3ROb2RlLm5vZGVOYW1lLFxuICAgICAgICBuZXdMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG5cbiAgICB3aGlsZSAobGlOb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICBuZXdMaXN0LmFwcGVuZENoaWxkKGxpTm9kZS5uZXh0U2libGluZyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdMaXN0O1xuICB9XG5cbn07Oy8qKlxuICogVW5kbyBNYW5hZ2VyIGZvciB3eXNpaHRtbDVcbiAqIHNsaWdodGx5IGluc3BpcmVkIGJ5IGh0dHA6Ly9ybml3YS5jb20vZWRpdGluZy91bmRvbWFuYWdlci5odG1sI3RoZS11bmRvbWFuYWdlci1pbnRlcmZhY2VcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgWl9LRVkgICAgICAgICAgICAgICA9IDkwLFxuICAgICAgWV9LRVkgICAgICAgICAgICAgICA9IDg5LFxuICAgICAgQkFDS1NQQUNFX0tFWSAgICAgICA9IDgsXG4gICAgICBERUxFVEVfS0VZICAgICAgICAgID0gNDYsXG4gICAgICBNQVhfSElTVE9SWV9FTlRSSUVTID0gMjUsXG4gICAgICBEQVRBX0FUVFJfTk9ERSAgICAgID0gXCJkYXRhLXd5c2lodG1sNS1zZWxlY3Rpb24tbm9kZVwiLFxuICAgICAgREFUQV9BVFRSX09GRlNFVCAgICA9IFwiZGF0YS13eXNpaHRtbDUtc2VsZWN0aW9uLW9mZnNldFwiLFxuICAgICAgVU5ET19IVE1MICAgICAgICAgICA9ICc8c3BhbiBpZD1cIl93eXNpaHRtbDUtdW5kb1wiIGNsYXNzPVwiX3d5c2lodG1sNS10ZW1wXCI+JyArIHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UgKyAnPC9zcGFuPicsXG4gICAgICBSRURPX0hUTUwgICAgICAgICAgID0gJzxzcGFuIGlkPVwiX3d5c2lodG1sNS1yZWRvXCIgY2xhc3M9XCJfd3lzaWh0bWw1LXRlbXBcIj4nICsgd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSArICc8L3NwYW4+JyxcbiAgICAgIGRvbSAgICAgICAgICAgICAgICAgPSB3eXNpaHRtbDUuZG9tO1xuXG4gIGZ1bmN0aW9uIGNsZWFuVGVtcEVsZW1lbnRzKGRvYykge1xuICAgIHZhciB0ZW1wRWxlbWVudDtcbiAgICB3aGlsZSAodGVtcEVsZW1lbnQgPSBkb2MucXVlcnlTZWxlY3RvcihcIi5fd3lzaWh0bWw1LXRlbXBcIikpIHtcbiAgICAgIHRlbXBFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHd5c2lodG1sNS5VbmRvTWFuYWdlciA9IHd5c2lodG1sNS5sYW5nLkRpc3BhdGNoZXIuZXh0ZW5kKFxuICAgIC8qKiBAc2NvcGUgd3lzaWh0bWw1LlVuZG9NYW5hZ2VyLnByb3RvdHlwZSAqLyB7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICB0aGlzLmNvbXBvc2VyID0gZWRpdG9yLmNvbXBvc2VyO1xuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jb21wb3Nlci5lbGVtZW50O1xuXG4gICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgIHRoaXMuaGlzdG9yeVN0ciA9IFtdO1xuICAgICAgdGhpcy5oaXN0b3J5RG9tID0gW107XG5cbiAgICAgIHRoaXMudHJhbnNhY3QoKTtcblxuICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgIH0sXG5cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCAgICAgID0gdGhpcyxcbiAgICAgICAgICBkb2MgICAgICAgPSB0aGlzLmNvbXBvc2VyLnNhbmRib3guZ2V0RG9jdW1lbnQoKSxcbiAgICAgICAgICBsYXN0S2V5O1xuXG4gICAgICAvLyBDYXRjaCBDVFJMK1ogYW5kIENUUkwrWVxuICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSB8fCAoIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlLFxuICAgICAgICAgICAgaXNVbmRvID0ga2V5Q29kZSA9PT0gWl9LRVkgJiYgIWV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgaXNSZWRvID0gKGtleUNvZGUgPT09IFpfS0VZICYmIGV2ZW50LnNoaWZ0S2V5KSB8fCAoa2V5Q29kZSA9PT0gWV9LRVkpO1xuXG4gICAgICAgIGlmIChpc1VuZG8pIHtcbiAgICAgICAgICB0aGF0LnVuZG8oKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVkbykge1xuICAgICAgICAgIHRoYXQucmVkbygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYXRjaCBkZWxldGUgYW5kIGJhY2tzcGFjZVxuICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gbGFzdEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RLZXkgPSBrZXlDb2RlO1xuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBCQUNLU1BBQ0VfS0VZIHx8IGtleUNvZGUgPT09IERFTEVURV9LRVkpIHtcbiAgICAgICAgICB0aGF0LnRyYW5zYWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmVkaXRvclxuICAgICAgICAub24oXCJuZXd3b3JkOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoYXQudHJhbnNhY3QoKTtcbiAgICAgICAgfSlcblxuICAgICAgICAub24oXCJiZWZvcmVjb21tYW5kOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoYXQudHJhbnNhY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRyYW5zYWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcmV2aW91c0h0bWwgICAgICA9IHRoaXMuaGlzdG9yeVN0clt0aGlzLnBvc2l0aW9uIC0gMV0sXG4gICAgICAgICAgY3VycmVudEh0bWwgICAgICAgPSB0aGlzLmNvbXBvc2VyLmdldFZhbHVlKGZhbHNlLCBmYWxzZSksXG4gICAgICAgICAgY29tcG9zZXJJc1Zpc2libGUgICA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgJiYgdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCA+IDAsXG4gICAgICAgICAgcmFuZ2UsIG5vZGUsIG9mZnNldCwgZWxlbWVudCwgcG9zaXRpb247XG5cbiAgICAgIGlmIChjdXJyZW50SHRtbCA9PT0gcHJldmlvdXNIdG1sKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaGlzdG9yeVN0ci5sZW5ndGggPSB0aGlzLmhpc3RvcnlEb20ubGVuZ3RoID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIGlmIChsZW5ndGggPiBNQVhfSElTVE9SWV9FTlRSSUVTKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVN0ci5zaGlmdCgpO1xuICAgICAgICB0aGlzLmhpc3RvcnlEb20uc2hpZnQoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi0tO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG5cbiAgICAgIGlmIChjb21wb3NlcklzVmlzaWJsZSkge1xuICAgICAgICAvLyBEbyBub3Qgc3RhcnQgc2F2aW5nIHNlbGVjdGlvbiBpZiBjb21wb3NlciBpcyBub3QgdmlzaWJsZVxuICAgICAgICByYW5nZSAgID0gdGhpcy5jb21wb3Nlci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgbm9kZSAgICA9IChyYW5nZSAmJiByYW5nZS5zdGFydENvbnRhaW5lcikgPyByYW5nZS5zdGFydENvbnRhaW5lciA6IHRoaXMuZWxlbWVudDtcbiAgICAgICAgb2Zmc2V0ICA9IChyYW5nZSAmJiByYW5nZS5zdGFydE9mZnNldCkgPyByYW5nZS5zdGFydE9mZnNldCA6IDA7XG5cbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50ICA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0Q2hpbGROb2RlSW5kZXgoZWxlbWVudCwgbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShEQVRBX0FUVFJfT0ZGU0VULCBvZmZzZXQpO1xuICAgICAgICBpZiAodHlwZW9mKHBvc2l0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKERBVEFfQVRUUl9OT0RFLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNsb25lID0gdGhpcy5lbGVtZW50LmNsb25lTm9kZSghIWN1cnJlbnRIdG1sKTtcbiAgICAgIHRoaXMuaGlzdG9yeURvbS5wdXNoKGNsb25lKTtcbiAgICAgIHRoaXMuaGlzdG9yeVN0ci5wdXNoKGN1cnJlbnRIdG1sKTtcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoREFUQV9BVFRSX09GRlNFVCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKERBVEFfQVRUUl9OT0RFKTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICB1bmRvOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJhbnNhY3QoKTtcblxuICAgICAgaWYgKCF0aGlzLnVuZG9Qb3NzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQodGhpcy5oaXN0b3J5RG9tWy0tdGhpcy5wb3NpdGlvbiAtIDFdKTtcbiAgICAgIHRoaXMuZWRpdG9yLmZpcmUoXCJ1bmRvOmNvbXBvc2VyXCIpO1xuICAgIH0sXG5cbiAgICByZWRvOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yZWRvUG9zc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KHRoaXMuaGlzdG9yeURvbVsrK3RoaXMucG9zaXRpb24gLSAxXSk7XG4gICAgICB0aGlzLmVkaXRvci5maXJlKFwicmVkbzpjb21wb3NlclwiKTtcbiAgICB9LFxuXG4gICAgdW5kb1Bvc3NpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID4gMTtcbiAgICB9LFxuXG4gICAgcmVkb1Bvc3NpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uIDwgdGhpcy5oaXN0b3J5U3RyLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbihoaXN0b3J5RW50cnkpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgY2hpbGROb2RlcyA9IGhpc3RvcnlFbnRyeS5jaGlsZE5vZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGhpc3RvcnlFbnRyeS5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzdG9yZSBzZWxlY3Rpb25cbiAgICAgIHZhciBvZmZzZXQsXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwb3NpdGlvbjtcblxuICAgICAgaWYgKGhpc3RvcnlFbnRyeS5oYXNBdHRyaWJ1dGUoREFUQV9BVFRSX09GRlNFVCkpIHtcbiAgICAgICAgb2Zmc2V0ICAgID0gaGlzdG9yeUVudHJ5LmdldEF0dHJpYnV0ZShEQVRBX0FUVFJfT0ZGU0VUKTtcbiAgICAgICAgcG9zaXRpb24gID0gaGlzdG9yeUVudHJ5LmdldEF0dHJpYnV0ZShEQVRBX0FUVFJfTk9ERSk7XG4gICAgICAgIG5vZGUgICAgICA9IHRoaXMuZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgICAgICA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiW1wiICsgREFUQV9BVFRSX09GRlNFVCArIFwiXVwiKSB8fCB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIG9mZnNldCAgICA9IG5vZGUuZ2V0QXR0cmlidXRlKERBVEFfQVRUUl9PRkZTRVQpO1xuICAgICAgICBwb3NpdGlvbiAgPSBub2RlLmdldEF0dHJpYnV0ZShEQVRBX0FUVFJfTk9ERSk7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKERBVEFfQVRUUl9PRkZTRVQpO1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShEQVRBX0FUVFJfTk9ERSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gdGhpcy5nZXRDaGlsZE5vZGVCeUluZGV4KG5vZGUsICtwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcG9zZXIuc2VsZWN0aW9uLnNldChub2RlLCBvZmZzZXQpO1xuICAgIH0sXG5cbiAgICBnZXRDaGlsZE5vZGVJbmRleDogZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuICAgICAgdmFyIGkgICAgICAgICAgID0gMCxcbiAgICAgICAgICBjaGlsZE5vZGVzICA9IHBhcmVudC5jaGlsZE5vZGVzLFxuICAgICAgICAgIGxlbmd0aCAgICAgID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpXSA9PT0gY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDaGlsZE5vZGVCeUluZGV4OiBmdW5jdGlvbihwYXJlbnQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcGFyZW50LmNoaWxkTm9kZXNbaW5kZXhdO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuOy8qKlxuICogVE9ETzogdGhlIGZvbGxvd2luZyBtZXRob2RzIHN0aWxsIG5lZWQgdW5pdCB0ZXN0IGNvdmVyYWdlXG4gKi9cbnd5c2lodG1sNS52aWV3cy5WaWV3ID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlZpZXcucHJvdG90eXBlICovIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLnBhcmVudCAgID0gcGFyZW50O1xuICAgIHRoaXMuZWxlbWVudCAgPSB0ZXh0YXJlYUVsZW1lbnQ7XG4gICAgdGhpcy5jb25maWcgICA9IGNvbmZpZztcbiAgICBpZiAoIXRoaXMuY29uZmlnLm5vVGV4dGFyZWEpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZVZpZXdDaGFuZ2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgX29ic2VydmVWaWV3Q2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQub24oXCJiZWZvcmVsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhhdC5wYXJlbnQub24oXCJjaGFuZ2Vfdmlld1wiLCBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIGlmICh2aWV3ID09PSB0aGF0Lm5hbWUpIHtcbiAgICAgICAgICB0aGF0LnBhcmVudC5jdXJyZW50VmlldyA9IHRoYXQ7XG4gICAgICAgICAgdGhhdC5zaG93KCk7XG4gICAgICAgICAgLy8gVXNpbmcgdGlueSBkZWxheSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBpcyBzZXQgYmVmb3JlIGZvY3VzaW5nXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5mb2N1cygpOyB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkgeyB0aGlzLmVsZW1lbnQuZm9jdXMoKTsgfSBjYXRjaChlKSB7fVxuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICB9LFxuXG4gIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICB9LFxuXG4gIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICB9XG59KTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gICAgICAgPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgYnJvd3NlciAgID0gd3lzaWh0bWw1LmJyb3dzZXI7XG5cbiAgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyID0gd3lzaWh0bWw1LnZpZXdzLlZpZXcuZXh0ZW5kKFxuICAgIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyLnByb3RvdHlwZSAqLyB7XG4gICAgbmFtZTogXCJjb21wb3NlclwiLFxuXG4gICAgLy8gTmVlZGVkIGZvciBmaXJlZm94IGluIG9yZGVyIHRvIGRpc3BsYXkgYSBwcm9wZXIgY2FyZXQgaW4gYW4gZW1wdHkgY29udGVudEVkaXRhYmxlXG4gICAgQ0FSRVRfSEFDSzogXCI8YnI+XCIsXG5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ocGFyZW50LCBlZGl0YWJsZUVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgdGhpcy5iYXNlKHBhcmVudCwgZWRpdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5ub1RleHRhcmVhKSB7XG4gICAgICAgICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMucGFyZW50LnRleHRhcmVhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkaXRhYmxlQXJlYSA9IGVkaXRhYmxlRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5jb250ZW50RWRpdGFibGVNb2RlKSB7XG4gICAgICAgICAgdGhpcy5faW5pdENvbnRlbnRFZGl0YWJsZUFyZWEoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faW5pdFNhbmRib3goKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IGJyb3dzZXIuZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkoKSA/IFwiXCIgOiB0aGlzLkNBUkVUX0hBQ0s7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbihwYXJzZSwgY2xlYXJJbnRlcm5hbHMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaXNFbXB0eSgpID8gXCJcIiA6IHd5c2lodG1sNS5xdWlya3MuZ2V0Q29ycmVjdElubmVySFRNTCh0aGlzLmVsZW1lbnQpO1xuICAgICAgaWYgKHBhcnNlICE9PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMucGFyZW50LnBhcnNlKHZhbHVlLCAoY2xlYXJJbnRlcm5hbHMgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKGh0bWwsIHBhcnNlKSB7XG4gICAgICBpZiAocGFyc2UpIHtcbiAgICAgICAgaHRtbCA9IHRoaXMucGFyZW50LnBhcnNlKGh0bWwpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmlubmVyVGV4dCA9IGh0bWw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFuVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBhcmVudC5wYXJzZSh0aGlzLmVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZWRpdGFibGVBcmVhLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9kaXNwbGF5U3R5bGUgfHwgXCJcIjtcblxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5ub1RleHRhcmVhICYmICF0aGlzLnRleHRhcmVhLmVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0aGlzLCBvdGhlcndpc2UgY29udGVudEVkaXRhYmxlIGJlY29tZXMgdW5lZGl0YWJsZVxuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9kaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGhpcy5lZGl0YWJsZUFyZWEpO1xuICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlTdHlsZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheVN0eWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdGFibGVBcmVhLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhcmVudC5maXJlKFwiZGlzYWJsZTpjb21wb3NlclwiKTtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgfSxcblxuICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhcmVudC5maXJlKFwiZW5hYmxlOmNvbXBvc2VyXCIpO1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcInRydWVcIik7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbihzZXRUb0VuZCkge1xuICAgICAgLy8gSUUgOCBmaXJlcyB0aGUgZm9jdXMgZXZlbnQgYWZ0ZXIgLmZvY3VzKClcbiAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIGJ5IG91ciBzaW11bGF0ZV9wbGFjZWhvbGRlci5qcyB0byB3b3JrXG4gICAgICAvLyB0aGVyZWZvcmUgd2UgY2xlYXIgaXQgb3Vyc2VsdmVzIHRoaXMgdGltZVxuICAgICAgaWYgKHd5c2lodG1sNS5icm93c2VyLmRvZXNBc3luY0ZvY3VzKCkgJiYgdGhpcy5oYXNQbGFjZWhvbGRlclNldCgpKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iYXNlKCk7XG5cbiAgICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKHNldFRvRW5kICYmIGxhc3RDaGlsZCAmJiB0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICBpZiAobGFzdENoaWxkLm5vZGVOYW1lID09PSBcIkJSXCIpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRCZWZvcmUodGhpcy5lbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0QWZ0ZXIodGhpcy5lbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvbS5nZXRUZXh0Q29udGVudCh0aGlzLmVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBoYXNQbGFjZWhvbGRlclNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXh0Q29udGVudCgpID09ICgodGhpcy5jb25maWcubm9UZXh0YXJlYSkgPyB0aGlzLmVkaXRhYmxlQXJlYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBsYWNlaG9sZGVyXCIpIDogdGhpcy50ZXh0YXJlYS5lbGVtZW50LmdldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpKSAmJiB0aGlzLnBsYWNlaG9sZGVyU2V0O1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbm5lckhUTUwgPSB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gKC9eKFxcc3w8YnI+fDxcXC9icj58PHA+fDxcXC9wPikqJC9pKS50ZXN0KGlubmVySFRNTCkgIHx8XG4gICAgICAgICAgICAgaW5uZXJIVE1MID09PSBcIlwiICAgICAgICAgICAgfHxcbiAgICAgICAgICAgICBpbm5lckhUTUwgPT09IFwiPGJyPlwiICAgICAgICB8fFxuICAgICAgICAgICAgIGlubmVySFRNTCA9PT0gXCI8cD48L3A+XCIgICAgIHx8XG4gICAgICAgICAgICAgaW5uZXJIVE1MID09PSBcIjxwPjxicj48L3A+XCIgfHxcbiAgICAgICAgICAgICB0aGlzLmhhc1BsYWNlaG9sZGVyU2V0KCk7XG4gICAgfSxcblxuICAgIF9pbml0Q29udGVudEVkaXRhYmxlQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5jb25maWcubm9UZXh0YXJlYSkge1xuICAgICAgICAgICAgdGhpcy5zYW5kYm94ID0gbmV3IGRvbS5Db250ZW50RWRpdGFibGVBcmVhKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2NyZWF0ZSgpO1xuICAgICAgICAgICAgfSwge30sIHRoaXMuZWRpdGFibGVBcmVhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2FuZGJveCA9IG5ldyBkb20uQ29udGVudEVkaXRhYmxlQXJlYShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jcmVhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lZGl0YWJsZUFyZWEgPSB0aGlzLnNhbmRib3guZ2V0Q29udGVudEVkaXRhYmxlKCk7XG4gICAgICAgICAgICBkb20uaW5zZXJ0KHRoaXMuZWRpdGFibGVBcmVhKS5hZnRlcih0aGlzLnRleHRhcmVhLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlV3lzaXd5Z0Zvcm1GaWVsZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0U2FuZGJveDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2FuZGJveCA9IG5ldyBkb20uU2FuZGJveChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5fY3JlYXRlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHN0eWxlc2hlZXRzOiAgdGhpcy5jb25maWcuc3R5bGVzaGVldHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lZGl0YWJsZUFyZWEgID0gdGhpcy5zYW5kYm94LmdldElmcmFtZSgpO1xuXG4gICAgICB2YXIgdGV4dGFyZWFFbGVtZW50ID0gdGhpcy50ZXh0YXJlYS5lbGVtZW50O1xuICAgICAgZG9tLmluc2VydCh0aGlzLmVkaXRhYmxlQXJlYSkuYWZ0ZXIodGV4dGFyZWFFbGVtZW50KTtcblxuICAgICAgdGhpcy5fY3JlYXRlV3lzaXd5Z0Zvcm1GaWVsZCgpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGVzIGhpZGRlbiBmaWVsZCB3aGljaCB0ZWxscyB0aGUgc2VydmVyIGFmdGVyIHN1Ym1pdCwgdGhhdCB0aGUgdXNlciB1c2VkIGFuIHd5c2l3eWcgZWRpdG9yXG4gICAgX2NyZWF0ZVd5c2l3eWdGb3JtRmllbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0YXJlYS5lbGVtZW50LmZvcm0pIHtcbiAgICAgICAgICB2YXIgaGlkZGVuRmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgaGlkZGVuRmllbGQudHlwZSAgID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICBoaWRkZW5GaWVsZC5uYW1lICAgPSBcIl93eXNpaHRtbDVfbW9kZVwiO1xuICAgICAgICAgIGhpZGRlbkZpZWxkLnZhbHVlICA9IDE7XG4gICAgICAgICAgZG9tLmluc2VydChoaWRkZW5GaWVsZCkuYWZ0ZXIodGhpcy50ZXh0YXJlYS5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuZG9jICAgICAgICAgICAgICAgID0gdGhpcy5zYW5kYm94LmdldERvY3VtZW50KCk7XG4gICAgICB0aGlzLmVsZW1lbnQgICAgICAgICAgICA9ICh0aGlzLmNvbmZpZy5jb250ZW50RWRpdGFibGVNb2RlKSA/IHRoaXMuc2FuZGJveC5nZXRDb250ZW50RWRpdGFibGUoKSA6IHRoaXMuZG9jLmJvZHk7XG4gICAgICBpZiAoIXRoaXMuY29uZmlnLm5vVGV4dGFyZWEpIHtcbiAgICAgICAgICB0aGlzLnRleHRhcmVhICAgICAgICAgICA9IHRoaXMucGFyZW50LnRleHRhcmVhO1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgID0gdGhpcy50ZXh0YXJlYS5nZXRWYWx1ZSh0cnVlLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2xlYW5VcCgpOyAvLyBjbGVhbnMgY29udGVudGVkaXRhYmxlIG9uIGluaXRpYXRpb24gYXMgaXQgbWF5IGNvbnRhaW4gaHRtbFxuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIHNlbGVjdGlvbiBoYW5kbGVyIGlzIHJlYWR5XG4gICAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyB3eXNpaHRtbDUuU2VsZWN0aW9uKHRoaXMucGFyZW50LCB0aGlzLmVsZW1lbnQsIHRoaXMuY29uZmlnLnVuZWRpdGFibGVDb250YWluZXJDbGFzc25hbWUpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgY29tbWFuZHMgZGlzcGF0Y2hlciBpcyByZWFkeVxuICAgICAgdGhpcy5jb21tYW5kcyAgPSBuZXcgd3lzaWh0bWw1LkNvbW1hbmRzKHRoaXMucGFyZW50KTtcblxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5ub1RleHRhcmVhKSB7XG4gICAgICAgICAgZG9tLmNvcHlBdHRyaWJ1dGVzKFtcbiAgICAgICAgICAgICAgXCJjbGFzc05hbWVcIiwgXCJzcGVsbGNoZWNrXCIsIFwidGl0bGVcIiwgXCJsYW5nXCIsIFwiZGlyXCIsIFwiYWNjZXNzS2V5XCJcbiAgICAgICAgICBdKS5mcm9tKHRoaXMudGV4dGFyZWEuZWxlbWVudCkudG8odGhpcy5lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5jb25maWcuY29tcG9zZXJDbGFzc05hbWUpO1xuICAgICAgLy9cbiAgICAgIC8vIE1ha2UgdGhlIGVkaXRvciBsb29rIGxpa2UgdGhlIG9yaWdpbmFsIHRleHRhcmVhLCBieSBzeW5jaW5nIHN0eWxlc1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnN0eWxlICYmICF0aGlzLmNvbmZpZy5jb250ZW50RWRpdGFibGVNb2RlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vYnNlcnZlKCk7XG5cbiAgICAgIHZhciBuYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpO1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNvbnRlbnRFZGl0YWJsZU1vZGUpIHsgZG9tLmFkZENsYXNzKHRoaXMuZWRpdGFibGVBcmVhLCBuYW1lKTsgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVuYWJsZSgpO1xuXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLm5vVGV4dGFyZWEgJiYgdGhpcy50ZXh0YXJlYS5lbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW11bGF0ZSBodG1sNSBwbGFjZWhvbGRlciBhdHRyaWJ1dGUgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgIHZhciBwbGFjZWhvbGRlclRleHQgPSB0eXBlb2YodGhpcy5jb25maWcucGxhY2Vob2xkZXIpID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gdGhpcy5jb25maWcucGxhY2Vob2xkZXJcbiAgICAgICAgOiAoKHRoaXMuY29uZmlnLm5vVGV4dGFyZWEpID8gdGhpcy5lZGl0YWJsZUFyZWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbGFjZWhvbGRlclwiKSA6IHRoaXMudGV4dGFyZWEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSk7XG4gICAgICBpZiAocGxhY2Vob2xkZXJUZXh0KSB7XG4gICAgICAgIGRvbS5zaW11bGF0ZVBsYWNlaG9sZGVyKHRoaXMucGFyZW50LCB0aGlzLCBwbGFjZWhvbGRlclRleHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgYnJvd3NlciBhdm9pZHMgdXNpbmcgaW5saW5lIHN0eWxlcyB3aGVuZXZlciBwb3NzaWJsZVxuICAgICAgdGhpcy5jb21tYW5kcy5leGVjKFwic3R5bGVXaXRoQ1NTXCIsIGZhbHNlKTtcblxuICAgICAgdGhpcy5faW5pdEF1dG9MaW5raW5nKCk7XG4gICAgICB0aGlzLl9pbml0T2JqZWN0UmVzaXppbmcoKTtcbiAgICAgIHRoaXMuX2luaXRVbmRvTWFuYWdlcigpO1xuICAgICAgdGhpcy5faW5pdExpbmVCcmVha2luZygpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBodG1sNSBhdXRvZm9jdXMgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgIC8vIFRoaXMgZG9lc24ndCB3b3JrIG9uIElPUyAoNS4xLjEpXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLm5vVGV4dGFyZWEgJiYgKHRoaXMudGV4dGFyZWEuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJhdXRvZm9jdXNcIikgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSA9PSB0aGlzLnRleHRhcmVhLmVsZW1lbnQpICYmICFicm93c2VyLmlzSW9zKCkpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5mb2N1cyh0cnVlKTsgfSwgMTAwKTtcbiAgICAgIH1cblxuICAgICAgLy8gSUUgc29tZXRpbWVzIGxlYXZlcyBhIHNpbmdsZSBwYXJhZ3JhcGgsIHdoaWNoIGNhbid0IGJlIHJlbW92ZWQgYnkgdGhlIHVzZXJcbiAgICAgIGlmICghYnJvd3Nlci5jbGVhcnNDb250ZW50RWRpdGFibGVDb3JyZWN0bHkoKSkge1xuICAgICAgICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgYSBzeW5jIHRoYXQgbWFrZXMgc3VyZSB0aGF0IHRleHRhcmVhIGFuZCBlZGl0b3IgaGF2ZSB0aGUgc2FtZSBjb250ZW50XG4gICAgICBpZiAodGhpcy5pbml0U3luYyAmJiB0aGlzLmNvbmZpZy5zeW5jKSB7XG4gICAgICAgIHRoaXMuaW5pdFN5bmMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gT2theSBoaWRlIHRoZSB0ZXh0YXJlYSwgd2UgYXJlIHJlYWR5IHRvIGdvXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLm5vVGV4dGFyZWEpIHsgdGhpcy50ZXh0YXJlYS5oaWRlKCk7IH1cblxuICAgICAgLy8gRmlyZSBnbG9iYWwgKGJlZm9yZS0pbG9hZCBldmVudFxuICAgICAgdGhpcy5wYXJlbnQuZmlyZShcImJlZm9yZWxvYWRcIikuZmlyZShcImxvYWRcIik7XG4gICAgfSxcblxuICAgIF9pbml0QXV0b0xpbmtpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgc3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nID0gYnJvd3Nlci5jYW5EaXNhYmxlQXV0b0xpbmtpbmcoKSxcbiAgICAgICAgICBzdXBwb3J0c0F1dG9MaW5raW5nICAgICAgICAgICAgPSBicm93c2VyLmRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlKCk7XG4gICAgICBpZiAoc3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImF1dG9VcmxEZXRlY3RcIiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmF1dG9MaW5rKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBkbyB0aGUgYXV0byBsaW5raW5nIGJ5IG91cnNlbHZlcyB3aGVuIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBhdXRvIGxpbmtpbmdcbiAgICAgIC8vIE9SIHdoZW4gaGUgc3VwcG9ydHMgYXV0byBsaW5raW5nIGJ1dCB3ZSB3ZXJlIGFibGUgdG8gdHVybiBpdCBvZmYgKElFOSspXG4gICAgICBpZiAoIXN1cHBvcnRzQXV0b0xpbmtpbmcgfHwgKHN1cHBvcnRzQXV0b0xpbmtpbmcgJiYgc3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nKSkge1xuICAgICAgICB0aGlzLnBhcmVudC5vbihcIm5ld3dvcmQ6Y29tcG9zZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGRvbS5nZXRUZXh0Q29udGVudCh0aGF0LmVsZW1lbnQpLm1hdGNoKGRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCkpIHtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uKHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHVuZWRpdGFibGVzID0gdGhhdC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIgKyB0aGF0LmNvbmZpZy51bmVkaXRhYmxlQ29udGFpbmVyQ2xhc3NuYW1lKSxcbiAgICAgICAgICAgICAgICAgIGlzSW5VbmVkaXRhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHVuZWRpdGFibGVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIGlmICh3eXNpaHRtbDUuZG9tLmNvbnRhaW5zKHVuZWRpdGFibGVzW2ldLCBlbmRDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICBpc0luVW5lZGl0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0luVW5lZGl0YWJsZSkgZG9tLmF1dG9MaW5rKGVuZENvbnRhaW5lci5wYXJlbnROb2RlLCBbdGhhdC5jb25maWcudW5lZGl0YWJsZUNvbnRhaW5lckNsYXNzbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwiYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkb20uYXV0b0xpbmsodGhhdC5lbGVtZW50LCBbdGhhdC5jb25maWcudW5lZGl0YWJsZUNvbnRhaW5lckNsYXNzbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzdW1pbmcgd2UgaGF2ZSB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiPmh0dHA6Ly93d3cuZ29vZ2xlLmRlPC9hPlxuICAgICAgLy8gSWYgYSB1c2VyIG5vdyBjaGFuZ2VzIHRoZSB1cmwgaW4gdGhlIGlubmVySFRNTCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAvLyBpdCdzIHN5bmNocm9uaXplZCB3aXRoIHRoZSBocmVmIGF0dHJpYnV0ZSAoYXMgbG9uZyBhcyB0aGUgaW5uZXJIVE1MIGlzIHN0aWxsIGEgdXJsKVxuICAgICAgdmFyIC8vIFVzZSBhIGxpdmUgTm9kZUxpc3QgdG8gY2hlY2sgd2hldGhlciB0aGVyZSBhcmUgYW55IGxpbmtzIGluIHRoZSBkb2N1bWVudFxuICAgICAgICAgIGxpbmtzICAgICAgICAgICA9IHRoaXMuc2FuZGJveC5nZXREb2N1bWVudCgpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKSxcbiAgICAgICAgICAvLyBUaGUgYXV0b0xpbmsgaGVscGVyIG1ldGhvZCByZXZlYWxzIGEgcmVnIGV4cCB0byBkZXRlY3QgY29ycmVjdCB1cmxzXG4gICAgICAgICAgdXJsUmVnRXhwICAgICAgID0gZG9tLmF1dG9MaW5rLlVSTF9SRUdfRVhQLFxuICAgICAgICAgIGdldFRleHRDb250ZW50ICA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyhkb20uZ2V0VGV4dENvbnRlbnQoZWxlbWVudCkpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudC5zdWJzdHIoMCwgNCkgPT09IFwid3d3LlwiKSB7XG4gICAgICAgICAgICAgIHRleHRDb250ZW50ID0gXCJodHRwOi8vXCIgKyB0ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgICAgICAgICB9O1xuXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIWxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSB0aGF0LnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgICAgbGluayAgICAgICAgID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIkFcIiB9LCA0KSxcbiAgICAgICAgICAgIHRleHRDb250ZW50O1xuXG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQobGluayk7XG4gICAgICAgIC8vIGtleWRvd24gaXMgZmlyZWQgYmVmb3JlIHRoZSBhY3R1YWwgY29udGVudCBpcyBjaGFuZ2VkXG4gICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBzZXQgYSB0aW1lb3V0IHRvIGNoYW5nZSB0aGUgaHJlZlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBuZXdUZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGxpbmspO1xuICAgICAgICAgIGlmIChuZXdUZXh0Q29udGVudCA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbmx5IHNldCBocmVmIHdoZW4gbmV3IGhyZWYgbG9va3MgbGlrZSBhIHZhbGlkIHVybFxuICAgICAgICAgIGlmIChuZXdUZXh0Q29udGVudC5tYXRjaCh1cmxSZWdFeHApKSB7XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgbmV3VGV4dENvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2luaXRPYmplY3RSZXNpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJlbmFibGVPYmplY3RSZXNpemluZ1wiLCB0cnVlKTtcblxuICAgICAgLy8gSUUgc2V0cyBpbmxpbmUgc3R5bGVzIGFmdGVyIHJlc2l6aW5nIG9iamVjdHNcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbGluZXMgbWFrZSBzdXJlIHRoYXQgdGhlIHdpZHRoL2hlaWdodCBjc3MgcHJvcGVydGllc1xuICAgICAgLy8gYXJlIGNvcGllZCBvdmVyIHRvIHRoZSB3aWR0aC9oZWlnaHQgYXR0cmlidXRlc1xuICAgICAgaWYgKGJyb3dzZXIuc3VwcG9ydHNFdmVudChcInJlc2l6ZWVuZFwiKSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyAgICAgICAgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgICAgICAgICAgIHByb3BlcnRpZXNMZW5ndGggID0gcHJvcGVydGllcy5sZW5ndGgsXG4gICAgICAgICAgICBlbGVtZW50ICAgICAgICAgICA9IHRoaXMuZWxlbWVudDtcblxuICAgICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcInJlc2l6ZWVuZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgc3R5bGUgID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgIT09IFwiSU1HXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKDsgaTxwcm9wZXJ0aWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZVtwcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgcGFyc2VJbnQoc3R5bGVbcHJvcGVydHldLCAxMCkpO1xuICAgICAgICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFmdGVyIHJlc2l6aW5nIElFIHNvbWV0aW1lcyBmb3JnZXRzIHRvIHJlbW92ZSB0aGUgb2xkIHJlc2l6ZSBoYW5kbGVzXG4gICAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdFVuZG9NYW5hZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudW5kb01hbmFnZXIgPSBuZXcgd3lzaWh0bWw1LlVuZG9NYW5hZ2VyKHRoaXMucGFyZW50KTtcbiAgICB9LFxuXG4gICAgX2luaXRMaW5lQnJlYWtpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgVVNFX05BVElWRV9MSU5FX0JSRUFLX0lOU0lERV9UQUdTID0gW1wiTElcIiwgXCJQXCIsIFwiSDFcIiwgXCJIMlwiLCBcIkgzXCIsIFwiSDRcIiwgXCJINVwiLCBcIkg2XCJdLFxuICAgICAgICAgIExJU1RfVEFHUyAgICAgICAgICAgICAgICAgICAgICAgICA9IFtcIlVMXCIsIFwiT0xcIiwgXCJNRU5VXCJdO1xuXG4gICAgICBmdW5jdGlvbiBhZGp1c3Qoc2VsZWN0ZWROb2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBbXCJQXCIsIFwiRElWXCJdIH0sIDIpO1xuICAgICAgICBpZiAocGFyZW50RWxlbWVudCAmJiBkb20uY29udGFpbnModGhhdC5lbGVtZW50LCBwYXJlbnRFbGVtZW50KSkge1xuICAgICAgICAgIHRoYXQuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoYXQuY29uZmlnLnVzZUxpbmVCcmVha3MpIHtcbiAgICAgICAgICAgICAgZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyhwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJQXCIpIHtcbiAgICAgICAgICAgICAgZG9tLnJlbmFtZUVsZW1lbnQocGFyZW50RWxlbWVudCwgXCJwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jb25maWcudXNlTGluZUJyZWFrcykge1xuICAgICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFtcImZvY3VzXCIsIFwia2V5ZG93blwiXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoYXQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgcGFyYWdyYXBoID0gdGhhdC5kb2MuY3JlYXRlRWxlbWVudChcIlBcIik7XG4gICAgICAgICAgICB0aGF0LmVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgIHRoYXQuZWxlbWVudC5hcHBlbmRDaGlsZChwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgaWYgKCFicm93c2VyLmRpc3BsYXlzQ2FyZXRJbkVtcHR5Q29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkpIHtcbiAgICAgICAgICAgICAgcGFyYWdyYXBoLmlubmVySFRNTCA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5zZXRCZWZvcmUocGFyYWdyYXBoLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb24uc2VsZWN0Tm9kZShwYXJhZ3JhcGgsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcyBDaHJvbWUgKyBTYWZhcmkgY3JlYXRlIG5lc3RlZCA8cD4gb3IgPGhYPiB0YWdzIGFmdGVyIHBhc3RlXG4gICAgICAvLyBJbnNlcnRpbmcgYW4gaW52aXNpYmxlIHdoaXRlIHNwYWNlIGluIGZyb250IG9mIGl0IGZpeGVzIHRoZSBpc3N1ZVxuICAgICAgLy8gVGhpcyBpcyB0b28gaGFja3kgYW5kIGNhdXNlcyBzZWxlY3Rpb24gbm90IHRvIHJlcGxhY2UgY29udGVudCBvbiBwYXN0ZSBpbiBjaHJvbWVcbiAgICAgLyogaWYgKGJyb3dzZXIuY3JlYXRlc05lc3RlZEludmFsaWRNYXJrdXBBZnRlclBhc3RlKCkpIHtcbiAgICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcInBhc3RlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIGludmlzaWJsZVNwYWNlID0gdGhhdC5kb2MuY3JlYXRlVGV4dE5vZGUod3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSk7XG4gICAgICAgICAgdGhhdC5zZWxlY3Rpb24uaW5zZXJ0Tm9kZShpbnZpc2libGVTcGFjZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSovXG5cblxuICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuXG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlDb2RlICE9PSB3eXNpaHRtbDUuRU5URVJfS0VZICYmIGtleUNvZGUgIT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBibG9ja0VsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudCh0aGF0LnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSwgeyBub2RlTmFtZTogVVNFX05BVElWRV9MSU5FX0JSRUFLX0lOU0lERV9UQUdTIH0sIDQpO1xuICAgICAgICBpZiAoYmxvY2tFbGVtZW50KSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFVud3JhcCBwYXJhZ3JhcGggYWZ0ZXIgbGVhdmluZyBhIGxpc3Qgb3IgYSBIMS02XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlID0gdGhhdC5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCksXG4gICAgICAgICAgICAgICAgbGlzdDtcblxuICAgICAgICAgICAgaWYgKGJsb2NrRWxlbWVudC5ub2RlTmFtZSA9PT0gXCJMSVwiKSB7XG4gICAgICAgICAgICAgIGlmICghc2VsZWN0ZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGlzdCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogTElTVF9UQUdTIH0sIDIpO1xuXG4gICAgICAgICAgICAgIGlmICghbGlzdCkge1xuICAgICAgICAgICAgICAgIGFkanVzdChzZWxlY3RlZE5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuRU5URVJfS0VZICYmIGJsb2NrRWxlbWVudC5ub2RlTmFtZS5tYXRjaCgvXkhbMS02XSQvKSkge1xuICAgICAgICAgICAgICBhZGp1c3Qoc2VsZWN0ZWROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhhdC5jb25maWcudXNlTGluZUJyZWFrcyAmJiBrZXlDb2RlID09PSB3eXNpaHRtbDUuRU5URVJfS0VZICYmICF3eXNpaHRtbDUuYnJvd3Nlci5pbnNlcnRzTGluZUJyZWFrc09uUmV0dXJuKCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoYXQuY29tbWFuZHMuZXhlYyhcImluc2VydExpbmVCcmVha1wiKTtcblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gICAgICAgICAgICAgPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgZG9jICAgICAgICAgICAgID0gZG9jdW1lbnQsXG4gICAgICB3aW4gICAgICAgICAgICAgPSB3aW5kb3csXG4gICAgICBIT1NUX1RFTVBMQVRFICAgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIC8qKlxuICAgICAgICogU3R5bGVzIHRvIGNvcHkgZnJvbSB0ZXh0YXJlYSB0byB0aGUgY29tcG9zZXIgZWxlbWVudFxuICAgICAgICovXG4gICAgICBURVhUX0ZPUk1BVFRJTkcgPSBbXG4gICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiLFxuICAgICAgICBcImNvbG9yXCIsIFwiY3Vyc29yXCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LXNpemVcIiwgXCJmb250LXN0eWxlXCIsIFwiZm9udC12YXJpYW50XCIsIFwiZm9udC13ZWlnaHRcIixcbiAgICAgICAgXCJsaW5lLWhlaWdodFwiLCBcImxldHRlci1zcGFjaW5nXCIsXG4gICAgICAgIFwidGV4dC1hbGlnblwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtaW5kZW50XCIsIFwidGV4dC1yZW5kZXJpbmdcIixcbiAgICAgICAgXCJ3b3JkLWJyZWFrXCIsIFwid29yZC13cmFwXCIsIFwid29yZC1zcGFjaW5nXCJcbiAgICAgIF0sXG4gICAgICAvKipcbiAgICAgICAqIFN0eWxlcyB0byBjb3B5IGZyb20gdGV4dGFyZWEgdG8gdGhlIGlmcmFtZVxuICAgICAgICovXG4gICAgICBCT1hfRk9STUFUVElORyA9IFtcbiAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXG4gICAgICAgIFwiYm9yZGVyLWNvbGxhcHNlXCIsXG4gICAgICAgIFwiYm9yZGVyLWJvdHRvbS1jb2xvclwiLCBcImJvcmRlci1ib3R0b20tc3R5bGVcIiwgXCJib3JkZXItYm90dG9tLXdpZHRoXCIsXG4gICAgICAgIFwiYm9yZGVyLWxlZnQtY29sb3JcIiwgXCJib3JkZXItbGVmdC1zdHlsZVwiLCBcImJvcmRlci1sZWZ0LXdpZHRoXCIsXG4gICAgICAgIFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCIsIFwiYm9yZGVyLXJpZ2h0LXN0eWxlXCIsIFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIsXG4gICAgICAgIFwiYm9yZGVyLXRvcC1jb2xvclwiLCBcImJvcmRlci10b3Atc3R5bGVcIiwgXCJib3JkZXItdG9wLXdpZHRoXCIsXG4gICAgICAgIFwiY2xlYXJcIiwgXCJkaXNwbGF5XCIsIFwiZmxvYXRcIixcbiAgICAgICAgXCJtYXJnaW4tYm90dG9tXCIsIFwibWFyZ2luLWxlZnRcIiwgXCJtYXJnaW4tcmlnaHRcIiwgXCJtYXJnaW4tdG9wXCIsXG4gICAgICAgIFwib3V0bGluZS1jb2xvclwiLCBcIm91dGxpbmUtb2Zmc2V0XCIsIFwib3V0bGluZS13aWR0aFwiLCBcIm91dGxpbmUtc3R5bGVcIixcbiAgICAgICAgXCJwYWRkaW5nLWxlZnRcIiwgXCJwYWRkaW5nLXJpZ2h0XCIsIFwicGFkZGluZy10b3BcIiwgXCJwYWRkaW5nLWJvdHRvbVwiLFxuICAgICAgICBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwiei1pbmRleFwiLFxuICAgICAgICBcInZlcnRpY2FsLWFsaWduXCIsIFwidGV4dC1hbGlnblwiLFxuICAgICAgICBcIi13ZWJraXQtYm94LXNpemluZ1wiLCBcIi1tb3otYm94LXNpemluZ1wiLCBcIi1tcy1ib3gtc2l6aW5nXCIsIFwiYm94LXNpemluZ1wiLFxuICAgICAgICBcIi13ZWJraXQtYm94LXNoYWRvd1wiLCBcIi1tb3otYm94LXNoYWRvd1wiLCBcIi1tcy1ib3gtc2hhZG93XCIsXCJib3gtc2hhZG93XCIsXG4gICAgICAgIFwiLXdlYmtpdC1ib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLCBcIi1tb3otYm9yZGVyLXJhZGl1cy10b3ByaWdodFwiLCBcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsXG4gICAgICAgIFwiLXdlYmtpdC1ib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiLCBcIi1tb3otYm9yZGVyLXJhZGl1cy1ib3R0b21yaWdodFwiLCBcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsXG4gICAgICAgIFwiLXdlYmtpdC1ib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLWJvdHRvbWxlZnRcIiwgXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXG4gICAgICAgIFwiLXdlYmtpdC1ib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLXRvcGxlZnRcIiwgXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsXG4gICAgICAgIFwid2lkdGhcIiwgXCJoZWlnaHRcIlxuICAgICAgXSxcbiAgICAgIEFERElUSU9OQUxfQ1NTX1JVTEVTID0gW1xuICAgICAgICBcImh0bWwgICAgICAgICAgICAgICAgIHsgaGVpZ2h0OiAxMDAlOyB9XCIsXG4gICAgICAgIFwiYm9keSAgICAgICAgICAgICAgICAgeyBoZWlnaHQ6IDEwMCU7IHBhZGRpbmc6IDFweCAwIDAgMDsgbWFyZ2luOiAtMXB4IDAgMCAwOyB9XCIsXG4gICAgICAgIFwiYm9keSA+IHA6Zmlyc3QtY2hpbGQgeyBtYXJnaW4tdG9wOiAwOyB9XCIsXG4gICAgICAgIFwiLl93eXNpaHRtbDUtdGVtcCAgICAgeyBkaXNwbGF5OiBub25lOyB9XCIsXG4gICAgICAgIHd5c2lodG1sNS5icm93c2VyLmlzR2Vja28gP1xuICAgICAgICAgIFwiYm9keS5wbGFjZWhvbGRlciB7IGNvbG9yOiBncmF5dGV4dCAhaW1wb3J0YW50OyB9XCIgOlxuICAgICAgICAgIFwiYm9keS5wbGFjZWhvbGRlciB7IGNvbG9yOiAjYTlhOWE5ICFpbXBvcnRhbnQ7IH1cIixcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdXNlciBzZWUncyBicm9rZW4gaW1hZ2VzIGFuZCBjYW4gZGVsZXRlIHRoZW1cbiAgICAgICAgXCJpbWc6LW1vei1icm9rZW4gICAgICB7IC1tb3otZm9yY2UtYnJva2VuLWltYWdlLWljb246IDE7IGhlaWdodDogMjRweDsgd2lkdGg6IDI0cHg7IH1cIlxuICAgICAgXTtcblxuICAvKipcbiAgICogV2l0aCBcInNldEFjdGl2ZVwiIElFIG9mZmVycyBhIHNtYXJ0IHdheSBvZiBmb2N1c2luZyBlbGVtZW50cyB3aXRob3V0IHNjcm9sbGluZyB0aGVtIGludG8gdmlldzpcbiAgICogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NzM4KHY9dnMuODUpLmFzcHhcbiAgICpcbiAgICogT3RoZXIgYnJvd3NlcnMgbmVlZCBhIG1vcmUgaGFja3kgd2F5OiAocHNzc3QgZG9uJ3QgdGVsbCBteSBtYW1hKVxuICAgKiBJbiBvcmRlciB0byBwcmV2ZW50IHRoZSBlbGVtZW50IGJlaW5nIHNjcm9sbGVkIGludG8gdmlldyB3aGVuIGZvY3VzaW5nIGl0LCB3ZSBzaW1wbHlcbiAgICogbW92ZSBpdCBvdXQgb2YgdGhlIHNjcm9sbGFibGUgYXJlYSwgZm9jdXMgaXQsIGFuZCByZXNldCBpdCdzIHBvc2l0aW9uXG4gICAqL1xuICB2YXIgZm9jdXNXaXRob3V0U2Nyb2xsaW5nID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LnNldEFjdGl2ZSkge1xuICAgICAgLy8gRm9sbG93aW5nIGxpbmUgY291bGQgY2F1c2UgYSBqcyBlcnJvciB3aGVuIHRoZSB0ZXh0YXJlYSBpcyBpbnZpc2libGVcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20veGluZy93eXNpaHRtbDUvaXNzdWVzLzlcbiAgICAgIHRyeSB7IGVsZW1lbnQuc2V0QWN0aXZlKCk7IH0gY2F0Y2goZSkge31cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgb3JpZ2luYWxTY3JvbGxUb3AgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2MuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgb3JpZ2luYWxTY3JvbGxMZWZ0ID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvYy5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgb3JpZ2luYWxTdHlsZXMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogICAgICAgICBlbGVtZW50U3R5bGUucG9zaXRpb24sXG4gICAgICAgICAgICB0b3A6ICAgICAgICAgICAgICBlbGVtZW50U3R5bGUudG9wLFxuICAgICAgICAgICAgbGVmdDogICAgICAgICAgICAgZWxlbWVudFN0eWxlLmxlZnQsXG4gICAgICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiBlbGVtZW50U3R5bGUuV2Via2l0VXNlclNlbGVjdFxuICAgICAgICAgIH07XG5cbiAgICAgIGRvbS5zZXRTdHlsZXMoe1xuICAgICAgICBwb3NpdGlvbjogICAgICAgICBcImFic29sdXRlXCIsXG4gICAgICAgIHRvcDogICAgICAgICAgICAgIFwiLTk5OTk5cHhcIixcbiAgICAgICAgbGVmdDogICAgICAgICAgICAgXCItOTk5OTlweFwiLFxuICAgICAgICAvLyBEb24ndCBhc2sgd2h5IGJ1dCB0ZW1wb3JhcmlseSBzZXR0aW5nIC13ZWJraXQtdXNlci1zZWxlY3QgdG8gbm9uZSBtYWtlcyB0aGUgd2hvbGUgdGhpbmcgcGVyZm9ybWluZyBzbW9vdGhlclxuICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiBcIm5vbmVcIlxuICAgICAgfSkub24oZWxlbWVudCk7XG5cbiAgICAgIGVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgZG9tLnNldFN0eWxlcyhvcmlnaW5hbFN0eWxlcykub24oZWxlbWVudCk7XG5cbiAgICAgIGlmICh3aW4uc2Nyb2xsVG8pIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VyIGV4dGVuc2lvbnMgdW5zZXQgdGhpcyBtZXRob2QgdG8gcHJldmVudCBhbm5veWFuY2VzXG4gICAgICAgIC8vIFwiQmV0dGVyIFBvcFVwIEJsb2NrZXJcIiBmb3IgQ2hyb21lIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9iZXR0ZXJwb3B1cGJsb2NrZXIvc291cmNlL2Jyb3dzZS90cnVuay9ibG9ja1N0YXJ0LmpzIzEwMFxuICAgICAgICAvLyBJc3N1ZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2JldHRlcnBvcHVwYmxvY2tlci9pc3N1ZXMvZGV0YWlsP2lkPTFcbiAgICAgICAgd2luLnNjcm9sbFRvKG9yaWdpbmFsU2Nyb2xsTGVmdCwgb3JpZ2luYWxTY3JvbGxUb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIHd5c2lodG1sNS52aWV3cy5Db21wb3Nlci5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgb3JpZ2luYWxBY3RpdmVFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCI6Zm9jdXNcIiksXG4gICAgICAgIHRleHRhcmVhRWxlbWVudCAgICAgICA9IHRoaXMudGV4dGFyZWEuZWxlbWVudCxcbiAgICAgICAgaGFzUGxhY2Vob2xkZXIgICAgICAgID0gdGV4dGFyZWFFbGVtZW50Lmhhc0F0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpLFxuICAgICAgICBvcmlnaW5hbFBsYWNlaG9sZGVyICAgPSBoYXNQbGFjZWhvbGRlciAmJiB0ZXh0YXJlYUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiksXG4gICAgICAgIG9yaWdpbmFsRGlzcGxheVZhbHVlICA9IHRleHRhcmVhRWxlbWVudC5zdHlsZS5kaXNwbGF5LFxuICAgICAgICBvcmlnaW5hbERpc2FibGVkICAgICAgPSB0ZXh0YXJlYUVsZW1lbnQuZGlzYWJsZWQsXG4gICAgICAgIGRpc3BsYXlWYWx1ZUZvckNvcHlpbmc7XG5cbiAgICB0aGlzLmZvY3VzU3R5bGVzSG9zdCAgICAgID0gSE9TVF9URU1QTEFURS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIHRoaXMuYmx1clN0eWxlc0hvc3QgICAgICAgPSBIT1NUX1RFTVBMQVRFLmNsb25lTm9kZShmYWxzZSk7XG4gICAgdGhpcy5kaXNhYmxlZFN0eWxlc0hvc3QgICA9IEhPU1RfVEVNUExBVEUuY2xvbmVOb2RlKGZhbHNlKTtcblxuICAgIC8vIFJlbW92ZSBwbGFjZWhvbGRlciBiZWZvcmUgY29weWluZyAoYXMgdGhlIHBsYWNlaG9sZGVyIGhhcyBhbiBhZmZlY3Qgb24gdGhlIGNvbXB1dGVkIHN0eWxlKVxuICAgIGlmIChoYXNQbGFjZWhvbGRlcikge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0YXJlYUVsZW1lbnQgPT09IG9yaWdpbmFsQWN0aXZlRWxlbWVudCkge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICAvLyBlbmFibGUgZm9yIGNvcHlpbmcgc3R5bGVzXG4gICAgdGV4dGFyZWFFbGVtZW50LmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvLyBzZXQgdGV4dGFyZWEgdG8gZGlzcGxheT1cIm5vbmVcIiB0byBnZXQgY2FzY2FkZWQgc3R5bGVzIHZpYSBnZXRDb21wdXRlZFN0eWxlXG4gICAgdGV4dGFyZWFFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5VmFsdWVGb3JDb3B5aW5nID0gXCJub25lXCI7XG5cbiAgICBpZiAoKHRleHRhcmVhRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJyb3dzXCIpICYmIGRvbS5nZXRTdHlsZShcImhlaWdodFwiKS5mcm9tKHRleHRhcmVhRWxlbWVudCkgPT09IFwiYXV0b1wiKSB8fFxuICAgICAgICAodGV4dGFyZWFFbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbHNcIikgJiYgZG9tLmdldFN0eWxlKFwid2lkdGhcIikuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpID09PSBcImF1dG9cIikpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheVZhbHVlRm9yQ29weWluZyA9IG9yaWdpbmFsRGlzcGxheVZhbHVlO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLSBpZnJhbWUgc3R5bGVzIChoYXMgdG8gYmUgc2V0IGJlZm9yZSBlZGl0b3Igc3R5bGVzLCBvdGhlcndpc2UgSUU5IHNldHMgd3JvbmcgZm9udEZhbWlseSBvbiBibHVyU3R5bGVzSG9zdCkgLS0tLS0tLS0tXG4gICAgZG9tLmNvcHlTdHlsZXMoQk9YX0ZPUk1BVFRJTkcpLmZyb20odGV4dGFyZWFFbGVtZW50KS50byh0aGlzLmVkaXRhYmxlQXJlYSkuYW5kVG8odGhpcy5ibHVyU3R5bGVzSG9zdCk7XG5cbiAgICAvLyAtLS0tLS0tLS0gZWRpdG9yIHN0eWxlcyAtLS0tLS0tLS1cbiAgICBkb20uY29weVN0eWxlcyhURVhUX0ZPUk1BVFRJTkcpLmZyb20odGV4dGFyZWFFbGVtZW50KS50byh0aGlzLmVsZW1lbnQpLmFuZFRvKHRoaXMuYmx1clN0eWxlc0hvc3QpO1xuXG4gICAgLy8gLS0tLS0tLS0tIGFwcGx5IHN0YW5kYXJkIHJ1bGVzIC0tLS0tLS0tLVxuICAgIGRvbS5pbnNlcnRDU1MoQURESVRJT05BTF9DU1NfUlVMRVMpLmludG8odGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQpO1xuXG4gICAgLy8gLS0tLS0tLS0tIDpkaXNhYmxlZCBzdHlsZXMgLS0tLS0tLS0tXG4gICAgdGV4dGFyZWFFbGVtZW50LmRpc2FibGVkID0gdHJ1ZTtcbiAgICBkb20uY29weVN0eWxlcyhCT1hfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuZGlzYWJsZWRTdHlsZXNIb3N0KTtcbiAgICBkb20uY29weVN0eWxlcyhURVhUX0ZPUk1BVFRJTkcpLmZyb20odGV4dGFyZWFFbGVtZW50KS50byh0aGlzLmRpc2FibGVkU3R5bGVzSG9zdCk7XG4gICAgdGV4dGFyZWFFbGVtZW50LmRpc2FibGVkID0gb3JpZ2luYWxEaXNhYmxlZDtcblxuICAgIC8vIC0tLS0tLS0tLSA6Zm9jdXMgc3R5bGVzIC0tLS0tLS0tLVxuICAgIHRleHRhcmVhRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5VmFsdWU7XG4gICAgZm9jdXNXaXRob3V0U2Nyb2xsaW5nKHRleHRhcmVhRWxlbWVudCk7XG4gICAgdGV4dGFyZWFFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5VmFsdWVGb3JDb3B5aW5nO1xuXG4gICAgZG9tLmNvcHlTdHlsZXMoQk9YX0ZPUk1BVFRJTkcpLmZyb20odGV4dGFyZWFFbGVtZW50KS50byh0aGlzLmZvY3VzU3R5bGVzSG9zdCk7XG4gICAgZG9tLmNvcHlTdHlsZXMoVEVYVF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5mb2N1c1N0eWxlc0hvc3QpO1xuXG4gICAgLy8gcmVzZXQgdGV4dGFyZWFcbiAgICB0ZXh0YXJlYUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheVZhbHVlO1xuXG4gICAgZG9tLmNvcHlTdHlsZXMoW1wiZGlzcGxheVwiXSkuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuZWRpdGFibGVBcmVhKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGNoYW5nZSB0aGUgZGlzcGxheSBzdHlsZSBvZiB0aGUgaWZyYW1lIHdoZW4gY29weWluZyBzdHlsZXMgb2JsdXIvb25mb2N1c1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIGZvciB3aGVuIHRoZSBjaGFuZ2VfdmlldyBldmVudCBpcyBmaXJlZCB3aGVyZSB0aGUgaWZyYW1lIGlzIGhpZGRlbiBhbmQgdGhlblxuICAgIC8vIHRoZSBibHVyIGV2ZW50IGZpcmVzIGFuZCByZS1kaXNwbGF5cyBpdFxuICAgIHZhciBib3hGb3JtYXR0aW5nU3R5bGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoQk9YX0ZPUk1BVFRJTkcpLndpdGhvdXQoW1wiZGlzcGxheVwiXSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gcmVzdG9yZSBmb2N1cyAtLS0tLS0tLS1cbiAgICBpZiAob3JpZ2luYWxBY3RpdmVFbGVtZW50KSB7XG4gICAgICBvcmlnaW5hbEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gcmVzdG9yZSBwbGFjZWhvbGRlciAtLS0tLS0tLS1cbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCBvcmlnaW5hbFBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gU3luYyBmb2N1cy9ibHVyIHN0eWxlcyAtLS0tLS0tLS1cbiAgICB0aGlzLnBhcmVudC5vbihcImZvY3VzOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZG9tLmNvcHlTdHlsZXMoYm94Rm9ybWF0dGluZ1N0eWxlcykgLmZyb20odGhhdC5mb2N1c1N0eWxlc0hvc3QpLnRvKHRoYXQuZWRpdGFibGVBcmVhKTtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykgICAgIC5mcm9tKHRoYXQuZm9jdXNTdHlsZXNIb3N0KS50byh0aGF0LmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJlbnQub24oXCJibHVyOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZG9tLmNvcHlTdHlsZXMoYm94Rm9ybWF0dGluZ1N0eWxlcykgLmZyb20odGhhdC5ibHVyU3R5bGVzSG9zdCkudG8odGhhdC5lZGl0YWJsZUFyZWEpO1xuICAgICAgZG9tLmNvcHlTdHlsZXMoVEVYVF9GT1JNQVRUSU5HKSAgICAgLmZyb20odGhhdC5ibHVyU3R5bGVzSG9zdCkudG8odGhhdC5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMucGFyZW50Lm9ic2VydmUoXCJkaXNhYmxlOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZG9tLmNvcHlTdHlsZXMoYm94Rm9ybWF0dGluZ1N0eWxlcykgLmZyb20odGhhdC5kaXNhYmxlZFN0eWxlc0hvc3QpLnRvKHRoYXQuZWRpdGFibGVBcmVhKTtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykgICAgIC5mcm9tKHRoYXQuZGlzYWJsZWRTdHlsZXNIb3N0KS50byh0aGF0LmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJlbnQub2JzZXJ2ZShcImVuYWJsZTpjb21wb3NlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKGJveEZvcm1hdHRpbmdTdHlsZXMpIC5mcm9tKHRoYXQuYmx1clN0eWxlc0hvc3QpLnRvKHRoYXQuZWRpdGFibGVBcmVhKTtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykgICAgIC5mcm9tKHRoYXQuYmx1clN0eWxlc0hvc3QpLnRvKHRoYXQuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKHd5c2lodG1sNSk7XG47LyoqXG4gKiBUYWtpbmcgY2FyZSBvZiBldmVudHNcbiAqICAtIFNpbXVsYXRpbmcgJ2NoYW5nZScgZXZlbnQgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAqICAtIEhhbmRsaW5nIGRyYWcgJiBkcm9wIGxvZ2ljXG4gKiAgLSBDYXRjaCBwYXN0ZSBldmVudHNcbiAqICAtIERpc3BhdGNoIHByb3ByaWV0YXJ5IG5ld3dvcmQ6Y29tcG9zZXIgZXZlbnRcbiAqICAtIEtleWJvYXJkIHNob3J0Y3V0c1xuICovXG4oZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gICAgICAgPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgYnJvd3NlciAgID0gd3lzaWh0bWw1LmJyb3dzZXIsXG4gICAgICAvKipcbiAgICAgICAqIE1hcCBrZXlDb2RlcyB0byBxdWVyeSBjb21tYW5kc1xuICAgICAgICovXG4gICAgICBzaG9ydGN1dHMgPSB7XG4gICAgICAgIFwiNjZcIjogXCJib2xkXCIsICAgICAvLyBCXG4gICAgICAgIFwiNzNcIjogXCJpdGFsaWNcIiwgICAvLyBJXG4gICAgICAgIFwiODVcIjogXCJ1bmRlcmxpbmVcIiAvLyBVXG4gICAgICB9O1xuXG4gIHZhciBkZWxldGVBcm91bmRFZGl0YWJsZSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgdW5lZGl0YWJsZSwgZWxlbWVudCkge1xuICAgIC8vIG1lcmdlIG5vZGUgd2l0aCBwcmV2aW91cyBub2RlIGZyb20gdW5lZGl0YWJsZVxuICAgIHZhciBwcmV2Tm9kZSA9IHNlbGVjdGlvbi5nZXRQcmV2aW91c05vZGUodW5lZGl0YWJsZSwgdHJ1ZSksXG4gICAgICAgIGN1ck5vZGUgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG5cbiAgICBpZiAoY3VyTm9kZS5ub2RlVHlwZSAhPT0gMSAmJiBjdXJOb2RlLnBhcmVudE5vZGUgIT09IGVsZW1lbnQpIHsgY3VyTm9kZSA9IGN1ck5vZGUucGFyZW50Tm9kZTsgfVxuICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgaWYgKGN1ck5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICB2YXIgZmlyc3QgPSBjdXJOb2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKHByZXZOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICB3aGlsZSAoY3VyTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBwcmV2Tm9kZS5hcHBlbmRDaGlsZChjdXJOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoY3VyTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB1bmVkaXRhYmxlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGN1ck5vZGUuZmlyc3RDaGlsZCwgdW5lZGl0YWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjdXJOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLnNldEJlZm9yZShmaXJzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldk5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgIHByZXZOb2RlLmFwcGVuZENoaWxkKGN1ck5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuZWRpdGFibGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY3VyTm9kZSwgdW5lZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLnNldEJlZm9yZShjdXJOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZURlbGV0ZUtleVByZXNzID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdGlvbiwgZWxlbWVudCwgY29tcG9zZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24uY2FyZXRJc0luVGhlQmVnaW5uaWcoJ0xJJykpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29tcG9zZXIuY29tbWFuZHMuZXhlYygnb3V0ZGVudExpc3QnKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uLmNhcmV0SXNJblRoZUJlZ2lubmlnKCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5jYXJldElzRmlyc3RJblNlbGVjdGlvbigpICYmXG4gICAgICAgICAgICBzZWxlY3Rpb24uZ2V0UHJldmlvdXNOb2RlKCkgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbi5nZXRQcmV2aW91c05vZGUoKS5ub2RlTmFtZSAmJlxuICAgICAgICAgICAgKC9eSFxcZCQvZ2kpLnRlc3Qoc2VsZWN0aW9uLmdldFByZXZpb3VzTm9kZSgpLm5vZGVOYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgcHJldk5vZGUgPSBzZWxlY3Rpb24uZ2V0UHJldmlvdXNOb2RlKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoKC9eXFxzKiQvKS50ZXN0KHByZXZOb2RlLnRleHRDb250ZW50IHx8IHByZXZOb2RlLmlubmVyVGV4dCkpIHtcbiAgICAgICAgICAgIC8vIGhlYWRpbmcgaXMgZW1wdHlcbiAgICAgICAgICAgIHByZXZOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldk5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBwcmV2Tm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMocHJldk5vZGUpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJlZm9yZVVuZWRpdGFibGUgPSBzZWxlY3Rpb24uY2FyZXRJc0JlZm9yZVVuZWRpdGFibGUoKTtcbiAgICAgICAgLy8gRG8gYSBzcGVjaWFsIGRlbGV0ZSBpZiBjYXJldCB3b3VsZCBkZWxldGUgdW5lZGl0YWJsZVxuICAgICAgICBpZiAoYmVmb3JlVW5lZGl0YWJsZSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZGVsZXRlQXJvdW5kRWRpdGFibGUoc2VsZWN0aW9uLCBiZWZvcmVVbmVkaXRhYmxlLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsZWN0aW9uLmNvbnRhaW5zVW5lZGl0YWJsZSgpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5kZWxldGVDb250ZW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlVGFiS2V5RG93biA9IGZ1bmN0aW9uKGNvbXBvc2VyLCBlbGVtZW50KSB7XG4gICAgaWYgKCFjb21wb3Nlci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgfSBlbHNlIGlmIChjb21wb3Nlci5zZWxlY3Rpb24uY2FyZXRJc0luVGhlQmVnaW5uaWcoJ0xJJykpIHtcbiAgICAgIGlmIChjb21wb3Nlci5jb21tYW5kcy5leGVjKCdpbmRlbnRMaXN0JykpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJcyAmZW1zcDsgY2xvc2UgZW5vdWdoIHRvIHRhYi4gQ291bGQgbm90IGZpbmQgZW5vdWdoIGNvdW50ZXIgYXJndW1lbnRzIGZvciBub3cuXG4gICAgY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImluc2VydEhUTUxcIiwgXCImZW1zcDtcIik7XG4gIH07XG5cbiAgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICBzdGF0ZSAgICAgICAgICAgICAgID0gdGhpcy5nZXRWYWx1ZShmYWxzZSwgZmFsc2UpLFxuICAgICAgICBjb250YWluZXIgICAgICAgICAgID0gKHRoaXMuc2FuZGJveC5nZXRJZnJhbWUpID8gdGhpcy5zYW5kYm94LmdldElmcmFtZSgpIDogdGhpcy5zYW5kYm94LmdldENvbnRlbnRFZGl0YWJsZSgpLFxuICAgICAgICBlbGVtZW50ICAgICAgICAgICAgID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBmb2N1c0JsdXJFbGVtZW50ICAgID0gKGJyb3dzZXIuc3VwcG9ydHNFdmVudHNJbklmcmFtZUNvcnJlY3RseSgpIHx8IHRoaXMuc2FuZGJveC5nZXRDb250ZW50RWRpdGFibGUpID8gZWxlbWVudCA6IHRoaXMuc2FuZGJveC5nZXRXaW5kb3coKSxcbiAgICAgICAgcGFzdGVFdmVudHMgICAgICAgICA9IFtcImRyb3BcIiwgXCJwYXN0ZVwiLCBcImJlZm9yZXBhc3RlXCJdLFxuICAgICAgICBpbnRlcmFjdGlvbkV2ZW50cyAgID0gW1wiZHJvcFwiLCBcInBhc3RlXCIsIFwibW91c2V1cFwiLCBcImZvY3VzXCIsIFwia2V5dXBcIl07XG5cbiAgICAvLyAtLS0tLS0tLS0gZGVzdHJveTpjb21wb3NlciBldmVudCAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShjb250YWluZXIsIFwiRE9NTm9kZVJlbW92ZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhckludGVydmFsKGRvbU5vZGVSZW1vdmVkSW50ZXJ2YWwpO1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImRlc3Ryb3k6Y29tcG9zZXJcIik7XG4gICAgfSk7XG5cbiAgICAvLyBET01Ob2RlUmVtb3ZlZCBldmVudCBpcyBub3Qgc3VwcG9ydGVkIGluIElFIDhcbiAgICBpZiAoIWJyb3dzZXIuc3VwcG9ydHNNdXRhdGlvbkV2ZW50cygpKSB7XG4gICAgICAgIHZhciBkb21Ob2RlUmVtb3ZlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFkb20uY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBjb250YWluZXIpKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGRvbU5vZGVSZW1vdmVkSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImRlc3Ryb3k6Y29tcG9zZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAyNTApO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLSBVc2VyIGludGVyYWN0aW9uIHRyYWNraW5nIC0tXG5cbiAgICBkb20ub2JzZXJ2ZShmb2N1c0JsdXJFbGVtZW50LCBpbnRlcmFjdGlvbkV2ZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwiaW50ZXJhY3Rpb25cIikuZmlyZShcImludGVyYWN0aW9uOmNvbXBvc2VyXCIpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG5cblxuICAgIGlmICh0aGlzLmNvbmZpZy5oYW5kbGVUYWJsZXMpIHtcbiAgICAgIGlmKCF0aGlzLnRhYmxlQ2xpY2tIYW5kbGUgJiYgdGhpcy5kb2MuZXhlY0NvbW1hbmQgJiYgd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNDb21tYW5kKHRoaXMuZG9jLCBcImVuYWJsZU9iamVjdFJlc2l6aW5nXCIpICYmIHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzQ29tbWFuZCh0aGlzLmRvYywgXCJlbmFibGVJbmxpbmVUYWJsZUVkaXRpbmdcIikpIHtcbiAgICAgICAgaWYgKHRoaXMuc2FuZGJveC5nZXRJZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLnRhYmxlQ2xpY2tIYW5kbGUgPSBkb20ub2JzZXJ2ZShjb250YWluZXIgLCBbXCJmb2N1c1wiLCBcIm1vdXNldXBcIiwgXCJtb3VzZW92ZXJcIl0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5kb2MuZXhlY0NvbW1hbmQoXCJlbmFibGVPYmplY3RSZXNpemluZ1wiLCBmYWxzZSwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIHRoYXQuZG9jLmV4ZWNDb21tYW5kKFwiZW5hYmxlSW5saW5lVGFibGVFZGl0aW5nXCIsIGZhbHNlLCBcImZhbHNlXCIpO1xuICAgICAgICAgICAgdGhhdC50YWJsZUNsaWNrSGFuZGxlLnN0b3AoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5kb2MuZXhlY0NvbW1hbmQoXCJlbmFibGVPYmplY3RSZXNpemluZ1wiLCBmYWxzZSwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIHRoYXQuZG9jLmV4ZWNDb21tYW5kKFwiZW5hYmxlSW5saW5lVGFibGVFZGl0aW5nXCIsIGZhbHNlLCBcImZhbHNlXCIpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gd3lzaWh0bWw1LnF1aXJrcy50YWJsZUNlbGxzU2VsZWN0aW9uKGVsZW1lbnQsIHRoYXQucGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gRm9jdXMgJiBibHVyIGxvZ2ljIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGZvY3VzQmx1ckVsZW1lbnQsIFwiZm9jdXNcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJmb2N1c1wiLCBldmVudCkuZmlyZShcImZvY3VzOmNvbXBvc2VyXCIsIGV2ZW50KTtcblxuICAgICAgLy8gRGVsYXkgc3RvcmluZyBvZiBzdGF0ZSB1bnRpbCBhbGwgZm9jdXMgaGFuZGxlciBhcmUgZmlyZWRcbiAgICAgIC8vIGVzcGVjaWFsbHkgdGhlIG9uZSB3aGljaCByZXNldHMgdGhlIHBsYWNlaG9sZGVyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzdGF0ZSA9IHRoYXQuZ2V0VmFsdWUoZmFsc2UsIGZhbHNlKTsgfSwgMCk7XG4gICAgfSk7XG5cbiAgICBkb20ub2JzZXJ2ZShmb2N1c0JsdXJFbGVtZW50LCBcImJsdXJcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChzdGF0ZSAhPT0gdGhhdC5nZXRWYWx1ZShmYWxzZSwgZmFsc2UpKSB7XG4gICAgICAgIC8vY3JlYXRlIGNoYW5nZSBldmVudCBpZiBzdXBwb3J0ZWQgKGFsbCBleGNlcHQgSUU4KVxuICAgICAgICB2YXIgY2hhbmdlZXZlbnQgPSBldmVudDtcbiAgICAgICAgaWYodHlwZW9mIE9iamVjdC5jcmVhdGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNoYW5nZWV2ZW50ID0gT2JqZWN0LmNyZWF0ZShldmVudCwgeyB0eXBlOiB7IHZhbHVlOiAnY2hhbmdlJyB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJjaGFuZ2VcIiwgY2hhbmdlZXZlbnQpLmZpcmUoXCJjaGFuZ2U6Y29tcG9zZXJcIiwgY2hhbmdlZXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImJsdXJcIiwgZXZlbnQpLmZpcmUoXCJibHVyOmNvbXBvc2VyXCIsIGV2ZW50KTtcbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLSBEcmFnICYgRHJvcCBsb2dpYyAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImRyYWdlbnRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJ1bnNldF9wbGFjZWhvbGRlclwiKTtcbiAgICB9KTtcblxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIHBhc3RlRXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShldmVudC50eXBlLCBldmVudCkuZmlyZShldmVudC50eXBlICsgXCI6Y29tcG9zZXJcIiwgZXZlbnQpO1xuICAgIH0pO1xuXG5cbiAgICBpZiAodGhpcy5jb25maWcuY29weWVkRnJvbU1hcmtpbmcpIHtcbiAgICAgIC8vIElmIHN1cHBvcnRlZCB0aGUgY29waWVkIHNvdXJjZSBpcyBiYXNlZCBkaXJlY3RseSBvbiBzZWxlY3Rpb25cbiAgICAgIC8vIFZlcnkgdXNlZnVsIGZvciB3ZWJraXQgYmFzZWQgYnJvd3NlcnMgd2hlcmUgY29weSB3aWxsIG90aGVyd2lzZSBjb250YWluIGEgbG90IG9mIGNvZGUgYW5kIHN0eWxlcyBiYXNlZCBvbiB3aGF0ZXZlciBhbmQgbm90IGFjdHVhbGx5IGluIHNlbGVjdGlvbi5cbiAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwiY29weVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCB0aGF0LmNvbmZpZy5jb3B5ZWRGcm9tTWFya2luZyArIHRoYXQuc2VsZWN0aW9uLmdldEh0bWwoKSk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0LnBhcmVudC5maXJlKGV2ZW50LnR5cGUsIGV2ZW50KS5maXJlKGV2ZW50LnR5cGUgKyBcIjpjb21wb3NlclwiLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gbmV3b3JkIGV2ZW50IC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5dXBcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgIGlmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuU1BBQ0VfS0VZIHx8IGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcIm5ld3dvcmQ6Y29tcG9zZXJcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmVudC5vbihcInBhc3RlOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5wYXJlbnQuZmlyZShcIm5ld3dvcmQ6Y29tcG9zZXJcIik7IH0sIDApO1xuICAgIH0pO1xuXG4gICAgLy8gLS0tLS0tLS0tIE1ha2Ugc3VyZSB0aGF0IGltYWdlcyBhcmUgc2VsZWN0ZWQgd2hlbiBjbGlja2luZyBvbiB0aGVtIC0tLS0tLS0tLVxuICAgIGlmICghYnJvd3Nlci5jYW5TZWxlY3RJbWFnZXNJbkNvbnRlbnRFZGl0YWJsZSgpKSB7XG4gICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB2YXIgYWxsSW1hZ2VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKSxcbiAgICAgICAgICAgIG5vdE15SW1hZ2VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIHRoYXQuY29uZmlnLnVuZWRpdGFibGVDb250YWluZXJDbGFzc25hbWUgKyAnIGltZycpLFxuICAgICAgICAgICAgbXlJbWFnZXMgPSB3eXNpaHRtbDUubGFuZy5hcnJheShhbGxJbWFnZXMpLndpdGhvdXQobm90TXlJbWFnZXMpO1xuXG4gICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09IFwiSU1HXCIgJiYgd3lzaWh0bWw1LmxhbmcuYXJyYXkobXlJbWFnZXMpLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5zZWxlY3ROb2RlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghYnJvd3Nlci5jYW5TZWxlY3RJbWFnZXNJbkNvbnRlbnRFZGl0YWJsZSgpKSB7XG4gICAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwiZHJvcFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgSSBrbmV3IGhvdyB0byBnZXQgZHJvcHBlZCBlbGVtZW50cyBsaXN0IGZyb20gZXZlbnQgSSBjb3VsZCBsaW1pdCBpdCB0byBvbmx5IElNRyBlbGVtZW50IGNhc2VcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGJyb3dzZXIuaGFzSGlzdG9yeUlzc3VlKCkgJiYgYnJvd3Nlci5zdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSgpKSB7XG4gICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleUNvZGUgICA9IGV2ZW50LmtleUNvZGUsXG4gICAgICAgICAgICB3aW4gICAgICAgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcsXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IDM3IHx8IGtleUNvZGUgPT09IDM5KSB7XG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IDM3KSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24ubW9kaWZ5KFwiZXh0ZW5kXCIsIFwibGVmdFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgICAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLmNvbGxhcHNlVG9TdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5tb2RpZnkoXCJleHRlbmRcIiwgXCJyaWdodFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgICAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLmNvbGxhcHNlVG9FbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tIFNob3J0Y3V0IGxvZ2ljIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGtleUNvZGUgID0gZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICBjb21tYW5kICA9IHNob3J0Y3V0c1trZXlDb2RlXTtcbiAgICAgIGlmICgoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJiAhZXZlbnQuYWx0S2V5ICYmIGNvbW1hbmQpIHtcbiAgICAgICAgdGhhdC5jb21tYW5kcy5leGVjKGNvbW1hbmQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKGtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgLy8gZGVsZXRlIGtleVxuICAgICAgICBoYW5kbGVEZWxldGVLZXlQcmVzcyhldmVudCwgdGhhdC5zZWxlY3Rpb24sIGVsZW1lbnQsIHRoYXQpO1xuICAgICAgfSBlbHNlIGlmICh0aGF0LmNvbmZpZy5oYW5kbGVUYWJLZXkgJiYga2V5Q29kZSA9PT0gOSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBoYW5kbGVUYWJLZXlEb3duKHRoYXQsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gLS0tLS0tLS0tIE1ha2Ugc3VyZSB0aGF0IHdoZW4gcHJlc3NpbmcgYmFja3NwYWNlL2RlbGV0ZSBvbiBzZWxlY3RlZCBpbWFnZXMgZGVsZXRlcyB0aGUgaW1hZ2UgYW5kIGl0J3MgYW5jaG9yIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRhcmdldCAgPSB0aGF0LnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUodHJ1ZSksXG4gICAgICAgICAga2V5Q29kZSA9IGV2ZW50LmtleUNvZGUsXG4gICAgICAgICAgcGFyZW50O1xuICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgPT09IFwiSU1HXCIgJiYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZIHx8IGtleUNvZGUgPT09IHd5c2lodG1sNS5ERUxFVEVfS0VZKSkgeyAvLyA4ID0+IGJhY2tzcGFjZSwgNDYgPT4gZGVsZXRlXG4gICAgICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAvLyBkZWxldGUgdGhlIDxpbWc+XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICAvLyBhbmQgaXQncyBwYXJlbnQgPGE+IHRvbyBpZiBpdCBoYXNuJ3QgZ290IGFueSBvdGhlciBjaGlsZCBub2Rlc1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVOYW1lID09PSBcIkFcIiAmJiAhcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoZWxlbWVudCk7IH0sIDApO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gLS0tLS0tLS0tIElFIDgrOSBmb2N1cyB0aGUgZWRpdG9yIHdoZW4gdGhlIGlmcmFtZSBpcyBjbGlja2VkICh3aXRob3V0IGFjdHVhbGx5IGZpcmluZyB0aGUgJ2ZvY3VzJyBldmVudCBvbiB0aGUgPGJvZHk+KSAtLS0tLS0tLS1cbiAgICBpZiAoIXRoaXMuY29uZmlnLmNvbnRlbnRFZGl0YWJsZU1vZGUgJiYgYnJvd3Nlci5oYXNJZnJhbWVGb2N1c0lzc3VlKCkpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGNvbnRhaW5lciwgXCJmb2N1c1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhhdC5kb2MucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSAhPT0gdGhhdC5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwiYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gU2hvdyB1cmwgaW4gdG9vbHRpcCB3aGVuIGhvdmVyaW5nIGxpbmtzIG9yIGltYWdlcyAtLS0tLS0tLS1cbiAgICB2YXIgdGl0bGVQcmVmaXhlcyA9IHtcbiAgICAgIElNRzogXCJJbWFnZTogXCIsXG4gICAgICBBOiAgIFwiTGluazogXCJcbiAgICB9O1xuXG4gICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgICA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZSxcbiAgICAgICAgICB0aXRsZTtcbiAgICAgIGlmIChub2RlTmFtZSAhPT0gXCJBXCIgJiYgbm9kZU5hbWUgIT09IFwiSU1HXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc1RpdGxlID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZShcInRpdGxlXCIpO1xuICAgICAgaWYoIWhhc1RpdGxlKXtcbiAgICAgICAgdGl0bGUgPSB0aXRsZVByZWZpeGVzW25vZGVOYW1lXSArICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRpdGxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7XG47LyoqXG4gKiBDbGFzcyB0aGF0IHRha2VzIGNhcmUgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIGNvbXBvc2VyIGFuZCB0aGUgdGV4dGFyZWEgaXMgYWx3YXlzIGluIHN5bmNcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgSU5URVJWQUwgPSA0MDA7XG5cbiAgd3lzaWh0bWw1LnZpZXdzLlN5bmNocm9uaXplciA9IEJhc2UuZXh0ZW5kKFxuICAgIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlN5bmNocm9uaXplci5wcm90b3R5cGUgKi8ge1xuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGVkaXRvciwgdGV4dGFyZWEsIGNvbXBvc2VyKSB7XG4gICAgICB0aGlzLmVkaXRvciAgID0gZWRpdG9yO1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IHRleHRhcmVhO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGNvbXBvc2VyO1xuXG4gICAgICB0aGlzLl9vYnNlcnZlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN5bmMgaHRtbCBmcm9tIGNvbXBvc2VyIHRvIHRleHRhcmVhXG4gICAgICogVGFrZXMgY2FyZSBvZiBwbGFjZWhvbGRlcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZFBhcnNlSHRtbCBXaGV0aGVyIHRoZSBodG1sIHNob3VsZCBiZSBzYW5pdGl6ZWQgYmVmb3JlIGluc2VydGluZyBpdCBpbnRvIHRoZSB0ZXh0YXJlYVxuICAgICAqL1xuICAgIGZyb21Db21wb3NlclRvVGV4dGFyZWE6IGZ1bmN0aW9uKHNob3VsZFBhcnNlSHRtbCkge1xuICAgICAgdGhpcy50ZXh0YXJlYS5zZXRWYWx1ZSh3eXNpaHRtbDUubGFuZy5zdHJpbmcodGhpcy5jb21wb3Nlci5nZXRWYWx1ZShmYWxzZSwgZmFsc2UpKS50cmltKCksIHNob3VsZFBhcnNlSHRtbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN5bmMgdmFsdWUgb2YgdGV4dGFyZWEgdG8gY29tcG9zZXJcbiAgICAgKiBUYWtlcyBjYXJlIG9mIHBsYWNlaG9sZGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkUGFyc2VIdG1sIFdoZXRoZXIgdGhlIGh0bWwgc2hvdWxkIGJlIHNhbml0aXplZCBiZWZvcmUgaW5zZXJ0aW5nIGl0IGludG8gdGhlIGNvbXBvc2VyXG4gICAgICovXG4gICAgZnJvbVRleHRhcmVhVG9Db21wb3NlcjogZnVuY3Rpb24oc2hvdWxkUGFyc2VIdG1sKSB7XG4gICAgICB2YXIgdGV4dGFyZWFWYWx1ZSA9IHRoaXMudGV4dGFyZWEuZ2V0VmFsdWUoZmFsc2UsIGZhbHNlKTtcbiAgICAgIGlmICh0ZXh0YXJlYVZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29tcG9zZXIuc2V0VmFsdWUodGV4dGFyZWFWYWx1ZSwgc2hvdWxkUGFyc2VIdG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcG9zZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuZmlyZShcInNldF9wbGFjZWhvbGRlclwiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlIHN5bmNpbmcgYmFzZWQgb24gdmlldyBzdGF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkUGFyc2VIdG1sIFdoZXRoZXIgdGhlIGh0bWwgc2hvdWxkIGJlIHNhbml0aXplZCBiZWZvcmUgaW5zZXJ0aW5nIGl0IGludG8gdGhlIGNvbXBvc2VyL3RleHRhcmVhXG4gICAgICovXG4gICAgc3luYzogZnVuY3Rpb24oc2hvdWxkUGFyc2VIdG1sKSB7XG4gICAgICBpZiAodGhpcy5lZGl0b3IuY3VycmVudFZpZXcubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgIHRoaXMuZnJvbVRleHRhcmVhVG9Db21wb3NlcihzaG91bGRQYXJzZUh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKHNob3VsZFBhcnNlSHRtbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGludGVydmFsLWJhc2VkIHN5bmNpbmdcbiAgICAgKiBhbHNvIG1ha2VzIHN1cmUgdGhhdCBvbi1zdWJtaXQgdGhlIGNvbXBvc2VyJ3MgY29udGVudCBpcyBzeW5jZWQgd2l0aCB0aGUgdGV4dGFyZWFcbiAgICAgKiBpbW1lZGlhdGVseSB3aGVuIHRoZSBmb3JtIGdldHMgc3VibWl0dGVkXG4gICAgICovXG4gICAgX29ic2VydmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGludGVydmFsLFxuICAgICAgICAgIHRoYXQgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgIGZvcm0gICAgICAgICAgPSB0aGlzLnRleHRhcmVhLmVsZW1lbnQuZm9ybSxcbiAgICAgICAgICBzdGFydEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyB0aGF0LmZyb21Db21wb3NlclRvVGV4dGFyZWEoKTsgfSwgSU5URVJWQUwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RvcEludGVydmFsICA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgfTtcblxuICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuXG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dGFyZWEgaXMgaW4gYSBmb3JtIG1ha2Ugc3VyZSB0aGF0IGFmdGVyIG9ucmVzZXQgYW5kIG9uc3VibWl0IHRoZSBjb21wb3NlclxuICAgICAgICAvLyBoYXMgdGhlIGNvcnJlY3Qgc3RhdGVcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGZvcm0sIFwic3VibWl0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoYXQuc3luYyh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShmb3JtLCBcInJlc2V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRoYXQuZnJvbVRleHRhcmVhVG9Db21wb3NlcigpOyB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRpdG9yLm9uKFwiY2hhbmdlX3ZpZXdcIiwgZnVuY3Rpb24odmlldykge1xuICAgICAgICBpZiAodmlldyA9PT0gXCJjb21wb3NlclwiICYmICFpbnRlcnZhbCkge1xuICAgICAgICAgIHRoYXQuZnJvbVRleHRhcmVhVG9Db21wb3Nlcih0cnVlKTtcbiAgICAgICAgICBzdGFydEludGVydmFsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmlldyA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgdGhhdC5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKHRydWUpO1xuICAgICAgICAgIHN0b3BJbnRlcnZhbCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lZGl0b3Iub24oXCJkZXN0cm95OmNvbXBvc2VyXCIsIHN0b3BJbnRlcnZhbCk7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG47d3lzaWh0bWw1LnZpZXdzLlRleHRhcmVhID0gd3lzaWh0bWw1LnZpZXdzLlZpZXcuZXh0ZW5kKFxuICAvKiogQHNjb3BlIHd5c2lodG1sNS52aWV3cy5UZXh0YXJlYS5wcm90b3R5cGUgKi8ge1xuICBuYW1lOiBcInRleHRhcmVhXCIsXG5cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLmJhc2UocGFyZW50LCB0ZXh0YXJlYUVsZW1lbnQsIGNvbmZpZyk7XG5cbiAgICB0aGlzLl9vYnNlcnZlKCk7XG4gIH0sXG5cbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IFwiXCI7XG4gIH0sXG5cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHBhcnNlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5pc0VtcHR5KCkgPyBcIlwiIDogdGhpcy5lbGVtZW50LnZhbHVlO1xuICAgIGlmIChwYXJzZSAhPT0gZmFsc2UpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJlbnQucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgc2V0VmFsdWU6IGZ1bmN0aW9uKGh0bWwsIHBhcnNlKSB7XG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICBodG1sID0gdGhpcy5wYXJlbnQucGFyc2UoaHRtbCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IGh0bWw7XG4gIH0sXG5cbiAgY2xlYW5VcDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHRtbCA9IHRoaXMucGFyZW50LnBhcnNlKHRoaXMuZWxlbWVudC52YWx1ZSk7XG4gICAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBodG1sO1xuICB9LFxuXG4gIGhhc1BsYWNlaG9sZGVyU2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3VwcG9ydHNQbGFjZWhvbGRlciA9IHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzUGxhY2Vob2xkZXJBdHRyaWJ1dGVPbih0aGlzLmVsZW1lbnQpLFxuICAgICAgICBwbGFjZWhvbGRlclRleHQgICAgID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpIHx8IG51bGwsXG4gICAgICAgIHZhbHVlICAgICAgICAgICAgICAgPSB0aGlzLmVsZW1lbnQudmFsdWUsXG4gICAgICAgIGlzRW1wdHkgICAgICAgICAgICAgPSAhdmFsdWU7XG4gICAgcmV0dXJuIChzdXBwb3J0c1BsYWNlaG9sZGVyICYmIGlzRW1wdHkpIHx8ICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXJUZXh0KTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXd5c2lodG1sNS5sYW5nLnN0cmluZyh0aGlzLmVsZW1lbnQudmFsdWUpLnRyaW0oKSB8fCB0aGlzLmhhc1BsYWNlaG9sZGVyU2V0KCk7XG4gIH0sXG5cbiAgX29ic2VydmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBwYXJlbnQgID0gdGhpcy5wYXJlbnQsXG4gICAgICAgIGV2ZW50TWFwcGluZyA9IHtcbiAgICAgICAgICBmb2N1c2luOiAgXCJmb2N1c1wiLFxuICAgICAgICAgIGZvY3Vzb3V0OiBcImJsdXJcIlxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGluZyBmb2N1cygpIG9yIGJsdXIoKSBvbiBhbiBlbGVtZW50IGRvZXNuJ3Qgc3luY2hyb25vdXNseSB0cmlnZ2VyIHRoZSBhdHRhY2hlZCBmb2N1cy9ibHVyIGV2ZW50c1xuICAgICAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIGZvciBmb2N1c2luIGFuZCBmb2N1c291dCwgc28gbGV0J3MgdXNlIHRoZW0gd2hlbmV2ZXIgcG9zc2libGUsIGtrdGh4YmFpXG4gICAgICAgICAqL1xuICAgICAgICBldmVudHMgPSB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwiZm9jdXNpblwiKSA/IFtcImZvY3VzaW5cIiwgXCJmb2N1c291dFwiLCBcImNoYW5nZVwiXSA6IFtcImZvY3VzXCIsIFwiYmx1clwiLCBcImNoYW5nZVwiXTtcblxuICAgIHBhcmVudC5vbihcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZWxlbWVudCwgZXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRNYXBwaW5nW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gICAgICAgIHBhcmVudC5maXJlKGV2ZW50TmFtZSkuZmlyZShldmVudE5hbWUgKyBcIjp0ZXh0YXJlYVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZWxlbWVudCwgW1wicGFzdGVcIiwgXCJkcm9wXCJdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgcGFyZW50LmZpcmUoXCJwYXN0ZVwiKS5maXJlKFwicGFzdGU6dGV4dGFyZWFcIik7IH0sIDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuOy8qKlxuICogV1lTSUhUTUw1IEVkaXRvclxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWRpdGFibGVFbGVtZW50IFJlZmVyZW5jZSB0byB0aGUgdGV4dGFyZWEgd2hpY2ggc2hvdWxkIGJlIHR1cm5lZCBpbnRvIGEgcmljaCB0ZXh0IGludGVyZmFjZVxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFNlZSBkZWZhdWx0Q29uZmlnIG9iamVjdCBiZWxvdyBmb3IgZXhwbGFuYXRpb24gb2YgZWFjaCBpbmRpdmlkdWFsIGNvbmZpZyBvcHRpb25cbiAqXG4gKiBAZXZlbnRzXG4gKiAgICBsb2FkXG4gKiAgICBiZWZvcmVsb2FkIChmb3IgaW50ZXJuYWwgdXNlIG9ubHkpXG4gKiAgICBmb2N1c1xuICogICAgZm9jdXM6Y29tcG9zZXJcbiAqICAgIGZvY3VzOnRleHRhcmVhXG4gKiAgICBibHVyXG4gKiAgICBibHVyOmNvbXBvc2VyXG4gKiAgICBibHVyOnRleHRhcmVhXG4gKiAgICBjaGFuZ2VcbiAqICAgIGNoYW5nZTpjb21wb3NlclxuICogICAgY2hhbmdlOnRleHRhcmVhXG4gKiAgICBwYXN0ZVxuICogICAgcGFzdGU6Y29tcG9zZXJcbiAqICAgIHBhc3RlOnRleHRhcmVhXG4gKiAgICBuZXd3b3JkOmNvbXBvc2VyXG4gKiAgICBkZXN0cm95OmNvbXBvc2VyXG4gKiAgICB1bmRvOmNvbXBvc2VyXG4gKiAgICByZWRvOmNvbXBvc2VyXG4gKiAgICBiZWZvcmVjb21tYW5kOmNvbXBvc2VyXG4gKiAgICBhZnRlcmNvbW1hbmQ6Y29tcG9zZXJcbiAqICAgIGVuYWJsZTpjb21wb3NlclxuICogICAgZGlzYWJsZTpjb21wb3NlclxuICogICAgY2hhbmdlX3ZpZXdcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG5cbiAgdmFyIGRlZmF1bHRDb25maWcgPSB7XG4gICAgLy8gR2l2ZSB0aGUgZWRpdG9yIGEgbmFtZSwgdGhlIG5hbWUgd2lsbCBhbHNvIGJlIHNldCBhcyBjbGFzcyBuYW1lIG9uIHRoZSBpZnJhbWUgYW5kIG9uIHRoZSBpZnJhbWUncyBib2R5XG4gICAgbmFtZTogICAgICAgICAgICAgICAgIHVuZGVmLFxuICAgIC8vIFdoZXRoZXIgdGhlIGVkaXRvciBzaG91bGQgbG9vayBsaWtlIHRoZSB0ZXh0YXJlYSAoYnkgYWRvcHRpbmcgc3R5bGVzKVxuICAgIHN0eWxlOiAgICAgICAgICAgICAgICB0cnVlLFxuICAgIC8vIElkIG9mIHRoZSB0b29sYmFyIGVsZW1lbnQsIHBhc3MgZmFsc2V5IHZhbHVlIGlmIHlvdSBkb24ndCB3YW50IGFueSB0b29sYmFyIGxvZ2ljXG4gICAgdG9vbGJhcjogICAgICAgICAgICAgIHVuZGVmLFxuICAgIC8vIFdoZXRoZXIgdG9vbGJhciBpcyBkaXNwbGF5ZWQgYWZ0ZXIgaW5pdCBieSBzY3JpcHQgYXV0b21hdGljYWxseS5cbiAgICAvLyBDYW4gYmUgc2V0IHRvIGZhbHNlIGlmIHRvb2xvYmFyIGlzIHNldCB0byBkaXNwbGF5IG9ubHkgb24gZWRpdGFibGUgYXJlYSBmb2N1c1xuICAgIHNob3dUb29sYmFyQWZ0ZXJJbml0OiB0cnVlLFxuICAgIC8vIFdoZXRoZXIgdXJscywgZW50ZXJlZCBieSB0aGUgdXNlciBzaG91bGQgYXV0b21hdGljYWxseSBiZWNvbWUgY2xpY2thYmxlLWxpbmtzXG4gICAgYXV0b0xpbms6ICAgICAgICAgICAgIHRydWUsXG4gICAgLy8gSW5jbHVkZXMgdGFibGUgZWRpdGluZyBldmVudHMgYW5kIGNlbGwgc2VsZWN0aW9uIHRyYWNraW5nXG4gICAgaGFuZGxlVGFibGVzOiAgICAgICAgIHRydWUsXG4gICAgLy8gVGFiIGtleSBpbnNlcnRzIHRhYiBpbnRvIHRleHQgYXMgZGVmYXVsdCBiZWhhdmlvdXIuIEl0IGNhbiBiZSBkaXNhYmxlZCB0byByZWdhaW4ga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgIGhhbmRsZVRhYktleTogICAgICAgICB0cnVlLFxuICAgIC8vIE9iamVjdCB3aGljaCBpbmNsdWRlcyBwYXJzZXIgcnVsZXMgdG8gYXBwbHkgd2hlbiBodG1sIGdldHMgY2xlYW5lZFxuICAgIC8vIFNlZSBwYXJzZXJfcnVsZXMvKi5qcyBmb3IgZXhhbXBsZXNcbiAgICBwYXJzZXJSdWxlczogICAgICAgICAgeyB0YWdzOiB7IGJyOiB7fSwgc3Bhbjoge30sIGRpdjoge30sIHA6IHt9IH0sIGNsYXNzZXM6IHt9IH0sXG4gICAgLy8gT2JqZWN0IHdoaWNoIGluY2x1ZGVzIHBhcnNlciB3aGVuIHRoZSB1c2VyIGluc2VydHMgY29udGVudCB2aWEgY29weSAmIHBhc3RlLiBJZiBudWxsIHBhcnNlclJ1bGVzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkXG4gICAgcGFzdGVQYXJzZXJSdWxlc2V0czogbnVsbCxcbiAgICAvLyBQYXJzZXIgbWV0aG9kIHRvIHVzZSB3aGVuIHRoZSB1c2VyIGluc2VydHMgY29udGVudFxuICAgIHBhcnNlcjogICAgICAgICAgICAgICB3eXNpaHRtbDUuZG9tLnBhcnNlLFxuICAgIC8vIENsYXNzIG5hbWUgd2hpY2ggc2hvdWxkIGJlIHNldCBvbiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgaW4gdGhlIGNyZWF0ZWQgc2FuZGJveCBpZnJhbWUsIGNhbiBiZSBzdHlsZWQgdmlhIHRoZSAnc3R5bGVzaGVldHMnIG9wdGlvblxuICAgIGNvbXBvc2VyQ2xhc3NOYW1lOiAgICBcInd5c2lodG1sNS1lZGl0b3JcIixcbiAgICAvLyBDbGFzcyBuYW1lIHRvIGFkZCB0byB0aGUgYm9keSB3aGVuIHRoZSB3eXNpaHRtbDUgZWRpdG9yIGlzIHN1cHBvcnRlZFxuICAgIGJvZHlDbGFzc05hbWU6ICAgICAgICBcInd5c2lodG1sNS1zdXBwb3J0ZWRcIixcbiAgICAvLyBCeSBkZWZhdWx0IHd5c2lodG1sNSB3aWxsIGluc2VydCBhIDxicj4gZm9yIGxpbmUgYnJlYWtzLCBzZXQgdGhpcyB0byBmYWxzZSB0byB1c2UgPHA+XG4gICAgdXNlTGluZUJyZWFrczogICAgICAgIHRydWUsXG4gICAgLy8gQXJyYXkgKG9yIHNpbmdsZSBzdHJpbmcpIG9mIHN0eWxlc2hlZXQgdXJscyB0byBiZSBsb2FkZWQgaW4gdGhlIGVkaXRvcidzIGlmcmFtZVxuICAgIHN0eWxlc2hlZXRzOiAgICAgICAgICBbXSxcbiAgICAvLyBQbGFjZWhvbGRlciB0ZXh0IHRvIHVzZSwgZGVmYXVsdHMgdG8gdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvbiB0aGUgdGV4dGFyZWEgZWxlbWVudFxuICAgIHBsYWNlaG9sZGVyVGV4dDogICAgICB1bmRlZixcbiAgICAvLyBXaGV0aGVyIHRoZSByaWNoIHRleHQgZWRpdG9yIHNob3VsZCBiZSByZW5kZXJlZCBvbiB0b3VjaCBkZXZpY2VzICh3eXNpaHRtbDUgPj0gMC4zLjAgY29tZXMgd2l0aCBiYXNpYyBzdXBwb3J0IGZvciBpT1MgNSlcbiAgICBzdXBwb3J0VG91Y2hEZXZpY2VzOiAgdHJ1ZSxcbiAgICAvLyBXaGV0aGVyIHNlbnNlbGVzcyA8c3Bhbj4gZWxlbWVudHMgKGVtcHR5IG9yIHdpdGhvdXQgYXR0cmlidXRlcykgc2hvdWxkIGJlIHJlbW92ZWQvcmVwbGFjZWQgd2l0aCB0aGVpciBjb250ZW50XG4gICAgY2xlYW5VcDogICAgICAgICAgICAgIHRydWUsXG4gICAgLy8gV2hldGhlciB0byB1c2UgZGl2IGluc3RlYWQgb2Ygc2VjdXJlIGlmcmFtZVxuICAgIGNvbnRlbnRFZGl0YWJsZU1vZGU6IGZhbHNlLFxuICAgIC8vIENsYXNzbmFtZSBvZiBjb250YWluZXIgdGhhdCBlZGl0b3Igc2hvdWxkIG5vdCB0b3VjaCBhbmQgcGFzcyB0aHJvdWdoXG4gICAgLy8gUGFzcyBmYWxzZSB0byBkaXNhYmxlXG4gICAgdW5lZGl0YWJsZUNvbnRhaW5lckNsYXNzbmFtZTogXCJ3eXNpaHRtbDUtdW5lZGl0YWJsZS1jb250YWluZXJcIixcbiAgICAvLyBCcm93c2VycyB0aGF0IHN1cHBvcnQgY29waWVkIHNvdXJjZSBoYW5kbGluZyB3aWxsIGdldCBhIG1hcmtpbmcgb2YgdGhlIG9yaWdpbiBvZiB0aGUgY29waWVkIHNvdXJjZSAoZm9yIGRldGVybWluaWcgY29kZSBjbGVhbnVwIHJ1bGVzIG9uIHBhc3RlKVxuICAgIC8vIEFsc28gY29waWVkIHNvdXJjZSBpcyBiYXNlZCBkaXJlY3RseSBvbiBzZWxlY3Rpb24gLSBcbiAgICAvLyAodmVyeSB1c2VmdWwgZm9yIHdlYmtpdCBiYXNlZCBicm93c2VycyB3aGVyZSBjb3B5IHdpbGwgb3RoZXJ3aXNlIGNvbnRhaW4gYSBsb3Qgb2YgY29kZSBhbmQgc3R5bGVzIGJhc2VkIG9uIHdoYXRldmVyIGFuZCBub3QgYWN0dWFsbHkgaW4gc2VsZWN0aW9uKS5cbiAgICAvLyBJZiBmYWxzeSB2YWx1ZSBpcyBwYXNzZWQgc291cmNlIG92ZXJyaWRlIGlzIGFsc28gZGlzYWJsZWRcbiAgICBjb3B5ZWRGcm9tTWFya2luZzogJzxtZXRhIG5hbWU9XCJjb3BpZWQtZnJvbVwiIGNvbnRlbnQ9XCJ3eXNpaHRtbDVcIj4nXG4gIH07XG5cbiAgd3lzaWh0bWw1LkVkaXRvciA9IHd5c2lodG1sNS5sYW5nLkRpc3BhdGNoZXIuZXh0ZW5kKFxuICAgIC8qKiBAc2NvcGUgd3lzaWh0bWw1LkVkaXRvci5wcm90b3R5cGUgKi8ge1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihlZGl0YWJsZUVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgdGhpcy5lZGl0YWJsZUVsZW1lbnQgID0gdHlwZW9mKGVkaXRhYmxlRWxlbWVudCkgPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlZGl0YWJsZUVsZW1lbnQpIDogZWRpdGFibGVFbGVtZW50O1xuICAgICAgdGhpcy5jb25maWcgICAgICAgICAgID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHt9KS5tZXJnZShkZWZhdWx0Q29uZmlnKS5tZXJnZShjb25maWcpLmdldCgpO1xuICAgICAgdGhpcy5faXNDb21wYXRpYmxlICAgID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydGVkKCk7XG5cbiAgICAgIGlmICh0aGlzLmVkaXRhYmxlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9IFwidGV4dGFyZWFcIikge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmNvbnRlbnRFZGl0YWJsZU1vZGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY29uZmlnLm5vVGV4dGFyZWEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5ub1RleHRhcmVhKSB7XG4gICAgICAgICAgdGhpcy50ZXh0YXJlYSAgICAgICAgID0gbmV3IHd5c2lodG1sNS52aWV3cy5UZXh0YXJlYSh0aGlzLCB0aGlzLmVkaXRhYmxlRWxlbWVudCwgdGhpcy5jb25maWcpO1xuICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcgICAgICA9IHRoaXMudGV4dGFyZWE7XG4gICAgICB9XG5cbiAgICAgIC8vIFNvcnQgb3V0IHVuc3VwcG9ydGVkL3Vud2FudGVkIGJyb3dzZXJzIGhlcmVcbiAgICAgIGlmICghdGhpcy5faXNDb21wYXRpYmxlIHx8ICghdGhpcy5jb25maWcuc3VwcG9ydFRvdWNoRGV2aWNlcyAmJiB3eXNpaHRtbDUuYnJvd3Nlci5pc1RvdWNoRGV2aWNlKCkpKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5maXJlKFwiYmVmb3JlbG9hZFwiKS5maXJlKFwibG9hZFwiKTsgfSwgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNsYXNzIG5hbWUgdG8gYm9keSwgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZWRpdG9yIGlzIHN1cHBvcnRlZFxuICAgICAgd3lzaWh0bWw1LmRvbS5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCB0aGlzLmNvbmZpZy5ib2R5Q2xhc3NOYW1lKTtcblxuICAgICAgdGhpcy5jb21wb3NlciA9IG5ldyB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIodGhpcywgdGhpcy5lZGl0YWJsZUVsZW1lbnQsIHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB0aGlzLmNvbXBvc2VyO1xuXG4gICAgICBpZiAodHlwZW9mKHRoaXMuY29uZmlnLnBhcnNlcikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9pbml0UGFyc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub24oXCJiZWZvcmVsb2FkXCIsIHRoaXMuaGFuZGxlQmVmb3JlTG9hZCk7XG4gICAgfSxcblxuICAgIGhhbmRsZUJlZm9yZUxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLm5vVGV4dGFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY2hyb25pemVyID0gbmV3IHd5c2lodG1sNS52aWV3cy5TeW5jaHJvbml6ZXIodGhpcywgdGhpcy50ZXh0YXJlYSwgdGhpcy5jb21wb3Nlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRvb2xiYXIpIHtcbiAgICAgICAgICB0aGlzLnRvb2xiYXIgPSBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhcih0aGlzLCB0aGlzLmNvbmZpZy50b29sYmFyLCB0aGlzLmNvbmZpZy5zaG93VG9vbGJhckFmdGVySW5pdCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNDb21wYXRpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0NvbXBhdGlibGU7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcuY2xlYXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24ocGFyc2UsIGNsZWFySW50ZXJuYWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50Vmlldy5nZXRWYWx1ZShwYXJzZSwgY2xlYXJJbnRlcm5hbHMpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oaHRtbCwgcGFyc2UpIHtcbiAgICAgIHRoaXMuZmlyZShcInVuc2V0X3BsYWNlaG9sZGVyXCIpO1xuXG4gICAgICBpZiAoIWh0bWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50Vmlldy5zZXRWYWx1ZShodG1sLCBwYXJzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYW5VcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcuY2xlYW5VcCgpO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24oc2V0VG9FbmQpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcuZm9jdXMoc2V0VG9FbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGUgZWRpdG9yIChtYWtlIGl0IHJlYWRvbmx5KVxuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgZWRpdG9yXG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcuZW5hYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50Vmlldy5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIGhhc1BsYWNlaG9sZGVyU2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWV3Lmhhc1BsYWNlaG9sZGVyU2V0KCk7XG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbihodG1sT3JFbGVtZW50LCBjbGVhckludGVybmFscykge1xuICAgICAgdmFyIHBhcnNlQ29udGV4dCA9ICh0aGlzLmNvbmZpZy5jb250ZW50RWRpdGFibGVNb2RlKSA/IGRvY3VtZW50IDogKCh0aGlzLmNvbXBvc2VyKSA/IHRoaXMuY29tcG9zZXIuc2FuZGJveC5nZXREb2N1bWVudCgpIDogbnVsbCk7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0aGlzLmNvbmZpZy5wYXJzZXIoaHRtbE9yRWxlbWVudCwge1xuICAgICAgICBcInJ1bGVzXCI6IHRoaXMuY29uZmlnLnBhcnNlclJ1bGVzLFxuICAgICAgICBcImNsZWFuVXBcIjogdGhpcy5jb25maWcuY2xlYW5VcCxcbiAgICAgICAgXCJjb250ZXh0XCI6IHBhcnNlQ29udGV4dCxcbiAgICAgICAgXCJ1bmVkaXRhYmxlQ2xhc3NcIjogdGhpcy5jb25maWcudW5lZGl0YWJsZUNvbnRhaW5lckNsYXNzbmFtZSxcbiAgICAgICAgXCJjbGVhckludGVybmFsc1wiIDogY2xlYXJJbnRlcm5hbHNcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZihodG1sT3JFbGVtZW50KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB3eXNpaHRtbDUucXVpcmtzLnJlZHJhdyhodG1sT3JFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBodG1sIHBhcnNlciBsb2dpY1xuICAgICAqICAtIE9ic2VydmVzIGZvciBwYXN0ZSBhbmQgZHJvcFxuICAgICAqL1xuICAgIF9pbml0UGFyc2VyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBvbGRIdG1sLFxuICAgICAgICAgIGNsZWFuSHRtbDtcblxuICAgICAgaWYgKHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzTW9kZW5QYXN0ZSgpKSB7XG4gICAgICAgIHRoaXMub24oXCJwYXN0ZTpjb21wb3NlclwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgb2xkSHRtbCA9IHd5c2lodG1sNS5kb20uZ2V0UGFzdGVkSHRtbChldmVudCk7XG4gICAgICAgICAgaWYgKG9sZEh0bWwpIHtcbiAgICAgICAgICAgIHRoYXQuX2NsZWFuQW5kUGFzdGUob2xkSHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbihcImJlZm9yZXBhc3RlOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB3eXNpaHRtbDUuZG9tLmdldFBhc3RlZEh0bWxXaXRoRGl2KHRoYXQuY29tcG9zZXIsIGZ1bmN0aW9uKHBhc3RlZEhUTUwpIHtcbiAgICAgICAgICAgIGlmIChwYXN0ZWRIVE1MKSB7XG4gICAgICAgICAgICAgIHRoYXQuX2NsZWFuQW5kUGFzdGUocGFzdGVkSFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICB9XG4gICAgfSxcblxuICAgIF9jbGVhbkFuZFBhc3RlOiBmdW5jdGlvbiAob2xkSHRtbCkge1xuICAgICAgdmFyIGNsZWFuSHRtbCA9IHd5c2lodG1sNS5xdWlya3MuY2xlYW5QYXN0ZWRIVE1MKG9sZEh0bWwsIHtcbiAgICAgICAgXCJyZWZlcmVuY2VOb2RlXCI6IHRoaXMuY29tcG9zZXIuZWxlbWVudCxcbiAgICAgICAgXCJydWxlc1wiOiB0aGlzLmNvbmZpZy5wYXN0ZVBhcnNlclJ1bGVzZXRzIHx8IFt7XCJzZXRcIjogdGhpcy5jb25maWcucGFyc2VyUnVsZXN9XSxcbiAgICAgICAgXCJ1bmVkaXRhYmxlQ2xhc3NcIjogdGhpcy5jb25maWcudW5lZGl0YWJsZUNvbnRhaW5lckNsYXNzbmFtZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbXBvc2VyLnNlbGVjdGlvbi5kZWxldGVDb250ZW50cygpO1xuICAgICAgdGhpcy5jb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0SFRNTChjbGVhbkh0bWwpO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuOy8qKlxuICogVG9vbGJhciBEaWFsb2dcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGxpbmsgVGhlIHRvb2xiYXIgbGluayB3aGljaCBjYXVzZXMgdGhlIGRpYWxvZyB0byBzaG93IHVwXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciBUaGUgZGlhbG9nIGNvbnRhaW5lclxuICpcbiAqIEBleGFtcGxlXG4gKiAgICA8IS0tIFRvb2xiYXIgbGluayAtLT5cbiAqICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJpbnNlcnRJbWFnZVwiPmluc2VydCBhbiBpbWFnZTwvYT5cbiAqXG4gKiAgICA8IS0tIERpYWxvZyAtLT5cbiAqICAgIDxkaXYgZGF0YS13eXNpaHRtbDUtZGlhbG9nPVwiaW5zZXJ0SW1hZ2VcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XG4gKiAgICAgIDxsYWJlbD5cbiAqICAgICAgICBVUkw6IDxpbnB1dCBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJzcmNcIiB2YWx1ZT1cImh0dHA6Ly9cIj5cbiAqICAgICAgPC9sYWJlbD5cbiAqICAgICAgPGxhYmVsPlxuICogICAgICAgIEFsdGVybmF0aXZlIHRleHQ6IDxpbnB1dCBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJhbHRcIiB2YWx1ZT1cIlwiPlxuICogICAgICA8L2xhYmVsPlxuICogICAgPC9kaXY+XG4gKlxuICogICAgPHNjcmlwdD5cbiAqICAgICAgdmFyIGRpYWxvZyA9IG5ldyB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2coXG4gKiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdpbnNlcnRJbWFnZSddXCIpLFxuICogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nPSdpbnNlcnRJbWFnZSddXCIpXG4gKiAgICAgICk7XG4gKiAgICAgIGRpYWxvZy5vYnNlcnZlKFwic2F2ZVwiLCBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gKiAgICAgICAgLy8gZG8gc29tZXRoaW5nXG4gKiAgICAgIH0pO1xuICogICAgPC9zY3JpcHQ+XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSAgICAgICAgICAgICAgICAgICAgID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIENMQVNTX05BTUVfT1BFTkVEICAgICAgID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1kaWFsb2ctb3BlbmVkXCIsXG4gICAgICBTRUxFQ1RPUl9GT1JNX0VMRU1FTlRTICA9IFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWFcIixcbiAgICAgIFNFTEVDVE9SX0ZJRUxEUyAgICAgICAgID0gXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkXVwiLFxuICAgICAgQVRUUklCVVRFX0ZJRUxEUyAgICAgICAgPSBcImRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZFwiO1xuXG5cbiAgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nID0gd3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlci5leHRlbmQoXG4gICAgLyoqIEBzY29wZSB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2cucHJvdG90eXBlICovIHtcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24obGluaywgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmxpbmsgICAgICAgPSBsaW5rO1xuICAgICAgdGhpcy5jb250YWluZXIgID0gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgY2FsbGJhY2tXcmFwcGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhhdC5fc2VyaWFsaXplKCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PSB0aGF0LmVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgICAgICAgICB0aGF0LmZpcmUoXCJlZGl0XCIsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhhdC5maXJlKFwic2F2ZVwiLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH07XG5cbiAgICAgIGRvbS5vYnNlcnZlKHRoYXQubGluaywgXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyh0aGF0LmxpbmssIENMQVNTX05BTUVfT1BFTkVEKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRoYXQuaGlkZSgpOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRvbS5vYnNlcnZlKHRoaXMuY29udGFpbmVyLCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSkge1xuICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FU0NBUEVfS0VZKSB7XG4gICAgICAgICAgdGhhdC5maXJlKFwiY2FuY2VsXCIpO1xuICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPXNhdmVdXCIsIFwiY2xpY2tcIiwgY2FsbGJhY2tXcmFwcGVyKTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPWNhbmNlbF1cIiwgXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGF0LmZpcmUoXCJjYW5jZWxcIik7XG4gICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZm9ybUVsZW1lbnRzICA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRk9STV9FTEVNRU5UUyksXG4gICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgbGVuZ3RoICAgICAgICA9IGZvcm1FbGVtZW50cy5sZW5ndGgsXG4gICAgICAgICAgX2NsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbigpIHsgY2xlYXJJbnRlcnZhbCh0aGF0LmludGVydmFsKTsgfTtcbiAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRvbS5vYnNlcnZlKGZvcm1FbGVtZW50c1tpXSwgXCJjaGFuZ2VcIiwgX2NsZWFySW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vYnNlcnZlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYWJzIGFsbCBmaWVsZHMgaW4gdGhlIGRpYWxvZyBhbmQgcHV0cyB0aGVtIGluIGtleT0+dmFsdWUgc3R5bGUgaW4gYW4gb2JqZWN0IHdoaWNoXG4gICAgICogdGhlbiBnZXRzIHJldHVybmVkXG4gICAgICovXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YSAgICA9IHRoaXMuZWxlbWVudFRvQ2hhbmdlIHx8IHt9LFxuICAgICAgICAgIGZpZWxkcyAgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJRUxEUyksXG4gICAgICAgICAgbGVuZ3RoICA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICAgICAgaSAgICAgICA9IDA7XG5cbiAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbZmllbGRzW2ldLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfRklFTERTKV0gPSBmaWVsZHNbaV0udmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIFwiZWxlbWVudFRvQ2hhbmdlXCJcbiAgICAgKiBhbmQgaW5zZXJ0cyB0aGVtIGluIHRoZWlyIGNvcnJlc3BvbmRpbmcgZGlhbG9nIGlucHV0IGZpZWxkc1xuICAgICAqXG4gICAgICogQXNzdW1lIHRoZSBcImVsZW1lbnRUb0NoYW5nZVwiIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKiAgICA8YSBocmVmPVwiaHR0cDovL3d3dy5nb29nbGUuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Zm9vPC9hPlxuICAgICAqXG4gICAgICogYW5kIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBkaWFsb2c6XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwiaHJlZlwiIHZhbHVlPVwiXCI+XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwidGFyZ2V0XCIgdmFsdWU9XCJcIj5cbiAgICAgKlxuICAgICAqIGFmdGVyIGNhbGxpbmcgX2ludGVycG9sYXRlKCkgdGhlIGRpYWxvZyB3aWxsIGxvb2sgbGlrZSB0aGlzXG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwiaHJlZlwiIHZhbHVlPVwiaHR0cDovL3d3dy5nb29nbGUuY29tXCI+XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwidGFyZ2V0XCIgdmFsdWU9XCJfYmxhbmtcIj5cbiAgICAgKlxuICAgICAqIEJhc2ljYWxseSBpdCBhZG9wdGVkIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgaW5wdXQgZmllbGRzXG4gICAgICpcbiAgICAgKi9cbiAgICBfaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGF2b2lkSGlkZGVuRmllbGRzKSB7XG4gICAgICB2YXIgZmllbGQsXG4gICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSxcbiAgICAgICAgICBmaWVsZHMgICAgICAgICA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRklFTERTKSxcbiAgICAgICAgICBsZW5ndGggICAgICAgICA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICAgICAgaSAgICAgICAgICAgICAgPSAwO1xuICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG5cbiAgICAgICAgLy8gTmV2ZXIgY2hhbmdlIGVsZW1lbnRzIHdoZXJlIHRoZSB1c2VyIGlzIGN1cnJlbnRseSB0eXBpbmcgaW5cbiAgICAgICAgaWYgKGZpZWxkID09PSBmb2N1c2VkRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIGhpZGRlbiBmaWVsZHNcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS94aW5nL3d5c2lodG1sNS9wdWxsLzE0XG4gICAgICAgIGlmIChhdm9pZEhpZGRlbkZpZWxkcyAmJiBmaWVsZC50eXBlID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZC5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0ZJRUxEUyk7XG4gICAgICAgIG5ld1ZhbHVlICA9ICh0aGlzLmVsZW1lbnRUb0NoYW5nZSAmJiB0eXBlb2YodGhpcy5lbGVtZW50VG9DaGFuZ2UpICE9PSAnYm9vbGVhbicpID8gKHRoaXMuZWxlbWVudFRvQ2hhbmdlLmdldEF0dHJpYnV0ZShmaWVsZE5hbWUpIHx8IFwiXCIpIDogZmllbGQuZGVmYXVsdFZhbHVlO1xuICAgICAgICBmaWVsZC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBkaWFsb2cgZWxlbWVudFxuICAgICAqL1xuICAgIHNob3c6IGZ1bmN0aW9uKGVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgaWYgKGRvbS5oYXNDbGFzcyh0aGlzLmxpbmssIENMQVNTX05BTUVfT1BFTkVEKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgZmlyc3RGaWVsZCAgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMpO1xuICAgICAgdGhpcy5lbGVtZW50VG9DaGFuZ2UgPSBlbGVtZW50VG9DaGFuZ2U7XG4gICAgICB0aGlzLl9vYnNlcnZlKCk7XG4gICAgICB0aGlzLl9pbnRlcnBvbGF0ZSgpO1xuICAgICAgaWYgKGVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IHRoYXQuX2ludGVycG9sYXRlKHRydWUpOyB9LCA1MDApO1xuICAgICAgfVxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMubGluaywgQ0xBU1NfTkFNRV9PUEVORUQpO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLmZpcmUoXCJzaG93XCIpO1xuICAgICAgaWYgKGZpcnN0RmllbGQgJiYgIWVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZpcnN0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBkaWFsb2cgZWxlbWVudFxuICAgICAqL1xuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgIHRoaXMuZWxlbWVudFRvQ2hhbmdlID0gbnVsbDtcbiAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLmxpbmssIENMQVNTX05BTUVfT1BFTkVEKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHRoaXMuZmlyZShcImhpZGVcIik7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG47LyoqXG4gKiBDb252ZXJ0cyBzcGVlY2gtdG8tdGV4dCBhbmQgaW5zZXJ0cyB0aGlzIGludG8gdGhlIGVkaXRvclxuICogQXMgb2Ygbm93ICgyMDExLzAzLzI1KSB0aGlzIG9ubHkgaXMgc3VwcG9ydGVkIGluIENocm9tZSA+PSAxMVxuICpcbiAqIE5vdGUgdGhhdCBpdCBzZW5kcyB0aGUgcmVjb3JkZWQgYXVkaW8gdG8gdGhlIGdvb2dsZSBzcGVlY2ggcmVjb2duaXRpb24gYXBpOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MzYxODI2L2RvZXMtY2hyb21lLWhhdmUtYnVpbC1pbi1zcGVlY2gtcmVjb2duaXRpb24tZm9yLWlucHV0LXR5cGUtdGV4dC14LXdlYmtpdC1zcGVlY1xuICpcbiAqIEN1cnJlbnQgSFRNTDUgZHJhZnQgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHA6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3B1YmxpYy14Zy1odG1sc3BlZWNoLzIwMTFGZWIvYXR0LTAwMjAvYXBpLWRyYWZ0Lmh0bWxcbiAqXG4gKiBcIkFjY2Vzc2luZyBHb29nbGUgU3BlZWNoIEFQSSBDaHJvbWUgMTFcIlxuICogaHR0cDovL21pa2VwdWx0ei5jb20vMjAxMS8wMy9hY2Nlc3NpbmctZ29vZ2xlLXNwZWVjaC1hcGktY2hyb21lLTExL1xuICovXG4oZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tO1xuXG4gIHZhciBsaW5rU3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgfTtcblxuICB2YXIgd3JhcHBlclN0eWxlcyA9IHtcbiAgICBsZWZ0OiAgICAgMCxcbiAgICBtYXJnaW46ICAgMCxcbiAgICBvcGFjaXR5OiAgMCxcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICBwYWRkaW5nOiAgMCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHRvcDogICAgICAwLFxuICAgIHpJbmRleDogICAxXG4gIH07XG5cbiAgdmFyIGlucHV0U3R5bGVzID0ge1xuICAgIGN1cnNvcjogICAgIFwiaW5oZXJpdFwiLFxuICAgIGZvbnRTaXplOiAgIFwiNTBweFwiLFxuICAgIGhlaWdodDogICAgIFwiNTBweFwiLFxuICAgIG1hcmdpblRvcDogIFwiLTI1cHhcIixcbiAgICBvdXRsaW5lOiAgICAwLFxuICAgIHBhZGRpbmc6ICAgIDAsXG4gICAgcG9zaXRpb246ICAgXCJhYnNvbHV0ZVwiLFxuICAgIHJpZ2h0OiAgICAgIFwiLTRweFwiLFxuICAgIHRvcDogICAgICAgIFwiNTAlXCJcbiAgfTtcblxuICB2YXIgaW5wdXRBdHRyaWJ1dGVzID0ge1xuICAgIFwieC13ZWJraXQtc3BlZWNoXCI6IFwiXCIsXG4gICAgXCJzcGVlY2hcIjogICAgICAgICAgXCJcIlxuICB9O1xuXG4gIHd5c2lodG1sNS50b29sYmFyLlNwZWVjaCA9IGZ1bmN0aW9uKHBhcmVudCwgbGluaykge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpZiAoIXd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU3BlZWNoQXBpT24oaW5wdXQpKSB7XG4gICAgICBsaW5rLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhbmcgPSBwYXJlbnQuZWRpdG9yLnRleHRhcmVhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibGFuZ1wiKTtcbiAgICBpZiAobGFuZykge1xuICAgICAgaW5wdXRBdHRyaWJ1dGVzLmxhbmcgPSBsYW5nO1xuICAgIH1cblxuICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIHd5c2lodG1sNS5sYW5nLm9iamVjdCh3cmFwcGVyU3R5bGVzKS5tZXJnZSh7XG4gICAgICB3aWR0aDogIGxpbmsub2Zmc2V0V2lkdGggICsgXCJweFwiLFxuICAgICAgaGVpZ2h0OiBsaW5rLm9mZnNldEhlaWdodCArIFwicHhcIlxuICAgIH0pO1xuXG4gICAgZG9tLmluc2VydChpbnB1dCkuaW50byh3cmFwcGVyKTtcbiAgICBkb20uaW5zZXJ0KHdyYXBwZXIpLmludG8obGluayk7XG5cbiAgICBkb20uc2V0U3R5bGVzKGlucHV0U3R5bGVzKS5vbihpbnB1dCk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZXMoaW5wdXRBdHRyaWJ1dGVzKS5vbihpbnB1dCk7XG5cbiAgICBkb20uc2V0U3R5bGVzKHdyYXBwZXJTdHlsZXMpLm9uKHdyYXBwZXIpO1xuICAgIGRvbS5zZXRTdHlsZXMobGlua1N0eWxlcykub24obGluayk7XG5cbiAgICB2YXIgZXZlbnROYW1lID0gXCJvbndlYmtpdHNwZWVjaGNoYW5nZVwiIGluIGlucHV0ID8gXCJ3ZWJraXRzcGVlY2hjaGFuZ2VcIiA6IFwic3BlZWNoY2hhbmdlXCI7XG4gICAgZG9tLm9ic2VydmUoaW5wdXQsIGV2ZW50TmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICBwYXJlbnQuZXhlY0NvbW1hbmQoXCJpbnNlcnRUZXh0XCIsIGlucHV0LnZhbHVlKTtcbiAgICAgIGlucHV0LnZhbHVlID0gXCJcIjtcbiAgICB9KTtcblxuICAgIGRvbS5vYnNlcnZlKGlucHV0LCBcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZG9tLmhhc0NsYXNzKGxpbmssIFwid3lzaWh0bWw1LWNvbW1hbmQtZGlzYWJsZWRcIikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuOy8qKlxuICogVG9vbGJhclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUmVmZXJlbmNlIHRvIGluc3RhbmNlIG9mIEVkaXRvciBpbnN0YW5jZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgUmVmZXJlbmNlIHRvIHRoZSB0b29sYmFyIGNvbnRhaW5lciBlbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgIDxkaXYgaWQ9XCJ0b29sYmFyXCI+XG4gKiAgICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJjcmVhdGVMaW5rXCI+aW5zZXJ0IGxpbms8L2E+XG4gKiAgICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJmb3JtYXRCbG9ja1wiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XCJoMVwiPmluc2VydCBoMTwvYT5cbiAqICAgIDwvZGl2PlxuICpcbiAqICAgIDxzY3JpcHQ+XG4gKiAgICAgIHZhciB0b29sYmFyID0gbmV3IHd5c2lodG1sNS50b29sYmFyLlRvb2xiYXIoZWRpdG9yLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRvb2xiYXJcIikpO1xuICogICAgPC9zY3JpcHQ+XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUVfQ09NTUFORF9ESVNBQkxFRCAgID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1kaXNhYmxlZFwiLFxuICAgICAgQ0xBU1NfTkFNRV9DT01NQU5EU19ESVNBQkxFRCAgPSBcInd5c2lodG1sNS1jb21tYW5kcy1kaXNhYmxlZFwiLFxuICAgICAgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSAgICAgPSBcInd5c2lodG1sNS1jb21tYW5kLWFjdGl2ZVwiLFxuICAgICAgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFICAgICAgPSBcInd5c2lodG1sNS1hY3Rpb24tYWN0aXZlXCIsXG4gICAgICBkb20gICAgICAgICAgICAgICAgICAgICAgICAgICA9IHd5c2lodG1sNS5kb207XG5cbiAgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhciA9IEJhc2UuZXh0ZW5kKFxuICAgIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhci5wcm90b3R5cGUgKi8ge1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihlZGl0b3IsIGNvbnRhaW5lciwgc2hvd09uSW5pdCkge1xuICAgICAgdGhpcy5lZGl0b3IgICAgID0gZWRpdG9yO1xuICAgICAgdGhpcy5jb250YWluZXIgID0gdHlwZW9mKGNvbnRhaW5lcikgPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpIDogY29udGFpbmVyO1xuICAgICAgdGhpcy5jb21wb3NlciAgID0gZWRpdG9yLmNvbXBvc2VyO1xuXG4gICAgICB0aGlzLl9nZXRMaW5rcyhcImNvbW1hbmRcIik7XG4gICAgICB0aGlzLl9nZXRMaW5rcyhcImFjdGlvblwiKTtcblxuICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgaWYgKHNob3dPbkluaXQpIHsgdGhpcy5zaG93KCk7IH1cblxuICAgICAgaWYgKGVkaXRvci5jb25maWcuY2xhc3NOYW1lQ29tbWFuZERpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgQ0xBU1NfTkFNRV9DT01NQU5EX0RJU0FCTEVEID0gZWRpdG9yLmNvbmZpZy5jbGFzc05hbWVDb21tYW5kRGlzYWJsZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmNvbmZpZy5jbGFzc05hbWVDb21tYW5kc0Rpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgQ0xBU1NfTkFNRV9DT01NQU5EU19ESVNBQkxFRCA9IGVkaXRvci5jb25maWcuY2xhc3NOYW1lQ29tbWFuZHNEaXNhYmxlZDtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuY29uZmlnLmNsYXNzTmFtZUNvbW1hbmRBY3RpdmUgIT0gbnVsbCkge1xuICAgICAgICBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFID0gZWRpdG9yLmNvbmZpZy5jbGFzc05hbWVDb21tYW5kQWN0aXZlO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5jb25maWcuY2xhc3NOYW1lQWN0aW9uQWN0aXZlICE9IG51bGwpIHtcbiAgICAgICAgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFID0gZWRpdG9yLmNvbmZpZy5jbGFzc05hbWVBY3Rpb25BY3RpdmU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGVlY2hJbnB1dExpbmtzICA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS13eXNpaHRtbDUtY29tbWFuZD1pbnNlcnRTcGVlY2hdXCIpLFxuICAgICAgICAgIGxlbmd0aCAgICAgICAgICAgID0gc3BlZWNoSW5wdXRMaW5rcy5sZW5ndGgsXG4gICAgICAgICAgaSAgICAgICAgICAgICAgICAgPSAwO1xuICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3IHd5c2lodG1sNS50b29sYmFyLlNwZWVjaCh0aGlzLCBzcGVlY2hJbnB1dExpbmtzW2ldKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldExpbmtzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgbGlua3MgICA9IHRoaXNbdHlwZSArIFwiTGlua3NcIl0gPSB3eXNpaHRtbDUubGFuZy5hcnJheSh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSArIFwiXVwiKSkuZ2V0KCksXG4gICAgICAgICAgbGVuZ3RoICA9IGxpbmtzLmxlbmd0aCxcbiAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICBtYXBwaW5nID0gdGhpc1t0eXBlICsgXCJNYXBwaW5nXCJdID0ge30sXG4gICAgICAgICAgbGluayxcbiAgICAgICAgICBncm91cCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRpYWxvZztcbiAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmsgICAgPSBsaW5rc1tpXTtcbiAgICAgICAgbmFtZSAgICA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS13eXNpaHRtbDUtXCIgKyB0eXBlKTtcbiAgICAgICAgdmFsdWUgICA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS13eXNpaHRtbDUtXCIgKyB0eXBlICsgXCItdmFsdWVcIik7XG4gICAgICAgIGdyb3VwICAgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSArIFwiLWdyb3VwPSdcIiArIG5hbWUgKyBcIiddXCIpO1xuICAgICAgICBkaWFsb2cgID0gdGhpcy5fZ2V0RGlhbG9nKGxpbmssIG5hbWUpO1xuXG4gICAgICAgIG1hcHBpbmdbbmFtZSArIFwiOlwiICsgdmFsdWVdID0ge1xuICAgICAgICAgIGxpbms6ICAgbGluayxcbiAgICAgICAgICBncm91cDogIGdyb3VwLFxuICAgICAgICAgIG5hbWU6ICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogIHZhbHVlLFxuICAgICAgICAgIGRpYWxvZzogZGlhbG9nLFxuICAgICAgICAgIHN0YXRlOiAgZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldERpYWxvZzogZnVuY3Rpb24obGluaywgY29tbWFuZCkge1xuICAgICAgdmFyIHRoYXQgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LWRpYWxvZz0nXCIgKyBjb21tYW5kICsgXCInXVwiKSxcbiAgICAgICAgICBkaWFsb2csXG4gICAgICAgICAgY2FyZXRCb29rbWFyaztcblxuICAgICAgaWYgKGRpYWxvZ0VsZW1lbnQpIHtcbiAgICAgICAgaWYgKHd5c2lodG1sNS50b29sYmFyW1wiRGlhbG9nX1wiICsgY29tbWFuZF0pIHtcbiAgICAgICAgICAgIGRpYWxvZyA9IG5ldyB3eXNpaHRtbDUudG9vbGJhcltcIkRpYWxvZ19cIiArIGNvbW1hbmRdKGxpbmssIGRpYWxvZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlhbG9nID0gbmV3IHd5c2lodG1sNS50b29sYmFyLkRpYWxvZyhsaW5rLCBkaWFsb2dFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpYWxvZy5vbihcInNob3dcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FyZXRCb29rbWFyayA9IHRoYXQuY29tcG9zZXIuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG5cbiAgICAgICAgICB0aGF0LmVkaXRvci5maXJlKFwic2hvdzpkaWFsb2dcIiwgeyBjb21tYW5kOiBjb21tYW5kLCBkaWFsb2dDb250YWluZXI6IGRpYWxvZ0VsZW1lbnQsIGNvbW1hbmRMaW5rOiBsaW5rIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkaWFsb2cub24oXCJzYXZlXCIsIGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoY2FyZXRCb29rbWFyaykge1xuICAgICAgICAgICAgdGhhdC5jb21wb3Nlci5zZWxlY3Rpb24uc2V0Qm9va21hcmsoY2FyZXRCb29rbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoYXQuX2V4ZWNDb21tYW5kKGNvbW1hbmQsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgdGhhdC5lZGl0b3IuZmlyZShcInNhdmU6ZGlhbG9nXCIsIHsgY29tbWFuZDogY29tbWFuZCwgZGlhbG9nQ29udGFpbmVyOiBkaWFsb2dFbGVtZW50LCBjb21tYW5kTGluazogbGluayB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlhbG9nLm9uKFwiY2FuY2VsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoYXQuZWRpdG9yLmZvY3VzKGZhbHNlKTtcbiAgICAgICAgICB0aGF0LmVkaXRvci5maXJlKFwiY2FuY2VsOmRpYWxvZ1wiLCB7IGNvbW1hbmQ6IGNvbW1hbmQsIGRpYWxvZ0NvbnRhaW5lcjogZGlhbG9nRWxlbWVudCwgY29tbWFuZExpbms6IGxpbmsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgdG9vbGJhciA9IG5ldyB3eXNpaHRtbDUuVG9vbGJhcigpO1xuICAgICAqICAgIC8vIEluc2VydCBhIDxibG9ja3F1b3RlPiBlbGVtZW50IG9yIHdyYXAgY3VycmVudCBzZWxlY3Rpb24gaW4gPGJsb2NrcXVvdGU+XG4gICAgICogICAgdG9vbGJhci5leGVjQ29tbWFuZChcImZvcm1hdEJsb2NrXCIsIFwiYmxvY2txdW90ZVwiKTtcbiAgICAgKi9cbiAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24oY29tbWFuZCwgY29tbWFuZFZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21tYW5kc0Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbW1hbmRPYmogPSB0aGlzLmNvbW1hbmRNYXBwaW5nW2NvbW1hbmQgKyBcIjpcIiArIGNvbW1hbmRWYWx1ZV07XG5cbiAgICAgIC8vIFNob3cgZGlhbG9nIHdoZW4gYXZhaWxhYmxlXG4gICAgICBpZiAoY29tbWFuZE9iaiAmJiBjb21tYW5kT2JqLmRpYWxvZyAmJiAhY29tbWFuZE9iai5zdGF0ZSkge1xuICAgICAgICBjb21tYW5kT2JqLmRpYWxvZy5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9leGVjQ29tbWFuZChjb21tYW5kLCBjb21tYW5kVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY29tcG9zZXIgaXMgZm9jdXNzZWQgKGZhbHNlID0+IGRvbid0IG1vdmUgY2FyZXQgdG8gdGhlIGVuZClcbiAgICAgIHRoaXMuZWRpdG9yLmZvY3VzKGZhbHNlKTtcblxuICAgICAgdGhpcy5jb21wb3Nlci5jb21tYW5kcy5leGVjKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSk7XG4gICAgICB0aGlzLl91cGRhdGVMaW5rU3RhdGVzKCk7XG4gICAgfSxcblxuICAgIGV4ZWNBY3Rpb246IGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgaWYgKGFjdGlvbiA9PT0gXCJjaGFuZ2Vfdmlld1wiKSB7XG4gICAgICAgIGlmIChlZGl0b3IudGV4dGFyZWEpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuY3VycmVudFZpZXcgPT09IGVkaXRvci50ZXh0YXJlYSkge1xuICAgICAgICAgICAgICBlZGl0b3IuZmlyZShcImNoYW5nZV92aWV3XCIsIFwiY29tcG9zZXJcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3IuZmlyZShcImNoYW5nZV92aWV3XCIsIFwidGV4dGFyZWFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb24gPT0gXCJzaG93U291cmNlXCIpIHtcbiAgICAgICAgICBlZGl0b3IuZmlyZShcInNob3dTb3VyY2VcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9vYnNlcnZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ICAgICAgPSB0aGlzLFxuICAgICAgICAgIGVkaXRvciAgICA9IHRoaXMuZWRpdG9yLFxuICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgIGxpbmtzICAgICA9IHRoaXMuY29tbWFuZExpbmtzLmNvbmNhdCh0aGlzLmFjdGlvbkxpbmtzKSxcbiAgICAgICAgICBsZW5ndGggICAgPSBsaW5rcy5sZW5ndGgsXG4gICAgICAgICAgaSAgICAgICAgID0gMDtcblxuICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gJ2phdmFzY3JpcHQ6OycgYW5kIHVuc2VsZWN0YWJsZT1vbiBOZWVkZWQgZm9yIElFLCBidXQgZG9uZSBpbiBhbGwgYnJvd3NlcnMgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGdldCB0aGUgc2FtZSBjc3MgYXBwbGllZFxuICAgICAgICAvLyAoeW91IGtub3csIGE6bGluayB7IC4uLiB9IGRvZXNuJ3QgbWF0Y2ggYW5jaG9ycyB3aXRoIG1pc3NpbmcgaHJlZiBhdHRyaWJ1dGUpXG4gICAgICAgIGlmIChsaW5rc1tpXS5ub2RlTmFtZSA9PT0gXCJBXCIpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICBocmVmOiAgICAgICAgIFwiamF2YXNjcmlwdDo7XCIsXG4gICAgICAgICAgICB1bnNlbGVjdGFibGU6IFwib25cIlxuICAgICAgICAgIH0pLm9uKGxpbmtzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmlidXRlcyh7IHVuc2VsZWN0YWJsZTogXCJvblwiIH0pLm9uKGxpbmtzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOZWVkZWQgZm9yIG9wZXJhIGFuZCBjaHJvbWVcbiAgICAgIGRvbS5kZWxlZ2F0ZShjb250YWluZXIsIFwiW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmRdLCBbZGF0YS13eXNpaHRtbDUtYWN0aW9uXVwiLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbihldmVudCkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9KTtcblxuICAgICAgZG9tLmRlbGVnYXRlKGNvbnRhaW5lciwgXCJbZGF0YS13eXNpaHRtbDUtY29tbWFuZF1cIiwgXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgbGluayAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21tYW5kICAgICAgID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1jb21tYW5kXCIpLFxuICAgICAgICAgICAgY29tbWFuZFZhbHVlICA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZVwiKTtcbiAgICAgICAgdGhhdC5leGVjQ29tbWFuZChjb21tYW5kLCBjb21tYW5kVmFsdWUpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5kZWxlZ2F0ZShjb250YWluZXIsIFwiW2RhdGEtd3lzaWh0bWw1LWFjdGlvbl1cIiwgXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1hY3Rpb25cIik7XG4gICAgICAgIHRoYXQuZXhlY0FjdGlvbihhY3Rpb24pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGVkaXRvci5vbihcImludGVyYWN0aW9uOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoYXQuX3VwZGF0ZUxpbmtTdGF0ZXMoKTtcbiAgICAgIH0pO1xuXG4gICAgICBlZGl0b3Iub24oXCJmb2N1czpjb21wb3NlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5ib29rbWFyayA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuZWRpdG9yLmNvbmZpZy5oYW5kbGVUYWJsZXMpIHtcbiAgICAgICAgICBlZGl0b3Iub24oXCJ0YWJsZXNlbGVjdDpjb21wb3NlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtd3lzaWh0bWw1LWhpZGRlbnRvb2xzPVwidGFibGVcIl0nKVswXS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlZGl0b3Iub24oXCJ0YWJsZXVuc2VsZWN0OmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS13eXNpaHRtbDUtaGlkZGVudG9vbHM9XCJ0YWJsZVwiXScpWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZWRpdG9yLm9uKFwiY2hhbmdlX3ZpZXdcIiwgZnVuY3Rpb24oY3VycmVudFZpZXcpIHtcbiAgICAgICAgLy8gU2V0IHRpbWVvdXQgbmVlZGVkIGluIG9yZGVyIHRvIGxldCB0aGUgYmx1ciBldmVudCBmaXJlIGZpcnN0XG4gICAgICAgIGlmIChlZGl0b3IudGV4dGFyZWEpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRoYXQuY29tbWFuZHNEaXNhYmxlZCA9IChjdXJyZW50VmlldyAhPT0gXCJjb21wb3NlclwiKTtcbiAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlTGlua1N0YXRlcygpO1xuICAgICAgICAgICAgICBpZiAodGhhdC5jb21tYW5kc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKGNvbnRhaW5lciwgQ0xBU1NfTkFNRV9DT01NQU5EU19ESVNBQkxFRCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgQ0xBU1NfTkFNRV9DT01NQU5EU19ESVNBQkxFRCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUxpbmtTdGF0ZXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgY29tbWFuZE1hcHBpbmcgICAgPSB0aGlzLmNvbW1hbmRNYXBwaW5nLFxuICAgICAgICAgIGFjdGlvbk1hcHBpbmcgICAgID0gdGhpcy5hY3Rpb25NYXBwaW5nLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGNvbW1hbmQ7XG4gICAgICAvLyBldmVyeSBtaWxsaXNlY29uZCBjb3VudHMuLi4gdGhpcyBpcyBleGVjdXRlZCBxdWl0ZSBvZnRlblxuICAgICAgZm9yIChpIGluIGNvbW1hbmRNYXBwaW5nKSB7XG4gICAgICAgIGNvbW1hbmQgPSBjb21tYW5kTWFwcGluZ1tpXTtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZHNEaXNhYmxlZCkge1xuICAgICAgICAgIHN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZGlhbG9nKSB7XG4gICAgICAgICAgICBjb21tYW5kLmRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gdGhpcy5jb21wb3Nlci5jb21tYW5kcy5zdGF0ZShjb21tYW5kLm5hbWUsIGNvbW1hbmQudmFsdWUpO1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmxpbmssIENMQVNTX05BTUVfQ09NTUFORF9ESVNBQkxFRCk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5zdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1hbmQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZGlhbG9nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHN0YXRlKSA9PT0gXCJvYmplY3RcIiB8fCB3eXNpaHRtbDUubGFuZy5vYmplY3Qoc3RhdGUpLmlzQXJyYXkoKSkge1xuXG4gICAgICAgICAgICAgIGlmICghY29tbWFuZC5kaWFsb2cubXVsdGlzZWxlY3QgJiYgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHN0YXRlKS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBHcmFiIGZpcnN0IGFuZCBvbmx5IG9iamVjdC9lbGVtZW50IGluIHN0YXRlIGFycmF5LCBvdGhlcndpc2UgY29udmVydCBzdGF0ZSBpbnRvIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBzaG93aW5nIGEgZGlhbG9nIGZvciBtdWx0aXBsZSBzZWxlY3RlZCBlbGVtZW50cyB3aGljaCBtYXkgaGF2ZSBkaWZmZXJlbnQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIGVnLiB3aGVuIHR3byBsaW5rcyB3aXRoIGRpZmZlcmVudCBocmVmIGFyZSBzZWxlY3RlZCwgdGhlIHN0YXRlIHdpbGwgYmUgYW4gYXJyYXkgY29uc2lzdGluZyBvZiBib3RoIGxpbmsgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhlIGRpYWxvZyBpbnRlcmZhY2UgY2FuIG9ubHkgdXBkYXRlIG9uZVxuICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGUubGVuZ3RoID09PSAxID8gc3RhdGVbMF0gOiB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21tYW5kLmRpYWxvZy5zaG93KHN0YXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbW1hbmQuZGlhbG9nLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZGlhbG9nKSB7XG4gICAgICAgICAgICBjb21tYW5kLmRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSBpbiBhY3Rpb25NYXBwaW5nKSB7XG4gICAgICAgIGFjdGlvbiA9IGFjdGlvbk1hcHBpbmdbaV07XG5cbiAgICAgICAgaWYgKGFjdGlvbi5uYW1lID09PSBcImNoYW5nZV92aWV3XCIpIHtcbiAgICAgICAgICBhY3Rpb24uc3RhdGUgPSB0aGlzLmVkaXRvci5jdXJyZW50VmlldyA9PT0gdGhpcy5lZGl0b3IudGV4dGFyZWE7XG4gICAgICAgICAgaWYgKGFjdGlvbi5zdGF0ZSkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGFjdGlvbi5saW5rLCBDTEFTU19OQU1FX0FDVElPTl9BQ1RJVkUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoYWN0aW9uLmxpbmssIENMQVNTX05BTUVfQUNUSU9OX0FDVElWRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgfSk7XG5cbn0pKHd5c2lodG1sNSk7XG47KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICAgIHd5c2lodG1sNS50b29sYmFyLkRpYWxvZ19jcmVhdGVUYWJsZSA9IHd5c2lodG1sNS50b29sYmFyLkRpYWxvZy5leHRlbmQoe1xuICAgICAgICBzaG93OiBmdW5jdGlvbihlbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZShlbGVtZW50VG9DaGFuZ2UpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xufSkod3lzaWh0bWw1KTtcbjsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gICAgICAgICAgICAgICAgICAgICA9IHd5c2lodG1sNS5kb20sXG4gICAgICBTRUxFQ1RPUl9GSUVMRFMgICAgICAgICA9IFwiW2RhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZF1cIixcbiAgICAgIEFUVFJJQlVURV9GSUVMRFMgICAgICAgID0gXCJkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGRcIjtcblxuICB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2dfZm9yZUNvbG9yU3R5bGUgPSB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2cuZXh0ZW5kKHtcbiAgICBtdWx0aXNlbGVjdDogdHJ1ZSxcblxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEgICAgPSB7fSxcbiAgICAgICAgICBmaWVsZHMgID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9GSUVMRFMpLFxuICAgICAgICAgIGxlbmd0aCAgPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgICAgIGkgICAgICAgPSAwO1xuXG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ZpZWxkc1tpXS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0ZJRUxEUyldID0gZmllbGRzW2ldLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIF9pbnRlcnBvbGF0ZTogZnVuY3Rpb24oYXZvaWRIaWRkZW5GaWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZCxcbiAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpLFxuICAgICAgICAgIGZpZWxkcyAgICAgICAgID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9GSUVMRFMpLFxuICAgICAgICAgIGxlbmd0aCAgICAgICAgID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBpICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgZmlyc3RFbGVtZW50ICAgPSAodGhpcy5lbGVtZW50VG9DaGFuZ2UpID8gKCh3eXNpaHRtbDUubGFuZy5vYmplY3QodGhpcy5lbGVtZW50VG9DaGFuZ2UpLmlzQXJyYXkoKSkgPyB0aGlzLmVsZW1lbnRUb0NoYW5nZVswXSA6IHRoaXMuZWxlbWVudFRvQ2hhbmdlKSA6IG51bGwsXG4gICAgICAgICAgY29sb3JTdHIgICAgICAgPSAoZmlyc3RFbGVtZW50KSA/IGZpcnN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgOiBudWxsLFxuICAgICAgICAgIGNvbG9yICAgICAgICAgID0gKGNvbG9yU3RyKSA/IHd5c2lodG1sNS5xdWlya3Muc3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb2xvclN0ciwgXCJjb2xvclwiKSA6IG51bGw7XG5cbiAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAvLyBOZXZlciBjaGFuZ2UgZWxlbWVudHMgd2hlcmUgdGhlIHVzZXIgaXMgY3VycmVudGx5IHR5cGluZyBpblxuICAgICAgICBpZiAoZmllbGQgPT09IGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIGhpZGRlbiBmaWVsZHMzXG4gICAgICAgIGlmIChhdm9pZEhpZGRlbkZpZWxkcyAmJiBmaWVsZC50eXBlID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfRklFTERTKSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JbM10gJiYgY29sb3JbM10gIT0gMSkge1xuICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IFwicmdiYShcIiArIGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiLFwiICsgY29sb3JbMl0gKyBcIixcIiArIGNvbG9yWzNdICsgXCIpO1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSBcInJnYihcIiArIGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiLFwiICsgY29sb3JbMl0gKyBcIik7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gXCJyZ2IoMCwwLDApO1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG47KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgZG9tICAgICAgICAgICAgICAgICAgICAgPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgU0VMRUNUT1JfRklFTERTICAgICAgICAgPSBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGRdXCIsXG4gICAgICBBVFRSSUJVVEVfRklFTERTICAgICAgICA9IFwiZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkXCI7XG5cbiAgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nX2ZvbnRTaXplU3R5bGUgPSB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2cuZXh0ZW5kKHtcbiAgICBtdWx0aXNlbGVjdDogdHJ1ZSxcblxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcInNpemVcIiA6IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJzaXplXCJdJykudmFsdWV9O1xuICAgIH0sXG5cbiAgICBfaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGF2b2lkSGlkZGVuRmllbGRzKSB7XG4gICAgICB2YXIgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpLFxuICAgICAgICAgIGZpZWxkICAgICAgICAgID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9J3NpemUnXVwiKSxcbiAgICAgICAgICBmaXJzdEVsZW1lbnQgICA9ICh0aGlzLmVsZW1lbnRUb0NoYW5nZSkgPyAoKHd5c2lodG1sNS5sYW5nLm9iamVjdCh0aGlzLmVsZW1lbnRUb0NoYW5nZSkuaXNBcnJheSgpKSA/IHRoaXMuZWxlbWVudFRvQ2hhbmdlWzBdIDogdGhpcy5lbGVtZW50VG9DaGFuZ2UpIDogbnVsbCxcbiAgICAgICAgICBzdHlsZVN0ciAgICAgICA9IChmaXJzdEVsZW1lbnQpID8gZmlyc3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA6IG51bGwsXG4gICAgICAgICAgc2l6ZSAgICAgICAgICAgPSAoc3R5bGVTdHIpID8gd3lzaWh0bWw1LnF1aXJrcy5zdHlsZVBhcnNlci5wYXJzZUZvbnRTaXplKHN0eWxlU3RyKSA6IG51bGw7XG5cbiAgICAgIGlmIChmaWVsZCAmJiBmaWVsZCAhPT0gZm9jdXNlZEVsZW1lbnQgJiYgc2l6ZSAmJiAhKC9eXFxzKiQvKS50ZXN0KHNpemUpKSB7XG4gICAgICAgIGZpZWxkLnZhbHVlID0gc2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyohXG5cbiBoYW5kbGViYXJzIHYxLjMuMFxuXG5Db3B5cmlnaHQgKEMpIDIwMTEgYnkgWWVodWRhIEthdHpcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG5AbGljZW5zZVxuKi9cbnZhciBIYW5kbGViYXJzPWZ1bmN0aW9uKCl7dmFyIGE9ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBhKGEpe3RoaXMuc3RyaW5nPWF9dmFyIGI7cmV0dXJuIGEucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJcIit0aGlzLnN0cmluZ30sYj1hfSgpLGI9ZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhKXtyZXR1cm4gaFthXXx8XCImYW1wO1wifWZ1bmN0aW9uIGMoYSxiKXtmb3IodmFyIGMgaW4gYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixjKSYmKGFbY109YltjXSl9ZnVuY3Rpb24gZChhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIGc/YS50b1N0cmluZygpOmF8fDA9PT1hPyhhPVwiXCIrYSxqLnRlc3QoYSk/YS5yZXBsYWNlKGksYik6YSk6XCJcIn1mdW5jdGlvbiBlKGEpe3JldHVybiBhfHwwPT09YT9tKGEpJiYwPT09YS5sZW5ndGg/ITA6ITE6ITB9dmFyIGY9e30sZz1hLGg9e1wiJlwiOlwiJmFtcDtcIixcIjxcIjpcIiZsdDtcIixcIj5cIjpcIiZndDtcIiwnXCInOlwiJnF1b3Q7XCIsXCInXCI6XCImI3gyNztcIixcImBcIjpcIiYjeDYwO1wifSxpPS9bJjw+XCInYF0vZyxqPS9bJjw+XCInYF0vO2YuZXh0ZW5kPWM7dmFyIGs9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmLnRvU3RyaW5nPWs7dmFyIGw9ZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYX07bCgveC8pJiYobD1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiZcIltvYmplY3QgRnVuY3Rpb25dXCI9PT1rLmNhbGwoYSl9KTt2YXIgbDtmLmlzRnVuY3Rpb249bDt2YXIgbT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm4gYSYmXCJvYmplY3RcIj09dHlwZW9mIGE/XCJbb2JqZWN0IEFycmF5XVwiPT09ay5jYWxsKGEpOiExfTtyZXR1cm4gZi5pc0FycmF5PW0sZi5lc2NhcGVFeHByZXNzaW9uPWQsZi5pc0VtcHR5PWUsZn0oYSksYz1mdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGEoYSxiKXt2YXIgZDtiJiZiLmZpcnN0TGluZSYmKGQ9Yi5maXJzdExpbmUsYSs9XCIgLSBcIitkK1wiOlwiK2IuZmlyc3RDb2x1bW4pO2Zvcih2YXIgZT1FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLGEpLGY9MDtmPGMubGVuZ3RoO2YrKyl0aGlzW2NbZl1dPWVbY1tmXV07ZCYmKHRoaXMubGluZU51bWJlcj1kLHRoaXMuY29sdW1uPWIuZmlyc3RDb2x1bW4pfXZhciBiLGM9W1wiZGVzY3JpcHRpb25cIixcImZpbGVOYW1lXCIsXCJsaW5lTnVtYmVyXCIsXCJtZXNzYWdlXCIsXCJuYW1lXCIsXCJudW1iZXJcIixcInN0YWNrXCJdO3JldHVybiBhLnByb3RvdHlwZT1uZXcgRXJyb3IsYj1hfSgpLGQ9ZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjKGEsYil7dGhpcy5oZWxwZXJzPWF8fHt9LHRoaXMucGFydGlhbHM9Ynx8e30sZCh0aGlzKX1mdW5jdGlvbiBkKGEpe2EucmVnaXN0ZXJIZWxwZXIoXCJoZWxwZXJNaXNzaW5nXCIsZnVuY3Rpb24oYSl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHZvaWQgMDt0aHJvdyBuZXcgaChcIk1pc3NpbmcgaGVscGVyOiAnXCIrYStcIidcIil9KSxhLnJlZ2lzdGVySGVscGVyKFwiYmxvY2tIZWxwZXJNaXNzaW5nXCIsZnVuY3Rpb24oYixjKXt2YXIgZD1jLmludmVyc2V8fGZ1bmN0aW9uKCl7fSxlPWMuZm47cmV0dXJuIG0oYikmJihiPWIuY2FsbCh0aGlzKSksYj09PSEwP2UodGhpcyk6Yj09PSExfHxudWxsPT1iP2QodGhpcyk6bChiKT9iLmxlbmd0aD4wP2EuaGVscGVycy5lYWNoKGIsYyk6ZCh0aGlzKTplKGIpfSksYS5yZWdpc3RlckhlbHBlcihcImVhY2hcIixmdW5jdGlvbihhLGIpe3ZhciBjLGQ9Yi5mbixlPWIuaW52ZXJzZSxmPTAsZz1cIlwiO2lmKG0oYSkmJihhPWEuY2FsbCh0aGlzKSksYi5kYXRhJiYoYz1xKGIuZGF0YSkpLGEmJlwib2JqZWN0XCI9PXR5cGVvZiBhKWlmKGwoYSkpZm9yKHZhciBoPWEubGVuZ3RoO2g+ZjtmKyspYyYmKGMuaW5kZXg9ZixjLmZpcnN0PTA9PT1mLGMubGFzdD1mPT09YS5sZW5ndGgtMSksZys9ZChhW2ZdLHtkYXRhOmN9KTtlbHNlIGZvcih2YXIgaSBpbiBhKWEuaGFzT3duUHJvcGVydHkoaSkmJihjJiYoYy5rZXk9aSxjLmluZGV4PWYsYy5maXJzdD0wPT09ZiksZys9ZChhW2ldLHtkYXRhOmN9KSxmKyspO3JldHVybiAwPT09ZiYmKGc9ZSh0aGlzKSksZ30pLGEucmVnaXN0ZXJIZWxwZXIoXCJpZlwiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIG0oYSkmJihhPWEuY2FsbCh0aGlzKSksIWIuaGFzaC5pbmNsdWRlWmVybyYmIWF8fGcuaXNFbXB0eShhKT9iLmludmVyc2UodGhpcyk6Yi5mbih0aGlzKX0pLGEucmVnaXN0ZXJIZWxwZXIoXCJ1bmxlc3NcIixmdW5jdGlvbihiLGMpe3JldHVybiBhLmhlbHBlcnNbXCJpZlwiXS5jYWxsKHRoaXMsYix7Zm46Yy5pbnZlcnNlLGludmVyc2U6Yy5mbixoYXNoOmMuaGFzaH0pfSksYS5yZWdpc3RlckhlbHBlcihcIndpdGhcIixmdW5jdGlvbihhLGIpe3JldHVybiBtKGEpJiYoYT1hLmNhbGwodGhpcykpLGcuaXNFbXB0eShhKT92b2lkIDA6Yi5mbihhKX0pLGEucmVnaXN0ZXJIZWxwZXIoXCJsb2dcIixmdW5jdGlvbihiLGMpe3ZhciBkPWMuZGF0YSYmbnVsbCE9Yy5kYXRhLmxldmVsP3BhcnNlSW50KGMuZGF0YS5sZXZlbCwxMCk6MTthLmxvZyhkLGIpfSl9ZnVuY3Rpb24gZShhLGIpe3AubG9nKGEsYil9dmFyIGY9e30sZz1hLGg9YixpPVwiMS4zLjBcIjtmLlZFUlNJT049aTt2YXIgaj00O2YuQ09NUElMRVJfUkVWSVNJT049ajt2YXIgaz17MTpcIjw9IDEuMC5yYy4yXCIsMjpcIj09IDEuMC4wLXJjLjNcIiwzOlwiPT0gMS4wLjAtcmMuNFwiLDQ6XCI+PSAxLjAuMFwifTtmLlJFVklTSU9OX0NIQU5HRVM9azt2YXIgbD1nLmlzQXJyYXksbT1nLmlzRnVuY3Rpb24sbj1nLnRvU3RyaW5nLG89XCJbb2JqZWN0IE9iamVjdF1cIjtmLkhhbmRsZWJhcnNFbnZpcm9ubWVudD1jLGMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpjLGxvZ2dlcjpwLGxvZzplLHJlZ2lzdGVySGVscGVyOmZ1bmN0aW9uKGEsYixjKXtpZihuLmNhbGwoYSk9PT1vKXtpZihjfHxiKXRocm93IG5ldyBoKFwiQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzXCIpO2cuZXh0ZW5kKHRoaXMuaGVscGVycyxhKX1lbHNlIGMmJihiLm5vdD1jKSx0aGlzLmhlbHBlcnNbYV09Yn0scmVnaXN0ZXJQYXJ0aWFsOmZ1bmN0aW9uKGEsYil7bi5jYWxsKGEpPT09bz9nLmV4dGVuZCh0aGlzLnBhcnRpYWxzLGEpOnRoaXMucGFydGlhbHNbYV09Yn19O3ZhciBwPXttZXRob2RNYXA6ezA6XCJkZWJ1Z1wiLDE6XCJpbmZvXCIsMjpcIndhcm5cIiwzOlwiZXJyb3JcIn0sREVCVUc6MCxJTkZPOjEsV0FSTjoyLEVSUk9SOjMsbGV2ZWw6Myxsb2c6ZnVuY3Rpb24oYSxiKXtpZihwLmxldmVsPD1hKXt2YXIgYz1wLm1ldGhvZE1hcFthXTtcInVuZGVmaW5lZFwiIT10eXBlb2YgY29uc29sZSYmY29uc29sZVtjXSYmY29uc29sZVtjXS5jYWxsKGNvbnNvbGUsYil9fX07Zi5sb2dnZXI9cCxmLmxvZz1lO3ZhciBxPWZ1bmN0aW9uKGEpe3ZhciBiPXt9O3JldHVybiBnLmV4dGVuZChiLGEpLGJ9O3JldHVybiBmLmNyZWF0ZUZyYW1lPXEsZn0oYixjKSxlPWZ1bmN0aW9uKGEsYixjKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBkKGEpe3ZhciBiPWEmJmFbMF18fDEsYz1tO2lmKGIhPT1jKXtpZihjPmIpe3ZhciBkPW5bY10sZT1uW2JdO3Rocm93IG5ldyBsKFwiVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYW4gb2xkZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoXCIrZCtcIikgb3IgZG93bmdyYWRlIHlvdXIgcnVudGltZSB0byBhbiBvbGRlciB2ZXJzaW9uIChcIitlK1wiKS5cIil9dGhyb3cgbmV3IGwoXCJUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuIFBsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoXCIrYVsxXStcIikuXCIpfX1mdW5jdGlvbiBlKGEsYil7aWYoIWIpdGhyb3cgbmV3IGwoXCJObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGVcIik7dmFyIGM9ZnVuY3Rpb24oYSxjLGQsZSxmLGcpe3ZhciBoPWIuVk0uaW52b2tlUGFydGlhbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbCE9aClyZXR1cm4gaDtpZihiLmNvbXBpbGUpe3ZhciBpPXtoZWxwZXJzOmUscGFydGlhbHM6ZixkYXRhOmd9O3JldHVybiBmW2NdPWIuY29tcGlsZShhLHtkYXRhOnZvaWQgMCE9PWd9LGIpLGZbY10oZCxpKX10aHJvdyBuZXcgbChcIlRoZSBwYXJ0aWFsIFwiK2MrXCIgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZVwiKX0sZD17ZXNjYXBlRXhwcmVzc2lvbjprLmVzY2FwZUV4cHJlc3Npb24saW52b2tlUGFydGlhbDpjLHByb2dyYW1zOltdLHByb2dyYW06ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMucHJvZ3JhbXNbYV07cmV0dXJuIGM/ZD1nKGEsYixjKTpkfHwoZD10aGlzLnByb2dyYW1zW2FdPWcoYSxiKSksZH0sbWVyZ2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hfHxiO3JldHVybiBhJiZiJiZhIT09YiYmKGM9e30say5leHRlbmQoYyxiKSxrLmV4dGVuZChjLGEpKSxjfSxwcm9ncmFtV2l0aERlcHRoOmIuVk0ucHJvZ3JhbVdpdGhEZXB0aCxub29wOmIuVk0ubm9vcCxjb21waWxlckluZm86bnVsbH07cmV0dXJuIGZ1bmN0aW9uKGMsZSl7ZT1lfHx7fTt2YXIgZixnLGg9ZS5wYXJ0aWFsP2U6YjtlLnBhcnRpYWx8fChmPWUuaGVscGVycyxnPWUucGFydGlhbHMpO3ZhciBpPWEuY2FsbChkLGgsYyxmLGcsZS5kYXRhKTtyZXR1cm4gZS5wYXJ0aWFsfHxiLlZNLmNoZWNrUmV2aXNpb24oZC5jb21waWxlckluZm8pLGl9fWZ1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKSxlPWZ1bmN0aW9uKGEsZSl7cmV0dXJuIGU9ZXx8e30sYi5hcHBseSh0aGlzLFthLGUuZGF0YXx8Y10uY29uY2F0KGQpKX07cmV0dXJuIGUucHJvZ3JhbT1hLGUuZGVwdGg9ZC5sZW5ndGgsZX1mdW5jdGlvbiBnKGEsYixjKXt2YXIgZD1mdW5jdGlvbihhLGQpe3JldHVybiBkPWR8fHt9LGIoYSxkLmRhdGF8fGMpfTtyZXR1cm4gZC5wcm9ncmFtPWEsZC5kZXB0aD0wLGR9ZnVuY3Rpb24gaChhLGIsYyxkLGUsZil7dmFyIGc9e3BhcnRpYWw6ITAsaGVscGVyczpkLHBhcnRpYWxzOmUsZGF0YTpmfTtpZih2b2lkIDA9PT1hKXRocm93IG5ldyBsKFwiVGhlIHBhcnRpYWwgXCIrYitcIiBjb3VsZCBub3QgYmUgZm91bmRcIik7cmV0dXJuIGEgaW5zdGFuY2VvZiBGdW5jdGlvbj9hKGMsZyk6dm9pZCAwfWZ1bmN0aW9uIGkoKXtyZXR1cm5cIlwifXZhciBqPXt9LGs9YSxsPWIsbT1jLkNPTVBJTEVSX1JFVklTSU9OLG49Yy5SRVZJU0lPTl9DSEFOR0VTO3JldHVybiBqLmNoZWNrUmV2aXNpb249ZCxqLnRlbXBsYXRlPWUsai5wcm9ncmFtV2l0aERlcHRoPWYsai5wcm9ncmFtPWcsai5pbnZva2VQYXJ0aWFsPWgsai5ub29wPWksan0oYixjLGQpLGY9ZnVuY3Rpb24oYSxiLGMsZCxlKXtcInVzZSBzdHJpY3RcIjt2YXIgZixnPWEsaD1iLGk9YyxqPWQsaz1lLGw9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgZy5IYW5kbGViYXJzRW52aXJvbm1lbnQ7cmV0dXJuIGouZXh0ZW5kKGEsZyksYS5TYWZlU3RyaW5nPWgsYS5FeGNlcHRpb249aSxhLlV0aWxzPWosYS5WTT1rLGEudGVtcGxhdGU9ZnVuY3Rpb24oYil7cmV0dXJuIGsudGVtcGxhdGUoYixhKX0sYX0sbT1sKCk7cmV0dXJuIG0uY3JlYXRlPWwsZj1tfShkLGEsYyxiLGUpO3JldHVybiBmfSgpO3RoaXNbXCJ3eXNpaHRtbDVcIl0gPSB0aGlzW1wid3lzaWh0bWw1XCJdIHx8IHt9O1xudGhpc1tcInd5c2lodG1sNVwiXVtcInRwbFwiXSA9IHRoaXNbXCJ3eXNpaHRtbDVcIl1bXCJ0cGxcIl0gfHwge307XG5cbnRoaXNbXCJ3eXNpaHRtbDVcIl1bXCJ0cGxcIl1bXCJibG9ja3F1b3RlXCJdID0gSGFuZGxlYmFycy50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcImJ0bi1cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIiBcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtcXVvdGUtbGVmdFxcXCI+PC9zcGFuPlxcbiAgICBcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXF1b3RlXFxcIj48L3NwYW4+XFxuICAgIFwiO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPGxpPlxcbiAgPGEgY2xhc3M9XFxcImJ0biBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNpemUpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiIGJ0bi1kZWZhdWx0XFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JtYXRCbG9ja1xcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiYmxvY2txdW90ZVxcXCIgZGF0YS13eXNpaHRtbDUtZGlzcGxheS1mb3JtYXQtbmFtZT1cXFwiZmFsc2VcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuZmEpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYucHJvZ3JhbSg1LCBwcm9ncmFtNSwgZGF0YSksZm46c2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgPC9hPlxcbjwvbGk+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pO1xuXG50aGlzW1wid3lzaWh0bWw1XCJdW1widHBsXCJdW1wiY29sb3JcIl0gPSBIYW5kbGViYXJzLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwiYnRuLVwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNpemUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPGxpIGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICA8YSBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGRyb3Bkb3duLXRvZ2dsZSBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNpemUpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxcIiBkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJjdXJyZW50LWNvbG9yXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmNvbG91cnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmJsYWNrKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCI8L3NwYW4+XFxuICAgIDxiIGNsYXNzPVxcXCJjYXJldFxcXCI+PC9iPlxcbiAgPC9hPlxcbiAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIj5cXG4gICAgPGxpPjxkaXYgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnNcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImJsYWNrXFxcIj48L2Rpdj48YSBjbGFzcz1cXFwid3lzaWh0bWw1LWNvbG9ycy10aXRsZVxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cXFwiZm9yZUNvbG9yXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJibGFja1xcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jb2xvdXJzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5ibGFjaykpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPjwvbGk+XFxuICAgIDxsaT48ZGl2IGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJzaWx2ZXJcXFwiPjwvZGl2PjxhIGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzLXRpdGxlXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JlQ29sb3JcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcInNpbHZlclxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jb2xvdXJzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaWx2ZXIpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT48L2xpPlxcbiAgICA8bGk+PGRpdiBjbGFzcz1cXFwid3lzaWh0bWw1LWNvbG9yc1xcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiZ3JheVxcXCI+PC9kaXY+PGEgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnMtdGl0bGVcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImZvcmVDb2xvclxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiZ3JheVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jb2xvdXJzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5ncmF5KSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCI8L2E+PC9saT5cXG4gICAgPGxpPjxkaXYgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnNcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcIm1hcm9vblxcXCI+PC9kaXY+PGEgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnMtdGl0bGVcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImZvcmVDb2xvclxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwibWFyb29uXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmNvbG91cnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLm1hcm9vbikpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPjwvbGk+XFxuICAgIDxsaT48ZGl2IGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJyZWRcXFwiPjwvZGl2PjxhIGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzLXRpdGxlXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JlQ29sb3JcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcInJlZFxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jb2xvdXJzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5yZWQpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT48L2xpPlxcbiAgICA8bGk+PGRpdiBjbGFzcz1cXFwid3lzaWh0bWw1LWNvbG9yc1xcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwicHVycGxlXFxcIj48L2Rpdj48YSBjbGFzcz1cXFwid3lzaWh0bWw1LWNvbG9ycy10aXRsZVxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cXFwiZm9yZUNvbG9yXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJwdXJwbGVcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuY29sb3VycykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEucHVycGxlKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCI8L2E+PC9saT5cXG4gICAgPGxpPjxkaXYgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnNcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImdyZWVuXFxcIj48L2Rpdj48YSBjbGFzcz1cXFwid3lzaWh0bWw1LWNvbG9ycy10aXRsZVxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cXFwiZm9yZUNvbG9yXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJncmVlblxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jb2xvdXJzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5ncmVlbikpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPjwvbGk+XFxuICAgIDxsaT48ZGl2IGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJvbGl2ZVxcXCI+PC9kaXY+PGEgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnMtdGl0bGVcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImZvcmVDb2xvclxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwib2xpdmVcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuY29sb3VycykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEub2xpdmUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT48L2xpPlxcbiAgICA8bGk+PGRpdiBjbGFzcz1cXFwid3lzaWh0bWw1LWNvbG9yc1xcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwibmF2eVxcXCI+PC9kaXY+PGEgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnMtdGl0bGVcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImZvcmVDb2xvclxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwibmF2eVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jb2xvdXJzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYXZ5KSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCI8L2E+PC9saT5cXG4gICAgPGxpPjxkaXYgY2xhc3M9XFxcInd5c2lodG1sNS1jb2xvcnNcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImJsdWVcXFwiPjwvZGl2PjxhIGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzLXRpdGxlXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JlQ29sb3JcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImJsdWVcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuY29sb3VycykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuYmx1ZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPjwvbGk+XFxuICAgIDxsaT48ZGl2IGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJvcmFuZ2VcXFwiPjwvZGl2PjxhIGNsYXNzPVxcXCJ3eXNpaHRtbDUtY29sb3JzLXRpdGxlXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JlQ29sb3JcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcIm9yYW5nZVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jb2xvdXJzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5vcmFuZ2UpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT48L2xpPlxcbiAgPC91bD5cXG48L2xpPlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcblxudGhpc1tcInd5c2lodG1sNVwiXVtcInRwbFwiXVtcImVtcGhhc2lzXCJdID0gSGFuZGxlYmFycy50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcImJ0bi1cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwiXFxuICAgIDxhIGNsYXNzPVxcXCJidG4gXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIiBidG4tZGVmYXVsdFxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cXFwic21hbGxcXFwiIHRpdGxlPVxcXCJDVFJMK1NcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5lbXBoYXNpcykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc21hbGwpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT5cXG4gICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuICBidWZmZXIgKz0gXCI8bGk+XFxuICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXBcXFwiPlxcbiAgICA8YSBjbGFzcz1cXFwiYnRuIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc2l6ZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCIgYnRuLWRlZmF1bHRcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImJvbGRcXFwiIHRpdGxlPVxcXCJDVFJMK0JcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5lbXBoYXNpcykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuYm9sZCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiYnRuIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc2l6ZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCIgYnRuLWRlZmF1bHRcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcIml0YWxpY1xcXCIgdGl0bGU9XFxcIkNUUkwrSVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmVtcGhhc2lzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pdGFsaWMpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT5cXG4gICAgPGEgY2xhc3M9XFxcImJ0biBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNpemUpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiIGJ0bi1kZWZhdWx0XFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJ1bmRlcmxpbmVcXFwiIHRpdGxlPVxcXCJDVFJMK1VcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5lbXBoYXNpcykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudW5kZXJsaW5lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCI8L2E+XFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5lbXBoYXNpcykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc21hbGwpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICA8L2Rpdj5cXG48L2xpPlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcblxudGhpc1tcInd5c2lodG1sNVwiXVtcInRwbFwiXVtcImZvbnQtc3R5bGVzXCJdID0gSGFuZGxlYmFycy50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcImJ0bi1cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1mb250XFxcIj48L3NwYW4+XFxuICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW01KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZm9udFxcXCI+PC9zcGFuPlxcbiAgICBcIjtcbiAgfVxuXG4gIGJ1ZmZlciArPSBcIjxsaSBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgPGEgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBkcm9wZG93bi10b2dnbGUgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5mYSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5wcm9ncmFtKDUsIHByb2dyYW01LCBkYXRhKSxmbjpzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgIDxzcGFuIGNsYXNzPVxcXCJjdXJyZW50LWZvbnRcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuZm9udF9zdHlsZXMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLm5vcm1hbCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9zcGFuPlxcbiAgICA8YiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvYj5cXG4gIDwvYT5cXG4gIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCI+XFxuICAgIDxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JtYXRCbG9ja1xcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwicFxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmZvbnRfc3R5bGVzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5ub3JtYWwpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT48L2xpPlxcbiAgICA8bGk+PGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cXFwiZm9ybWF0QmxvY2tcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImgxXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuZm9udF9zdHlsZXMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmgxKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCI8L2E+PC9saT5cXG4gICAgPGxpPjxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImZvcm1hdEJsb2NrXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJoMlxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmZvbnRfc3R5bGVzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5oMikpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPjwvbGk+XFxuICAgIDxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JtYXRCbG9ja1xcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiaDNcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5mb250X3N0eWxlcykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaDMpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT48L2xpPlxcbiAgICA8bGk+PGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cXFwiZm9ybWF0QmxvY2tcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImg0XFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuZm9udF9zdHlsZXMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmg0KSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCI8L2E+PC9saT5cXG4gICAgPGxpPjxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImZvcm1hdEJsb2NrXFxcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJoNVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmZvbnRfc3R5bGVzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5oNSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPjwvbGk+XFxuICAgIDxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVxcXCJmb3JtYXRCbG9ja1xcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiaDZcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5mb250X3N0eWxlcykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaDYpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT48L2xpPlxcbiAgPC91bD5cXG48L2xpPlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcblxudGhpc1tcInd5c2lodG1sNVwiXVtcInRwbFwiXVtcImh0bWxcIl0gPSBIYW5kbGViYXJzLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwiYnRuLVwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNpemUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0zKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtcGVuY2lsXFxcIj48L3NwYW4+XFxuICAgICAgXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXBlbmNpbFxcXCI+PC9zcGFuPlxcbiAgICAgIFwiO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPGxpPlxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwXFxcIj5cXG4gICAgPGEgY2xhc3M9XFxcImJ0biBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNpemUpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiIGJ0bi1kZWZhdWx0XFxcIiBkYXRhLXd5c2lodG1sNS1hY3Rpb249XFxcImNoYW5nZV92aWV3XFxcIiB0aXRsZT1cXFwiXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5odG1sKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5lZGl0KSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5mYSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5wcm9ncmFtKDUsIHByb2dyYW01LCBkYXRhKSxmbjpzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgIDwvYT5cXG4gIDwvZGl2PlxcbjwvbGk+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pO1xuXG50aGlzW1wid3lzaWh0bWw1XCJdW1widHBsXCJdW1wiaW1hZ2VcIl0gPSBIYW5kbGViYXJzLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIm1vZGFsLXNtXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcImJ0bi1cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1maWxlLWltYWdlLW9cXFwiPjwvc3Bhbj5cXG4gICAgXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1waWN0dXJlXFxcIj48L3NwYW4+XFxuICAgIFwiO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPGxpPlxcbiAgPGRpdiBjbGFzcz1cXFwiYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtbW9kYWwgbW9kYWwgZmFkZVxcXCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nPVxcXCJpbnNlcnRJbWFnZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZyBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNtYWxsbW9kYWxzKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPiZ0aW1lczs8L2E+XFxuICAgICAgICAgIDxoMz5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pbnNlcnQpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvaDM+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9XFxcImh0dHA6Ly9cXFwiIGNsYXNzPVxcXCJib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS11cmwgZm9ybS1jb250cm9sXFxcIiBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XFxcInNyY1xcXCI+XFxuICAgICAgICAgIDwvZGl2PiBcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyXFxcIj5cXG4gICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWFjdGlvbj1cXFwiY2FuY2VsXFxcIiBocmVmPVxcXCIjXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5jYW5jZWwpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIjwvYT5cXG4gICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgIGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1hY3Rpb249XFxcInNhdmVcXFwiIGhyZWY9XFxcIiNcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaW1hZ2UpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmluc2VydCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8YSBjbGFzcz1cXFwiYnRuIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc2l6ZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCIgYnRuLWRlZmF1bHRcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImluc2VydEltYWdlXFxcIiB0aXRsZT1cXFwiXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pbWFnZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaW5zZXJ0KSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuZmEpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYucHJvZ3JhbSg3LCBwcm9ncmFtNywgZGF0YSksZm46c2VsZi5wcm9ncmFtKDUsIHByb2dyYW01LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgPC9hPlxcbjwvbGk+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pO1xuXG50aGlzW1wid3lzaWh0bWw1XCJdW1widHBsXCJdW1wibGlua1wiXSA9IEhhbmRsZWJhcnMudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBzZWxmPXRoaXM7XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwibW9kYWwtc21cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwiYnRuLVwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNpemUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW01KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLXNoYXJlLXNxdWFyZS1vXFxcIj48L3NwYW4+XFxuICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW03KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tc2hhcmVcXFwiPjwvc3Bhbj5cXG4gICAgXCI7XG4gIH1cblxuICBidWZmZXIgKz0gXCI8bGk+XFxuICA8ZGl2IGNsYXNzPVxcXCJib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1saW5rLW1vZGFsIG1vZGFsIGZhZGVcXFwiIGRhdGEtd3lzaWh0bWw1LWRpYWxvZz1cXFwiY3JlYXRlTGlua1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZyBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnNtYWxsbW9kYWxzKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgICA8YSBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPiZ0aW1lczs8L2E+XFxuICAgICAgICAgIDxoMz5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmxpbmspKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmluc2VydCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9oMz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT1cXFwiaHR0cDovL1xcXCIgY2xhc3M9XFxcImJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstdXJsIGZvcm0tY29udHJvbFxcXCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVxcXCJocmVmXFxcIj5cXG4gICAgICAgICAgPC9kaXY+IFxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjaGVja2JveFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPiBcXG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgY2xhc3M9XFxcImJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstdGFyZ2V0XFxcIiBjaGVja2VkPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEubGluaykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudGFyZ2V0KSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXG4gICAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyXFxcIj5cXG4gICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWFjdGlvbj1cXFwiY2FuY2VsXFxcIiBocmVmPVxcXCIjXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmxpbmspKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmNhbmNlbCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPlxcbiAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIiBkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPVxcXCJzYXZlXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmxpbmspKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmluc2VydCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiPC9hPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8YSBjbGFzcz1cXFwiYnRuIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc2l6ZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCIgYnRuLWRlZmF1bHRcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImNyZWF0ZUxpbmtcXFwiIHRpdGxlPVxcXCJcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmxpbmspKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmluc2VydCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPlxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmZhKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLnByb2dyYW0oNywgcHJvZ3JhbTcsIGRhdGEpLGZuOnNlbGYucHJvZ3JhbSg1LCBwcm9ncmFtNSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gIDwvYT5cXG48L2xpPlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcblxudGhpc1tcInd5c2lodG1sNVwiXVtcInRwbFwiXVtcImxpc3RzXCJdID0gSGFuZGxlYmFycy50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcImJ0bi1cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1saXN0LXVsXFxcIj48L3NwYW4+XFxuICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW01KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tbGlzdFxcXCI+PC9zcGFuPlxcbiAgICBcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJmYSBmYS1saXN0LW9sXFxcIj48L3NwYW4+XFxuICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW05KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tdGgtbGlzdFxcXCI+PC9zcGFuPlxcbiAgICBcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZmEgZmEtb3V0ZGVudFxcXCI+PC9zcGFuPlxcbiAgICBcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1pbmRlbnQtcmlnaHRcXFwiPjwvc3Bhbj5cXG4gICAgXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImZhIGZhLWluZGVudFxcXCI+PC9zcGFuPlxcbiAgICBcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1pbmRlbnQtbGVmdFxcXCI+PC9zcGFuPlxcbiAgICBcIjtcbiAgfVxuXG4gIGJ1ZmZlciArPSBcIjxsaT5cXG4gIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cFxcXCI+XFxuICAgIDxhIGNsYXNzPVxcXCJidG4gXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5vcHRpb25zKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS50b29sYmFyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5zaXplKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIiBidG4tZGVmYXVsdFxcXCIgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cXFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFxcXCIgdGl0bGU9XFxcIlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEubGlzdHMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnVub3JkZXJlZCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPlxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmZhKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLnByb2dyYW0oNSwgcHJvZ3JhbTUsIGRhdGEpLGZuOnNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgPC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiYnRuIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc2l6ZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCIgYnRuLWRlZmF1bHRcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcImluc2VydE9yZGVyZWRMaXN0XFxcIiB0aXRsZT1cXFwiXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAubG9jYWxlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5saXN0cykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEub3JkZXJlZCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPlxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmZhKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLnByb2dyYW0oOSwgcHJvZ3JhbTksIGRhdGEpLGZuOnNlbGYucHJvZ3JhbSg3LCBwcm9ncmFtNywgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgPC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiYnRuIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc2l6ZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCIgYnRuLWRlZmF1bHRcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcIk91dGRlbnRcXFwiIHRpdGxlPVxcXCJcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5sb2NhbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmxpc3RzKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5vdXRkZW50KSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+XFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuZmEpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYucHJvZ3JhbSgxMywgcHJvZ3JhbTEzLCBkYXRhKSxmbjpzZWxmLnByb2dyYW0oMTEsIHByb2dyYW0xMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgPC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiYnRuIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9ucykpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEudG9vbGJhcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuc2l6ZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCIgYnRuLWRlZmF1bHRcXFwiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XFxcIkluZGVudFxcXCIgdGl0bGU9XFxcIlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmxvY2FsZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEubGlzdHMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmluZGVudCkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPlxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLm9wdGlvbnMpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLnRvb2xiYXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmZhKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLnByb2dyYW0oMTcsIHByb2dyYW0xNywgZGF0YSksZm46c2VsZi5wcm9ncmFtKDE1LCBwcm9ncmFtMTUsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgIDwvYT5cXG4gIDwvZGl2PlxcbjwvbGk+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKCdib290c3RyYXAud3lzaWh0bWw1JywgWydqcXVlcnknLCAnd3lzaWh0bWw1JywgJ2Jvb3RzdHJhcCcsICdib290c3RyYXAud3lzaWh0bWw1LnRlbXBsYXRlcycsICdib290c3RyYXAud3lzaWh0bWw1LmNvbW1hbmRzJ10sIGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGZhY3RvcnkoalF1ZXJ5LCB3eXNpaHRtbDUpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfVxufShmdW5jdGlvbiAoJCwgd3lzaWh0bWw1KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGJzV3lzaWh0bWw1ID0gZnVuY3Rpb24oJCwgd3lzaWh0bWw1KSB7XG5cbiAgICB2YXIgdGVtcGxhdGVzID0gZnVuY3Rpb24oa2V5LCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmKHd5c2lodG1sNS50cGxba2V5XSkge1xuICAgICAgICByZXR1cm4gd3lzaWh0bWw1LnRwbFtrZXldKHtsb2NhbGU6IGxvY2FsZSwgb3B0aW9uczogb3B0aW9uc30pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgV3lzaWh0bWw1ID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgIHZhciB0b29sYmFyT3B0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBmb3IodmFyIHQgaW4gdG9vbGJhck9wdHMuY3VzdG9tVGVtcGxhdGVzKSB7XG4gICAgICAgIGlmICh0b29sYmFyT3B0cy5jdXN0b21UZW1wbGF0ZXMuaGFzT3duUHJvcGVydHkodCkpIHtcbiAgICAgICAgICB3eXNpaHRtbDUudHBsW3RdID0gdG9vbGJhck9wdHMuY3VzdG9tVGVtcGxhdGVzW3RdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoZWwsIHRvb2xiYXJPcHRzKTtcbiAgICAgIHRoaXMuZWRpdG9yID0gIHRoaXMuY3JlYXRlRWRpdG9yKHRvb2xiYXJPcHRzKTtcbiAgICB9O1xuXG4gICAgV3lzaWh0bWw1LnByb3RvdHlwZSA9IHtcblxuICAgICAgY29uc3RydWN0b3I6IFd5c2lodG1sNSxcblxuICAgICAgY3JlYXRlRWRpdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIEFkZCB0aGUgdG9vbGJhciB0byBhIGNsb25lIG9mIHRoZSBvcHRpb25zIG9iamVjdCBzbyBtdWx0aXBsZSBpbnN0YW5jZXNcbiAgICAgICAgLy8gb2YgdGhlIFdZSVNZV0cgZG9uJ3QgYnJlYWsgYmVjYXVzZSAndG9vbGJhcicgaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMudG9vbGJhciA9IHRoaXMudG9vbGJhclswXTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUVkaXRvcih0aGlzLmVsWzBdLCBvcHRpb25zKTtcbiAgICAgIH0sXG5cblxuICAgICAgaW5pdGlhbGl6ZUVkaXRvcjogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVkaXRvciA9IG5ldyB3eXNpaHRtbDUuRWRpdG9yKHRoaXMuZWxbMF0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGVkaXRvci5vbignYmVmb3JlbG9hZCcsIHRoaXMuc3luY0Jvb3RzdHJhcERpYWxvZ0V2ZW50cyk7XG4gICAgICAgIGVkaXRvci5vbignYmVmb3JlbG9hZCcsIHRoaXMubG9hZFBhcnNlclJ1bGVzKTtcblxuICAgICAgICAvLyAjMzAgLSBib2R5IGlzIGluIElFIDEwIG5vdCBjcmVhdGVkIGJ5IGRlZmF1bHQsIHdoaWNoIGxlYWRzIHRvIG51bGxwb2ludGVyXG4gICAgICAgIC8vIDIwMTQvMDIvMTMgLSBhZGFwdGVkIHRvIHd5c2lodG1sNS0wLjQsIGRvZXMgbm90IHdvcmsgaW4gSUVcbiAgICAgICAgaWYoZWRpdG9yLmNvbXBvc2VyLmVkaXRhYmxlQXJlYS5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmFkZE1vcmVTaG9ydGN1dHMoZWRpdG9yLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbXBvc2VyLmVkaXRhYmxlQXJlYS5jb250ZW50RG9jdW1lbnQuYm9keSB8fCBlZGl0b3IuY29tcG9zZXIuZWRpdGFibGVBcmVhLmNvbnRlbnREb2N1bWVudCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2hvcnRjdXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZE1vcmVTaG9ydGN1dHMoZWRpdG9yLCBlZGl0b3IuY29tcG9zZXIuZWRpdGFibGVBcmVhLCBvcHRpb25zLnNob3J0Y3V0cyk7ICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgIGZvcih2YXIgZXZlbnROYW1lIGluIG9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICBlZGl0b3Iub24oZXZlbnROYW1lLCBvcHRpb25zLmV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgfSxcblxuICAgICAgbG9hZFBhcnNlclJ1bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoJC50eXBlKHRoaXMuY29uZmlnLnBhcnNlclJ1bGVzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHVybDogdGhpcy5jb25maWcucGFyc2VyUnVsZXMsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChwYXJzZXJSdWxlcykge1xuICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5wYXJzZXJSdWxlcyA9IHBhcnNlclJ1bGVzO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygncGFyc2VycnVsZXMgbG9hZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmNvbmZpZy5wYXN0ZVBhcnNlclJ1bGVzZXRzICYmICQudHlwZSh0aGlzLmNvbmZpZy5wYXN0ZVBhcnNlclJ1bGVzZXRzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHVybDogdGhpcy5jb25maWcucGFzdGVQYXJzZXJSdWxlc2V0cyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvclRocm93bik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHBhc3RlUGFyc2VyUnVsZXNldHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb25maWcucGFzdGVQYXJzZXJSdWxlc2V0cyA9IHBhc3RlUGFyc2VyUnVsZXNldHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vc3luYyB3eXNpaHRtbDUgZXZlbnRzIGZvciBkaWFsb2dzIHdpdGggYm9vdHN0cmFwIGV2ZW50c1xuICAgICAgc3luY0Jvb3RzdHJhcERpYWxvZ0V2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzO1xuICAgICAgICAkLm1hcCh0aGlzLnRvb2xiYXIuY29tbWFuZE1hcHBpbmcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihjb21tYW5kT2JqKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRPYmouZGlhbG9nO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24oY29tbWFuZE9iaikge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kT2JqLmRpYWxvZztcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbihkaWFsb2cpIHtcbiAgICAgICAgICBkaWFsb2cub24oJ3Nob3cnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQodGhpcy5jb250YWluZXIpLm1vZGFsKCdzaG93Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlhbG9nLm9uKCdoaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMuY29udGFpbmVyKS5tb2RhbCgnaGlkZScpO1xuICAgICAgICAgICAgc2V0VGltZW91dChlZGl0b3IuY29tcG9zZXIuZm9jdXMsIDApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgICQoZGlhbG9nLmNvbnRhaW5lcikub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5maW5kKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2NoYW5nZV92aWV3JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJCh0aGlzLnRvb2xiYXIuY29udGFpbmVyLmNoaWxkcmVuKS5maW5kKCdhLmJ0bicpLm5vdCgnW2RhdGEtd3lzaWh0bWw1LWFjdGlvbj1cImNoYW5nZV92aWV3XCJdJykudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgY3JlYXRlVG9vbGJhcjogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdG9vbGJhciA9ICQoJzx1bC8+Jywge1xuICAgICAgICAgICdjbGFzcycgOiAnd3lzaWh0bWw1LXRvb2xiYXInLFxuICAgICAgICAgICdzdHlsZSc6ICdkaXNwbGF5Om5vbmUnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3VsdHVyZSA9IG9wdGlvbnMubG9jYWxlIHx8IGRlZmF1bHRPcHRpb25zLmxvY2FsZSB8fCAnZW4nO1xuICAgICAgICBpZighbG9jYWxlLmhhc093blByb3BlcnR5KGN1bHR1cmUpKSB7XG4gICAgICAgICAgY29uc29sZS5kZWJ1ZygnTG9jYWxlIFxcJycgKyBjdWx0dXJlICsgJ1xcJyBub3QgZm91bmQuIEF2YWlsYWJsZSBsb2NhbGVzIGFyZTogJyArIE9iamVjdC5rZXlzKGxvY2FsZSkgKyAnLiBGYWxsaW5nIGJhY2sgdG8gXFwnZW5cXCcuJyk7XG4gICAgICAgICAgY3VsdHVyZSA9ICdlbic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2FsZU9iamVjdCA9ICQuZXh0ZW5kKHRydWUsIHt9LCBsb2NhbGUuZW4sIGxvY2FsZVtjdWx0dXJlXSk7XG4gICAgICAgIGZvcih2YXIga2V5IGluIG9wdGlvbnMudG9vbGJhcikge1xuICAgICAgICAgIGlmKG9wdGlvbnMudG9vbGJhcltrZXldKSB7XG4gICAgICAgICAgICB0b29sYmFyLmFwcGVuZCh0ZW1wbGF0ZXMoa2V5LCBsb2NhbGVPYmplY3QsIG9wdGlvbnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b29sYmFyLmZpbmQoJ2FbZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cImZvcm1hdEJsb2NrXCJdJykuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBlLmRlbGVnYXRlVGFyZ2V0IHx8IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICBlbCA9ICQodGFyZ2V0KSxcbiAgICAgICAgICBzaG93Zm9ybWF0ID0gZWwuZGF0YSgnd3lzaWh0bWw1LWRpc3BsYXktZm9ybWF0LW5hbWUnKSxcbiAgICAgICAgICBmb3JtYXRuYW1lID0gZWwuZGF0YSgnd3lzaWh0bWw1LWZvcm1hdC1uYW1lJykgfHwgZWwuaHRtbCgpO1xuICAgICAgICAgIGlmKHNob3dmb3JtYXQgPT09IHVuZGVmaW5lZCB8fCBzaG93Zm9ybWF0ID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHNlbGYudG9vbGJhci5maW5kKCcuY3VycmVudC1mb250JykudGV4dChmb3JtYXRuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRvb2xiYXIuZmluZCgnYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPVwiZm9yZUNvbG9yXCJdJykuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgdmFyIGVsID0gJCh0YXJnZXQpO1xuICAgICAgICAgIHNlbGYudG9vbGJhci5maW5kKCcuY3VycmVudC1jb2xvcicpLnRleHQoZWwuaHRtbCgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lbC5iZWZvcmUodG9vbGJhcik7XG5cbiAgICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgICB9LFxuXG4gICAgICBhZGRNb3JlU2hvcnRjdXRzOiBmdW5jdGlvbihlZGl0b3IsIGVsLCBzaG9ydGN1dHMpIHtcbiAgICAgICAgLyogc29tZSBhZGRpdGlvbmFsIHNob3J0Y3V0cyAqL1xuICAgICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZWwsICdrZXlkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICB2YXIga2V5Q29kZSAgPSBldmVudC5rZXlDb2RlLFxuICAgICAgICAgIGNvbW1hbmQgID0gc2hvcnRjdXRzW2tleUNvZGVdO1xuICAgICAgICAgIGlmICgoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSkgJiYgY29tbWFuZCAmJiB3eXNpaHRtbDUuY29tbWFuZHNbY29tbWFuZF0pIHtcbiAgICAgICAgICAgIHZhciBjb21tYW5kT2JqID0gZWRpdG9yLnRvb2xiYXIuY29tbWFuZE1hcHBpbmdbY29tbWFuZCArICc6bnVsbCddO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmRPYmogJiYgY29tbWFuZE9iai5kaWFsb2cgJiYgIWNvbW1hbmRPYmouc3RhdGUpIHtcbiAgICAgICAgICAgICAgY29tbWFuZE9iai5kaWFsb2cuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd3lzaWh0bWw1LmNvbW1hbmRzW2NvbW1hbmRdLmV4ZWMoZWRpdG9yLmNvbXBvc2VyLCBjb21tYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdGhlc2UgZGVmaW5lIG91ciBwdWJsaWMgYXBpXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICByZXNldERlZmF1bHRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSk7XG4gICAgICB9LFxuICAgICAgYnlwYXNzRGVmYXVsdHM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAkdGhpcy5kYXRhKCd3eXNpaHRtbDUnLCBuZXcgV3lzaWh0bWw1KCR0aGlzLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNoYWxsb3dFeHRlbmQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCAkLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSwgJCh0aGlzKS5kYXRhKCkpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtZXRob2RzLmJ5cGFzc0RlZmF1bHRzLmFwcGx5KHRoYXQsIFtzZXR0aW5nc10pO1xuICAgICAgfSxcbiAgICAgIGRlZXBFeHRlbmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sICQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWV0aG9kcy5ieXBhc3NEZWZhdWx0cy5hcHBseSh0aGF0LCBbc2V0dGluZ3NdKTtcbiAgICAgIH0sXG4gICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1ldGhvZHMuc2hhbGxvd0V4dGVuZC5hcHBseSh0aGF0LCBbb3B0aW9uc10pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLnd5c2lodG1sNSA9IGZ1bmN0aW9uICggbWV0aG9kICkge1xuICAgICAgaWYgKCBtZXRob2RzW21ldGhvZF0gKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzW21ldGhvZF0uYXBwbHkoIHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSk7XG4gICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhIG1ldGhvZCApIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkLmVycm9yKCAnTWV0aG9kICcgKyAgbWV0aG9kICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkud3lzaWh0bWw1JyApO1xuICAgICAgfSAgICBcbiAgICB9O1xuXG4gICAgJC5mbi53eXNpaHRtbDUuQ29uc3RydWN0b3IgPSBXeXNpaHRtbDU7XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSAkLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRvb2xiYXI6IHtcbiAgICAgICAgJ2ZvbnQtc3R5bGVzJzogdHJ1ZSxcbiAgICAgICAgJ2NvbG9yJzogZmFsc2UsXG4gICAgICAgICdlbXBoYXNpcyc6IHtcbiAgICAgICAgICAnc21hbGwnOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdibG9ja3F1b3RlJzogdHJ1ZSxcbiAgICAgICAgJ2xpc3RzJzogdHJ1ZSxcbiAgICAgICAgJ2h0bWwnOiBmYWxzZSxcbiAgICAgICAgJ2xpbmsnOiB0cnVlLFxuICAgICAgICAnaW1hZ2UnOiB0cnVlLFxuICAgICAgICAnc21hbGxtb2RhbHMnOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHVzZUxpbmVCcmVha3M6IGZhbHNlLFxuICAgICAgcGFyc2VyUnVsZXM6IHtcbiAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLXNpbHZlcicgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLWdyYXknIDogMSxcbiAgICAgICAgICAnd3lzaXd5Zy1jb2xvci13aGl0ZScgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLW1hcm9vbicgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLXJlZCcgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLXB1cnBsZScgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLWZ1Y2hzaWEnIDogMSxcbiAgICAgICAgICAnd3lzaXd5Zy1jb2xvci1ncmVlbicgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLWxpbWUnIDogMSxcbiAgICAgICAgICAnd3lzaXd5Zy1jb2xvci1vbGl2ZScgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLXllbGxvdycgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLW5hdnknIDogMSxcbiAgICAgICAgICAnd3lzaXd5Zy1jb2xvci1ibHVlJyA6IDEsXG4gICAgICAgICAgJ3d5c2l3eWctY29sb3ItdGVhbCcgOiAxLFxuICAgICAgICAgICd3eXNpd3lnLWNvbG9yLWFxdWEnIDogMSxcbiAgICAgICAgICAnd3lzaXd5Zy1jb2xvci1vcmFuZ2UnIDogMVxuICAgICAgICB9LFxuICAgICAgICB0YWdzOiB7XG4gICAgICAgICAgJ2InOiAge30sXG4gICAgICAgICAgJ2knOiAge30sXG4gICAgICAgICAgJ3N0cm9uZyc6IHt9LFxuICAgICAgICAgICdlbSc6IHt9LFxuICAgICAgICAgICdwJzoge30sXG4gICAgICAgICAgJ2JyJzoge30sXG4gICAgICAgICAgJ29sJzoge30sXG4gICAgICAgICAgJ3VsJzoge30sXG4gICAgICAgICAgJ2xpJzoge30sXG4gICAgICAgICAgJ2gxJzoge30sXG4gICAgICAgICAgJ2gyJzoge30sXG4gICAgICAgICAgJ2gzJzoge30sXG4gICAgICAgICAgJ2g0Jzoge30sXG4gICAgICAgICAgJ2g1Jzoge30sXG4gICAgICAgICAgJ2g2Jzoge30sXG4gICAgICAgICAgJ2Jsb2NrcXVvdGUnOiB7fSxcbiAgICAgICAgICAndSc6IDEsXG4gICAgICAgICAgJ2ltZyc6IHtcbiAgICAgICAgICAgICdjaGVja19hdHRyaWJ1dGVzJzoge1xuICAgICAgICAgICAgICAnd2lkdGgnOiAnbnVtYmVycycsXG4gICAgICAgICAgICAgICdhbHQnOiAnYWx0JyxcbiAgICAgICAgICAgICAgJ3NyYyc6ICd1cmwnLFxuICAgICAgICAgICAgICAnaGVpZ2h0JzogJ251bWJlcnMnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnYSc6ICB7XG4gICAgICAgICAgICAnY2hlY2tfYXR0cmlidXRlcyc6IHtcbiAgICAgICAgICAgICAgJ2hyZWYnOiAndXJsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdzZXRfYXR0cmlidXRlcyc6IHtcbiAgICAgICAgICAgICAgJ3RhcmdldCc6ICdfYmxhbmsnLFxuICAgICAgICAgICAgICAncmVsJzogJ25vZm9sbG93J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3NwYW4nOiAxLFxuICAgICAgICAgICdkaXYnOiAxLFxuICAgICAgICAgICdzbWFsbCc6IDEsXG4gICAgICAgICAgJ2NvZGUnOiAxLFxuICAgICAgICAgICdwcmUnOiAxXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsb2NhbGU6ICdlbicsXG4gICAgICBzaG9ydGN1dHM6IHtcbiAgICAgICAgJzgzJzogJ3NtYWxsJywvLyBTXG4gICAgICAgICc3NSc6ICdjcmVhdGVMaW5rJy8vIEtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiAkLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9uc0NhY2hlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSA9ICQuZXh0ZW5kKHRydWUsIHt9LCAkLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9ICQuZm4ud3lzaWh0bWw1LmxvY2FsZSA9IHt9O1xuICB9O1xuICBic1d5c2lodG1sNSgkLCB3eXNpaHRtbDUpO1xufSkpO1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB3eXNpaHRtbDUuY29tbWFuZHMuc21hbGwgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwic21hbGxcIik7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwic21hbGxcIik7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcblxuLyoqXG4gKiBFbmdsaXNoIHRyYW5zbGF0aW9uIGZvciBib290c3RyYXAtd3lzaWh0bWw1XG4gKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoJ2Jvb3RzdHJhcC53eXNpaHRtbDUuZW4tVVMnLCBbJ2pxdWVyeScsICdib290c3RyYXAud3lzaWh0bWw1J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgfVxufShmdW5jdGlvbiAoJCkge1xuICAkLmZuLnd5c2lodG1sNS5sb2NhbGUuZW4gPSAkLmZuLnd5c2lodG1sNS5sb2NhbGVbJ2VuLVVTJ10gPSB7XG4gICAgZm9udF9zdHlsZXM6IHtcbiAgICAgIG5vcm1hbDogJ05vcm1hbCB0ZXh0JyxcbiAgICAgIGgxOiAnSGVhZGluZyAxJyxcbiAgICAgIGgyOiAnSGVhZGluZyAyJyxcbiAgICAgIGgzOiAnSGVhZGluZyAzJyxcbiAgICAgIGg0OiAnSGVhZGluZyA0JyxcbiAgICAgIGg1OiAnSGVhZGluZyA1JyxcbiAgICAgIGg2OiAnSGVhZGluZyA2J1xuICAgIH0sXG4gICAgZW1waGFzaXM6IHtcbiAgICAgIGJvbGQ6ICdCb2xkJyxcbiAgICAgIGl0YWxpYzogJ0l0YWxpYycsXG4gICAgICB1bmRlcmxpbmU6ICdVbmRlcmxpbmUnLFxuICAgICAgc21hbGw6ICdTbWFsbCdcbiAgICB9LFxuICAgIGxpc3RzOiB7XG4gICAgICB1bm9yZGVyZWQ6ICdVbm9yZGVyZWQgbGlzdCcsXG4gICAgICBvcmRlcmVkOiAnT3JkZXJlZCBsaXN0JyxcbiAgICAgIG91dGRlbnQ6ICdPdXRkZW50JyxcbiAgICAgIGluZGVudDogJ0luZGVudCdcbiAgICB9LFxuICAgIGxpbms6IHtcbiAgICAgIGluc2VydDogJ0luc2VydCBsaW5rJyxcbiAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICB0YXJnZXQ6ICdPcGVuIGxpbmsgaW4gbmV3IHdpbmRvdydcbiAgICB9LFxuICAgIGltYWdlOiB7XG4gICAgICBpbnNlcnQ6ICdJbnNlcnQgaW1hZ2UnLFxuICAgICAgY2FuY2VsOiAnQ2FuY2VsJ1xuICAgIH0sXG4gICAgaHRtbDoge1xuICAgICAgZWRpdDogJ0VkaXQgSFRNTCdcbiAgICB9LFxuICAgIGNvbG91cnM6IHtcbiAgICAgIGJsYWNrOiAnQmxhY2snLFxuICAgICAgc2lsdmVyOiAnU2lsdmVyJyxcbiAgICAgIGdyYXk6ICdHcmV5JyxcbiAgICAgIG1hcm9vbjogJ01hcm9vbicsXG4gICAgICByZWQ6ICdSZWQnLFxuICAgICAgcHVycGxlOiAnUHVycGxlJyxcbiAgICAgIGdyZWVuOiAnR3JlZW4nLFxuICAgICAgb2xpdmU6ICdPbGl2ZScsXG4gICAgICBuYXZ5OiAnTmF2eScsXG4gICAgICBibHVlOiAnQmx1ZScsXG4gICAgICBvcmFuZ2U6ICdPcmFuZ2UnXG4gICAgfVxuICB9O1xufSkpO1xuIl19
